"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@fullcalendar";
exports.ids = ["vendor-chunks/@fullcalendar"];
exports.modules = {

/***/ "(ssr)/./node_modules/@fullcalendar/core/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@fullcalendar/core/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Calendar: () => (/* binding */ Calendar),\n/* harmony export */   JsonRequestError: () => (/* reexport safe */ _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.ag),\n/* harmony export */   createPlugin: () => (/* binding */ createPlugin),\n/* harmony export */   formatDate: () => (/* binding */ formatDate),\n/* harmony export */   formatRange: () => (/* binding */ formatRange),\n/* harmony export */   globalLocales: () => (/* binding */ globalLocales),\n/* harmony export */   globalPlugins: () => (/* binding */ globalPlugins),\n/* harmony export */   sliceEvents: () => (/* binding */ sliceEvents),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var _internal_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal-common.js */ \"(ssr)/./node_modules/@fullcalendar/core/internal-common.js\");\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! preact */ \"(ssr)/./node_modules/preact/dist/preact.mjs\");\n/* harmony import */ var preact_compat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! preact/compat */ \"(ssr)/./node_modules/preact/compat/dist/compat.mjs\");\n\n\n\n\nconst globalLocales = [];\nconst MINIMAL_RAW_EN_LOCALE = {\n    code: \"en\",\n    week: {\n        dow: 0,\n        doy: 4\n    },\n    direction: \"ltr\",\n    buttonText: {\n        prev: \"prev\",\n        next: \"next\",\n        prevYear: \"prev year\",\n        nextYear: \"next year\",\n        year: \"year\",\n        today: \"today\",\n        month: \"month\",\n        week: \"week\",\n        day: \"day\",\n        list: \"list\"\n    },\n    weekText: \"W\",\n    weekTextLong: \"Week\",\n    closeHint: \"Close\",\n    timeHint: \"Time\",\n    eventHint: \"Event\",\n    allDayText: \"all-day\",\n    moreLinkText: \"more\",\n    noEventsText: \"No events to display\"\n};\nconst RAW_EN_LOCALE = Object.assign(Object.assign({}, MINIMAL_RAW_EN_LOCALE), {\n    // Includes things we don't want other locales to inherit,\n    // things that derive from other translatable strings.\n    buttonHints: {\n        prev: \"Previous $0\",\n        next: \"Next $0\",\n        today (buttonText, unit) {\n            return unit === \"day\" ? \"Today\" : `This ${buttonText}`;\n        }\n    },\n    viewHint: \"$0 view\",\n    navLinkHint: \"Go to $0\",\n    moreLinkHint (eventCnt) {\n        return `Show ${eventCnt} more event${eventCnt === 1 ? \"\" : \"s\"}`;\n    }\n});\nfunction organizeRawLocales(explicitRawLocales) {\n    let defaultCode = explicitRawLocales.length > 0 ? explicitRawLocales[0].code : \"en\";\n    let allRawLocales = globalLocales.concat(explicitRawLocales);\n    let rawLocaleMap = {\n        en: RAW_EN_LOCALE\n    };\n    for (let rawLocale of allRawLocales){\n        rawLocaleMap[rawLocale.code] = rawLocale;\n    }\n    return {\n        map: rawLocaleMap,\n        defaultCode\n    };\n}\nfunction buildLocale(inputSingular, available) {\n    if (typeof inputSingular === \"object\" && !Array.isArray(inputSingular)) {\n        return parseLocale(inputSingular.code, [\n            inputSingular.code\n        ], inputSingular);\n    }\n    return queryLocale(inputSingular, available);\n}\nfunction queryLocale(codeArg, available) {\n    let codes = [].concat(codeArg || []); // will convert to array\n    let raw = queryRawLocale(codes, available) || RAW_EN_LOCALE;\n    return parseLocale(codeArg, codes, raw);\n}\nfunction queryRawLocale(codes, available) {\n    for(let i = 0; i < codes.length; i += 1){\n        let parts = codes[i].toLocaleLowerCase().split(\"-\");\n        for(let j = parts.length; j > 0; j -= 1){\n            let simpleId = parts.slice(0, j).join(\"-\");\n            if (available[simpleId]) {\n                return available[simpleId];\n            }\n        }\n    }\n    return null;\n}\nfunction parseLocale(codeArg, codes, raw) {\n    let merged = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.m)([\n        MINIMAL_RAW_EN_LOCALE,\n        raw\n    ], [\n        \"buttonText\"\n    ]);\n    delete merged.code; // don't want this part of the options\n    let { week } = merged;\n    delete merged.week;\n    return {\n        codeArg,\n        codes,\n        week,\n        simpleNumberFormat: new Intl.NumberFormat(codeArg),\n        options: merged\n    };\n}\n// TODO: easier way to add new hooks? need to update a million things\nfunction createPlugin(input) {\n    return {\n        id: (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.g)(),\n        name: input.name,\n        premiumReleaseDate: input.premiumReleaseDate ? new Date(input.premiumReleaseDate) : undefined,\n        deps: input.deps || [],\n        reducers: input.reducers || [],\n        isLoadingFuncs: input.isLoadingFuncs || [],\n        contextInit: [].concat(input.contextInit || []),\n        eventRefiners: input.eventRefiners || {},\n        eventDefMemberAdders: input.eventDefMemberAdders || [],\n        eventSourceRefiners: input.eventSourceRefiners || {},\n        isDraggableTransformers: input.isDraggableTransformers || [],\n        eventDragMutationMassagers: input.eventDragMutationMassagers || [],\n        eventDefMutationAppliers: input.eventDefMutationAppliers || [],\n        dateSelectionTransformers: input.dateSelectionTransformers || [],\n        datePointTransforms: input.datePointTransforms || [],\n        dateSpanTransforms: input.dateSpanTransforms || [],\n        views: input.views || {},\n        viewPropsTransformers: input.viewPropsTransformers || [],\n        isPropsValid: input.isPropsValid || null,\n        externalDefTransforms: input.externalDefTransforms || [],\n        viewContainerAppends: input.viewContainerAppends || [],\n        eventDropTransformers: input.eventDropTransformers || [],\n        componentInteractions: input.componentInteractions || [],\n        calendarInteractions: input.calendarInteractions || [],\n        themeClasses: input.themeClasses || {},\n        eventSourceDefs: input.eventSourceDefs || [],\n        cmdFormatter: input.cmdFormatter,\n        recurringTypes: input.recurringTypes || [],\n        namedTimeZonedImpl: input.namedTimeZonedImpl,\n        initialView: input.initialView || \"\",\n        elementDraggingImpl: input.elementDraggingImpl,\n        optionChangeHandlers: input.optionChangeHandlers || {},\n        scrollGridImpl: input.scrollGridImpl || null,\n        listenerRefiners: input.listenerRefiners || {},\n        optionRefiners: input.optionRefiners || {},\n        propSetHandlers: input.propSetHandlers || {}\n    };\n}\nfunction buildPluginHooks(pluginDefs, globalDefs) {\n    let currentPluginIds = {};\n    let hooks = {\n        premiumReleaseDate: undefined,\n        reducers: [],\n        isLoadingFuncs: [],\n        contextInit: [],\n        eventRefiners: {},\n        eventDefMemberAdders: [],\n        eventSourceRefiners: {},\n        isDraggableTransformers: [],\n        eventDragMutationMassagers: [],\n        eventDefMutationAppliers: [],\n        dateSelectionTransformers: [],\n        datePointTransforms: [],\n        dateSpanTransforms: [],\n        views: {},\n        viewPropsTransformers: [],\n        isPropsValid: null,\n        externalDefTransforms: [],\n        viewContainerAppends: [],\n        eventDropTransformers: [],\n        componentInteractions: [],\n        calendarInteractions: [],\n        themeClasses: {},\n        eventSourceDefs: [],\n        cmdFormatter: null,\n        recurringTypes: [],\n        namedTimeZonedImpl: null,\n        initialView: \"\",\n        elementDraggingImpl: null,\n        optionChangeHandlers: {},\n        scrollGridImpl: null,\n        listenerRefiners: {},\n        optionRefiners: {},\n        propSetHandlers: {}\n    };\n    function addDefs(defs) {\n        for (let def of defs){\n            const pluginName = def.name;\n            const currentId = currentPluginIds[pluginName];\n            if (currentId === undefined) {\n                currentPluginIds[pluginName] = def.id;\n                addDefs(def.deps);\n                hooks = combineHooks(hooks, def);\n            } else if (currentId !== def.id) {\n                // different ID than the one already added\n                console.warn(`Duplicate plugin '${pluginName}'`);\n            }\n        }\n    }\n    if (pluginDefs) {\n        addDefs(pluginDefs);\n    }\n    addDefs(globalDefs);\n    return hooks;\n}\nfunction buildBuildPluginHooks() {\n    let currentOverrideDefs = [];\n    let currentGlobalDefs = [];\n    let currentHooks;\n    return (overrideDefs, globalDefs)=>{\n        if (!currentHooks || !(0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.i)(overrideDefs, currentOverrideDefs) || !(0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.i)(globalDefs, currentGlobalDefs)) {\n            currentHooks = buildPluginHooks(overrideDefs, globalDefs);\n        }\n        currentOverrideDefs = overrideDefs;\n        currentGlobalDefs = globalDefs;\n        return currentHooks;\n    };\n}\nfunction combineHooks(hooks0, hooks1) {\n    return {\n        premiumReleaseDate: compareOptionalDates(hooks0.premiumReleaseDate, hooks1.premiumReleaseDate),\n        reducers: hooks0.reducers.concat(hooks1.reducers),\n        isLoadingFuncs: hooks0.isLoadingFuncs.concat(hooks1.isLoadingFuncs),\n        contextInit: hooks0.contextInit.concat(hooks1.contextInit),\n        eventRefiners: Object.assign(Object.assign({}, hooks0.eventRefiners), hooks1.eventRefiners),\n        eventDefMemberAdders: hooks0.eventDefMemberAdders.concat(hooks1.eventDefMemberAdders),\n        eventSourceRefiners: Object.assign(Object.assign({}, hooks0.eventSourceRefiners), hooks1.eventSourceRefiners),\n        isDraggableTransformers: hooks0.isDraggableTransformers.concat(hooks1.isDraggableTransformers),\n        eventDragMutationMassagers: hooks0.eventDragMutationMassagers.concat(hooks1.eventDragMutationMassagers),\n        eventDefMutationAppliers: hooks0.eventDefMutationAppliers.concat(hooks1.eventDefMutationAppliers),\n        dateSelectionTransformers: hooks0.dateSelectionTransformers.concat(hooks1.dateSelectionTransformers),\n        datePointTransforms: hooks0.datePointTransforms.concat(hooks1.datePointTransforms),\n        dateSpanTransforms: hooks0.dateSpanTransforms.concat(hooks1.dateSpanTransforms),\n        views: Object.assign(Object.assign({}, hooks0.views), hooks1.views),\n        viewPropsTransformers: hooks0.viewPropsTransformers.concat(hooks1.viewPropsTransformers),\n        isPropsValid: hooks1.isPropsValid || hooks0.isPropsValid,\n        externalDefTransforms: hooks0.externalDefTransforms.concat(hooks1.externalDefTransforms),\n        viewContainerAppends: hooks0.viewContainerAppends.concat(hooks1.viewContainerAppends),\n        eventDropTransformers: hooks0.eventDropTransformers.concat(hooks1.eventDropTransformers),\n        calendarInteractions: hooks0.calendarInteractions.concat(hooks1.calendarInteractions),\n        componentInteractions: hooks0.componentInteractions.concat(hooks1.componentInteractions),\n        themeClasses: Object.assign(Object.assign({}, hooks0.themeClasses), hooks1.themeClasses),\n        eventSourceDefs: hooks0.eventSourceDefs.concat(hooks1.eventSourceDefs),\n        cmdFormatter: hooks1.cmdFormatter || hooks0.cmdFormatter,\n        recurringTypes: hooks0.recurringTypes.concat(hooks1.recurringTypes),\n        namedTimeZonedImpl: hooks1.namedTimeZonedImpl || hooks0.namedTimeZonedImpl,\n        initialView: hooks0.initialView || hooks1.initialView,\n        elementDraggingImpl: hooks0.elementDraggingImpl || hooks1.elementDraggingImpl,\n        optionChangeHandlers: Object.assign(Object.assign({}, hooks0.optionChangeHandlers), hooks1.optionChangeHandlers),\n        scrollGridImpl: hooks1.scrollGridImpl || hooks0.scrollGridImpl,\n        listenerRefiners: Object.assign(Object.assign({}, hooks0.listenerRefiners), hooks1.listenerRefiners),\n        optionRefiners: Object.assign(Object.assign({}, hooks0.optionRefiners), hooks1.optionRefiners),\n        propSetHandlers: Object.assign(Object.assign({}, hooks0.propSetHandlers), hooks1.propSetHandlers)\n    };\n}\nfunction compareOptionalDates(date0, date1) {\n    if (date0 === undefined) {\n        return date1;\n    }\n    if (date1 === undefined) {\n        return date0;\n    }\n    return new Date(Math.max(date0.valueOf(), date1.valueOf()));\n}\nclass StandardTheme extends _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.T {\n}\nStandardTheme.prototype.classes = {\n    root: \"fc-theme-standard\",\n    tableCellShaded: \"fc-cell-shaded\",\n    buttonGroup: \"fc-button-group\",\n    button: \"fc-button fc-button-primary\",\n    buttonActive: \"fc-button-active\"\n};\nStandardTheme.prototype.baseIconClass = \"fc-icon\";\nStandardTheme.prototype.iconClasses = {\n    close: \"fc-icon-x\",\n    prev: \"fc-icon-chevron-left\",\n    next: \"fc-icon-chevron-right\",\n    prevYear: \"fc-icon-chevrons-left\",\n    nextYear: \"fc-icon-chevrons-right\"\n};\nStandardTheme.prototype.rtlIconClasses = {\n    prev: \"fc-icon-chevron-right\",\n    next: \"fc-icon-chevron-left\",\n    prevYear: \"fc-icon-chevrons-right\",\n    nextYear: \"fc-icon-chevrons-left\"\n};\nStandardTheme.prototype.iconOverrideOption = \"buttonIcons\"; // TODO: make TS-friendly\nStandardTheme.prototype.iconOverrideCustomButtonOption = \"icon\";\nStandardTheme.prototype.iconOverridePrefix = \"fc-icon-\";\nfunction compileViewDefs(defaultConfigs, overrideConfigs) {\n    let hash = {};\n    let viewType;\n    for(viewType in defaultConfigs){\n        ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n    }\n    for(viewType in overrideConfigs){\n        ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n    }\n    return hash;\n}\nfunction ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs) {\n    if (hash[viewType]) {\n        return hash[viewType];\n    }\n    let viewDef = buildViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n    if (viewDef) {\n        hash[viewType] = viewDef;\n    }\n    return viewDef;\n}\nfunction buildViewDef(viewType, hash, defaultConfigs, overrideConfigs) {\n    let defaultConfig = defaultConfigs[viewType];\n    let overrideConfig = overrideConfigs[viewType];\n    let queryProp = (name)=>defaultConfig && defaultConfig[name] !== null ? defaultConfig[name] : overrideConfig && overrideConfig[name] !== null ? overrideConfig[name] : null;\n    let theComponent = queryProp(\"component\");\n    let superType = queryProp(\"superType\");\n    let superDef = null;\n    if (superType) {\n        if (superType === viewType) {\n            throw new Error(\"Can't have a custom view type that references itself\");\n        }\n        superDef = ensureViewDef(superType, hash, defaultConfigs, overrideConfigs);\n    }\n    if (!theComponent && superDef) {\n        theComponent = superDef.component;\n    }\n    if (!theComponent) {\n        return null; // don't throw a warning, might be settings for a single-unit view\n    }\n    return {\n        type: viewType,\n        component: theComponent,\n        defaults: Object.assign(Object.assign({}, superDef ? superDef.defaults : {}), defaultConfig ? defaultConfig.rawOptions : {}),\n        overrides: Object.assign(Object.assign({}, superDef ? superDef.overrides : {}), overrideConfig ? overrideConfig.rawOptions : {})\n    };\n}\nfunction parseViewConfigs(inputs) {\n    return (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a)(inputs, parseViewConfig);\n}\nfunction parseViewConfig(input) {\n    let rawOptions = typeof input === \"function\" ? {\n        component: input\n    } : input;\n    let { component } = rawOptions;\n    if (rawOptions.content) {\n        // TODO: remove content/classNames/didMount/etc from options?\n        component = createViewHookComponent(rawOptions);\n    } else if (component && !(component.prototype instanceof _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.B)) {\n        // WHY?: people were using `component` property for `content`\n        // TODO: converge on one setting name\n        component = createViewHookComponent(Object.assign(Object.assign({}, rawOptions), {\n            content: component\n        }));\n    }\n    return {\n        superType: rawOptions.type,\n        component: component,\n        rawOptions\n    };\n}\nfunction createViewHookComponent(options) {\n    return (viewProps)=>(0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.V.Consumer, null, (context)=>(0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.C, {\n                elTag: \"div\",\n                elClasses: (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.b)(context.viewSpec),\n                renderProps: Object.assign(Object.assign({}, viewProps), {\n                    nextDayThreshold: context.options.nextDayThreshold\n                }),\n                generatorName: undefined,\n                customGenerator: options.content,\n                classNameGenerator: options.classNames,\n                didMount: options.didMount,\n                willUnmount: options.willUnmount\n            }));\n}\nfunction buildViewSpecs(defaultInputs, optionOverrides, dynamicOptionOverrides, localeDefaults) {\n    let defaultConfigs = parseViewConfigs(defaultInputs);\n    let overrideConfigs = parseViewConfigs(optionOverrides.views);\n    let viewDefs = compileViewDefs(defaultConfigs, overrideConfigs);\n    return (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a)(viewDefs, (viewDef)=>buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults));\n}\nfunction buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults) {\n    let durationInput = viewDef.overrides.duration || viewDef.defaults.duration || dynamicOptionOverrides.duration || optionOverrides.duration;\n    let duration = null;\n    let durationUnit = \"\";\n    let singleUnit = \"\";\n    let singleUnitOverrides = {};\n    if (durationInput) {\n        duration = createDurationCached(durationInput);\n        if (duration) {\n            let denom = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.c)(duration);\n            durationUnit = denom.unit;\n            if (denom.value === 1) {\n                singleUnit = durationUnit;\n                singleUnitOverrides = overrideConfigs[durationUnit] ? overrideConfigs[durationUnit].rawOptions : {};\n            }\n        }\n    }\n    let queryButtonText = (optionsSubset)=>{\n        let buttonTextMap = optionsSubset.buttonText || {};\n        let buttonTextKey = viewDef.defaults.buttonTextKey;\n        if (buttonTextKey != null && buttonTextMap[buttonTextKey] != null) {\n            return buttonTextMap[buttonTextKey];\n        }\n        if (buttonTextMap[viewDef.type] != null) {\n            return buttonTextMap[viewDef.type];\n        }\n        if (buttonTextMap[singleUnit] != null) {\n            return buttonTextMap[singleUnit];\n        }\n        return null;\n    };\n    let queryButtonTitle = (optionsSubset)=>{\n        let buttonHints = optionsSubset.buttonHints || {};\n        let buttonKey = viewDef.defaults.buttonTextKey; // use same key as text\n        if (buttonKey != null && buttonHints[buttonKey] != null) {\n            return buttonHints[buttonKey];\n        }\n        if (buttonHints[viewDef.type] != null) {\n            return buttonHints[viewDef.type];\n        }\n        if (buttonHints[singleUnit] != null) {\n            return buttonHints[singleUnit];\n        }\n        return null;\n    };\n    return {\n        type: viewDef.type,\n        component: viewDef.component,\n        duration,\n        durationUnit,\n        singleUnit,\n        optionDefaults: viewDef.defaults,\n        optionOverrides: Object.assign(Object.assign({}, singleUnitOverrides), viewDef.overrides),\n        buttonTextOverride: queryButtonText(dynamicOptionOverrides) || queryButtonText(optionOverrides) || // constructor-specified buttonText lookup hash takes precedence\n        viewDef.overrides.buttonText,\n        buttonTextDefault: queryButtonText(localeDefaults) || viewDef.defaults.buttonText || queryButtonText(_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.e) || viewDef.type,\n        // not DRY\n        buttonTitleOverride: queryButtonTitle(dynamicOptionOverrides) || queryButtonTitle(optionOverrides) || viewDef.overrides.buttonHint,\n        buttonTitleDefault: queryButtonTitle(localeDefaults) || viewDef.defaults.buttonHint || queryButtonTitle(_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.e)\n    };\n}\n// hack to get memoization working\nlet durationInputMap = {};\nfunction createDurationCached(durationInput) {\n    let json = JSON.stringify(durationInput);\n    let res = durationInputMap[json];\n    if (res === undefined) {\n        res = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.d)(durationInput);\n        durationInputMap[json] = res;\n    }\n    return res;\n}\nfunction reduceViewType(viewType, action) {\n    switch(action.type){\n        case \"CHANGE_VIEW_TYPE\":\n            viewType = action.viewType;\n    }\n    return viewType;\n}\nfunction reduceDynamicOptionOverrides(dynamicOptionOverrides, action) {\n    switch(action.type){\n        case \"SET_OPTION\":\n            return Object.assign(Object.assign({}, dynamicOptionOverrides), {\n                [action.optionName]: action.rawOptionValue\n            });\n        default:\n            return dynamicOptionOverrides;\n    }\n}\nfunction reduceDateProfile(currentDateProfile, action, currentDate, dateProfileGenerator) {\n    let dp;\n    switch(action.type){\n        case \"CHANGE_VIEW_TYPE\":\n            return dateProfileGenerator.build(action.dateMarker || currentDate);\n        case \"CHANGE_DATE\":\n            return dateProfileGenerator.build(action.dateMarker);\n        case \"PREV\":\n            dp = dateProfileGenerator.buildPrev(currentDateProfile, currentDate);\n            if (dp.isValid) {\n                return dp;\n            }\n            break;\n        case \"NEXT\":\n            dp = dateProfileGenerator.buildNext(currentDateProfile, currentDate);\n            if (dp.isValid) {\n                return dp;\n            }\n            break;\n    }\n    return currentDateProfile;\n}\nfunction initEventSources(calendarOptions, dateProfile, context) {\n    let activeRange = dateProfile ? dateProfile.activeRange : null;\n    return addSources({}, parseInitialSources(calendarOptions, context), activeRange, context);\n}\nfunction reduceEventSources(eventSources, action, dateProfile, context) {\n    let activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?\n    switch(action.type){\n        case \"ADD_EVENT_SOURCES\":\n            return addSources(eventSources, action.sources, activeRange, context);\n        case \"REMOVE_EVENT_SOURCE\":\n            return removeSource(eventSources, action.sourceId);\n        case \"PREV\":\n        case \"NEXT\":\n        case \"CHANGE_DATE\":\n        case \"CHANGE_VIEW_TYPE\":\n            if (dateProfile) {\n                return fetchDirtySources(eventSources, activeRange, context);\n            }\n            return eventSources;\n        case \"FETCH_EVENT_SOURCES\":\n            return fetchSourcesByIds(eventSources, action.sourceIds ? (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.f)(action.sourceIds) : excludeStaticSources(eventSources, context), activeRange, action.isRefetch || false, context);\n        case \"RECEIVE_EVENTS\":\n        case \"RECEIVE_EVENT_ERROR\":\n            return receiveResponse(eventSources, action.sourceId, action.fetchId, action.fetchRange);\n        case \"REMOVE_ALL_EVENT_SOURCES\":\n            return {};\n        default:\n            return eventSources;\n    }\n}\nfunction reduceEventSourcesNewTimeZone(eventSources, dateProfile, context) {\n    let activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?\n    return fetchSourcesByIds(eventSources, excludeStaticSources(eventSources, context), activeRange, true, context);\n}\nfunction computeEventSourcesLoading(eventSources) {\n    for(let sourceId in eventSources){\n        if (eventSources[sourceId].isFetching) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction addSources(eventSourceHash, sources, fetchRange, context) {\n    let hash = {};\n    for (let source of sources){\n        hash[source.sourceId] = source;\n    }\n    if (fetchRange) {\n        hash = fetchDirtySources(hash, fetchRange, context);\n    }\n    return Object.assign(Object.assign({}, eventSourceHash), hash);\n}\nfunction removeSource(eventSourceHash, sourceId) {\n    return (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.h)(eventSourceHash, (eventSource)=>eventSource.sourceId !== sourceId);\n}\nfunction fetchDirtySources(sourceHash, fetchRange, context) {\n    return fetchSourcesByIds(sourceHash, (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.h)(sourceHash, (eventSource)=>isSourceDirty(eventSource, fetchRange, context)), fetchRange, false, context);\n}\nfunction isSourceDirty(eventSource, fetchRange, context) {\n    if (!doesSourceNeedRange(eventSource, context)) {\n        return !eventSource.latestFetchId;\n    }\n    return !context.options.lazyFetching || !eventSource.fetchRange || eventSource.isFetching || // always cancel outdated in-progress fetches\n    fetchRange.start < eventSource.fetchRange.start || fetchRange.end > eventSource.fetchRange.end;\n}\nfunction fetchSourcesByIds(prevSources, sourceIdHash, fetchRange, isRefetch, context) {\n    let nextSources = {};\n    for(let sourceId in prevSources){\n        let source = prevSources[sourceId];\n        if (sourceIdHash[sourceId]) {\n            nextSources[sourceId] = fetchSource(source, fetchRange, isRefetch, context);\n        } else {\n            nextSources[sourceId] = source;\n        }\n    }\n    return nextSources;\n}\nfunction fetchSource(eventSource, fetchRange, isRefetch, context) {\n    let { options, calendarApi } = context;\n    let sourceDef = context.pluginHooks.eventSourceDefs[eventSource.sourceDefId];\n    let fetchId = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.g)();\n    sourceDef.fetch({\n        eventSource,\n        range: fetchRange,\n        isRefetch,\n        context\n    }, (res)=>{\n        let { rawEvents } = res;\n        if (options.eventSourceSuccess) {\n            rawEvents = options.eventSourceSuccess.call(calendarApi, rawEvents, res.response) || rawEvents;\n        }\n        if (eventSource.success) {\n            rawEvents = eventSource.success.call(calendarApi, rawEvents, res.response) || rawEvents;\n        }\n        context.dispatch({\n            type: \"RECEIVE_EVENTS\",\n            sourceId: eventSource.sourceId,\n            fetchId,\n            fetchRange,\n            rawEvents\n        });\n    }, (error)=>{\n        let errorHandled = false;\n        if (options.eventSourceFailure) {\n            options.eventSourceFailure.call(calendarApi, error);\n            errorHandled = true;\n        }\n        if (eventSource.failure) {\n            eventSource.failure(error);\n            errorHandled = true;\n        }\n        if (!errorHandled) {\n            console.warn(error.message, error);\n        }\n        context.dispatch({\n            type: \"RECEIVE_EVENT_ERROR\",\n            sourceId: eventSource.sourceId,\n            fetchId,\n            fetchRange,\n            error\n        });\n    });\n    return Object.assign(Object.assign({}, eventSource), {\n        isFetching: true,\n        latestFetchId: fetchId\n    });\n}\nfunction receiveResponse(sourceHash, sourceId, fetchId, fetchRange) {\n    let eventSource = sourceHash[sourceId];\n    if (eventSource && // not already removed\n    fetchId === eventSource.latestFetchId) {\n        return Object.assign(Object.assign({}, sourceHash), {\n            [sourceId]: Object.assign(Object.assign({}, eventSource), {\n                isFetching: false,\n                fetchRange\n            })\n        });\n    }\n    return sourceHash;\n}\nfunction excludeStaticSources(eventSources, context) {\n    return (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.h)(eventSources, (eventSource)=>doesSourceNeedRange(eventSource, context));\n}\nfunction parseInitialSources(rawOptions, context) {\n    let refiners = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.j)(context);\n    let rawSources = [].concat(rawOptions.eventSources || []);\n    let sources = []; // parsed\n    if (rawOptions.initialEvents) {\n        rawSources.unshift(rawOptions.initialEvents);\n    }\n    if (rawOptions.events) {\n        rawSources.unshift(rawOptions.events);\n    }\n    for (let rawSource of rawSources){\n        let source = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.p)(rawSource, context, refiners);\n        if (source) {\n            sources.push(source);\n        }\n    }\n    return sources;\n}\nfunction doesSourceNeedRange(eventSource, context) {\n    let defs = context.pluginHooks.eventSourceDefs;\n    return !defs[eventSource.sourceDefId].ignoreRange;\n}\nfunction reduceDateSelection(currentSelection, action) {\n    switch(action.type){\n        case \"UNSELECT_DATES\":\n            return null;\n        case \"SELECT_DATES\":\n            return action.selection;\n        default:\n            return currentSelection;\n    }\n}\nfunction reduceSelectedEvent(currentInstanceId, action) {\n    switch(action.type){\n        case \"UNSELECT_EVENT\":\n            return \"\";\n        case \"SELECT_EVENT\":\n            return action.eventInstanceId;\n        default:\n            return currentInstanceId;\n    }\n}\nfunction reduceEventDrag(currentDrag, action) {\n    let newDrag;\n    switch(action.type){\n        case \"UNSET_EVENT_DRAG\":\n            return null;\n        case \"SET_EVENT_DRAG\":\n            newDrag = action.state;\n            return {\n                affectedEvents: newDrag.affectedEvents,\n                mutatedEvents: newDrag.mutatedEvents,\n                isEvent: newDrag.isEvent\n            };\n        default:\n            return currentDrag;\n    }\n}\nfunction reduceEventResize(currentResize, action) {\n    let newResize;\n    switch(action.type){\n        case \"UNSET_EVENT_RESIZE\":\n            return null;\n        case \"SET_EVENT_RESIZE\":\n            newResize = action.state;\n            return {\n                affectedEvents: newResize.affectedEvents,\n                mutatedEvents: newResize.mutatedEvents,\n                isEvent: newResize.isEvent\n            };\n        default:\n            return currentResize;\n    }\n}\nfunction parseToolbars(calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {\n    let header = calendarOptions.headerToolbar ? parseToolbar(calendarOptions.headerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;\n    let footer = calendarOptions.footerToolbar ? parseToolbar(calendarOptions.footerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;\n    return {\n        header,\n        footer\n    };\n}\nfunction parseToolbar(sectionStrHash, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {\n    let sectionWidgets = {};\n    let viewsWithButtons = [];\n    let hasTitle = false;\n    for(let sectionName in sectionStrHash){\n        let sectionStr = sectionStrHash[sectionName];\n        let sectionRes = parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi);\n        sectionWidgets[sectionName] = sectionRes.widgets;\n        viewsWithButtons.push(...sectionRes.viewsWithButtons);\n        hasTitle = hasTitle || sectionRes.hasTitle;\n    }\n    return {\n        sectionWidgets,\n        viewsWithButtons,\n        hasTitle\n    };\n}\n/*\nBAD: querying icons and text here. should be done at render time\n*/ function parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {\n    let isRtl = calendarOptions.direction === \"rtl\";\n    let calendarCustomButtons = calendarOptions.customButtons || {};\n    let calendarButtonTextOverrides = calendarOptionOverrides.buttonText || {};\n    let calendarButtonText = calendarOptions.buttonText || {};\n    let calendarButtonHintOverrides = calendarOptionOverrides.buttonHints || {};\n    let calendarButtonHints = calendarOptions.buttonHints || {};\n    let sectionSubstrs = sectionStr ? sectionStr.split(\" \") : [];\n    let viewsWithButtons = [];\n    let hasTitle = false;\n    let widgets = sectionSubstrs.map((buttonGroupStr)=>buttonGroupStr.split(\",\").map((buttonName)=>{\n            if (buttonName === \"title\") {\n                hasTitle = true;\n                return {\n                    buttonName\n                };\n            }\n            let customButtonProps;\n            let viewSpec;\n            let buttonClick;\n            let buttonIcon; // only one of these will be set\n            let buttonText; // \"\n            let buttonHint;\n            // ^ for the title=\"\" attribute, for accessibility\n            if (customButtonProps = calendarCustomButtons[buttonName]) {\n                buttonClick = (ev)=>{\n                    if (customButtonProps.click) {\n                        customButtonProps.click.call(ev.target, ev, ev.target); // TODO: use Calendar this context?\n                    }\n                };\n                (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = customButtonProps.text);\n                buttonHint = customButtonProps.hint || customButtonProps.text;\n            } else if (viewSpec = viewSpecs[buttonName]) {\n                viewsWithButtons.push(buttonName);\n                buttonClick = ()=>{\n                    calendarApi.changeView(buttonName);\n                };\n                (buttonText = viewSpec.buttonTextOverride) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = viewSpec.buttonTextDefault);\n                let textFallback = viewSpec.buttonTextOverride || viewSpec.buttonTextDefault;\n                buttonHint = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.k)(viewSpec.buttonTitleOverride || viewSpec.buttonTitleDefault || calendarOptions.viewHint, [\n                    textFallback,\n                    buttonName\n                ], textFallback);\n            } else if (calendarApi[buttonName]) {\n                buttonClick = ()=>{\n                    calendarApi[buttonName]();\n                };\n                (buttonText = calendarButtonTextOverrides[buttonName]) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = calendarButtonText[buttonName]); // everything else is considered default\n                if (buttonName === \"prevYear\" || buttonName === \"nextYear\") {\n                    let prevOrNext = buttonName === \"prevYear\" ? \"prev\" : \"next\";\n                    buttonHint = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.k)(calendarButtonHintOverrides[prevOrNext] || calendarButtonHints[prevOrNext], [\n                        calendarButtonText.year || \"year\",\n                        \"year\"\n                    ], calendarButtonText[buttonName]);\n                } else {\n                    buttonHint = (navUnit)=>(0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.k)(calendarButtonHintOverrides[buttonName] || calendarButtonHints[buttonName], [\n                            calendarButtonText[navUnit] || navUnit,\n                            navUnit\n                        ], calendarButtonText[buttonName]);\n                }\n            }\n            return {\n                buttonName,\n                buttonClick,\n                buttonIcon,\n                buttonText,\n                buttonHint\n            };\n        }));\n    return {\n        widgets,\n        viewsWithButtons,\n        hasTitle\n    };\n}\n// always represents the current view. otherwise, it'd need to change value every time date changes\nclass ViewImpl {\n    constructor(type, getCurrentData, dateEnv){\n        this.type = type;\n        this.getCurrentData = getCurrentData;\n        this.dateEnv = dateEnv;\n    }\n    get calendar() {\n        return this.getCurrentData().calendarApi;\n    }\n    get title() {\n        return this.getCurrentData().viewTitle;\n    }\n    get activeStart() {\n        return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.start);\n    }\n    get activeEnd() {\n        return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.end);\n    }\n    get currentStart() {\n        return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.start);\n    }\n    get currentEnd() {\n        return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.end);\n    }\n    getOption(name) {\n        return this.getCurrentData().options[name]; // are the view-specific options\n    }\n}\nlet eventSourceDef$2 = {\n    ignoreRange: true,\n    parseMeta (refined) {\n        if (Array.isArray(refined.events)) {\n            return refined.events;\n        }\n        return null;\n    },\n    fetch (arg, successCallback) {\n        successCallback({\n            rawEvents: arg.eventSource.meta\n        });\n    }\n};\nconst arrayEventSourcePlugin = createPlugin({\n    name: \"array-event-source\",\n    eventSourceDefs: [\n        eventSourceDef$2\n    ]\n});\nlet eventSourceDef$1 = {\n    parseMeta (refined) {\n        if (typeof refined.events === \"function\") {\n            return refined.events;\n        }\n        return null;\n    },\n    fetch (arg, successCallback, errorCallback) {\n        const { dateEnv } = arg.context;\n        const func = arg.eventSource.meta;\n        (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.u)(func.bind(null, (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.l)(arg.range, dateEnv)), (rawEvents)=>successCallback({\n                rawEvents\n            }), errorCallback);\n    }\n};\nconst funcEventSourcePlugin = createPlugin({\n    name: \"func-event-source\",\n    eventSourceDefs: [\n        eventSourceDef$1\n    ]\n});\nconst JSON_FEED_EVENT_SOURCE_REFINERS = {\n    method: String,\n    extraParams: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.n,\n    startParam: String,\n    endParam: String,\n    timeZoneParam: String\n};\nlet eventSourceDef = {\n    parseMeta (refined) {\n        if (refined.url && (refined.format === \"json\" || !refined.format)) {\n            return {\n                url: refined.url,\n                format: \"json\",\n                method: (refined.method || \"GET\").toUpperCase(),\n                extraParams: refined.extraParams,\n                startParam: refined.startParam,\n                endParam: refined.endParam,\n                timeZoneParam: refined.timeZoneParam\n            };\n        }\n        return null;\n    },\n    fetch (arg, successCallback, errorCallback) {\n        const { meta } = arg.eventSource;\n        const requestParams = buildRequestParams(meta, arg.range, arg.context);\n        (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.r)(meta.method, meta.url, requestParams).then(([rawEvents, response])=>{\n            successCallback({\n                rawEvents,\n                response\n            });\n        }, errorCallback);\n    }\n};\nconst jsonFeedEventSourcePlugin = createPlugin({\n    name: \"json-event-source\",\n    eventSourceRefiners: JSON_FEED_EVENT_SOURCE_REFINERS,\n    eventSourceDefs: [\n        eventSourceDef\n    ]\n});\nfunction buildRequestParams(meta, range, context) {\n    let { dateEnv, options } = context;\n    let startParam;\n    let endParam;\n    let timeZoneParam;\n    let customRequestParams;\n    let params = {};\n    startParam = meta.startParam;\n    if (startParam == null) {\n        startParam = options.startParam;\n    }\n    endParam = meta.endParam;\n    if (endParam == null) {\n        endParam = options.endParam;\n    }\n    timeZoneParam = meta.timeZoneParam;\n    if (timeZoneParam == null) {\n        timeZoneParam = options.timeZoneParam;\n    }\n    // retrieve any outbound GET/POST data from the options\n    if (typeof meta.extraParams === \"function\") {\n        // supplied as a function that returns a key/value object\n        customRequestParams = meta.extraParams();\n    } else {\n        // probably supplied as a straight key/value object\n        customRequestParams = meta.extraParams || {};\n    }\n    Object.assign(params, customRequestParams);\n    params[startParam] = dateEnv.formatIso(range.start);\n    params[endParam] = dateEnv.formatIso(range.end);\n    if (dateEnv.timeZone !== \"local\") {\n        params[timeZoneParam] = dateEnv.timeZone;\n    }\n    return params;\n}\nconst SIMPLE_RECURRING_REFINERS = {\n    daysOfWeek: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.n,\n    startTime: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.d,\n    endTime: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.d,\n    duration: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.d,\n    startRecur: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.n,\n    endRecur: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.n\n};\nlet recurring = {\n    parse (refined, dateEnv) {\n        if (refined.daysOfWeek || refined.startTime || refined.endTime || refined.startRecur || refined.endRecur) {\n            let recurringData = {\n                daysOfWeek: refined.daysOfWeek || null,\n                startTime: refined.startTime || null,\n                endTime: refined.endTime || null,\n                startRecur: refined.startRecur ? dateEnv.createMarker(refined.startRecur) : null,\n                endRecur: refined.endRecur ? dateEnv.createMarker(refined.endRecur) : null\n            };\n            let duration;\n            if (refined.duration) {\n                duration = refined.duration;\n            }\n            if (!duration && refined.startTime && refined.endTime) {\n                duration = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.s)(refined.endTime, refined.startTime);\n            }\n            return {\n                allDayGuess: Boolean(!refined.startTime && !refined.endTime),\n                duration,\n                typeData: recurringData\n            };\n        }\n        return null;\n    },\n    expand (typeData, framingRange, dateEnv) {\n        let clippedFramingRange = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.o)(framingRange, {\n            start: typeData.startRecur,\n            end: typeData.endRecur\n        });\n        if (clippedFramingRange) {\n            return expandRanges(typeData.daysOfWeek, typeData.startTime, clippedFramingRange, dateEnv);\n        }\n        return [];\n    }\n};\nconst simpleRecurringEventsPlugin = createPlugin({\n    name: \"simple-recurring-event\",\n    recurringTypes: [\n        recurring\n    ],\n    eventRefiners: SIMPLE_RECURRING_REFINERS\n});\nfunction expandRanges(daysOfWeek, startTime, framingRange, dateEnv) {\n    let dowHash = daysOfWeek ? (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.f)(daysOfWeek) : null;\n    let dayMarker = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.q)(framingRange.start);\n    let endMarker = framingRange.end;\n    let instanceStarts = [];\n    while(dayMarker < endMarker){\n        let instanceStart;\n        // if everyday, or this particular day-of-week\n        if (!dowHash || dowHash[dayMarker.getUTCDay()]) {\n            if (startTime) {\n                instanceStart = dateEnv.add(dayMarker, startTime);\n            } else {\n                instanceStart = dayMarker;\n            }\n            instanceStarts.push(instanceStart);\n        }\n        dayMarker = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.t)(dayMarker, 1);\n    }\n    return instanceStarts;\n}\nconst changeHandlerPlugin = createPlugin({\n    name: \"change-handler\",\n    optionChangeHandlers: {\n        events (events, context) {\n            handleEventSources([\n                events\n            ], context);\n        },\n        eventSources: handleEventSources\n    }\n});\n/*\nBUG: if `event` was supplied, all previously-given `eventSources` will be wiped out\n*/ function handleEventSources(inputs, context) {\n    let unfoundSources = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.v)(context.getCurrentData().eventSources);\n    if (unfoundSources.length === 1 && inputs.length === 1 && Array.isArray(unfoundSources[0]._raw) && Array.isArray(inputs[0])) {\n        context.dispatch({\n            type: \"RESET_RAW_EVENTS\",\n            sourceId: unfoundSources[0].sourceId,\n            rawEvents: inputs[0]\n        });\n        return;\n    }\n    let newInputs = [];\n    for (let input of inputs){\n        let inputFound = false;\n        for(let i = 0; i < unfoundSources.length; i += 1){\n            if (unfoundSources[i]._raw === input) {\n                unfoundSources.splice(i, 1); // delete\n                inputFound = true;\n                break;\n            }\n        }\n        if (!inputFound) {\n            newInputs.push(input);\n        }\n    }\n    for (let unfoundSource of unfoundSources){\n        context.dispatch({\n            type: \"REMOVE_EVENT_SOURCE\",\n            sourceId: unfoundSource.sourceId\n        });\n    }\n    for (let newInput of newInputs){\n        context.calendarApi.addEventSource(newInput);\n    }\n}\nfunction handleDateProfile(dateProfile, context) {\n    context.emitter.trigger(\"datesSet\", Object.assign(Object.assign({}, (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.l)(dateProfile.activeRange, context.dateEnv)), {\n        view: context.viewApi\n    }));\n}\nfunction handleEventStore(eventStore, context) {\n    let { emitter } = context;\n    if (emitter.hasHandlers(\"eventsSet\")) {\n        emitter.trigger(\"eventsSet\", (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.w)(eventStore, context));\n    }\n}\n/*\nthis array is exposed on the root namespace so that UMD plugins can add to it.\nsee the rollup-bundles script.\n*/ const globalPlugins = [\n    arrayEventSourcePlugin,\n    funcEventSourcePlugin,\n    jsonFeedEventSourcePlugin,\n    simpleRecurringEventsPlugin,\n    changeHandlerPlugin,\n    createPlugin({\n        name: \"misc\",\n        isLoadingFuncs: [\n            (state)=>computeEventSourcesLoading(state.eventSources)\n        ],\n        propSetHandlers: {\n            dateProfile: handleDateProfile,\n            eventStore: handleEventStore\n        }\n    })\n];\nclass TaskRunner {\n    constructor(runTaskOption, drainedOption){\n        this.runTaskOption = runTaskOption;\n        this.drainedOption = drainedOption;\n        this.queue = [];\n        this.delayedRunner = new _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.D(this.drain.bind(this));\n    }\n    request(task, delay) {\n        this.queue.push(task);\n        this.delayedRunner.request(delay);\n    }\n    pause(scope) {\n        this.delayedRunner.pause(scope);\n    }\n    resume(scope, force) {\n        this.delayedRunner.resume(scope, force);\n    }\n    drain() {\n        let { queue } = this;\n        while(queue.length){\n            let completedTasks = [];\n            let task;\n            while(task = queue.shift()){\n                this.runTask(task);\n                completedTasks.push(task);\n            }\n            this.drained(completedTasks);\n        } // keep going, in case new tasks were added in the drained handler\n    }\n    runTask(task) {\n        if (this.runTaskOption) {\n            this.runTaskOption(task);\n        }\n    }\n    drained(completedTasks) {\n        if (this.drainedOption) {\n            this.drainedOption(completedTasks);\n        }\n    }\n}\n// Computes what the title at the top of the calendarApi should be for this view\nfunction buildTitle(dateProfile, viewOptions, dateEnv) {\n    let range;\n    // for views that span a large unit of time, show the proper interval, ignoring stray days before and after\n    if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {\n        range = dateProfile.currentRange;\n    } else {\n        range = dateProfile.activeRange;\n    }\n    return dateEnv.formatRange(range.start, range.end, (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.x)(viewOptions.titleFormat || buildTitleFormat(dateProfile)), {\n        isEndExclusive: dateProfile.isRangeAllDay,\n        defaultSeparator: viewOptions.titleRangeSeparator\n    });\n}\n// Generates the format string that should be used to generate the title for the current date range.\n// Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.\nfunction buildTitleFormat(dateProfile) {\n    let { currentRangeUnit } = dateProfile;\n    if (currentRangeUnit === \"year\") {\n        return {\n            year: \"numeric\"\n        };\n    }\n    if (currentRangeUnit === \"month\") {\n        return {\n            year: \"numeric\",\n            month: \"long\"\n        }; // like \"September 2014\"\n    }\n    let days = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.y)(dateProfile.currentRange.start, dateProfile.currentRange.end);\n    if (days !== null && days > 1) {\n        // multi-day range. shorter, like \"Sep 9 - 10 2014\"\n        return {\n            year: \"numeric\",\n            month: \"short\",\n            day: \"numeric\"\n        };\n    }\n    // one day. longer, like \"September 9 2014\"\n    return {\n        year: \"numeric\",\n        month: \"long\",\n        day: \"numeric\"\n    };\n}\n// in future refactor, do the redux-style function(state=initial) for initial-state\n// also, whatever is happening in constructor, have it happen in action queue too\nclass CalendarDataManager {\n    constructor(props){\n        this.computeCurrentViewData = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(this._computeCurrentViewData);\n        this.organizeRawLocales = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(organizeRawLocales);\n        this.buildLocale = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildLocale);\n        this.buildPluginHooks = buildBuildPluginHooks();\n        this.buildDateEnv = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildDateEnv$1);\n        this.buildTheme = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildTheme);\n        this.parseToolbars = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(parseToolbars);\n        this.buildViewSpecs = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildViewSpecs);\n        this.buildDateProfileGenerator = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.A)(buildDateProfileGenerator);\n        this.buildViewApi = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildViewApi);\n        this.buildViewUiProps = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.A)(buildViewUiProps);\n        this.buildEventUiBySource = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildEventUiBySource, _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.E);\n        this.buildEventUiBases = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildEventUiBases);\n        this.parseContextBusinessHours = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.A)(parseContextBusinessHours);\n        this.buildTitle = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildTitle);\n        this.emitter = new _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.F();\n        this.actionRunner = new TaskRunner(this._handleAction.bind(this), this.updateData.bind(this));\n        this.currentCalendarOptionsInput = {};\n        this.currentCalendarOptionsRefined = {};\n        this.currentViewOptionsInput = {};\n        this.currentViewOptionsRefined = {};\n        this.currentCalendarOptionsRefiners = {};\n        this.optionsForRefining = [];\n        this.optionsForHandling = [];\n        this.getCurrentData = ()=>this.data;\n        this.dispatch = (action)=>{\n            this.actionRunner.request(action); // protects against recursive calls to _handleAction\n        };\n        this.props = props;\n        this.actionRunner.pause();\n        let dynamicOptionOverrides = {};\n        let optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);\n        let currentViewType = optionsData.calendarOptions.initialView || optionsData.pluginHooks.initialView;\n        let currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);\n        // wire things up\n        // TODO: not DRY\n        props.calendarApi.currentDataManager = this;\n        this.emitter.setThisContext(props.calendarApi);\n        this.emitter.setOptions(currentViewData.options);\n        let currentDate = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.G)(optionsData.calendarOptions, optionsData.dateEnv);\n        let dateProfile = currentViewData.dateProfileGenerator.build(currentDate);\n        if (!(0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.H)(dateProfile.activeRange, currentDate)) {\n            currentDate = dateProfile.currentRange.start;\n        }\n        let calendarContext = {\n            dateEnv: optionsData.dateEnv,\n            options: optionsData.calendarOptions,\n            pluginHooks: optionsData.pluginHooks,\n            calendarApi: props.calendarApi,\n            dispatch: this.dispatch,\n            emitter: this.emitter,\n            getCurrentData: this.getCurrentData\n        };\n        // needs to be after setThisContext\n        for (let callback of optionsData.pluginHooks.contextInit){\n            callback(calendarContext);\n        }\n        // NOT DRY\n        let eventSources = initEventSources(optionsData.calendarOptions, dateProfile, calendarContext);\n        let initialState = {\n            dynamicOptionOverrides,\n            currentViewType,\n            currentDate,\n            dateProfile,\n            businessHours: this.parseContextBusinessHours(calendarContext),\n            eventSources,\n            eventUiBases: {},\n            eventStore: (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.I)(),\n            renderableEventStore: (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.I)(),\n            dateSelection: null,\n            eventSelection: \"\",\n            eventDrag: null,\n            eventResize: null,\n            selectionConfig: this.buildViewUiProps(calendarContext).selectionConfig\n        };\n        let contextAndState = Object.assign(Object.assign({}, calendarContext), initialState);\n        for (let reducer of optionsData.pluginHooks.reducers){\n            Object.assign(initialState, reducer(null, null, contextAndState));\n        }\n        if (computeIsLoading(initialState, calendarContext)) {\n            this.emitter.trigger(\"loading\", true); // NOT DRY\n        }\n        this.state = initialState;\n        this.updateData();\n        this.actionRunner.resume();\n    }\n    resetOptions(optionOverrides, changedOptionNames) {\n        let { props } = this;\n        if (changedOptionNames === undefined) {\n            props.optionOverrides = optionOverrides;\n        } else {\n            props.optionOverrides = Object.assign(Object.assign({}, props.optionOverrides || {}), optionOverrides);\n            this.optionsForRefining.push(...changedOptionNames);\n        }\n        if (changedOptionNames === undefined || changedOptionNames.length) {\n            this.actionRunner.request({\n                type: \"NOTHING\"\n            });\n        }\n    }\n    _handleAction(action) {\n        let { props, state, emitter } = this;\n        let dynamicOptionOverrides = reduceDynamicOptionOverrides(state.dynamicOptionOverrides, action);\n        let optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);\n        let currentViewType = reduceViewType(state.currentViewType, action);\n        let currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);\n        // wire things up\n        // TODO: not DRY\n        props.calendarApi.currentDataManager = this;\n        emitter.setThisContext(props.calendarApi);\n        emitter.setOptions(currentViewData.options);\n        let calendarContext = {\n            dateEnv: optionsData.dateEnv,\n            options: optionsData.calendarOptions,\n            pluginHooks: optionsData.pluginHooks,\n            calendarApi: props.calendarApi,\n            dispatch: this.dispatch,\n            emitter,\n            getCurrentData: this.getCurrentData\n        };\n        let { currentDate, dateProfile } = state;\n        if (this.data && this.data.dateProfileGenerator !== currentViewData.dateProfileGenerator) {\n            dateProfile = currentViewData.dateProfileGenerator.build(currentDate);\n        }\n        currentDate = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.J)(currentDate, action);\n        dateProfile = reduceDateProfile(dateProfile, action, currentDate, currentViewData.dateProfileGenerator);\n        if (action.type === \"PREV\" || // TODO: move this logic into DateProfileGenerator\n        action.type === \"NEXT\" || // \"\n        !(0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.H)(dateProfile.currentRange, currentDate)) {\n            currentDate = dateProfile.currentRange.start;\n        }\n        let eventSources = reduceEventSources(state.eventSources, action, dateProfile, calendarContext);\n        let eventStore = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.K)(state.eventStore, action, eventSources, dateProfile, calendarContext);\n        let isEventsLoading = computeEventSourcesLoading(eventSources); // BAD. also called in this func in computeIsLoading\n        let renderableEventStore = isEventsLoading && !currentViewData.options.progressiveEventRendering ? state.renderableEventStore || eventStore : eventStore;\n        let { eventUiSingleBase, selectionConfig } = this.buildViewUiProps(calendarContext); // will memoize obj\n        let eventUiBySource = this.buildEventUiBySource(eventSources);\n        let eventUiBases = this.buildEventUiBases(renderableEventStore.defs, eventUiSingleBase, eventUiBySource);\n        let newState = {\n            dynamicOptionOverrides,\n            currentViewType,\n            currentDate,\n            dateProfile,\n            eventSources,\n            eventStore,\n            renderableEventStore,\n            selectionConfig,\n            eventUiBases,\n            businessHours: this.parseContextBusinessHours(calendarContext),\n            dateSelection: reduceDateSelection(state.dateSelection, action),\n            eventSelection: reduceSelectedEvent(state.eventSelection, action),\n            eventDrag: reduceEventDrag(state.eventDrag, action),\n            eventResize: reduceEventResize(state.eventResize, action)\n        };\n        let contextAndState = Object.assign(Object.assign({}, calendarContext), newState);\n        for (let reducer of optionsData.pluginHooks.reducers){\n            Object.assign(newState, reducer(state, action, contextAndState)); // give the OLD state, for old value\n        }\n        let wasLoading = computeIsLoading(state, calendarContext);\n        let isLoading = computeIsLoading(newState, calendarContext);\n        // TODO: use propSetHandlers in plugin system\n        if (!wasLoading && isLoading) {\n            emitter.trigger(\"loading\", true);\n        } else if (wasLoading && !isLoading) {\n            emitter.trigger(\"loading\", false);\n        }\n        this.state = newState;\n        if (props.onAction) {\n            props.onAction(action);\n        }\n    }\n    updateData() {\n        let { props, state } = this;\n        let oldData = this.data;\n        let optionsData = this.computeOptionsData(props.optionOverrides, state.dynamicOptionOverrides, props.calendarApi);\n        let currentViewData = this.computeCurrentViewData(state.currentViewType, optionsData, props.optionOverrides, state.dynamicOptionOverrides);\n        let data = this.data = Object.assign(Object.assign(Object.assign({\n            viewTitle: this.buildTitle(state.dateProfile, currentViewData.options, optionsData.dateEnv),\n            calendarApi: props.calendarApi,\n            dispatch: this.dispatch,\n            emitter: this.emitter,\n            getCurrentData: this.getCurrentData\n        }, optionsData), currentViewData), state);\n        let changeHandlers = optionsData.pluginHooks.optionChangeHandlers;\n        let oldCalendarOptions = oldData && oldData.calendarOptions;\n        let newCalendarOptions = optionsData.calendarOptions;\n        if (oldCalendarOptions && oldCalendarOptions !== newCalendarOptions) {\n            if (oldCalendarOptions.timeZone !== newCalendarOptions.timeZone) {\n                // hack\n                state.eventSources = data.eventSources = reduceEventSourcesNewTimeZone(data.eventSources, state.dateProfile, data);\n                state.eventStore = data.eventStore = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.L)(data.eventStore, oldData.dateEnv, data.dateEnv);\n                state.renderableEventStore = data.renderableEventStore = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.L)(data.renderableEventStore, oldData.dateEnv, data.dateEnv);\n            }\n            for(let optionName in changeHandlers){\n                if (this.optionsForHandling.indexOf(optionName) !== -1 || oldCalendarOptions[optionName] !== newCalendarOptions[optionName]) {\n                    changeHandlers[optionName](newCalendarOptions[optionName], data);\n                }\n            }\n        }\n        this.optionsForHandling = [];\n        if (props.onData) {\n            props.onData(data);\n        }\n    }\n    computeOptionsData(optionOverrides, dynamicOptionOverrides, calendarApi) {\n        // TODO: blacklist options that are handled by optionChangeHandlers\n        if (!this.optionsForRefining.length && optionOverrides === this.stableOptionOverrides && dynamicOptionOverrides === this.stableDynamicOptionOverrides) {\n            return this.stableCalendarOptionsData;\n        }\n        let { refinedOptions, pluginHooks, localeDefaults, availableLocaleData, extra } = this.processRawCalendarOptions(optionOverrides, dynamicOptionOverrides);\n        warnUnknownOptions(extra);\n        let dateEnv = this.buildDateEnv(refinedOptions.timeZone, refinedOptions.locale, refinedOptions.weekNumberCalculation, refinedOptions.firstDay, refinedOptions.weekText, pluginHooks, availableLocaleData, refinedOptions.defaultRangeSeparator);\n        let viewSpecs = this.buildViewSpecs(pluginHooks.views, this.stableOptionOverrides, this.stableDynamicOptionOverrides, localeDefaults);\n        let theme = this.buildTheme(refinedOptions, pluginHooks);\n        let toolbarConfig = this.parseToolbars(refinedOptions, this.stableOptionOverrides, theme, viewSpecs, calendarApi);\n        return this.stableCalendarOptionsData = {\n            calendarOptions: refinedOptions,\n            pluginHooks,\n            dateEnv,\n            viewSpecs,\n            theme,\n            toolbarConfig,\n            localeDefaults,\n            availableRawLocales: availableLocaleData.map\n        };\n    }\n    // always called from behind a memoizer\n    processRawCalendarOptions(optionOverrides, dynamicOptionOverrides) {\n        let { locales, locale } = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.M)([\n            _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.e,\n            optionOverrides,\n            dynamicOptionOverrides\n        ]);\n        let availableLocaleData = this.organizeRawLocales(locales);\n        let availableRawLocales = availableLocaleData.map;\n        let localeDefaults = this.buildLocale(locale || availableLocaleData.defaultCode, availableRawLocales).options;\n        let pluginHooks = this.buildPluginHooks(optionOverrides.plugins || [], globalPlugins);\n        let refiners = this.currentCalendarOptionsRefiners = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.N), _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.O), _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.P), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);\n        let extra = {};\n        let raw = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.M)([\n            _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.e,\n            localeDefaults,\n            optionOverrides,\n            dynamicOptionOverrides\n        ]);\n        let refined = {};\n        let currentRaw = this.currentCalendarOptionsInput;\n        let currentRefined = this.currentCalendarOptionsRefined;\n        let anyChanges = false;\n        for(let optionName in raw){\n            if (this.optionsForRefining.indexOf(optionName) === -1 && (raw[optionName] === currentRaw[optionName] || _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.Q[optionName] && optionName in currentRaw && _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.Q[optionName](currentRaw[optionName], raw[optionName]))) {\n                refined[optionName] = currentRefined[optionName];\n            } else if (refiners[optionName]) {\n                refined[optionName] = refiners[optionName](raw[optionName]);\n                anyChanges = true;\n            } else {\n                extra[optionName] = currentRaw[optionName];\n            }\n        }\n        if (anyChanges) {\n            this.currentCalendarOptionsInput = raw;\n            this.currentCalendarOptionsRefined = refined;\n            this.stableOptionOverrides = optionOverrides;\n            this.stableDynamicOptionOverrides = dynamicOptionOverrides;\n        }\n        this.optionsForHandling.push(...this.optionsForRefining);\n        this.optionsForRefining = [];\n        return {\n            rawOptions: this.currentCalendarOptionsInput,\n            refinedOptions: this.currentCalendarOptionsRefined,\n            pluginHooks,\n            availableLocaleData,\n            localeDefaults,\n            extra\n        };\n    }\n    _computeCurrentViewData(viewType, optionsData, optionOverrides, dynamicOptionOverrides) {\n        let viewSpec = optionsData.viewSpecs[viewType];\n        if (!viewSpec) {\n            throw new Error(`viewType \"${viewType}\" is not available. Please make sure you've loaded all neccessary plugins`);\n        }\n        let { refinedOptions, extra } = this.processRawViewOptions(viewSpec, optionsData.pluginHooks, optionsData.localeDefaults, optionOverrides, dynamicOptionOverrides);\n        warnUnknownOptions(extra);\n        let dateProfileGenerator = this.buildDateProfileGenerator({\n            dateProfileGeneratorClass: viewSpec.optionDefaults.dateProfileGeneratorClass,\n            duration: viewSpec.duration,\n            durationUnit: viewSpec.durationUnit,\n            usesMinMaxTime: viewSpec.optionDefaults.usesMinMaxTime,\n            dateEnv: optionsData.dateEnv,\n            calendarApi: this.props.calendarApi,\n            slotMinTime: refinedOptions.slotMinTime,\n            slotMaxTime: refinedOptions.slotMaxTime,\n            showNonCurrentDates: refinedOptions.showNonCurrentDates,\n            dayCount: refinedOptions.dayCount,\n            dateAlignment: refinedOptions.dateAlignment,\n            dateIncrement: refinedOptions.dateIncrement,\n            hiddenDays: refinedOptions.hiddenDays,\n            weekends: refinedOptions.weekends,\n            nowInput: refinedOptions.now,\n            validRangeInput: refinedOptions.validRange,\n            visibleRangeInput: refinedOptions.visibleRange,\n            fixedWeekCount: refinedOptions.fixedWeekCount\n        });\n        let viewApi = this.buildViewApi(viewType, this.getCurrentData, optionsData.dateEnv);\n        return {\n            viewSpec,\n            options: refinedOptions,\n            dateProfileGenerator,\n            viewApi\n        };\n    }\n    processRawViewOptions(viewSpec, pluginHooks, localeDefaults, optionOverrides, dynamicOptionOverrides) {\n        let raw = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.M)([\n            _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.e,\n            viewSpec.optionDefaults,\n            localeDefaults,\n            optionOverrides,\n            viewSpec.optionOverrides,\n            dynamicOptionOverrides\n        ]);\n        let refiners = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.N), _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.O), _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.P), _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.R), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);\n        let refined = {};\n        let currentRaw = this.currentViewOptionsInput;\n        let currentRefined = this.currentViewOptionsRefined;\n        let anyChanges = false;\n        let extra = {};\n        for(let optionName in raw){\n            if (raw[optionName] === currentRaw[optionName] || _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.Q[optionName] && _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.Q[optionName](raw[optionName], currentRaw[optionName])) {\n                refined[optionName] = currentRefined[optionName];\n            } else {\n                if (raw[optionName] === this.currentCalendarOptionsInput[optionName] || _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.Q[optionName] && _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.Q[optionName](raw[optionName], this.currentCalendarOptionsInput[optionName])) {\n                    if (optionName in this.currentCalendarOptionsRefined) {\n                        refined[optionName] = this.currentCalendarOptionsRefined[optionName];\n                    }\n                } else if (refiners[optionName]) {\n                    refined[optionName] = refiners[optionName](raw[optionName]);\n                } else {\n                    extra[optionName] = raw[optionName];\n                }\n                anyChanges = true;\n            }\n        }\n        if (anyChanges) {\n            this.currentViewOptionsInput = raw;\n            this.currentViewOptionsRefined = refined;\n        }\n        return {\n            rawOptions: this.currentViewOptionsInput,\n            refinedOptions: this.currentViewOptionsRefined,\n            extra\n        };\n    }\n}\nfunction buildDateEnv$1(timeZone, explicitLocale, weekNumberCalculation, firstDay, weekText, pluginHooks, availableLocaleData, defaultSeparator) {\n    let locale = buildLocale(explicitLocale || availableLocaleData.defaultCode, availableLocaleData.map);\n    return new _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.S({\n        calendarSystem: \"gregory\",\n        timeZone,\n        namedTimeZoneImpl: pluginHooks.namedTimeZonedImpl,\n        locale,\n        weekNumberCalculation,\n        firstDay,\n        weekText,\n        cmdFormatter: pluginHooks.cmdFormatter,\n        defaultSeparator\n    });\n}\nfunction buildTheme(options, pluginHooks) {\n    let ThemeClass = pluginHooks.themeClasses[options.themeSystem] || StandardTheme;\n    return new ThemeClass(options);\n}\nfunction buildDateProfileGenerator(props) {\n    let DateProfileGeneratorClass = props.dateProfileGeneratorClass || _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.U;\n    return new DateProfileGeneratorClass(props);\n}\nfunction buildViewApi(type, getCurrentData, dateEnv) {\n    return new ViewImpl(type, getCurrentData, dateEnv);\n}\nfunction buildEventUiBySource(eventSources) {\n    return (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a)(eventSources, (eventSource)=>eventSource.ui);\n}\nfunction buildEventUiBases(eventDefs, eventUiSingleBase, eventUiBySource) {\n    let eventUiBases = {\n        \"\": eventUiSingleBase\n    };\n    for(let defId in eventDefs){\n        let def = eventDefs[defId];\n        if (def.sourceId && eventUiBySource[def.sourceId]) {\n            eventUiBases[defId] = eventUiBySource[def.sourceId];\n        }\n    }\n    return eventUiBases;\n}\nfunction buildViewUiProps(calendarContext) {\n    let { options } = calendarContext;\n    return {\n        eventUiSingleBase: (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.W)({\n            display: options.eventDisplay,\n            editable: options.editable,\n            startEditable: options.eventStartEditable,\n            durationEditable: options.eventDurationEditable,\n            constraint: options.eventConstraint,\n            overlap: typeof options.eventOverlap === \"boolean\" ? options.eventOverlap : undefined,\n            allow: options.eventAllow,\n            backgroundColor: options.eventBackgroundColor,\n            borderColor: options.eventBorderColor,\n            textColor: options.eventTextColor,\n            color: options.eventColor\n        }, calendarContext),\n        selectionConfig: (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.W)({\n            constraint: options.selectConstraint,\n            overlap: typeof options.selectOverlap === \"boolean\" ? options.selectOverlap : undefined,\n            allow: options.selectAllow\n        }, calendarContext)\n    };\n}\nfunction computeIsLoading(state, context) {\n    for (let isLoadingFunc of context.pluginHooks.isLoadingFuncs){\n        if (isLoadingFunc(state)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction parseContextBusinessHours(calendarContext) {\n    return (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.X)(calendarContext.options.businessHours, calendarContext);\n}\nfunction warnUnknownOptions(options, viewName) {\n    for(let optionName in options){\n        console.warn(`Unknown option '${optionName}'` + (viewName ? ` for view '${viewName}'` : \"\"));\n    }\n}\nclass ToolbarSection extends _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    render() {\n        let children = this.props.widgetGroups.map((widgetGroup)=>this.renderWidgetGroup(widgetGroup));\n        return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            className: \"fc-toolbar-chunk\"\n        }, ...children);\n    }\n    renderWidgetGroup(widgetGroup) {\n        let { props } = this;\n        let { theme } = this.context;\n        let children = [];\n        let isOnlyButtons = true;\n        for (let widget of widgetGroup){\n            let { buttonName, buttonClick, buttonText, buttonIcon, buttonHint } = widget;\n            if (buttonName === \"title\") {\n                isOnlyButtons = false;\n                children.push((0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"h2\", {\n                    className: \"fc-toolbar-title\",\n                    id: props.titleId\n                }, props.title));\n            } else {\n                let isPressed = buttonName === props.activeButton;\n                let isDisabled = !props.isTodayEnabled && buttonName === \"today\" || !props.isPrevEnabled && buttonName === \"prev\" || !props.isNextEnabled && buttonName === \"next\";\n                let buttonClasses = [\n                    `fc-${buttonName}-button`,\n                    theme.getClass(\"button\")\n                ];\n                if (isPressed) {\n                    buttonClasses.push(theme.getClass(\"buttonActive\"));\n                }\n                children.push((0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"button\", {\n                    type: \"button\",\n                    title: typeof buttonHint === \"function\" ? buttonHint(props.navUnit) : buttonHint,\n                    disabled: isDisabled,\n                    \"aria-pressed\": isPressed,\n                    className: buttonClasses.join(\" \"),\n                    onClick: buttonClick\n                }, buttonText || (buttonIcon ? (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"span\", {\n                    className: buttonIcon,\n                    role: \"img\"\n                }) : \"\")));\n            }\n        }\n        if (children.length > 1) {\n            let groupClassName = isOnlyButtons && theme.getClass(\"buttonGroup\") || \"\";\n            return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: groupClassName\n            }, ...children);\n        }\n        return children[0];\n    }\n}\nclass Toolbar extends _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    render() {\n        let { model, extraClassName } = this.props;\n        let forceLtr = false;\n        let startContent;\n        let endContent;\n        let sectionWidgets = model.sectionWidgets;\n        let centerContent = sectionWidgets.center;\n        if (sectionWidgets.left) {\n            forceLtr = true;\n            startContent = sectionWidgets.left;\n        } else {\n            startContent = sectionWidgets.start;\n        }\n        if (sectionWidgets.right) {\n            forceLtr = true;\n            endContent = sectionWidgets.right;\n        } else {\n            endContent = sectionWidgets.end;\n        }\n        let classNames = [\n            extraClassName || \"\",\n            \"fc-toolbar\",\n            forceLtr ? \"fc-toolbar-ltr\" : \"\"\n        ];\n        return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            className: classNames.join(\" \")\n        }, this.renderSection(\"start\", startContent || []), this.renderSection(\"center\", centerContent || []), this.renderSection(\"end\", endContent || []));\n    }\n    renderSection(key, widgetGroups) {\n        let { props } = this;\n        return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(ToolbarSection, {\n            key: key,\n            widgetGroups: widgetGroups,\n            title: props.title,\n            navUnit: props.navUnit,\n            activeButton: props.activeButton,\n            isTodayEnabled: props.isTodayEnabled,\n            isPrevEnabled: props.isPrevEnabled,\n            isNextEnabled: props.isNextEnabled,\n            titleId: props.titleId\n        });\n    }\n}\nclass ViewHarness extends _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    constructor(){\n        super(...arguments);\n        this.state = {\n            availableWidth: null\n        };\n        this.handleEl = (el)=>{\n            this.el = el;\n            (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.Y)(this.props.elRef, el);\n            this.updateAvailableWidth();\n        };\n        this.handleResize = ()=>{\n            this.updateAvailableWidth();\n        };\n    }\n    render() {\n        let { props, state } = this;\n        let { aspectRatio } = props;\n        let classNames = [\n            \"fc-view-harness\",\n            aspectRatio || props.liquid || props.height ? \"fc-view-harness-active\" // harness controls the height\n             : \"fc-view-harness-passive\"\n        ];\n        let height = \"\";\n        let paddingBottom = \"\";\n        if (aspectRatio) {\n            if (state.availableWidth !== null) {\n                height = state.availableWidth / aspectRatio;\n            } else {\n                // while waiting to know availableWidth, we can't set height to *zero*\n                // because will cause lots of unnecessary scrollbars within scrollgrid.\n                // BETTER: don't start rendering ANYTHING yet until we know container width\n                // NOTE: why not always use paddingBottom? Causes height oscillation (issue 5606)\n                paddingBottom = `${1 / aspectRatio * 100}%`;\n            }\n        } else {\n            height = props.height || \"\";\n        }\n        return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            \"aria-labelledby\": props.labeledById,\n            ref: this.handleEl,\n            className: classNames.join(\" \"),\n            style: {\n                height,\n                paddingBottom\n            }\n        }, props.children);\n    }\n    componentDidMount() {\n        this.context.addResizeHandler(this.handleResize);\n    }\n    componentWillUnmount() {\n        this.context.removeResizeHandler(this.handleResize);\n    }\n    updateAvailableWidth() {\n        if (this.el && // needed. but why?\n        this.props.aspectRatio // aspectRatio is the only height setting that needs availableWidth\n        ) {\n            this.setState({\n                availableWidth: this.el.offsetWidth\n            });\n        }\n    }\n}\n/*\nDetects when the user clicks on an event within a DateComponent\n*/ class EventClicking extends _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.Z {\n    constructor(settings){\n        super(settings);\n        this.handleSegClick = (ev, segEl)=>{\n            let { component } = this;\n            let { context } = component;\n            let seg = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__._)(segEl);\n            if (seg && // might be the <div> surrounding the more link\n            component.isValidSegDownEl(ev.target)) {\n                // our way to simulate a link click for elements that can't be <a> tags\n                // grab before trigger fired in case trigger trashes DOM thru rerendering\n                let hasUrlContainer = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.$)(ev.target, \".fc-event-forced-url\");\n                let url = hasUrlContainer ? hasUrlContainer.querySelector(\"a[href]\").href : \"\";\n                context.emitter.trigger(\"eventClick\", {\n                    el: segEl,\n                    event: new _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a0(component.context, seg.eventRange.def, seg.eventRange.instance),\n                    jsEvent: ev,\n                    view: context.viewApi\n                });\n                if (url && !ev.defaultPrevented) {\n                    window.location.href = url;\n                }\n            }\n        };\n        this.destroy = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a1)(settings.el, \"click\", \".fc-event\", this.handleSegClick);\n    }\n}\n/*\nTriggers events and adds/removes core classNames when the user's pointer\nenters/leaves event-elements of a component.\n*/ class EventHovering extends _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.Z {\n    constructor(settings){\n        super(settings);\n        // for simulating an eventMouseLeave when the event el is destroyed while mouse is over it\n        this.handleEventElRemove = (el)=>{\n            if (el === this.currentSegEl) {\n                this.handleSegLeave(null, this.currentSegEl);\n            }\n        };\n        this.handleSegEnter = (ev, segEl)=>{\n            if ((0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__._)(segEl)) {\n                this.currentSegEl = segEl;\n                this.triggerEvent(\"eventMouseEnter\", ev, segEl);\n            }\n        };\n        this.handleSegLeave = (ev, segEl)=>{\n            if (this.currentSegEl) {\n                this.currentSegEl = null;\n                this.triggerEvent(\"eventMouseLeave\", ev, segEl);\n            }\n        };\n        this.removeHoverListeners = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a2)(settings.el, \".fc-event\", this.handleSegEnter, this.handleSegLeave);\n    }\n    destroy() {\n        this.removeHoverListeners();\n    }\n    triggerEvent(publicEvName, ev, segEl) {\n        let { component } = this;\n        let { context } = component;\n        let seg = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__._)(segEl);\n        if (!ev || component.isValidSegDownEl(ev.target)) {\n            context.emitter.trigger(publicEvName, {\n                el: segEl,\n                event: new _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a0(context, seg.eventRange.def, seg.eventRange.instance),\n                jsEvent: ev,\n                view: context.viewApi\n            });\n        }\n    }\n}\nclass CalendarContent extends _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a3 {\n    constructor(){\n        super(...arguments);\n        this.buildViewContext = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a4);\n        this.buildViewPropTransformers = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildViewPropTransformers);\n        this.buildToolbarProps = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildToolbarProps);\n        this.headerRef = (0,preact__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        this.footerRef = (0,preact__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        this.interactionsStore = {};\n        // eslint-disable-next-line\n        this.state = {\n            viewLabelId: (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a5)()\n        };\n        // Component Registration\n        // -----------------------------------------------------------------------------------------------------------------\n        this.registerInteractiveComponent = (component, settingsInput)=>{\n            let settings = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a6)(component, settingsInput);\n            let DEFAULT_INTERACTIONS = [\n                EventClicking,\n                EventHovering\n            ];\n            let interactionClasses = DEFAULT_INTERACTIONS.concat(this.props.pluginHooks.componentInteractions);\n            let interactions = interactionClasses.map((TheInteractionClass)=>new TheInteractionClass(settings));\n            this.interactionsStore[component.uid] = interactions;\n            _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a7[component.uid] = settings;\n        };\n        this.unregisterInteractiveComponent = (component)=>{\n            let listeners = this.interactionsStore[component.uid];\n            if (listeners) {\n                for (let listener of listeners){\n                    listener.destroy();\n                }\n                delete this.interactionsStore[component.uid];\n            }\n            delete _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a7[component.uid];\n        };\n        // Resizing\n        // -----------------------------------------------------------------------------------------------------------------\n        this.resizeRunner = new _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.D(()=>{\n            this.props.emitter.trigger(\"_resize\", true); // should window resizes be considered \"forced\" ?\n            this.props.emitter.trigger(\"windowResize\", {\n                view: this.props.viewApi\n            });\n        });\n        this.handleWindowResize = (ev)=>{\n            let { options } = this.props;\n            if (options.handleWindowResize && ev.target === window // avoid jqui events\n            ) {\n                this.resizeRunner.request(options.windowResizeDelay);\n            }\n        };\n    }\n    /*\n    renders INSIDE of an outer div\n    */ render() {\n        let { props } = this;\n        let { toolbarConfig, options } = props;\n        let toolbarProps = this.buildToolbarProps(props.viewSpec, props.dateProfile, props.dateProfileGenerator, props.currentDate, (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a8)(props.options.now, props.dateEnv), props.viewTitle);\n        let viewVGrow = false;\n        let viewHeight = \"\";\n        let viewAspectRatio;\n        if (props.isHeightAuto || props.forPrint) {\n            viewHeight = \"\";\n        } else if (options.height != null) {\n            viewVGrow = true;\n        } else if (options.contentHeight != null) {\n            viewHeight = options.contentHeight;\n        } else {\n            viewAspectRatio = Math.max(options.aspectRatio, 0.5); // prevent from getting too tall\n        }\n        let viewContext = this.buildViewContext(props.viewSpec, props.viewApi, props.options, props.dateProfileGenerator, props.dateEnv, props.theme, props.pluginHooks, props.dispatch, props.getCurrentData, props.emitter, props.calendarApi, this.registerInteractiveComponent, this.unregisterInteractiveComponent);\n        let viewLabelId = toolbarConfig.header && toolbarConfig.header.hasTitle ? this.state.viewLabelId : undefined;\n        return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.V.Provider, {\n            value: viewContext\n        }, toolbarConfig.header && (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(Toolbar, Object.assign({\n            ref: this.headerRef,\n            extraClassName: \"fc-header-toolbar\",\n            model: toolbarConfig.header,\n            titleId: viewLabelId\n        }, toolbarProps)), (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(ViewHarness, {\n            liquid: viewVGrow,\n            height: viewHeight,\n            aspectRatio: viewAspectRatio,\n            labeledById: viewLabelId\n        }, this.renderView(props), this.buildAppendContent()), toolbarConfig.footer && (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(Toolbar, Object.assign({\n            ref: this.footerRef,\n            extraClassName: \"fc-footer-toolbar\",\n            model: toolbarConfig.footer,\n            titleId: \"\"\n        }, toolbarProps)));\n    }\n    componentDidMount() {\n        let { props } = this;\n        this.calendarInteractions = props.pluginHooks.calendarInteractions.map((CalendarInteractionClass)=>new CalendarInteractionClass(props));\n        window.addEventListener(\"resize\", this.handleWindowResize);\n        let { propSetHandlers } = props.pluginHooks;\n        for(let propName in propSetHandlers){\n            propSetHandlers[propName](props[propName], props);\n        }\n    }\n    componentDidUpdate(prevProps) {\n        let { props } = this;\n        let { propSetHandlers } = props.pluginHooks;\n        for(let propName in propSetHandlers){\n            if (props[propName] !== prevProps[propName]) {\n                propSetHandlers[propName](props[propName], props);\n            }\n        }\n    }\n    componentWillUnmount() {\n        window.removeEventListener(\"resize\", this.handleWindowResize);\n        this.resizeRunner.clear();\n        for (let interaction of this.calendarInteractions){\n            interaction.destroy();\n        }\n        this.props.emitter.trigger(\"_unmount\");\n    }\n    buildAppendContent() {\n        let { props } = this;\n        let children = props.pluginHooks.viewContainerAppends.map((buildAppendContent)=>buildAppendContent(props));\n        return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(preact__WEBPACK_IMPORTED_MODULE_1__.Fragment, {}, ...children);\n    }\n    renderView(props) {\n        let { pluginHooks } = props;\n        let { viewSpec } = props;\n        let viewProps = {\n            dateProfile: props.dateProfile,\n            businessHours: props.businessHours,\n            eventStore: props.renderableEventStore,\n            eventUiBases: props.eventUiBases,\n            dateSelection: props.dateSelection,\n            eventSelection: props.eventSelection,\n            eventDrag: props.eventDrag,\n            eventResize: props.eventResize,\n            isHeightAuto: props.isHeightAuto,\n            forPrint: props.forPrint\n        };\n        let transformers = this.buildViewPropTransformers(pluginHooks.viewPropsTransformers);\n        for (let transformer of transformers){\n            Object.assign(viewProps, transformer.transform(viewProps, props));\n        }\n        let ViewComponent = viewSpec.component;\n        return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(ViewComponent, Object.assign({}, viewProps));\n    }\n}\nfunction buildToolbarProps(viewSpec, dateProfile, dateProfileGenerator, currentDate, now, title) {\n    // don't force any date-profiles to valid date profiles (the `false`) so that we can tell if it's invalid\n    let todayInfo = dateProfileGenerator.build(now, undefined, false); // TODO: need `undefined` or else INFINITE LOOP for some reason\n    let prevInfo = dateProfileGenerator.buildPrev(dateProfile, currentDate, false);\n    let nextInfo = dateProfileGenerator.buildNext(dateProfile, currentDate, false);\n    return {\n        title,\n        activeButton: viewSpec.type,\n        navUnit: viewSpec.singleUnit,\n        isTodayEnabled: todayInfo.isValid && !(0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.H)(dateProfile.currentRange, now),\n        isPrevEnabled: prevInfo.isValid,\n        isNextEnabled: nextInfo.isValid\n    };\n}\n// Plugin\n// -----------------------------------------------------------------------------------------------------------------\nfunction buildViewPropTransformers(theClasses) {\n    return theClasses.map((TheClass)=>new TheClass());\n}\nclass Calendar extends _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a9 {\n    constructor(el, optionOverrides = {}){\n        super();\n        this.isRendering = false;\n        this.isRendered = false;\n        this.currentClassNames = [];\n        this.customContentRenderId = 0;\n        this.handleAction = (action)=>{\n            // actions we know we want to render immediately\n            switch(action.type){\n                case \"SET_EVENT_DRAG\":\n                case \"SET_EVENT_RESIZE\":\n                    this.renderRunner.tryDrain();\n            }\n        };\n        this.handleData = (data)=>{\n            this.currentData = data;\n            this.renderRunner.request(data.calendarOptions.rerenderDelay);\n        };\n        this.handleRenderRequest = ()=>{\n            if (this.isRendering) {\n                this.isRendered = true;\n                let { currentData } = this;\n                (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.aa)(()=>{\n                    (0,preact__WEBPACK_IMPORTED_MODULE_1__.render)((0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.ab, {\n                        options: currentData.calendarOptions,\n                        theme: currentData.theme,\n                        emitter: currentData.emitter\n                    }, (classNames, height, isHeightAuto, forPrint)=>{\n                        this.setClassNames(classNames);\n                        this.setHeight(height);\n                        return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.ac.Provider, {\n                            value: this.customContentRenderId\n                        }, (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(CalendarContent, Object.assign({\n                            isHeightAuto: isHeightAuto,\n                            forPrint: forPrint\n                        }, currentData)));\n                    }), this.el);\n                });\n            } else if (this.isRendered) {\n                this.isRendered = false;\n                (0,preact__WEBPACK_IMPORTED_MODULE_1__.render)(null, this.el);\n                this.setClassNames([]);\n                this.setHeight(\"\");\n            }\n        };\n        (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.ad)(el);\n        this.el = el;\n        this.renderRunner = new _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.D(this.handleRenderRequest);\n        new CalendarDataManager({\n            optionOverrides,\n            calendarApi: this,\n            onAction: this.handleAction,\n            onData: this.handleData\n        });\n    }\n    render() {\n        let wasRendering = this.isRendering;\n        if (!wasRendering) {\n            this.isRendering = true;\n        } else {\n            this.customContentRenderId += 1;\n        }\n        this.renderRunner.request();\n        if (wasRendering) {\n            this.updateSize();\n        }\n    }\n    destroy() {\n        if (this.isRendering) {\n            this.isRendering = false;\n            this.renderRunner.request();\n        }\n    }\n    updateSize() {\n        (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.aa)(()=>{\n            super.updateSize();\n        });\n    }\n    batchRendering(func) {\n        this.renderRunner.pause(\"batchRendering\");\n        func();\n        this.renderRunner.resume(\"batchRendering\");\n    }\n    pauseRendering() {\n        this.renderRunner.pause(\"pauseRendering\");\n    }\n    resumeRendering() {\n        this.renderRunner.resume(\"pauseRendering\", true);\n    }\n    resetOptions(optionOverrides, changedOptionNames) {\n        this.currentDataManager.resetOptions(optionOverrides, changedOptionNames);\n    }\n    setClassNames(classNames) {\n        if (!(0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.i)(classNames, this.currentClassNames)) {\n            let { classList } = this.el;\n            for (let className of this.currentClassNames){\n                classList.remove(className);\n            }\n            for (let className of classNames){\n                classList.add(className);\n            }\n            this.currentClassNames = classNames;\n        }\n    }\n    setHeight(height) {\n        (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.ae)(this.el, \"height\", height);\n    }\n}\nfunction formatDate(dateInput, options = {}) {\n    let dateEnv = buildDateEnv(options);\n    let formatter = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.x)(options);\n    let dateMeta = dateEnv.createMarkerMeta(dateInput);\n    if (!dateMeta) {\n        return \"\";\n    }\n    return dateEnv.format(dateMeta.marker, formatter, {\n        forcedTzo: dateMeta.forcedTzo\n    });\n}\nfunction formatRange(startInput, endInput, options) {\n    let dateEnv = buildDateEnv(typeof options === \"object\" && options ? options : {}); // pass in if non-null object\n    let formatter = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.x)(options);\n    let startMeta = dateEnv.createMarkerMeta(startInput);\n    let endMeta = dateEnv.createMarkerMeta(endInput);\n    if (!startMeta || !endMeta) {\n        return \"\";\n    }\n    return dateEnv.formatRange(startMeta.marker, endMeta.marker, formatter, {\n        forcedStartTzo: startMeta.forcedTzo,\n        forcedEndTzo: endMeta.forcedTzo,\n        isEndExclusive: options.isEndExclusive,\n        defaultSeparator: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.e.defaultRangeSeparator\n    });\n}\n// TODO: more DRY and optimized\nfunction buildDateEnv(settings) {\n    let locale = buildLocale(settings.locale || \"en\", organizeRawLocales([]).map); // TODO: don't hardcode 'en' everywhere\n    return new _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.S(Object.assign(Object.assign({\n        timeZone: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.e.timeZone,\n        calendarSystem: \"gregory\"\n    }, settings), {\n        locale\n    }));\n}\n// HELPERS\n/*\nif nextDayThreshold is specified, slicing is done in an all-day fashion.\nyou can get nextDayThreshold from context.nextDayThreshold\n*/ function sliceEvents(props, allDay) {\n    return (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.af)(props.eventStore, props.eventUiBases, props.dateProfile.activeRange, allDay ? props.nextDayThreshold : null).fg;\n}\nconst version = \"6.1.15\";\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFpaUQ7QUFDbitDO0FBQ007QUFDN0M7QUFFdkIsTUFBTWtKLGdCQUFnQixFQUFFO0FBRXhCLE1BQU1DLHdCQUF3QjtJQUMxQkMsTUFBTTtJQUNOQyxNQUFNO1FBQ0ZDLEtBQUs7UUFDTEMsS0FBSztJQUNUO0lBQ0FDLFdBQVc7SUFDWEMsWUFBWTtRQUNSQyxNQUFNO1FBQ05DLE1BQU07UUFDTkMsVUFBVTtRQUNWQyxVQUFVO1FBQ1ZDLE1BQU07UUFDTkMsT0FBTztRQUNQQyxPQUFPO1FBQ1BYLE1BQU07UUFDTlksS0FBSztRQUNMQyxNQUFNO0lBQ1Y7SUFDQUMsVUFBVTtJQUNWQyxjQUFjO0lBQ2RDLFdBQVc7SUFDWEMsVUFBVTtJQUNWQyxXQUFXO0lBQ1hDLFlBQVk7SUFDWkMsY0FBYztJQUNkQyxjQUFjO0FBQ2xCO0FBQ0EsTUFBTUMsZ0JBQWdCQyxPQUFPQyxNQUFNLENBQUNELE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUcxQix3QkFBd0I7SUFDMUUsMERBQTBEO0lBQzFELHNEQUFzRDtJQUN0RDJCLGFBQWE7UUFDVHBCLE1BQU07UUFDTkMsTUFBTTtRQUNOSSxPQUFNTixVQUFVLEVBQUVzQixJQUFJO1lBQ2xCLE9BQU8sU0FBVSxRQUNYLFVBQ0EsQ0FBQyxLQUFLLEVBQUV0QixXQUFXLENBQUM7UUFDOUI7SUFDSjtJQUFHdUIsVUFBVTtJQUFXQyxhQUFhO0lBQVlDLGNBQWFDLFFBQVE7UUFDbEUsT0FBTyxDQUFDLEtBQUssRUFBRUEsU0FBUyxXQUFXLEVBQUVBLGFBQWEsSUFBSSxLQUFLLElBQUksQ0FBQztJQUNwRTtBQUFFO0FBQ04sU0FBU0MsbUJBQW1CQyxrQkFBa0I7SUFDMUMsSUFBSUMsY0FBY0QsbUJBQW1CRSxNQUFNLEdBQUcsSUFBSUYsa0JBQWtCLENBQUMsRUFBRSxDQUFDakMsSUFBSSxHQUFHO0lBQy9F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QixZQUFZclosUUFBUWdaLGdCQUFnQixDQUFDRztJQUN6QyxJQUFJRyxVQUFVdFosUUFBUWdaLGdCQUFnQixDQUFDSTtJQUN2QyxJQUFJLENBQUNDLGFBQWEsQ0FBQ0MsU0FBUztRQUN4QixPQUFPO0lBQ1g7SUFDQSxPQUFPdFosUUFBUTJHLFdBQVcsQ0FBQzBTLFVBQVVKLE1BQU0sRUFBRUssUUFBUUwsTUFBTSxFQUFFSCxXQUFXO1FBQ3BFUyxnQkFBZ0JGLFVBQVVILFNBQVM7UUFDbkNNLGNBQWNGLFFBQVFKLFNBQVM7UUFDL0JwUyxnQkFBZ0JoWixRQUFRZ1osY0FBYztRQUN0Q0Usa0JBQWtCOWtCLGtEQUFvQkEsQ0FBQ3lwQixxQkFBcUI7SUFDaEU7QUFDSjtBQUNBLCtCQUErQjtBQUMvQixTQUFTcEUsYUFBYXdMLFFBQVE7SUFDMUIsSUFBSXZILFNBQVMvZSxZQUFZc21CLFNBQVN2SCxNQUFNLElBQUksTUFBTXpmLG1CQUFtQixFQUFFLEVBQUVTLEdBQUcsR0FBRyx1Q0FBdUM7SUFDdEgsT0FBTyxJQUFJaEcsa0RBQU9BLENBQUMrRSxPQUFPQyxNQUFNLENBQUNELE9BQU9DLE1BQU0sQ0FBQztRQUFFaVgsVUFBVXZnQixrREFBb0JBLENBQUN1Z0IsUUFBUTtRQUFFNkssZ0JBQWdCO0lBQVUsR0FBR3lGLFdBQVc7UUFBRXZIO0lBQU87QUFDL0k7QUFFQSxVQUFVO0FBQ1Y7OztBQUdBLEdBQ0EsU0FBU2lPLFlBQVlyUyxLQUFLLEVBQUVzUyxNQUFNO0lBQzlCLE9BQU9wd0IsdURBQWVBLENBQUM4ZCxNQUFNakMsVUFBVSxFQUFFaUMsTUFBTWtDLFlBQVksRUFBRWxDLE1BQU01TyxXQUFXLENBQUNDLFdBQVcsRUFBRWloQixTQUFTdFMsTUFBTXBTLGdCQUFnQixHQUFHLE1BQU0ya0IsRUFBRTtBQUMxSTtBQUVBLE1BQU1DLFVBQVU7QUFFK0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWhhc3BvcnQtbWFuYWdlbWVudC8uL25vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvaW5kZXguanM/YTY2YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtIGFzIG1lcmdlUHJvcHMsIGcgYXMgZ3VpZCwgaSBhcyBpc0FycmF5c0VxdWFsLCBUIGFzIFRoZW1lLCBhIGFzIG1hcEhhc2gsIEIgYXMgQmFzZUNvbXBvbmVudCwgViBhcyBWaWV3Q29udGV4dFR5cGUsIEMgYXMgQ29udGVudENvbnRhaW5lciwgYiBhcyBidWlsZFZpZXdDbGFzc05hbWVzLCBjIGFzIGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvciwgZCBhcyBjcmVhdGVEdXJhdGlvbiwgZSBhcyBCQVNFX09QVElPTl9ERUZBVUxUUywgZiBhcyBhcnJheVRvSGFzaCwgaCBhcyBmaWx0ZXJIYXNoLCBqIGFzIGJ1aWxkRXZlbnRTb3VyY2VSZWZpbmVycywgcCBhcyBwYXJzZUV2ZW50U291cmNlLCBrIGFzIGZvcm1hdFdpdGhPcmRpbmFscywgdSBhcyB1bnByb21pc2lmeSwgbCBhcyBidWlsZFJhbmdlQXBpV2l0aFRpbWVab25lLCBuIGFzIGlkZW50aXR5LCByIGFzIHJlcXVlc3RKc29uLCBzIGFzIHN1YnRyYWN0RHVyYXRpb25zLCBvIGFzIGludGVyc2VjdFJhbmdlcywgcSBhcyBzdGFydE9mRGF5LCB0IGFzIGFkZERheXMsIHYgYXMgaGFzaFZhbHVlc1RvQXJyYXksIHcgYXMgYnVpbGRFdmVudEFwaXMsIEQgYXMgRGVsYXllZFJ1bm5lciwgeCBhcyBjcmVhdGVGb3JtYXR0ZXIsIHkgYXMgZGlmZldob2xlRGF5cywgeiBhcyBtZW1vaXplLCBBIGFzIG1lbW9pemVPYmpBcmcsIEUgYXMgaXNQcm9wc0VxdWFsLCBGIGFzIEVtaXR0ZXIsIEcgYXMgZ2V0SW5pdGlhbERhdGUsIEggYXMgcmFuZ2VDb250YWluc01hcmtlciwgSSBhcyBjcmVhdGVFbXB0eUV2ZW50U3RvcmUsIEogYXMgcmVkdWNlQ3VycmVudERhdGUsIEsgYXMgcmVkdWNlRXZlbnRTdG9yZSwgTCBhcyByZXpvbmVFdmVudFN0b3JlRGF0ZXMsIE0gYXMgbWVyZ2VSYXdPcHRpb25zLCBOIGFzIEJBU0VfT1BUSU9OX1JFRklORVJTLCBPIGFzIENBTEVOREFSX0xJU1RFTkVSX1JFRklORVJTLCBQIGFzIENBTEVOREFSX09QVElPTl9SRUZJTkVSUywgUSBhcyBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SUywgUiBhcyBWSUVXX09QVElPTl9SRUZJTkVSUywgUyBhcyBEYXRlRW52LCBVIGFzIERhdGVQcm9maWxlR2VuZXJhdG9yLCBXIGFzIGNyZWF0ZUV2ZW50VWksIFggYXMgcGFyc2VCdXNpbmVzc0hvdXJzLCBZIGFzIHNldFJlZiwgWiBhcyBJbnRlcmFjdGlvbiwgXyBhcyBnZXRFbFNlZywgJCBhcyBlbGVtZW50Q2xvc2VzdCwgYTAgYXMgRXZlbnRJbXBsLCBhMSBhcyBsaXN0ZW5CeVNlbGVjdG9yLCBhMiBhcyBsaXN0ZW5Ub0hvdmVyQnlTZWxlY3RvciwgYTMgYXMgUHVyZUNvbXBvbmVudCwgYTQgYXMgYnVpbGRWaWV3Q29udGV4dCwgYTUgYXMgZ2V0VW5pcXVlRG9tSWQsIGE2IGFzIHBhcnNlSW50ZXJhY3Rpb25TZXR0aW5ncywgYTcgYXMgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlLCBhOCBhcyBnZXROb3csIGE5IGFzIENhbGVuZGFySW1wbCwgYWEgYXMgZmx1c2hTeW5jLCBhYiBhcyBDYWxlbmRhclJvb3QsIGFjIGFzIFJlbmRlcklkLCBhZCBhcyBlbnN1cmVFbEhhc1N0eWxlcywgYWUgYXMgYXBwbHlTdHlsZVByb3AsIGFmIGFzIHNsaWNlRXZlbnRTdG9yZSB9IGZyb20gJy4vaW50ZXJuYWwtY29tbW9uLmpzJztcbmV4cG9ydCB7IGFnIGFzIEpzb25SZXF1ZXN0RXJyb3IgfSBmcm9tICcuL2ludGVybmFsLWNvbW1vbi5qcyc7XG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBjcmVhdGVSZWYsIEZyYWdtZW50LCByZW5kZXIgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0ICdwcmVhY3QvY29tcGF0JztcblxuY29uc3QgZ2xvYmFsTG9jYWxlcyA9IFtdO1xuXG5jb25zdCBNSU5JTUFMX1JBV19FTl9MT0NBTEUgPSB7XG4gICAgY29kZTogJ2VuJyxcbiAgICB3ZWVrOiB7XG4gICAgICAgIGRvdzogMCxcbiAgICAgICAgZG95OiA0LCAvLyA0IGRheXMgbmVlZCB0byBiZSB3aXRoaW4gdGhlIHllYXIgdG8gYmUgY29uc2lkZXJlZCB0aGUgZmlyc3Qgd2Vla1xuICAgIH0sXG4gICAgZGlyZWN0aW9uOiAnbHRyJyxcbiAgICBidXR0b25UZXh0OiB7XG4gICAgICAgIHByZXY6ICdwcmV2JyxcbiAgICAgICAgbmV4dDogJ25leHQnLFxuICAgICAgICBwcmV2WWVhcjogJ3ByZXYgeWVhcicsXG4gICAgICAgIG5leHRZZWFyOiAnbmV4dCB5ZWFyJyxcbiAgICAgICAgeWVhcjogJ3llYXInLFxuICAgICAgICB0b2RheTogJ3RvZGF5JyxcbiAgICAgICAgbW9udGg6ICdtb250aCcsXG4gICAgICAgIHdlZWs6ICd3ZWVrJyxcbiAgICAgICAgZGF5OiAnZGF5JyxcbiAgICAgICAgbGlzdDogJ2xpc3QnLFxuICAgIH0sXG4gICAgd2Vla1RleHQ6ICdXJyxcbiAgICB3ZWVrVGV4dExvbmc6ICdXZWVrJyxcbiAgICBjbG9zZUhpbnQ6ICdDbG9zZScsXG4gICAgdGltZUhpbnQ6ICdUaW1lJyxcbiAgICBldmVudEhpbnQ6ICdFdmVudCcsXG4gICAgYWxsRGF5VGV4dDogJ2FsbC1kYXknLFxuICAgIG1vcmVMaW5rVGV4dDogJ21vcmUnLFxuICAgIG5vRXZlbnRzVGV4dDogJ05vIGV2ZW50cyB0byBkaXNwbGF5Jyxcbn07XG5jb25zdCBSQVdfRU5fTE9DQUxFID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBNSU5JTUFMX1JBV19FTl9MT0NBTEUpLCB7IFxuICAgIC8vIEluY2x1ZGVzIHRoaW5ncyB3ZSBkb24ndCB3YW50IG90aGVyIGxvY2FsZXMgdG8gaW5oZXJpdCxcbiAgICAvLyB0aGluZ3MgdGhhdCBkZXJpdmUgZnJvbSBvdGhlciB0cmFuc2xhdGFibGUgc3RyaW5ncy5cbiAgICBidXR0b25IaW50czoge1xuICAgICAgICBwcmV2OiAnUHJldmlvdXMgJDAnLFxuICAgICAgICBuZXh0OiAnTmV4dCAkMCcsXG4gICAgICAgIHRvZGF5KGJ1dHRvblRleHQsIHVuaXQpIHtcbiAgICAgICAgICAgIHJldHVybiAodW5pdCA9PT0gJ2RheScpXG4gICAgICAgICAgICAgICAgPyAnVG9kYXknXG4gICAgICAgICAgICAgICAgOiBgVGhpcyAke2J1dHRvblRleHR9YDtcbiAgICAgICAgfSxcbiAgICB9LCB2aWV3SGludDogJyQwIHZpZXcnLCBuYXZMaW5rSGludDogJ0dvIHRvICQwJywgbW9yZUxpbmtIaW50KGV2ZW50Q250KSB7XG4gICAgICAgIHJldHVybiBgU2hvdyAke2V2ZW50Q250fSBtb3JlIGV2ZW50JHtldmVudENudCA9PT0gMSA/ICcnIDogJ3MnfWA7XG4gICAgfSB9KTtcbmZ1bmN0aW9uIG9yZ2FuaXplUmF3TG9jYWxlcyhleHBsaWNpdFJhd0xvY2FsZXMpIHtcbiAgICBsZXQgZGVmYXVsdENvZGUgPSBleHBsaWNpdFJhd0xvY2FsZXMubGVuZ3RoID4gMCA/IGV4cGxpY2l0UmF3TG9jYWxlc1swXS5jb2RlIDogJ2VuJztcbiAgICBsZXQgYWxsUmF3TG9jYWxlcyA9IGdsb2JhbExvY2FsZXMuY29uY2F0KGV4cGxpY2l0UmF3TG9jYWxlcyk7XG4gICAgbGV0IHJhd0xvY2FsZU1hcCA9IHtcbiAgICAgICAgZW46IFJBV19FTl9MT0NBTEUsXG4gICAgfTtcbiAgICBmb3IgKGxldCByYXdMb2NhbGUgb2YgYWxsUmF3TG9jYWxlcykge1xuICAgICAgICByYXdMb2NhbGVNYXBbcmF3TG9jYWxlLmNvZGVdID0gcmF3TG9jYWxlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBtYXA6IHJhd0xvY2FsZU1hcCxcbiAgICAgICAgZGVmYXVsdENvZGUsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkTG9jYWxlKGlucHV0U2luZ3VsYXIsIGF2YWlsYWJsZSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXRTaW5ndWxhciA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaW5wdXRTaW5ndWxhcikpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlTG9jYWxlKGlucHV0U2luZ3VsYXIuY29kZSwgW2lucHV0U2luZ3VsYXIuY29kZV0sIGlucHV0U2luZ3VsYXIpO1xuICAgIH1cbiAgICByZXR1cm4gcXVlcnlMb2NhbGUoaW5wdXRTaW5ndWxhciwgYXZhaWxhYmxlKTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5TG9jYWxlKGNvZGVBcmcsIGF2YWlsYWJsZSkge1xuICAgIGxldCBjb2RlcyA9IFtdLmNvbmNhdChjb2RlQXJnIHx8IFtdKTsgLy8gd2lsbCBjb252ZXJ0IHRvIGFycmF5XG4gICAgbGV0IHJhdyA9IHF1ZXJ5UmF3TG9jYWxlKGNvZGVzLCBhdmFpbGFibGUpIHx8IFJBV19FTl9MT0NBTEU7XG4gICAgcmV0dXJuIHBhcnNlTG9jYWxlKGNvZGVBcmcsIGNvZGVzLCByYXcpO1xufVxuZnVuY3Rpb24gcXVlcnlSYXdMb2NhbGUoY29kZXMsIGF2YWlsYWJsZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgbGV0IHBhcnRzID0gY29kZXNbaV0udG9Mb2NhbGVMb3dlckNhc2UoKS5zcGxpdCgnLScpO1xuICAgICAgICBmb3IgKGxldCBqID0gcGFydHMubGVuZ3RoOyBqID4gMDsgaiAtPSAxKSB7XG4gICAgICAgICAgICBsZXQgc2ltcGxlSWQgPSBwYXJ0cy5zbGljZSgwLCBqKS5qb2luKCctJyk7XG4gICAgICAgICAgICBpZiAoYXZhaWxhYmxlW3NpbXBsZUlkXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhdmFpbGFibGVbc2ltcGxlSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcGFyc2VMb2NhbGUoY29kZUFyZywgY29kZXMsIHJhdykge1xuICAgIGxldCBtZXJnZWQgPSBtZXJnZVByb3BzKFtNSU5JTUFMX1JBV19FTl9MT0NBTEUsIHJhd10sIFsnYnV0dG9uVGV4dCddKTtcbiAgICBkZWxldGUgbWVyZ2VkLmNvZGU7IC8vIGRvbid0IHdhbnQgdGhpcyBwYXJ0IG9mIHRoZSBvcHRpb25zXG4gICAgbGV0IHsgd2VlayB9ID0gbWVyZ2VkO1xuICAgIGRlbGV0ZSBtZXJnZWQud2VlaztcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlQXJnLFxuICAgICAgICBjb2RlcyxcbiAgICAgICAgd2VlayxcbiAgICAgICAgc2ltcGxlTnVtYmVyRm9ybWF0OiBuZXcgSW50bC5OdW1iZXJGb3JtYXQoY29kZUFyZyksXG4gICAgICAgIG9wdGlvbnM6IG1lcmdlZCxcbiAgICB9O1xufVxuXG4vLyBUT0RPOiBlYXNpZXIgd2F5IHRvIGFkZCBuZXcgaG9va3M/IG5lZWQgdG8gdXBkYXRlIGEgbWlsbGlvbiB0aGluZ3NcbmZ1bmN0aW9uIGNyZWF0ZVBsdWdpbihpbnB1dCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBndWlkKCksXG4gICAgICAgIG5hbWU6IGlucHV0Lm5hbWUsXG4gICAgICAgIHByZW1pdW1SZWxlYXNlRGF0ZTogaW5wdXQucHJlbWl1bVJlbGVhc2VEYXRlID8gbmV3IERhdGUoaW5wdXQucHJlbWl1bVJlbGVhc2VEYXRlKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZGVwczogaW5wdXQuZGVwcyB8fCBbXSxcbiAgICAgICAgcmVkdWNlcnM6IGlucHV0LnJlZHVjZXJzIHx8IFtdLFxuICAgICAgICBpc0xvYWRpbmdGdW5jczogaW5wdXQuaXNMb2FkaW5nRnVuY3MgfHwgW10sXG4gICAgICAgIGNvbnRleHRJbml0OiBbXS5jb25jYXQoaW5wdXQuY29udGV4dEluaXQgfHwgW10pLFxuICAgICAgICBldmVudFJlZmluZXJzOiBpbnB1dC5ldmVudFJlZmluZXJzIHx8IHt9LFxuICAgICAgICBldmVudERlZk1lbWJlckFkZGVyczogaW5wdXQuZXZlbnREZWZNZW1iZXJBZGRlcnMgfHwgW10sXG4gICAgICAgIGV2ZW50U291cmNlUmVmaW5lcnM6IGlucHV0LmV2ZW50U291cmNlUmVmaW5lcnMgfHwge30sXG4gICAgICAgIGlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzOiBpbnB1dC5pc0RyYWdnYWJsZVRyYW5zZm9ybWVycyB8fCBbXSxcbiAgICAgICAgZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnM6IGlucHV0LmV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzIHx8IFtdLFxuICAgICAgICBldmVudERlZk11dGF0aW9uQXBwbGllcnM6IGlucHV0LmV2ZW50RGVmTXV0YXRpb25BcHBsaWVycyB8fCBbXSxcbiAgICAgICAgZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVyczogaW5wdXQuZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycyB8fCBbXSxcbiAgICAgICAgZGF0ZVBvaW50VHJhbnNmb3JtczogaW5wdXQuZGF0ZVBvaW50VHJhbnNmb3JtcyB8fCBbXSxcbiAgICAgICAgZGF0ZVNwYW5UcmFuc2Zvcm1zOiBpbnB1dC5kYXRlU3BhblRyYW5zZm9ybXMgfHwgW10sXG4gICAgICAgIHZpZXdzOiBpbnB1dC52aWV3cyB8fCB7fSxcbiAgICAgICAgdmlld1Byb3BzVHJhbnNmb3JtZXJzOiBpbnB1dC52aWV3UHJvcHNUcmFuc2Zvcm1lcnMgfHwgW10sXG4gICAgICAgIGlzUHJvcHNWYWxpZDogaW5wdXQuaXNQcm9wc1ZhbGlkIHx8IG51bGwsXG4gICAgICAgIGV4dGVybmFsRGVmVHJhbnNmb3JtczogaW5wdXQuZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zIHx8IFtdLFxuICAgICAgICB2aWV3Q29udGFpbmVyQXBwZW5kczogaW5wdXQudmlld0NvbnRhaW5lckFwcGVuZHMgfHwgW10sXG4gICAgICAgIGV2ZW50RHJvcFRyYW5zZm9ybWVyczogaW5wdXQuZXZlbnREcm9wVHJhbnNmb3JtZXJzIHx8IFtdLFxuICAgICAgICBjb21wb25lbnRJbnRlcmFjdGlvbnM6IGlucHV0LmNvbXBvbmVudEludGVyYWN0aW9ucyB8fCBbXSxcbiAgICAgICAgY2FsZW5kYXJJbnRlcmFjdGlvbnM6IGlucHV0LmNhbGVuZGFySW50ZXJhY3Rpb25zIHx8IFtdLFxuICAgICAgICB0aGVtZUNsYXNzZXM6IGlucHV0LnRoZW1lQ2xhc3NlcyB8fCB7fSxcbiAgICAgICAgZXZlbnRTb3VyY2VEZWZzOiBpbnB1dC5ldmVudFNvdXJjZURlZnMgfHwgW10sXG4gICAgICAgIGNtZEZvcm1hdHRlcjogaW5wdXQuY21kRm9ybWF0dGVyLFxuICAgICAgICByZWN1cnJpbmdUeXBlczogaW5wdXQucmVjdXJyaW5nVHlwZXMgfHwgW10sXG4gICAgICAgIG5hbWVkVGltZVpvbmVkSW1wbDogaW5wdXQubmFtZWRUaW1lWm9uZWRJbXBsLFxuICAgICAgICBpbml0aWFsVmlldzogaW5wdXQuaW5pdGlhbFZpZXcgfHwgJycsXG4gICAgICAgIGVsZW1lbnREcmFnZ2luZ0ltcGw6IGlucHV0LmVsZW1lbnREcmFnZ2luZ0ltcGwsXG4gICAgICAgIG9wdGlvbkNoYW5nZUhhbmRsZXJzOiBpbnB1dC5vcHRpb25DaGFuZ2VIYW5kbGVycyB8fCB7fSxcbiAgICAgICAgc2Nyb2xsR3JpZEltcGw6IGlucHV0LnNjcm9sbEdyaWRJbXBsIHx8IG51bGwsXG4gICAgICAgIGxpc3RlbmVyUmVmaW5lcnM6IGlucHV0Lmxpc3RlbmVyUmVmaW5lcnMgfHwge30sXG4gICAgICAgIG9wdGlvblJlZmluZXJzOiBpbnB1dC5vcHRpb25SZWZpbmVycyB8fCB7fSxcbiAgICAgICAgcHJvcFNldEhhbmRsZXJzOiBpbnB1dC5wcm9wU2V0SGFuZGxlcnMgfHwge30sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUGx1Z2luSG9va3MocGx1Z2luRGVmcywgZ2xvYmFsRGVmcykge1xuICAgIGxldCBjdXJyZW50UGx1Z2luSWRzID0ge307XG4gICAgbGV0IGhvb2tzID0ge1xuICAgICAgICBwcmVtaXVtUmVsZWFzZURhdGU6IHVuZGVmaW5lZCxcbiAgICAgICAgcmVkdWNlcnM6IFtdLFxuICAgICAgICBpc0xvYWRpbmdGdW5jczogW10sXG4gICAgICAgIGNvbnRleHRJbml0OiBbXSxcbiAgICAgICAgZXZlbnRSZWZpbmVyczoge30sXG4gICAgICAgIGV2ZW50RGVmTWVtYmVyQWRkZXJzOiBbXSxcbiAgICAgICAgZXZlbnRTb3VyY2VSZWZpbmVyczoge30sXG4gICAgICAgIGlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzOiBbXSxcbiAgICAgICAgZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnM6IFtdLFxuICAgICAgICBldmVudERlZk11dGF0aW9uQXBwbGllcnM6IFtdLFxuICAgICAgICBkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzOiBbXSxcbiAgICAgICAgZGF0ZVBvaW50VHJhbnNmb3JtczogW10sXG4gICAgICAgIGRhdGVTcGFuVHJhbnNmb3JtczogW10sXG4gICAgICAgIHZpZXdzOiB7fSxcbiAgICAgICAgdmlld1Byb3BzVHJhbnNmb3JtZXJzOiBbXSxcbiAgICAgICAgaXNQcm9wc1ZhbGlkOiBudWxsLFxuICAgICAgICBleHRlcm5hbERlZlRyYW5zZm9ybXM6IFtdLFxuICAgICAgICB2aWV3Q29udGFpbmVyQXBwZW5kczogW10sXG4gICAgICAgIGV2ZW50RHJvcFRyYW5zZm9ybWVyczogW10sXG4gICAgICAgIGNvbXBvbmVudEludGVyYWN0aW9uczogW10sXG4gICAgICAgIGNhbGVuZGFySW50ZXJhY3Rpb25zOiBbXSxcbiAgICAgICAgdGhlbWVDbGFzc2VzOiB7fSxcbiAgICAgICAgZXZlbnRTb3VyY2VEZWZzOiBbXSxcbiAgICAgICAgY21kRm9ybWF0dGVyOiBudWxsLFxuICAgICAgICByZWN1cnJpbmdUeXBlczogW10sXG4gICAgICAgIG5hbWVkVGltZVpvbmVkSW1wbDogbnVsbCxcbiAgICAgICAgaW5pdGlhbFZpZXc6ICcnLFxuICAgICAgICBlbGVtZW50RHJhZ2dpbmdJbXBsOiBudWxsLFxuICAgICAgICBvcHRpb25DaGFuZ2VIYW5kbGVyczoge30sXG4gICAgICAgIHNjcm9sbEdyaWRJbXBsOiBudWxsLFxuICAgICAgICBsaXN0ZW5lclJlZmluZXJzOiB7fSxcbiAgICAgICAgb3B0aW9uUmVmaW5lcnM6IHt9LFxuICAgICAgICBwcm9wU2V0SGFuZGxlcnM6IHt9LFxuICAgIH07XG4gICAgZnVuY3Rpb24gYWRkRGVmcyhkZWZzKSB7XG4gICAgICAgIGZvciAobGV0IGRlZiBvZiBkZWZzKSB7XG4gICAgICAgICAgICBjb25zdCBwbHVnaW5OYW1lID0gZGVmLm5hbWU7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50SWQgPSBjdXJyZW50UGx1Z2luSWRzW3BsdWdpbk5hbWVdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFBsdWdpbklkc1twbHVnaW5OYW1lXSA9IGRlZi5pZDtcbiAgICAgICAgICAgICAgICBhZGREZWZzKGRlZi5kZXBzKTtcbiAgICAgICAgICAgICAgICBob29rcyA9IGNvbWJpbmVIb29rcyhob29rcywgZGVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRJZCAhPT0gZGVmLmlkKSB7XG4gICAgICAgICAgICAgICAgLy8gZGlmZmVyZW50IElEIHRoYW4gdGhlIG9uZSBhbHJlYWR5IGFkZGVkXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBEdXBsaWNhdGUgcGx1Z2luICcke3BsdWdpbk5hbWV9J2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwbHVnaW5EZWZzKSB7XG4gICAgICAgIGFkZERlZnMocGx1Z2luRGVmcyk7XG4gICAgfVxuICAgIGFkZERlZnMoZ2xvYmFsRGVmcyk7XG4gICAgcmV0dXJuIGhvb2tzO1xufVxuZnVuY3Rpb24gYnVpbGRCdWlsZFBsdWdpbkhvb2tzKCkge1xuICAgIGxldCBjdXJyZW50T3ZlcnJpZGVEZWZzID0gW107XG4gICAgbGV0IGN1cnJlbnRHbG9iYWxEZWZzID0gW107XG4gICAgbGV0IGN1cnJlbnRIb29rcztcbiAgICByZXR1cm4gKG92ZXJyaWRlRGVmcywgZ2xvYmFsRGVmcykgPT4ge1xuICAgICAgICBpZiAoIWN1cnJlbnRIb29rcyB8fCAhaXNBcnJheXNFcXVhbChvdmVycmlkZURlZnMsIGN1cnJlbnRPdmVycmlkZURlZnMpIHx8ICFpc0FycmF5c0VxdWFsKGdsb2JhbERlZnMsIGN1cnJlbnRHbG9iYWxEZWZzKSkge1xuICAgICAgICAgICAgY3VycmVudEhvb2tzID0gYnVpbGRQbHVnaW5Ib29rcyhvdmVycmlkZURlZnMsIGdsb2JhbERlZnMpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRPdmVycmlkZURlZnMgPSBvdmVycmlkZURlZnM7XG4gICAgICAgIGN1cnJlbnRHbG9iYWxEZWZzID0gZ2xvYmFsRGVmcztcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRIb29rcztcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tYmluZUhvb2tzKGhvb2tzMCwgaG9va3MxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJlbWl1bVJlbGVhc2VEYXRlOiBjb21wYXJlT3B0aW9uYWxEYXRlcyhob29rczAucHJlbWl1bVJlbGVhc2VEYXRlLCBob29rczEucHJlbWl1bVJlbGVhc2VEYXRlKSxcbiAgICAgICAgcmVkdWNlcnM6IGhvb2tzMC5yZWR1Y2Vycy5jb25jYXQoaG9va3MxLnJlZHVjZXJzKSxcbiAgICAgICAgaXNMb2FkaW5nRnVuY3M6IGhvb2tzMC5pc0xvYWRpbmdGdW5jcy5jb25jYXQoaG9va3MxLmlzTG9hZGluZ0Z1bmNzKSxcbiAgICAgICAgY29udGV4dEluaXQ6IGhvb2tzMC5jb250ZXh0SW5pdC5jb25jYXQoaG9va3MxLmNvbnRleHRJbml0KSxcbiAgICAgICAgZXZlbnRSZWZpbmVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBob29rczAuZXZlbnRSZWZpbmVycyksIGhvb2tzMS5ldmVudFJlZmluZXJzKSxcbiAgICAgICAgZXZlbnREZWZNZW1iZXJBZGRlcnM6IGhvb2tzMC5ldmVudERlZk1lbWJlckFkZGVycy5jb25jYXQoaG9va3MxLmV2ZW50RGVmTWVtYmVyQWRkZXJzKSxcbiAgICAgICAgZXZlbnRTb3VyY2VSZWZpbmVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBob29rczAuZXZlbnRTb3VyY2VSZWZpbmVycyksIGhvb2tzMS5ldmVudFNvdXJjZVJlZmluZXJzKSxcbiAgICAgICAgaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnM6IGhvb2tzMC5pc0RyYWdnYWJsZVRyYW5zZm9ybWVycy5jb25jYXQoaG9va3MxLmlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzKSxcbiAgICAgICAgZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnM6IGhvb2tzMC5ldmVudERyYWdNdXRhdGlvbk1hc3NhZ2Vycy5jb25jYXQoaG9va3MxLmV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzKSxcbiAgICAgICAgZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzOiBob29rczAuZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzLmNvbmNhdChob29rczEuZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzKSxcbiAgICAgICAgZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVyczogaG9va3MwLmRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMuY29uY2F0KGhvb2tzMS5kYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzKSxcbiAgICAgICAgZGF0ZVBvaW50VHJhbnNmb3JtczogaG9va3MwLmRhdGVQb2ludFRyYW5zZm9ybXMuY29uY2F0KGhvb2tzMS5kYXRlUG9pbnRUcmFuc2Zvcm1zKSxcbiAgICAgICAgZGF0ZVNwYW5UcmFuc2Zvcm1zOiBob29rczAuZGF0ZVNwYW5UcmFuc2Zvcm1zLmNvbmNhdChob29rczEuZGF0ZVNwYW5UcmFuc2Zvcm1zKSxcbiAgICAgICAgdmlld3M6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaG9va3MwLnZpZXdzKSwgaG9va3MxLnZpZXdzKSxcbiAgICAgICAgdmlld1Byb3BzVHJhbnNmb3JtZXJzOiBob29rczAudmlld1Byb3BzVHJhbnNmb3JtZXJzLmNvbmNhdChob29rczEudmlld1Byb3BzVHJhbnNmb3JtZXJzKSxcbiAgICAgICAgaXNQcm9wc1ZhbGlkOiBob29rczEuaXNQcm9wc1ZhbGlkIHx8IGhvb2tzMC5pc1Byb3BzVmFsaWQsXG4gICAgICAgIGV4dGVybmFsRGVmVHJhbnNmb3JtczogaG9va3MwLmV4dGVybmFsRGVmVHJhbnNmb3Jtcy5jb25jYXQoaG9va3MxLmV4dGVybmFsRGVmVHJhbnNmb3JtcyksXG4gICAgICAgIHZpZXdDb250YWluZXJBcHBlbmRzOiBob29rczAudmlld0NvbnRhaW5lckFwcGVuZHMuY29uY2F0KGhvb2tzMS52aWV3Q29udGFpbmVyQXBwZW5kcyksXG4gICAgICAgIGV2ZW50RHJvcFRyYW5zZm9ybWVyczogaG9va3MwLmV2ZW50RHJvcFRyYW5zZm9ybWVycy5jb25jYXQoaG9va3MxLmV2ZW50RHJvcFRyYW5zZm9ybWVycyksXG4gICAgICAgIGNhbGVuZGFySW50ZXJhY3Rpb25zOiBob29rczAuY2FsZW5kYXJJbnRlcmFjdGlvbnMuY29uY2F0KGhvb2tzMS5jYWxlbmRhckludGVyYWN0aW9ucyksXG4gICAgICAgIGNvbXBvbmVudEludGVyYWN0aW9uczogaG9va3MwLmNvbXBvbmVudEludGVyYWN0aW9ucy5jb25jYXQoaG9va3MxLmNvbXBvbmVudEludGVyYWN0aW9ucyksXG4gICAgICAgIHRoZW1lQ2xhc3NlczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBob29rczAudGhlbWVDbGFzc2VzKSwgaG9va3MxLnRoZW1lQ2xhc3NlcyksXG4gICAgICAgIGV2ZW50U291cmNlRGVmczogaG9va3MwLmV2ZW50U291cmNlRGVmcy5jb25jYXQoaG9va3MxLmV2ZW50U291cmNlRGVmcyksXG4gICAgICAgIGNtZEZvcm1hdHRlcjogaG9va3MxLmNtZEZvcm1hdHRlciB8fCBob29rczAuY21kRm9ybWF0dGVyLFxuICAgICAgICByZWN1cnJpbmdUeXBlczogaG9va3MwLnJlY3VycmluZ1R5cGVzLmNvbmNhdChob29rczEucmVjdXJyaW5nVHlwZXMpLFxuICAgICAgICBuYW1lZFRpbWVab25lZEltcGw6IGhvb2tzMS5uYW1lZFRpbWVab25lZEltcGwgfHwgaG9va3MwLm5hbWVkVGltZVpvbmVkSW1wbCxcbiAgICAgICAgaW5pdGlhbFZpZXc6IGhvb2tzMC5pbml0aWFsVmlldyB8fCBob29rczEuaW5pdGlhbFZpZXcsXG4gICAgICAgIGVsZW1lbnREcmFnZ2luZ0ltcGw6IGhvb2tzMC5lbGVtZW50RHJhZ2dpbmdJbXBsIHx8IGhvb2tzMS5lbGVtZW50RHJhZ2dpbmdJbXBsLFxuICAgICAgICBvcHRpb25DaGFuZ2VIYW5kbGVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBob29rczAub3B0aW9uQ2hhbmdlSGFuZGxlcnMpLCBob29rczEub3B0aW9uQ2hhbmdlSGFuZGxlcnMpLFxuICAgICAgICBzY3JvbGxHcmlkSW1wbDogaG9va3MxLnNjcm9sbEdyaWRJbXBsIHx8IGhvb2tzMC5zY3JvbGxHcmlkSW1wbCxcbiAgICAgICAgbGlzdGVuZXJSZWZpbmVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBob29rczAubGlzdGVuZXJSZWZpbmVycyksIGhvb2tzMS5saXN0ZW5lclJlZmluZXJzKSxcbiAgICAgICAgb3B0aW9uUmVmaW5lcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaG9va3MwLm9wdGlvblJlZmluZXJzKSwgaG9va3MxLm9wdGlvblJlZmluZXJzKSxcbiAgICAgICAgcHJvcFNldEhhbmRsZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGhvb2tzMC5wcm9wU2V0SGFuZGxlcnMpLCBob29rczEucHJvcFNldEhhbmRsZXJzKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcGFyZU9wdGlvbmFsRGF0ZXMoZGF0ZTAsIGRhdGUxKSB7XG4gICAgaWYgKGRhdGUwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGRhdGUxO1xuICAgIH1cbiAgICBpZiAoZGF0ZTEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZGF0ZTA7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0ZShNYXRoLm1heChkYXRlMC52YWx1ZU9mKCksIGRhdGUxLnZhbHVlT2YoKSkpO1xufVxuXG5jbGFzcyBTdGFuZGFyZFRoZW1lIGV4dGVuZHMgVGhlbWUge1xufVxuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuY2xhc3NlcyA9IHtcbiAgICByb290OiAnZmMtdGhlbWUtc3RhbmRhcmQnLFxuICAgIHRhYmxlQ2VsbFNoYWRlZDogJ2ZjLWNlbGwtc2hhZGVkJyxcbiAgICBidXR0b25Hcm91cDogJ2ZjLWJ1dHRvbi1ncm91cCcsXG4gICAgYnV0dG9uOiAnZmMtYnV0dG9uIGZjLWJ1dHRvbi1wcmltYXJ5JyxcbiAgICBidXR0b25BY3RpdmU6ICdmYy1idXR0b24tYWN0aXZlJyxcbn07XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5iYXNlSWNvbkNsYXNzID0gJ2ZjLWljb24nO1xuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbkNsYXNzZXMgPSB7XG4gICAgY2xvc2U6ICdmYy1pY29uLXgnLFxuICAgIHByZXY6ICdmYy1pY29uLWNoZXZyb24tbGVmdCcsXG4gICAgbmV4dDogJ2ZjLWljb24tY2hldnJvbi1yaWdodCcsXG4gICAgcHJldlllYXI6ICdmYy1pY29uLWNoZXZyb25zLWxlZnQnLFxuICAgIG5leHRZZWFyOiAnZmMtaWNvbi1jaGV2cm9ucy1yaWdodCcsXG59O1xuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUucnRsSWNvbkNsYXNzZXMgPSB7XG4gICAgcHJldjogJ2ZjLWljb24tY2hldnJvbi1yaWdodCcsXG4gICAgbmV4dDogJ2ZjLWljb24tY2hldnJvbi1sZWZ0JyxcbiAgICBwcmV2WWVhcjogJ2ZjLWljb24tY2hldnJvbnMtcmlnaHQnLFxuICAgIG5leHRZZWFyOiAnZmMtaWNvbi1jaGV2cm9ucy1sZWZ0Jyxcbn07XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVPcHRpb24gPSAnYnV0dG9uSWNvbnMnOyAvLyBUT0RPOiBtYWtlIFRTLWZyaWVuZGx5XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb24gPSAnaWNvbic7XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVQcmVmaXggPSAnZmMtaWNvbi0nO1xuXG5mdW5jdGlvbiBjb21waWxlVmlld0RlZnMoZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncykge1xuICAgIGxldCBoYXNoID0ge307XG4gICAgbGV0IHZpZXdUeXBlO1xuICAgIGZvciAodmlld1R5cGUgaW4gZGVmYXVsdENvbmZpZ3MpIHtcbiAgICAgICAgZW5zdXJlVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XG4gICAgfVxuICAgIGZvciAodmlld1R5cGUgaW4gb3ZlcnJpZGVDb25maWdzKSB7XG4gICAgICAgIGVuc3VyZVZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaDtcbn1cbmZ1bmN0aW9uIGVuc3VyZVZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpIHtcbiAgICBpZiAoaGFzaFt2aWV3VHlwZV0pIHtcbiAgICAgICAgcmV0dXJuIGhhc2hbdmlld1R5cGVdO1xuICAgIH1cbiAgICBsZXQgdmlld0RlZiA9IGJ1aWxkVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XG4gICAgaWYgKHZpZXdEZWYpIHtcbiAgICAgICAgaGFzaFt2aWV3VHlwZV0gPSB2aWV3RGVmO1xuICAgIH1cbiAgICByZXR1cm4gdmlld0RlZjtcbn1cbmZ1bmN0aW9uIGJ1aWxkVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncykge1xuICAgIGxldCBkZWZhdWx0Q29uZmlnID0gZGVmYXVsdENvbmZpZ3Nbdmlld1R5cGVdO1xuICAgIGxldCBvdmVycmlkZUNvbmZpZyA9IG92ZXJyaWRlQ29uZmlnc1t2aWV3VHlwZV07XG4gICAgbGV0IHF1ZXJ5UHJvcCA9IChuYW1lKSA9PiAoKGRlZmF1bHRDb25maWcgJiYgZGVmYXVsdENvbmZpZ1tuYW1lXSAhPT0gbnVsbCkgPyBkZWZhdWx0Q29uZmlnW25hbWVdIDpcbiAgICAgICAgKChvdmVycmlkZUNvbmZpZyAmJiBvdmVycmlkZUNvbmZpZ1tuYW1lXSAhPT0gbnVsbCkgPyBvdmVycmlkZUNvbmZpZ1tuYW1lXSA6IG51bGwpKTtcbiAgICBsZXQgdGhlQ29tcG9uZW50ID0gcXVlcnlQcm9wKCdjb21wb25lbnQnKTtcbiAgICBsZXQgc3VwZXJUeXBlID0gcXVlcnlQcm9wKCdzdXBlclR5cGUnKTtcbiAgICBsZXQgc3VwZXJEZWYgPSBudWxsO1xuICAgIGlmIChzdXBlclR5cGUpIHtcbiAgICAgICAgaWYgKHN1cGVyVHlwZSA9PT0gdmlld1R5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBoYXZlIGEgY3VzdG9tIHZpZXcgdHlwZSB0aGF0IHJlZmVyZW5jZXMgaXRzZWxmJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXJEZWYgPSBlbnN1cmVWaWV3RGVmKHN1cGVyVHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XG4gICAgfVxuICAgIGlmICghdGhlQ29tcG9uZW50ICYmIHN1cGVyRGVmKSB7XG4gICAgICAgIHRoZUNvbXBvbmVudCA9IHN1cGVyRGVmLmNvbXBvbmVudDtcbiAgICB9XG4gICAgaWYgKCF0aGVDb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7IC8vIGRvbid0IHRocm93IGEgd2FybmluZywgbWlnaHQgYmUgc2V0dGluZ3MgZm9yIGEgc2luZ2xlLXVuaXQgdmlld1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiB2aWV3VHlwZSxcbiAgICAgICAgY29tcG9uZW50OiB0aGVDb21wb25lbnQsXG4gICAgICAgIGRlZmF1bHRzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChzdXBlckRlZiA/IHN1cGVyRGVmLmRlZmF1bHRzIDoge30pKSwgKGRlZmF1bHRDb25maWcgPyBkZWZhdWx0Q29uZmlnLnJhd09wdGlvbnMgOiB7fSkpLFxuICAgICAgICBvdmVycmlkZXM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHN1cGVyRGVmID8gc3VwZXJEZWYub3ZlcnJpZGVzIDoge30pKSwgKG92ZXJyaWRlQ29uZmlnID8gb3ZlcnJpZGVDb25maWcucmF3T3B0aW9ucyA6IHt9KSksXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VWaWV3Q29uZmlncyhpbnB1dHMpIHtcbiAgICByZXR1cm4gbWFwSGFzaChpbnB1dHMsIHBhcnNlVmlld0NvbmZpZyk7XG59XG5mdW5jdGlvbiBwYXJzZVZpZXdDb25maWcoaW5wdXQpIHtcbiAgICBsZXQgcmF3T3B0aW9ucyA9IHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgIHsgY29tcG9uZW50OiBpbnB1dCB9IDpcbiAgICAgICAgaW5wdXQ7XG4gICAgbGV0IHsgY29tcG9uZW50IH0gPSByYXdPcHRpb25zO1xuICAgIGlmIChyYXdPcHRpb25zLmNvbnRlbnQpIHtcbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGNvbnRlbnQvY2xhc3NOYW1lcy9kaWRNb3VudC9ldGMgZnJvbSBvcHRpb25zP1xuICAgICAgICBjb21wb25lbnQgPSBjcmVhdGVWaWV3SG9va0NvbXBvbmVudChyYXdPcHRpb25zKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29tcG9uZW50ICYmICEoY29tcG9uZW50LnByb3RvdHlwZSBpbnN0YW5jZW9mIEJhc2VDb21wb25lbnQpKSB7XG4gICAgICAgIC8vIFdIWT86IHBlb3BsZSB3ZXJlIHVzaW5nIGBjb21wb25lbnRgIHByb3BlcnR5IGZvciBgY29udGVudGBcbiAgICAgICAgLy8gVE9ETzogY29udmVyZ2Ugb24gb25lIHNldHRpbmcgbmFtZVxuICAgICAgICBjb21wb25lbnQgPSBjcmVhdGVWaWV3SG9va0NvbXBvbmVudChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJhd09wdGlvbnMpLCB7IGNvbnRlbnQ6IGNvbXBvbmVudCB9KSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHN1cGVyVHlwZTogcmF3T3B0aW9ucy50eXBlLFxuICAgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudCxcbiAgICAgICAgcmF3T3B0aW9ucywgLy8gaW5jbHVkZXMgdHlwZSBhbmQgY29tcG9uZW50IHRvbyA6KFxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVWaWV3SG9va0NvbXBvbmVudChvcHRpb25zKSB7XG4gICAgcmV0dXJuICh2aWV3UHJvcHMpID0+IChjcmVhdGVFbGVtZW50KFZpZXdDb250ZXh0VHlwZS5Db25zdW1lciwgbnVsbCwgKGNvbnRleHQpID0+IChjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIHsgZWxUYWc6IFwiZGl2XCIsIGVsQ2xhc3NlczogYnVpbGRWaWV3Q2xhc3NOYW1lcyhjb250ZXh0LnZpZXdTcGVjKSwgcmVuZGVyUHJvcHM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdmlld1Byb3BzKSwgeyBuZXh0RGF5VGhyZXNob2xkOiBjb250ZXh0Lm9wdGlvbnMubmV4dERheVRocmVzaG9sZCB9KSwgZ2VuZXJhdG9yTmFtZTogdW5kZWZpbmVkLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMuY29udGVudCwgY2xhc3NOYW1lR2VuZXJhdG9yOiBvcHRpb25zLmNsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLmRpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy53aWxsVW5tb3VudCB9KSkpKTtcbn1cblxuZnVuY3Rpb24gYnVpbGRWaWV3U3BlY3MoZGVmYXVsdElucHV0cywgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBsb2NhbGVEZWZhdWx0cykge1xuICAgIGxldCBkZWZhdWx0Q29uZmlncyA9IHBhcnNlVmlld0NvbmZpZ3MoZGVmYXVsdElucHV0cyk7XG4gICAgbGV0IG92ZXJyaWRlQ29uZmlncyA9IHBhcnNlVmlld0NvbmZpZ3Mob3B0aW9uT3ZlcnJpZGVzLnZpZXdzKTtcbiAgICBsZXQgdmlld0RlZnMgPSBjb21waWxlVmlld0RlZnMoZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XG4gICAgcmV0dXJuIG1hcEhhc2godmlld0RlZnMsICh2aWV3RGVmKSA9PiBidWlsZFZpZXdTcGVjKHZpZXdEZWYsIG92ZXJyaWRlQ29uZmlncywgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBsb2NhbGVEZWZhdWx0cykpO1xufVxuZnVuY3Rpb24gYnVpbGRWaWV3U3BlYyh2aWV3RGVmLCBvdmVycmlkZUNvbmZpZ3MsIG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcywgbG9jYWxlRGVmYXVsdHMpIHtcbiAgICBsZXQgZHVyYXRpb25JbnB1dCA9IHZpZXdEZWYub3ZlcnJpZGVzLmR1cmF0aW9uIHx8XG4gICAgICAgIHZpZXdEZWYuZGVmYXVsdHMuZHVyYXRpb24gfHxcbiAgICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcy5kdXJhdGlvbiB8fFxuICAgICAgICBvcHRpb25PdmVycmlkZXMuZHVyYXRpb247XG4gICAgbGV0IGR1cmF0aW9uID0gbnVsbDtcbiAgICBsZXQgZHVyYXRpb25Vbml0ID0gJyc7XG4gICAgbGV0IHNpbmdsZVVuaXQgPSAnJztcbiAgICBsZXQgc2luZ2xlVW5pdE92ZXJyaWRlcyA9IHt9O1xuICAgIGlmIChkdXJhdGlvbklucHV0KSB7XG4gICAgICAgIGR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb25DYWNoZWQoZHVyYXRpb25JbnB1dCk7XG4gICAgICAgIGlmIChkdXJhdGlvbikgeyAvLyB2YWxpZD9cbiAgICAgICAgICAgIGxldCBkZW5vbSA9IGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXJhdGlvbik7XG4gICAgICAgICAgICBkdXJhdGlvblVuaXQgPSBkZW5vbS51bml0O1xuICAgICAgICAgICAgaWYgKGRlbm9tLnZhbHVlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgc2luZ2xlVW5pdCA9IGR1cmF0aW9uVW5pdDtcbiAgICAgICAgICAgICAgICBzaW5nbGVVbml0T3ZlcnJpZGVzID0gb3ZlcnJpZGVDb25maWdzW2R1cmF0aW9uVW5pdF0gPyBvdmVycmlkZUNvbmZpZ3NbZHVyYXRpb25Vbml0XS5yYXdPcHRpb25zIDoge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHF1ZXJ5QnV0dG9uVGV4dCA9IChvcHRpb25zU3Vic2V0KSA9PiB7XG4gICAgICAgIGxldCBidXR0b25UZXh0TWFwID0gb3B0aW9uc1N1YnNldC5idXR0b25UZXh0IHx8IHt9O1xuICAgICAgICBsZXQgYnV0dG9uVGV4dEtleSA9IHZpZXdEZWYuZGVmYXVsdHMuYnV0dG9uVGV4dEtleTtcbiAgICAgICAgaWYgKGJ1dHRvblRleHRLZXkgIT0gbnVsbCAmJiBidXR0b25UZXh0TWFwW2J1dHRvblRleHRLZXldICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBidXR0b25UZXh0TWFwW2J1dHRvblRleHRLZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidXR0b25UZXh0TWFwW3ZpZXdEZWYudHlwZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvblRleHRNYXBbdmlld0RlZi50eXBlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnV0dG9uVGV4dE1hcFtzaW5nbGVVbml0XSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uVGV4dE1hcFtzaW5nbGVVbml0XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIGxldCBxdWVyeUJ1dHRvblRpdGxlID0gKG9wdGlvbnNTdWJzZXQpID0+IHtcbiAgICAgICAgbGV0IGJ1dHRvbkhpbnRzID0gb3B0aW9uc1N1YnNldC5idXR0b25IaW50cyB8fCB7fTtcbiAgICAgICAgbGV0IGJ1dHRvbktleSA9IHZpZXdEZWYuZGVmYXVsdHMuYnV0dG9uVGV4dEtleTsgLy8gdXNlIHNhbWUga2V5IGFzIHRleHRcbiAgICAgICAgaWYgKGJ1dHRvbktleSAhPSBudWxsICYmIGJ1dHRvbkhpbnRzW2J1dHRvbktleV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbkhpbnRzW2J1dHRvbktleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1dHRvbkhpbnRzW3ZpZXdEZWYudHlwZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbkhpbnRzW3ZpZXdEZWYudHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1dHRvbkhpbnRzW3NpbmdsZVVuaXRdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBidXR0b25IaW50c1tzaW5nbGVVbml0XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHZpZXdEZWYudHlwZSxcbiAgICAgICAgY29tcG9uZW50OiB2aWV3RGVmLmNvbXBvbmVudCxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGR1cmF0aW9uVW5pdCxcbiAgICAgICAgc2luZ2xlVW5pdCxcbiAgICAgICAgb3B0aW9uRGVmYXVsdHM6IHZpZXdEZWYuZGVmYXVsdHMsXG4gICAgICAgIG9wdGlvbk92ZXJyaWRlczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzaW5nbGVVbml0T3ZlcnJpZGVzKSwgdmlld0RlZi5vdmVycmlkZXMpLFxuICAgICAgICBidXR0b25UZXh0T3ZlcnJpZGU6IHF1ZXJ5QnV0dG9uVGV4dChkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKSB8fFxuICAgICAgICAgICAgcXVlcnlCdXR0b25UZXh0KG9wdGlvbk92ZXJyaWRlcykgfHwgLy8gY29uc3RydWN0b3Itc3BlY2lmaWVkIGJ1dHRvblRleHQgbG9va3VwIGhhc2ggdGFrZXMgcHJlY2VkZW5jZVxuICAgICAgICAgICAgdmlld0RlZi5vdmVycmlkZXMuYnV0dG9uVGV4dCxcbiAgICAgICAgYnV0dG9uVGV4dERlZmF1bHQ6IHF1ZXJ5QnV0dG9uVGV4dChsb2NhbGVEZWZhdWx0cykgfHxcbiAgICAgICAgICAgIHZpZXdEZWYuZGVmYXVsdHMuYnV0dG9uVGV4dCB8fFxuICAgICAgICAgICAgcXVlcnlCdXR0b25UZXh0KEJBU0VfT1BUSU9OX0RFRkFVTFRTKSB8fFxuICAgICAgICAgICAgdmlld0RlZi50eXBlLFxuICAgICAgICAvLyBub3QgRFJZXG4gICAgICAgIGJ1dHRvblRpdGxlT3ZlcnJpZGU6IHF1ZXJ5QnV0dG9uVGl0bGUoZHluYW1pY09wdGlvbk92ZXJyaWRlcykgfHxcbiAgICAgICAgICAgIHF1ZXJ5QnV0dG9uVGl0bGUob3B0aW9uT3ZlcnJpZGVzKSB8fFxuICAgICAgICAgICAgdmlld0RlZi5vdmVycmlkZXMuYnV0dG9uSGludCxcbiAgICAgICAgYnV0dG9uVGl0bGVEZWZhdWx0OiBxdWVyeUJ1dHRvblRpdGxlKGxvY2FsZURlZmF1bHRzKSB8fFxuICAgICAgICAgICAgdmlld0RlZi5kZWZhdWx0cy5idXR0b25IaW50IHx8XG4gICAgICAgICAgICBxdWVyeUJ1dHRvblRpdGxlKEJBU0VfT1BUSU9OX0RFRkFVTFRTKSxcbiAgICAgICAgLy8gd2lsbCBldmVudHVhbGx5IGZhbGwgYmFjayB0byBidXR0b25UZXh0XG4gICAgfTtcbn1cbi8vIGhhY2sgdG8gZ2V0IG1lbW9pemF0aW9uIHdvcmtpbmdcbmxldCBkdXJhdGlvbklucHV0TWFwID0ge307XG5mdW5jdGlvbiBjcmVhdGVEdXJhdGlvbkNhY2hlZChkdXJhdGlvbklucHV0KSB7XG4gICAgbGV0IGpzb24gPSBKU09OLnN0cmluZ2lmeShkdXJhdGlvbklucHV0KTtcbiAgICBsZXQgcmVzID0gZHVyYXRpb25JbnB1dE1hcFtqc29uXTtcbiAgICBpZiAocmVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzID0gY3JlYXRlRHVyYXRpb24oZHVyYXRpb25JbnB1dCk7XG4gICAgICAgIGR1cmF0aW9uSW5wdXRNYXBbanNvbl0gPSByZXM7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHJlZHVjZVZpZXdUeXBlKHZpZXdUeXBlLCBhY3Rpb24pIHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9WSUVXX1RZUEUnOlxuICAgICAgICAgICAgdmlld1R5cGUgPSBhY3Rpb24udmlld1R5cGU7XG4gICAgfVxuICAgIHJldHVybiB2aWV3VHlwZTtcbn1cblxuZnVuY3Rpb24gcmVkdWNlRHluYW1pY09wdGlvbk92ZXJyaWRlcyhkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBhY3Rpb24pIHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1NFVF9PUFRJT04nOlxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZHluYW1pY09wdGlvbk92ZXJyaWRlcyksIHsgW2FjdGlvbi5vcHRpb25OYW1lXTogYWN0aW9uLnJhd09wdGlvblZhbHVlIH0pO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGR5bmFtaWNPcHRpb25PdmVycmlkZXM7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWR1Y2VEYXRlUHJvZmlsZShjdXJyZW50RGF0ZVByb2ZpbGUsIGFjdGlvbiwgY3VycmVudERhdGUsIGRhdGVQcm9maWxlR2VuZXJhdG9yKSB7XG4gICAgbGV0IGRwO1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnQ0hBTkdFX1ZJRVdfVFlQRSc6XG4gICAgICAgICAgICByZXR1cm4gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGQoYWN0aW9uLmRhdGVNYXJrZXIgfHwgY3VycmVudERhdGUpO1xuICAgICAgICBjYXNlICdDSEFOR0VfREFURSc6XG4gICAgICAgICAgICByZXR1cm4gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGQoYWN0aW9uLmRhdGVNYXJrZXIpO1xuICAgICAgICBjYXNlICdQUkVWJzpcbiAgICAgICAgICAgIGRwID0gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGRQcmV2KGN1cnJlbnREYXRlUHJvZmlsZSwgY3VycmVudERhdGUpO1xuICAgICAgICAgICAgaWYgKGRwLmlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZHA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTkVYVCc6XG4gICAgICAgICAgICBkcCA9IGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkTmV4dChjdXJyZW50RGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlKTtcbiAgICAgICAgICAgIGlmIChkcC5pc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50RGF0ZVByb2ZpbGU7XG59XG5cbmZ1bmN0aW9uIGluaXRFdmVudFNvdXJjZXMoY2FsZW5kYXJPcHRpb25zLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIGxldCBhY3RpdmVSYW5nZSA9IGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsO1xuICAgIHJldHVybiBhZGRTb3VyY2VzKHt9LCBwYXJzZUluaXRpYWxTb3VyY2VzKGNhbGVuZGFyT3B0aW9ucywgY29udGV4dCksIGFjdGl2ZVJhbmdlLCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIHJlZHVjZUV2ZW50U291cmNlcyhldmVudFNvdXJjZXMsIGFjdGlvbiwgZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcbiAgICBsZXQgYWN0aXZlUmFuZ2UgPSBkYXRlUHJvZmlsZSA/IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlIDogbnVsbDsgLy8gbmVlZCB0aGlzIGNoZWNrP1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnQUREX0VWRU5UX1NPVVJDRVMnOiAvLyBhbHJlYWR5IHBhcnNlZFxuICAgICAgICAgICAgcmV0dXJuIGFkZFNvdXJjZXMoZXZlbnRTb3VyY2VzLCBhY3Rpb24uc291cmNlcywgYWN0aXZlUmFuZ2UsIGNvbnRleHQpO1xuICAgICAgICBjYXNlICdSRU1PVkVfRVZFTlRfU09VUkNFJzpcbiAgICAgICAgICAgIHJldHVybiByZW1vdmVTb3VyY2UoZXZlbnRTb3VyY2VzLCBhY3Rpb24uc291cmNlSWQpO1xuICAgICAgICBjYXNlICdQUkVWJzogLy8gVE9ETzogaG93IGRvIHdlIHRyYWNrIGFsbCBhY3Rpb25zIHRoYXQgYWZmZWN0IGRhdGVQcm9maWxlIDooXG4gICAgICAgIGNhc2UgJ05FWFQnOlxuICAgICAgICBjYXNlICdDSEFOR0VfREFURSc6XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9WSUVXX1RZUEUnOlxuICAgICAgICAgICAgaWYgKGRhdGVQcm9maWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoRGlydHlTb3VyY2VzKGV2ZW50U291cmNlcywgYWN0aXZlUmFuZ2UsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50U291cmNlcztcbiAgICAgICAgY2FzZSAnRkVUQ0hfRVZFTlRfU09VUkNFUyc6XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hTb3VyY2VzQnlJZHMoZXZlbnRTb3VyY2VzLCBhY3Rpb24uc291cmNlSWRzID8gLy8gd2h5IG5vIHR5cGU/XG4gICAgICAgICAgICAgICAgYXJyYXlUb0hhc2goYWN0aW9uLnNvdXJjZUlkcykgOlxuICAgICAgICAgICAgICAgIGV4Y2x1ZGVTdGF0aWNTb3VyY2VzKGV2ZW50U291cmNlcywgY29udGV4dCksIGFjdGl2ZVJhbmdlLCBhY3Rpb24uaXNSZWZldGNoIHx8IGZhbHNlLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAnUkVDRUlWRV9FVkVOVFMnOlxuICAgICAgICBjYXNlICdSRUNFSVZFX0VWRU5UX0VSUk9SJzpcbiAgICAgICAgICAgIHJldHVybiByZWNlaXZlUmVzcG9uc2UoZXZlbnRTb3VyY2VzLCBhY3Rpb24uc291cmNlSWQsIGFjdGlvbi5mZXRjaElkLCBhY3Rpb24uZmV0Y2hSYW5nZSk7XG4gICAgICAgIGNhc2UgJ1JFTU9WRV9BTExfRVZFTlRfU09VUkNFUyc6XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRTb3VyY2VzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlZHVjZUV2ZW50U291cmNlc05ld1RpbWVab25lKGV2ZW50U291cmNlcywgZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcbiAgICBsZXQgYWN0aXZlUmFuZ2UgPSBkYXRlUHJvZmlsZSA/IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlIDogbnVsbDsgLy8gbmVlZCB0aGlzIGNoZWNrP1xuICAgIHJldHVybiBmZXRjaFNvdXJjZXNCeUlkcyhldmVudFNvdXJjZXMsIGV4Y2x1ZGVTdGF0aWNTb3VyY2VzKGV2ZW50U291cmNlcywgY29udGV4dCksIGFjdGl2ZVJhbmdlLCB0cnVlLCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVFdmVudFNvdXJjZXNMb2FkaW5nKGV2ZW50U291cmNlcykge1xuICAgIGZvciAobGV0IHNvdXJjZUlkIGluIGV2ZW50U291cmNlcykge1xuICAgICAgICBpZiAoZXZlbnRTb3VyY2VzW3NvdXJjZUlkXS5pc0ZldGNoaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBhZGRTb3VyY2VzKGV2ZW50U291cmNlSGFzaCwgc291cmNlcywgZmV0Y2hSYW5nZSwgY29udGV4dCkge1xuICAgIGxldCBoYXNoID0ge307XG4gICAgZm9yIChsZXQgc291cmNlIG9mIHNvdXJjZXMpIHtcbiAgICAgICAgaGFzaFtzb3VyY2Uuc291cmNlSWRdID0gc291cmNlO1xuICAgIH1cbiAgICBpZiAoZmV0Y2hSYW5nZSkge1xuICAgICAgICBoYXNoID0gZmV0Y2hEaXJ0eVNvdXJjZXMoaGFzaCwgZmV0Y2hSYW5nZSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50U291cmNlSGFzaCksIGhhc2gpO1xufVxuZnVuY3Rpb24gcmVtb3ZlU291cmNlKGV2ZW50U291cmNlSGFzaCwgc291cmNlSWQpIHtcbiAgICByZXR1cm4gZmlsdGVySGFzaChldmVudFNvdXJjZUhhc2gsIChldmVudFNvdXJjZSkgPT4gZXZlbnRTb3VyY2Uuc291cmNlSWQgIT09IHNvdXJjZUlkKTtcbn1cbmZ1bmN0aW9uIGZldGNoRGlydHlTb3VyY2VzKHNvdXJjZUhhc2gsIGZldGNoUmFuZ2UsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZmV0Y2hTb3VyY2VzQnlJZHMoc291cmNlSGFzaCwgZmlsdGVySGFzaChzb3VyY2VIYXNoLCAoZXZlbnRTb3VyY2UpID0+IGlzU291cmNlRGlydHkoZXZlbnRTb3VyY2UsIGZldGNoUmFuZ2UsIGNvbnRleHQpKSwgZmV0Y2hSYW5nZSwgZmFsc2UsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gaXNTb3VyY2VEaXJ0eShldmVudFNvdXJjZSwgZmV0Y2hSYW5nZSwgY29udGV4dCkge1xuICAgIGlmICghZG9lc1NvdXJjZU5lZWRSYW5nZShldmVudFNvdXJjZSwgY29udGV4dCkpIHtcbiAgICAgICAgcmV0dXJuICFldmVudFNvdXJjZS5sYXRlc3RGZXRjaElkO1xuICAgIH1cbiAgICByZXR1cm4gIWNvbnRleHQub3B0aW9ucy5sYXp5RmV0Y2hpbmcgfHxcbiAgICAgICAgIWV2ZW50U291cmNlLmZldGNoUmFuZ2UgfHxcbiAgICAgICAgZXZlbnRTb3VyY2UuaXNGZXRjaGluZyB8fCAvLyBhbHdheXMgY2FuY2VsIG91dGRhdGVkIGluLXByb2dyZXNzIGZldGNoZXNcbiAgICAgICAgZmV0Y2hSYW5nZS5zdGFydCA8IGV2ZW50U291cmNlLmZldGNoUmFuZ2Uuc3RhcnQgfHxcbiAgICAgICAgZmV0Y2hSYW5nZS5lbmQgPiBldmVudFNvdXJjZS5mZXRjaFJhbmdlLmVuZDtcbn1cbmZ1bmN0aW9uIGZldGNoU291cmNlc0J5SWRzKHByZXZTb3VyY2VzLCBzb3VyY2VJZEhhc2gsIGZldGNoUmFuZ2UsIGlzUmVmZXRjaCwgY29udGV4dCkge1xuICAgIGxldCBuZXh0U291cmNlcyA9IHt9O1xuICAgIGZvciAobGV0IHNvdXJjZUlkIGluIHByZXZTb3VyY2VzKSB7XG4gICAgICAgIGxldCBzb3VyY2UgPSBwcmV2U291cmNlc1tzb3VyY2VJZF07XG4gICAgICAgIGlmIChzb3VyY2VJZEhhc2hbc291cmNlSWRdKSB7XG4gICAgICAgICAgICBuZXh0U291cmNlc1tzb3VyY2VJZF0gPSBmZXRjaFNvdXJjZShzb3VyY2UsIGZldGNoUmFuZ2UsIGlzUmVmZXRjaCwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXh0U291cmNlc1tzb3VyY2VJZF0gPSBzb3VyY2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5leHRTb3VyY2VzO1xufVxuZnVuY3Rpb24gZmV0Y2hTb3VyY2UoZXZlbnRTb3VyY2UsIGZldGNoUmFuZ2UsIGlzUmVmZXRjaCwgY29udGV4dCkge1xuICAgIGxldCB7IG9wdGlvbnMsIGNhbGVuZGFyQXBpIH0gPSBjb250ZXh0O1xuICAgIGxldCBzb3VyY2VEZWYgPSBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50U291cmNlRGVmc1tldmVudFNvdXJjZS5zb3VyY2VEZWZJZF07XG4gICAgbGV0IGZldGNoSWQgPSBndWlkKCk7XG4gICAgc291cmNlRGVmLmZldGNoKHtcbiAgICAgICAgZXZlbnRTb3VyY2UsXG4gICAgICAgIHJhbmdlOiBmZXRjaFJhbmdlLFxuICAgICAgICBpc1JlZmV0Y2gsXG4gICAgICAgIGNvbnRleHQsXG4gICAgfSwgKHJlcykgPT4ge1xuICAgICAgICBsZXQgeyByYXdFdmVudHMgfSA9IHJlcztcbiAgICAgICAgaWYgKG9wdGlvbnMuZXZlbnRTb3VyY2VTdWNjZXNzKSB7XG4gICAgICAgICAgICByYXdFdmVudHMgPSBvcHRpb25zLmV2ZW50U291cmNlU3VjY2Vzcy5jYWxsKGNhbGVuZGFyQXBpLCByYXdFdmVudHMsIHJlcy5yZXNwb25zZSkgfHwgcmF3RXZlbnRzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudFNvdXJjZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICByYXdFdmVudHMgPSBldmVudFNvdXJjZS5zdWNjZXNzLmNhbGwoY2FsZW5kYXJBcGksIHJhd0V2ZW50cywgcmVzLnJlc3BvbnNlKSB8fCByYXdFdmVudHM7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnUkVDRUlWRV9FVkVOVFMnLFxuICAgICAgICAgICAgc291cmNlSWQ6IGV2ZW50U291cmNlLnNvdXJjZUlkLFxuICAgICAgICAgICAgZmV0Y2hJZCxcbiAgICAgICAgICAgIGZldGNoUmFuZ2UsXG4gICAgICAgICAgICByYXdFdmVudHMsXG4gICAgICAgIH0pO1xuICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICBsZXQgZXJyb3JIYW5kbGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChvcHRpb25zLmV2ZW50U291cmNlRmFpbHVyZSkge1xuICAgICAgICAgICAgb3B0aW9ucy5ldmVudFNvdXJjZUZhaWx1cmUuY2FsbChjYWxlbmRhckFwaSwgZXJyb3IpO1xuICAgICAgICAgICAgZXJyb3JIYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnRTb3VyY2UuZmFpbHVyZSkge1xuICAgICAgICAgICAgZXZlbnRTb3VyY2UuZmFpbHVyZShlcnJvcik7XG4gICAgICAgICAgICBlcnJvckhhbmRsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXJyb3JIYW5kbGVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IubWVzc2FnZSwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ1JFQ0VJVkVfRVZFTlRfRVJST1InLFxuICAgICAgICAgICAgc291cmNlSWQ6IGV2ZW50U291cmNlLnNvdXJjZUlkLFxuICAgICAgICAgICAgZmV0Y2hJZCxcbiAgICAgICAgICAgIGZldGNoUmFuZ2UsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRTb3VyY2UpLCB7IGlzRmV0Y2hpbmc6IHRydWUsIGxhdGVzdEZldGNoSWQ6IGZldGNoSWQgfSk7XG59XG5mdW5jdGlvbiByZWNlaXZlUmVzcG9uc2Uoc291cmNlSGFzaCwgc291cmNlSWQsIGZldGNoSWQsIGZldGNoUmFuZ2UpIHtcbiAgICBsZXQgZXZlbnRTb3VyY2UgPSBzb3VyY2VIYXNoW3NvdXJjZUlkXTtcbiAgICBpZiAoZXZlbnRTb3VyY2UgJiYgLy8gbm90IGFscmVhZHkgcmVtb3ZlZFxuICAgICAgICBmZXRjaElkID09PSBldmVudFNvdXJjZS5sYXRlc3RGZXRjaElkKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZUhhc2gpLCB7IFtzb3VyY2VJZF06IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRTb3VyY2UpLCB7IGlzRmV0Y2hpbmc6IGZhbHNlLCBmZXRjaFJhbmdlIH0pIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlSGFzaDtcbn1cbmZ1bmN0aW9uIGV4Y2x1ZGVTdGF0aWNTb3VyY2VzKGV2ZW50U291cmNlcywgY29udGV4dCkge1xuICAgIHJldHVybiBmaWx0ZXJIYXNoKGV2ZW50U291cmNlcywgKGV2ZW50U291cmNlKSA9PiBkb2VzU291cmNlTmVlZFJhbmdlKGV2ZW50U291cmNlLCBjb250ZXh0KSk7XG59XG5mdW5jdGlvbiBwYXJzZUluaXRpYWxTb3VyY2VzKHJhd09wdGlvbnMsIGNvbnRleHQpIHtcbiAgICBsZXQgcmVmaW5lcnMgPSBidWlsZEV2ZW50U291cmNlUmVmaW5lcnMoY29udGV4dCk7XG4gICAgbGV0IHJhd1NvdXJjZXMgPSBbXS5jb25jYXQocmF3T3B0aW9ucy5ldmVudFNvdXJjZXMgfHwgW10pO1xuICAgIGxldCBzb3VyY2VzID0gW107IC8vIHBhcnNlZFxuICAgIGlmIChyYXdPcHRpb25zLmluaXRpYWxFdmVudHMpIHtcbiAgICAgICAgcmF3U291cmNlcy51bnNoaWZ0KHJhd09wdGlvbnMuaW5pdGlhbEV2ZW50cyk7XG4gICAgfVxuICAgIGlmIChyYXdPcHRpb25zLmV2ZW50cykge1xuICAgICAgICByYXdTb3VyY2VzLnVuc2hpZnQocmF3T3B0aW9ucy5ldmVudHMpO1xuICAgIH1cbiAgICBmb3IgKGxldCByYXdTb3VyY2Ugb2YgcmF3U291cmNlcykge1xuICAgICAgICBsZXQgc291cmNlID0gcGFyc2VFdmVudFNvdXJjZShyYXdTb3VyY2UsIGNvbnRleHQsIHJlZmluZXJzKTtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgc291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZXM7XG59XG5mdW5jdGlvbiBkb2VzU291cmNlTmVlZFJhbmdlKGV2ZW50U291cmNlLCBjb250ZXh0KSB7XG4gICAgbGV0IGRlZnMgPSBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50U291cmNlRGVmcztcbiAgICByZXR1cm4gIWRlZnNbZXZlbnRTb3VyY2Uuc291cmNlRGVmSWRdLmlnbm9yZVJhbmdlO1xufVxuXG5mdW5jdGlvbiByZWR1Y2VEYXRlU2VsZWN0aW9uKGN1cnJlbnRTZWxlY3Rpb24sIGFjdGlvbikge1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnVU5TRUxFQ1RfREFURVMnOlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgJ1NFTEVDVF9EQVRFUyc6XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uLnNlbGVjdGlvbjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50U2VsZWN0aW9uO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVkdWNlU2VsZWN0ZWRFdmVudChjdXJyZW50SW5zdGFuY2VJZCwgYWN0aW9uKSB7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdVTlNFTEVDVF9FVkVOVCc6XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIGNhc2UgJ1NFTEVDVF9FVkVOVCc6XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uLmV2ZW50SW5zdGFuY2VJZDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50SW5zdGFuY2VJZDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlZHVjZUV2ZW50RHJhZyhjdXJyZW50RHJhZywgYWN0aW9uKSB7XG4gICAgbGV0IG5ld0RyYWc7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdVTlNFVF9FVkVOVF9EUkFHJzpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlICdTRVRfRVZFTlRfRFJBRyc6XG4gICAgICAgICAgICBuZXdEcmFnID0gYWN0aW9uLnN0YXRlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogbmV3RHJhZy5hZmZlY3RlZEV2ZW50cyxcbiAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRzOiBuZXdEcmFnLm11dGF0ZWRFdmVudHMsXG4gICAgICAgICAgICAgICAgaXNFdmVudDogbmV3RHJhZy5pc0V2ZW50LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50RHJhZztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlZHVjZUV2ZW50UmVzaXplKGN1cnJlbnRSZXNpemUsIGFjdGlvbikge1xuICAgIGxldCBuZXdSZXNpemU7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdVTlNFVF9FVkVOVF9SRVNJWkUnOlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgJ1NFVF9FVkVOVF9SRVNJWkUnOlxuICAgICAgICAgICAgbmV3UmVzaXplID0gYWN0aW9uLnN0YXRlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogbmV3UmVzaXplLmFmZmVjdGVkRXZlbnRzLFxuICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudHM6IG5ld1Jlc2l6ZS5tdXRhdGVkRXZlbnRzLFxuICAgICAgICAgICAgICAgIGlzRXZlbnQ6IG5ld1Jlc2l6ZS5pc0V2ZW50LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50UmVzaXplO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VUb29sYmFycyhjYWxlbmRhck9wdGlvbnMsIGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLCB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSkge1xuICAgIGxldCBoZWFkZXIgPSBjYWxlbmRhck9wdGlvbnMuaGVhZGVyVG9vbGJhciA/IHBhcnNlVG9vbGJhcihjYWxlbmRhck9wdGlvbnMuaGVhZGVyVG9vbGJhciwgY2FsZW5kYXJPcHRpb25zLCBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcywgdGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGkpIDogbnVsbDtcbiAgICBsZXQgZm9vdGVyID0gY2FsZW5kYXJPcHRpb25zLmZvb3RlclRvb2xiYXIgPyBwYXJzZVRvb2xiYXIoY2FsZW5kYXJPcHRpb25zLmZvb3RlclRvb2xiYXIsIGNhbGVuZGFyT3B0aW9ucywgY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsIHRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKSA6IG51bGw7XG4gICAgcmV0dXJuIHsgaGVhZGVyLCBmb290ZXIgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlVG9vbGJhcihzZWN0aW9uU3RySGFzaCwgY2FsZW5kYXJPcHRpb25zLCBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcywgdGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGkpIHtcbiAgICBsZXQgc2VjdGlvbldpZGdldHMgPSB7fTtcbiAgICBsZXQgdmlld3NXaXRoQnV0dG9ucyA9IFtdO1xuICAgIGxldCBoYXNUaXRsZSA9IGZhbHNlO1xuICAgIGZvciAobGV0IHNlY3Rpb25OYW1lIGluIHNlY3Rpb25TdHJIYXNoKSB7XG4gICAgICAgIGxldCBzZWN0aW9uU3RyID0gc2VjdGlvblN0ckhhc2hbc2VjdGlvbk5hbWVdO1xuICAgICAgICBsZXQgc2VjdGlvblJlcyA9IHBhcnNlU2VjdGlvbihzZWN0aW9uU3RyLCBjYWxlbmRhck9wdGlvbnMsIGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLCB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSk7XG4gICAgICAgIHNlY3Rpb25XaWRnZXRzW3NlY3Rpb25OYW1lXSA9IHNlY3Rpb25SZXMud2lkZ2V0cztcbiAgICAgICAgdmlld3NXaXRoQnV0dG9ucy5wdXNoKC4uLnNlY3Rpb25SZXMudmlld3NXaXRoQnV0dG9ucyk7XG4gICAgICAgIGhhc1RpdGxlID0gaGFzVGl0bGUgfHwgc2VjdGlvblJlcy5oYXNUaXRsZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2VjdGlvbldpZGdldHMsIHZpZXdzV2l0aEJ1dHRvbnMsIGhhc1RpdGxlIH07XG59XG4vKlxuQkFEOiBxdWVyeWluZyBpY29ucyBhbmQgdGV4dCBoZXJlLiBzaG91bGQgYmUgZG9uZSBhdCByZW5kZXIgdGltZVxuKi9cbmZ1bmN0aW9uIHBhcnNlU2VjdGlvbihzZWN0aW9uU3RyLCBjYWxlbmRhck9wdGlvbnMsIC8vIGRlZmF1bHRzK292ZXJyaWRlcywgdGhlbiByZWZpbmVkXG5jYWxlbmRhck9wdGlvbk92ZXJyaWRlcywgLy8gb3ZlcnJpZGVzIG9ubHkhLCB1bnJlZmluZWQgOihcbnRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKSB7XG4gICAgbGV0IGlzUnRsID0gY2FsZW5kYXJPcHRpb25zLmRpcmVjdGlvbiA9PT0gJ3J0bCc7XG4gICAgbGV0IGNhbGVuZGFyQ3VzdG9tQnV0dG9ucyA9IGNhbGVuZGFyT3B0aW9ucy5jdXN0b21CdXR0b25zIHx8IHt9O1xuICAgIGxldCBjYWxlbmRhckJ1dHRvblRleHRPdmVycmlkZXMgPSBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcy5idXR0b25UZXh0IHx8IHt9O1xuICAgIGxldCBjYWxlbmRhckJ1dHRvblRleHQgPSBjYWxlbmRhck9wdGlvbnMuYnV0dG9uVGV4dCB8fCB7fTtcbiAgICBsZXQgY2FsZW5kYXJCdXR0b25IaW50T3ZlcnJpZGVzID0gY2FsZW5kYXJPcHRpb25PdmVycmlkZXMuYnV0dG9uSGludHMgfHwge307XG4gICAgbGV0IGNhbGVuZGFyQnV0dG9uSGludHMgPSBjYWxlbmRhck9wdGlvbnMuYnV0dG9uSGludHMgfHwge307XG4gICAgbGV0IHNlY3Rpb25TdWJzdHJzID0gc2VjdGlvblN0ciA/IHNlY3Rpb25TdHIuc3BsaXQoJyAnKSA6IFtdO1xuICAgIGxldCB2aWV3c1dpdGhCdXR0b25zID0gW107XG4gICAgbGV0IGhhc1RpdGxlID0gZmFsc2U7XG4gICAgbGV0IHdpZGdldHMgPSBzZWN0aW9uU3Vic3Rycy5tYXAoKGJ1dHRvbkdyb3VwU3RyKSA9PiAoYnV0dG9uR3JvdXBTdHIuc3BsaXQoJywnKS5tYXAoKGJ1dHRvbk5hbWUpID0+IHtcbiAgICAgICAgaWYgKGJ1dHRvbk5hbWUgPT09ICd0aXRsZScpIHtcbiAgICAgICAgICAgIGhhc1RpdGxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB7IGJ1dHRvbk5hbWUgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VzdG9tQnV0dG9uUHJvcHM7XG4gICAgICAgIGxldCB2aWV3U3BlYztcbiAgICAgICAgbGV0IGJ1dHRvbkNsaWNrO1xuICAgICAgICBsZXQgYnV0dG9uSWNvbjsgLy8gb25seSBvbmUgb2YgdGhlc2Ugd2lsbCBiZSBzZXRcbiAgICAgICAgbGV0IGJ1dHRvblRleHQ7IC8vIFwiXG4gICAgICAgIGxldCBidXR0b25IaW50O1xuICAgICAgICAvLyBeIGZvciB0aGUgdGl0bGU9XCJcIiBhdHRyaWJ1dGUsIGZvciBhY2Nlc3NpYmlsaXR5XG4gICAgICAgIGlmICgoY3VzdG9tQnV0dG9uUHJvcHMgPSBjYWxlbmRhckN1c3RvbUJ1dHRvbnNbYnV0dG9uTmFtZV0pKSB7XG4gICAgICAgICAgICBidXR0b25DbGljayA9IChldikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjdXN0b21CdXR0b25Qcm9wcy5jbGljaykge1xuICAgICAgICAgICAgICAgICAgICBjdXN0b21CdXR0b25Qcm9wcy5jbGljay5jYWxsKGV2LnRhcmdldCwgZXYsIGV2LnRhcmdldCk7IC8vIFRPRE86IHVzZSBDYWxlbmRhciB0aGlzIGNvbnRleHQ/XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIChidXR0b25JY29uID0gdGhlbWUuZ2V0Q3VzdG9tQnV0dG9uSWNvbkNsYXNzKGN1c3RvbUJ1dHRvblByb3BzKSkgfHxcbiAgICAgICAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEljb25DbGFzcyhidXR0b25OYW1lLCBpc1J0bCkpIHx8XG4gICAgICAgICAgICAgICAgKGJ1dHRvblRleHQgPSBjdXN0b21CdXR0b25Qcm9wcy50ZXh0KTtcbiAgICAgICAgICAgIGJ1dHRvbkhpbnQgPSBjdXN0b21CdXR0b25Qcm9wcy5oaW50IHx8IGN1c3RvbUJ1dHRvblByb3BzLnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHZpZXdTcGVjID0gdmlld1NwZWNzW2J1dHRvbk5hbWVdKSkge1xuICAgICAgICAgICAgdmlld3NXaXRoQnV0dG9ucy5wdXNoKGJ1dHRvbk5hbWUpO1xuICAgICAgICAgICAgYnV0dG9uQ2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsZW5kYXJBcGkuY2hhbmdlVmlldyhidXR0b25OYW1lKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAoYnV0dG9uVGV4dCA9IHZpZXdTcGVjLmJ1dHRvblRleHRPdmVycmlkZSkgfHxcbiAgICAgICAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEljb25DbGFzcyhidXR0b25OYW1lLCBpc1J0bCkpIHx8XG4gICAgICAgICAgICAgICAgKGJ1dHRvblRleHQgPSB2aWV3U3BlYy5idXR0b25UZXh0RGVmYXVsdCk7XG4gICAgICAgICAgICBsZXQgdGV4dEZhbGxiYWNrID0gdmlld1NwZWMuYnV0dG9uVGV4dE92ZXJyaWRlIHx8XG4gICAgICAgICAgICAgICAgdmlld1NwZWMuYnV0dG9uVGV4dERlZmF1bHQ7XG4gICAgICAgICAgICBidXR0b25IaW50ID0gZm9ybWF0V2l0aE9yZGluYWxzKHZpZXdTcGVjLmJ1dHRvblRpdGxlT3ZlcnJpZGUgfHxcbiAgICAgICAgICAgICAgICB2aWV3U3BlYy5idXR0b25UaXRsZURlZmF1bHQgfHxcbiAgICAgICAgICAgICAgICBjYWxlbmRhck9wdGlvbnMudmlld0hpbnQsIFt0ZXh0RmFsbGJhY2ssIGJ1dHRvbk5hbWVdLCAvLyB2aWV3LW5hbWUgPSBidXR0b25OYW1lXG4gICAgICAgICAgICB0ZXh0RmFsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNhbGVuZGFyQXBpW2J1dHRvbk5hbWVdKSB7IC8vIGEgY2FsZW5kYXJBcGkgbWV0aG9kXG4gICAgICAgICAgICBidXR0b25DbGljayA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjYWxlbmRhckFwaVtidXR0b25OYW1lXSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIChidXR0b25UZXh0ID0gY2FsZW5kYXJCdXR0b25UZXh0T3ZlcnJpZGVzW2J1dHRvbk5hbWVdKSB8fFxuICAgICAgICAgICAgICAgIChidXR0b25JY29uID0gdGhlbWUuZ2V0SWNvbkNsYXNzKGJ1dHRvbk5hbWUsIGlzUnRsKSkgfHxcbiAgICAgICAgICAgICAgICAoYnV0dG9uVGV4dCA9IGNhbGVuZGFyQnV0dG9uVGV4dFtidXR0b25OYW1lXSk7IC8vIGV2ZXJ5dGhpbmcgZWxzZSBpcyBjb25zaWRlcmVkIGRlZmF1bHRcbiAgICAgICAgICAgIGlmIChidXR0b25OYW1lID09PSAncHJldlllYXInIHx8IGJ1dHRvbk5hbWUgPT09ICduZXh0WWVhcicpIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJldk9yTmV4dCA9IGJ1dHRvbk5hbWUgPT09ICdwcmV2WWVhcicgPyAncHJldicgOiAnbmV4dCc7XG4gICAgICAgICAgICAgICAgYnV0dG9uSGludCA9IGZvcm1hdFdpdGhPcmRpbmFscyhjYWxlbmRhckJ1dHRvbkhpbnRPdmVycmlkZXNbcHJldk9yTmV4dF0gfHxcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXJCdXR0b25IaW50c1twcmV2T3JOZXh0XSwgW1xuICAgICAgICAgICAgICAgICAgICBjYWxlbmRhckJ1dHRvblRleHQueWVhciB8fCAneWVhcicsXG4gICAgICAgICAgICAgICAgICAgICd5ZWFyJyxcbiAgICAgICAgICAgICAgICBdLCBjYWxlbmRhckJ1dHRvblRleHRbYnV0dG9uTmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnV0dG9uSGludCA9IChuYXZVbml0KSA9PiBmb3JtYXRXaXRoT3JkaW5hbHMoY2FsZW5kYXJCdXR0b25IaW50T3ZlcnJpZGVzW2J1dHRvbk5hbWVdIHx8XG4gICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyQnV0dG9uSGludHNbYnV0dG9uTmFtZV0sIFtcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXJCdXR0b25UZXh0W25hdlVuaXRdIHx8IG5hdlVuaXQsXG4gICAgICAgICAgICAgICAgICAgIG5hdlVuaXQsXG4gICAgICAgICAgICAgICAgXSwgY2FsZW5kYXJCdXR0b25UZXh0W2J1dHRvbk5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBidXR0b25OYW1lLCBidXR0b25DbGljaywgYnV0dG9uSWNvbiwgYnV0dG9uVGV4dCwgYnV0dG9uSGludCB9O1xuICAgIH0pKSk7XG4gICAgcmV0dXJuIHsgd2lkZ2V0cywgdmlld3NXaXRoQnV0dG9ucywgaGFzVGl0bGUgfTtcbn1cblxuLy8gYWx3YXlzIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgdmlldy4gb3RoZXJ3aXNlLCBpdCdkIG5lZWQgdG8gY2hhbmdlIHZhbHVlIGV2ZXJ5IHRpbWUgZGF0ZSBjaGFuZ2VzXG5jbGFzcyBWaWV3SW1wbCB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgZ2V0Q3VycmVudERhdGEsIGRhdGVFbnYpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50RGF0YSA9IGdldEN1cnJlbnREYXRhO1xuICAgICAgICB0aGlzLmRhdGVFbnYgPSBkYXRlRW52O1xuICAgIH1cbiAgICBnZXQgY2FsZW5kYXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnREYXRhKCkuY2FsZW5kYXJBcGk7XG4gICAgfVxuICAgIGdldCB0aXRsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudERhdGEoKS52aWV3VGl0bGU7XG4gICAgfVxuICAgIGdldCBhY3RpdmVTdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUVudi50b0RhdGUodGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLnN0YXJ0KTtcbiAgICB9XG4gICAgZ2V0IGFjdGl2ZUVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUVudi50b0RhdGUodGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLmVuZCk7XG4gICAgfVxuICAgIGdldCBjdXJyZW50U3RhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVFbnYudG9EYXRlKHRoaXMuZ2V0Q3VycmVudERhdGEoKS5kYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2Uuc3RhcnQpO1xuICAgIH1cbiAgICBnZXQgY3VycmVudEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUVudi50b0RhdGUodGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5lbmQpO1xuICAgIH1cbiAgICBnZXRPcHRpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50RGF0YSgpLm9wdGlvbnNbbmFtZV07IC8vIGFyZSB0aGUgdmlldy1zcGVjaWZpYyBvcHRpb25zXG4gICAgfVxufVxuXG5sZXQgZXZlbnRTb3VyY2VEZWYkMiA9IHtcbiAgICBpZ25vcmVSYW5nZTogdHJ1ZSxcbiAgICBwYXJzZU1ldGEocmVmaW5lZCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZpbmVkLmV2ZW50cykpIHtcbiAgICAgICAgICAgIHJldHVybiByZWZpbmVkLmV2ZW50cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGZldGNoKGFyZywgc3VjY2Vzc0NhbGxiYWNrKSB7XG4gICAgICAgIHN1Y2Nlc3NDYWxsYmFjayh7XG4gICAgICAgICAgICByYXdFdmVudHM6IGFyZy5ldmVudFNvdXJjZS5tZXRhLFxuICAgICAgICB9KTtcbiAgICB9LFxufTtcbmNvbnN0IGFycmF5RXZlbnRTb3VyY2VQbHVnaW4gPSBjcmVhdGVQbHVnaW4oe1xuICAgIG5hbWU6ICdhcnJheS1ldmVudC1zb3VyY2UnLFxuICAgIGV2ZW50U291cmNlRGVmczogW2V2ZW50U291cmNlRGVmJDJdLFxufSk7XG5cbmxldCBldmVudFNvdXJjZURlZiQxID0ge1xuICAgIHBhcnNlTWV0YShyZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVmaW5lZC5ldmVudHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiByZWZpbmVkLmV2ZW50cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGZldGNoKGFyZywgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHsgZGF0ZUVudiB9ID0gYXJnLmNvbnRleHQ7XG4gICAgICAgIGNvbnN0IGZ1bmMgPSBhcmcuZXZlbnRTb3VyY2UubWV0YTtcbiAgICAgICAgdW5wcm9taXNpZnkoZnVuYy5iaW5kKG51bGwsIGJ1aWxkUmFuZ2VBcGlXaXRoVGltZVpvbmUoYXJnLnJhbmdlLCBkYXRlRW52KSksIChyYXdFdmVudHMpID0+IHN1Y2Nlc3NDYWxsYmFjayh7IHJhd0V2ZW50cyB9KSwgZXJyb3JDYWxsYmFjayk7XG4gICAgfSxcbn07XG5jb25zdCBmdW5jRXZlbnRTb3VyY2VQbHVnaW4gPSBjcmVhdGVQbHVnaW4oe1xuICAgIG5hbWU6ICdmdW5jLWV2ZW50LXNvdXJjZScsXG4gICAgZXZlbnRTb3VyY2VEZWZzOiBbZXZlbnRTb3VyY2VEZWYkMV0sXG59KTtcblxuY29uc3QgSlNPTl9GRUVEX0VWRU5UX1NPVVJDRV9SRUZJTkVSUyA9IHtcbiAgICBtZXRob2Q6IFN0cmluZyxcbiAgICBleHRyYVBhcmFtczogaWRlbnRpdHksXG4gICAgc3RhcnRQYXJhbTogU3RyaW5nLFxuICAgIGVuZFBhcmFtOiBTdHJpbmcsXG4gICAgdGltZVpvbmVQYXJhbTogU3RyaW5nLFxufTtcblxubGV0IGV2ZW50U291cmNlRGVmID0ge1xuICAgIHBhcnNlTWV0YShyZWZpbmVkKSB7XG4gICAgICAgIGlmIChyZWZpbmVkLnVybCAmJiAocmVmaW5lZC5mb3JtYXQgPT09ICdqc29uJyB8fCAhcmVmaW5lZC5mb3JtYXQpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogcmVmaW5lZC51cmwsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnanNvbicsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAocmVmaW5lZC5tZXRob2QgfHwgJ0dFVCcpLnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgZXh0cmFQYXJhbXM6IHJlZmluZWQuZXh0cmFQYXJhbXMsXG4gICAgICAgICAgICAgICAgc3RhcnRQYXJhbTogcmVmaW5lZC5zdGFydFBhcmFtLFxuICAgICAgICAgICAgICAgIGVuZFBhcmFtOiByZWZpbmVkLmVuZFBhcmFtLFxuICAgICAgICAgICAgICAgIHRpbWVab25lUGFyYW06IHJlZmluZWQudGltZVpvbmVQYXJhbSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBmZXRjaChhcmcsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgICAgICBjb25zdCB7IG1ldGEgfSA9IGFyZy5ldmVudFNvdXJjZTtcbiAgICAgICAgY29uc3QgcmVxdWVzdFBhcmFtcyA9IGJ1aWxkUmVxdWVzdFBhcmFtcyhtZXRhLCBhcmcucmFuZ2UsIGFyZy5jb250ZXh0KTtcbiAgICAgICAgcmVxdWVzdEpzb24obWV0YS5tZXRob2QsIG1ldGEudXJsLCByZXF1ZXN0UGFyYW1zKS50aGVuKChbcmF3RXZlbnRzLCByZXNwb25zZV0pID0+IHtcbiAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjayh7IHJhd0V2ZW50cywgcmVzcG9uc2UgfSk7XG4gICAgICAgIH0sIGVycm9yQ2FsbGJhY2spO1xuICAgIH0sXG59O1xuY29uc3QganNvbkZlZWRFdmVudFNvdXJjZVBsdWdpbiA9IGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogJ2pzb24tZXZlbnQtc291cmNlJyxcbiAgICBldmVudFNvdXJjZVJlZmluZXJzOiBKU09OX0ZFRURfRVZFTlRfU09VUkNFX1JFRklORVJTLFxuICAgIGV2ZW50U291cmNlRGVmczogW2V2ZW50U291cmNlRGVmXSxcbn0pO1xuZnVuY3Rpb24gYnVpbGRSZXF1ZXN0UGFyYW1zKG1ldGEsIHJhbmdlLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgZGF0ZUVudiwgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICBsZXQgc3RhcnRQYXJhbTtcbiAgICBsZXQgZW5kUGFyYW07XG4gICAgbGV0IHRpbWVab25lUGFyYW07XG4gICAgbGV0IGN1c3RvbVJlcXVlc3RQYXJhbXM7XG4gICAgbGV0IHBhcmFtcyA9IHt9O1xuICAgIHN0YXJ0UGFyYW0gPSBtZXRhLnN0YXJ0UGFyYW07XG4gICAgaWYgKHN0YXJ0UGFyYW0gPT0gbnVsbCkge1xuICAgICAgICBzdGFydFBhcmFtID0gb3B0aW9ucy5zdGFydFBhcmFtO1xuICAgIH1cbiAgICBlbmRQYXJhbSA9IG1ldGEuZW5kUGFyYW07XG4gICAgaWYgKGVuZFBhcmFtID09IG51bGwpIHtcbiAgICAgICAgZW5kUGFyYW0gPSBvcHRpb25zLmVuZFBhcmFtO1xuICAgIH1cbiAgICB0aW1lWm9uZVBhcmFtID0gbWV0YS50aW1lWm9uZVBhcmFtO1xuICAgIGlmICh0aW1lWm9uZVBhcmFtID09IG51bGwpIHtcbiAgICAgICAgdGltZVpvbmVQYXJhbSA9IG9wdGlvbnMudGltZVpvbmVQYXJhbTtcbiAgICB9XG4gICAgLy8gcmV0cmlldmUgYW55IG91dGJvdW5kIEdFVC9QT1NUIGRhdGEgZnJvbSB0aGUgb3B0aW9uc1xuICAgIGlmICh0eXBlb2YgbWV0YS5leHRyYVBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBzdXBwbGllZCBhcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGtleS92YWx1ZSBvYmplY3RcbiAgICAgICAgY3VzdG9tUmVxdWVzdFBhcmFtcyA9IG1ldGEuZXh0cmFQYXJhbXMoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIHByb2JhYmx5IHN1cHBsaWVkIGFzIGEgc3RyYWlnaHQga2V5L3ZhbHVlIG9iamVjdFxuICAgICAgICBjdXN0b21SZXF1ZXN0UGFyYW1zID0gbWV0YS5leHRyYVBhcmFtcyB8fCB7fTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbihwYXJhbXMsIGN1c3RvbVJlcXVlc3RQYXJhbXMpO1xuICAgIHBhcmFtc1tzdGFydFBhcmFtXSA9IGRhdGVFbnYuZm9ybWF0SXNvKHJhbmdlLnN0YXJ0KTtcbiAgICBwYXJhbXNbZW5kUGFyYW1dID0gZGF0ZUVudi5mb3JtYXRJc28ocmFuZ2UuZW5kKTtcbiAgICBpZiAoZGF0ZUVudi50aW1lWm9uZSAhPT0gJ2xvY2FsJykge1xuICAgICAgICBwYXJhbXNbdGltZVpvbmVQYXJhbV0gPSBkYXRlRW52LnRpbWVab25lO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1zO1xufVxuXG5jb25zdCBTSU1QTEVfUkVDVVJSSU5HX1JFRklORVJTID0ge1xuICAgIGRheXNPZldlZWs6IGlkZW50aXR5LFxuICAgIHN0YXJ0VGltZTogY3JlYXRlRHVyYXRpb24sXG4gICAgZW5kVGltZTogY3JlYXRlRHVyYXRpb24sXG4gICAgZHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxuICAgIHN0YXJ0UmVjdXI6IGlkZW50aXR5LFxuICAgIGVuZFJlY3VyOiBpZGVudGl0eSxcbn07XG5cbmxldCByZWN1cnJpbmcgPSB7XG4gICAgcGFyc2UocmVmaW5lZCwgZGF0ZUVudikge1xuICAgICAgICBpZiAocmVmaW5lZC5kYXlzT2ZXZWVrIHx8IHJlZmluZWQuc3RhcnRUaW1lIHx8IHJlZmluZWQuZW5kVGltZSB8fCByZWZpbmVkLnN0YXJ0UmVjdXIgfHwgcmVmaW5lZC5lbmRSZWN1cikge1xuICAgICAgICAgICAgbGV0IHJlY3VycmluZ0RhdGEgPSB7XG4gICAgICAgICAgICAgICAgZGF5c09mV2VlazogcmVmaW5lZC5kYXlzT2ZXZWVrIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lOiByZWZpbmVkLnN0YXJ0VGltZSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIGVuZFRpbWU6IHJlZmluZWQuZW5kVGltZSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIHN0YXJ0UmVjdXI6IHJlZmluZWQuc3RhcnRSZWN1ciA/IGRhdGVFbnYuY3JlYXRlTWFya2VyKHJlZmluZWQuc3RhcnRSZWN1cikgOiBudWxsLFxuICAgICAgICAgICAgICAgIGVuZFJlY3VyOiByZWZpbmVkLmVuZFJlY3VyID8gZGF0ZUVudi5jcmVhdGVNYXJrZXIocmVmaW5lZC5lbmRSZWN1cikgOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBkdXJhdGlvbjtcbiAgICAgICAgICAgIGlmIChyZWZpbmVkLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24gPSByZWZpbmVkLmR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkdXJhdGlvbiAmJiByZWZpbmVkLnN0YXJ0VGltZSAmJiByZWZpbmVkLmVuZFRpbWUpIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IHN1YnRyYWN0RHVyYXRpb25zKHJlZmluZWQuZW5kVGltZSwgcmVmaW5lZC5zdGFydFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhbGxEYXlHdWVzczogQm9vbGVhbighcmVmaW5lZC5zdGFydFRpbWUgJiYgIXJlZmluZWQuZW5kVGltZSksXG4gICAgICAgICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgdHlwZURhdGE6IHJlY3VycmluZ0RhdGEsIC8vIGRvZXNuJ3QgbmVlZCBlbmRUaW1lIGFueW1vcmUgYnV0IG9oIHdlbGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBleHBhbmQodHlwZURhdGEsIGZyYW1pbmdSYW5nZSwgZGF0ZUVudikge1xuICAgICAgICBsZXQgY2xpcHBlZEZyYW1pbmdSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhmcmFtaW5nUmFuZ2UsIHsgc3RhcnQ6IHR5cGVEYXRhLnN0YXJ0UmVjdXIsIGVuZDogdHlwZURhdGEuZW5kUmVjdXIgfSk7XG4gICAgICAgIGlmIChjbGlwcGVkRnJhbWluZ1JhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwYW5kUmFuZ2VzKHR5cGVEYXRhLmRheXNPZldlZWssIHR5cGVEYXRhLnN0YXJ0VGltZSwgY2xpcHBlZEZyYW1pbmdSYW5nZSwgZGF0ZUVudik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG59O1xuY29uc3Qgc2ltcGxlUmVjdXJyaW5nRXZlbnRzUGx1Z2luID0gY3JlYXRlUGx1Z2luKHtcbiAgICBuYW1lOiAnc2ltcGxlLXJlY3VycmluZy1ldmVudCcsXG4gICAgcmVjdXJyaW5nVHlwZXM6IFtyZWN1cnJpbmddLFxuICAgIGV2ZW50UmVmaW5lcnM6IFNJTVBMRV9SRUNVUlJJTkdfUkVGSU5FUlMsXG59KTtcbmZ1bmN0aW9uIGV4cGFuZFJhbmdlcyhkYXlzT2ZXZWVrLCBzdGFydFRpbWUsIGZyYW1pbmdSYW5nZSwgZGF0ZUVudikge1xuICAgIGxldCBkb3dIYXNoID0gZGF5c09mV2VlayA/IGFycmF5VG9IYXNoKGRheXNPZldlZWspIDogbnVsbDtcbiAgICBsZXQgZGF5TWFya2VyID0gc3RhcnRPZkRheShmcmFtaW5nUmFuZ2Uuc3RhcnQpO1xuICAgIGxldCBlbmRNYXJrZXIgPSBmcmFtaW5nUmFuZ2UuZW5kO1xuICAgIGxldCBpbnN0YW5jZVN0YXJ0cyA9IFtdO1xuICAgIHdoaWxlIChkYXlNYXJrZXIgPCBlbmRNYXJrZXIpIHtcbiAgICAgICAgbGV0IGluc3RhbmNlU3RhcnQ7XG4gICAgICAgIC8vIGlmIGV2ZXJ5ZGF5LCBvciB0aGlzIHBhcnRpY3VsYXIgZGF5LW9mLXdlZWtcbiAgICAgICAgaWYgKCFkb3dIYXNoIHx8IGRvd0hhc2hbZGF5TWFya2VyLmdldFVUQ0RheSgpXSkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlU3RhcnQgPSBkYXRlRW52LmFkZChkYXlNYXJrZXIsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZVN0YXJ0ID0gZGF5TWFya2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zdGFuY2VTdGFydHMucHVzaChpbnN0YW5jZVN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBkYXlNYXJrZXIgPSBhZGREYXlzKGRheU1hcmtlciwgMSk7XG4gICAgfVxuICAgIHJldHVybiBpbnN0YW5jZVN0YXJ0cztcbn1cblxuY29uc3QgY2hhbmdlSGFuZGxlclBsdWdpbiA9IGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogJ2NoYW5nZS1oYW5kbGVyJyxcbiAgICBvcHRpb25DaGFuZ2VIYW5kbGVyczoge1xuICAgICAgICBldmVudHMoZXZlbnRzLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBoYW5kbGVFdmVudFNvdXJjZXMoW2V2ZW50c10sIGNvbnRleHQpO1xuICAgICAgICB9LFxuICAgICAgICBldmVudFNvdXJjZXM6IGhhbmRsZUV2ZW50U291cmNlcyxcbiAgICB9LFxufSk7XG4vKlxuQlVHOiBpZiBgZXZlbnRgIHdhcyBzdXBwbGllZCwgYWxsIHByZXZpb3VzbHktZ2l2ZW4gYGV2ZW50U291cmNlc2Agd2lsbCBiZSB3aXBlZCBvdXRcbiovXG5mdW5jdGlvbiBoYW5kbGVFdmVudFNvdXJjZXMoaW5wdXRzLCBjb250ZXh0KSB7XG4gICAgbGV0IHVuZm91bmRTb3VyY2VzID0gaGFzaFZhbHVlc1RvQXJyYXkoY29udGV4dC5nZXRDdXJyZW50RGF0YSgpLmV2ZW50U291cmNlcyk7XG4gICAgaWYgKHVuZm91bmRTb3VyY2VzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICBpbnB1dHMubGVuZ3RoID09PSAxICYmXG4gICAgICAgIEFycmF5LmlzQXJyYXkodW5mb3VuZFNvdXJjZXNbMF0uX3JhdykgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheShpbnB1dHNbMF0pKSB7XG4gICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ1JFU0VUX1JBV19FVkVOVFMnLFxuICAgICAgICAgICAgc291cmNlSWQ6IHVuZm91bmRTb3VyY2VzWzBdLnNvdXJjZUlkLFxuICAgICAgICAgICAgcmF3RXZlbnRzOiBpbnB1dHNbMF0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBuZXdJbnB1dHMgPSBbXTtcbiAgICBmb3IgKGxldCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAgICAgbGV0IGlucHV0Rm91bmQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1bmZvdW5kU291cmNlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKHVuZm91bmRTb3VyY2VzW2ldLl9yYXcgPT09IGlucHV0KSB7XG4gICAgICAgICAgICAgICAgdW5mb3VuZFNvdXJjZXMuc3BsaWNlKGksIDEpOyAvLyBkZWxldGVcbiAgICAgICAgICAgICAgICBpbnB1dEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlucHV0Rm91bmQpIHtcbiAgICAgICAgICAgIG5ld0lucHV0cy5wdXNoKGlucHV0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCB1bmZvdW5kU291cmNlIG9mIHVuZm91bmRTb3VyY2VzKSB7XG4gICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVF9TT1VSQ0UnLFxuICAgICAgICAgICAgc291cmNlSWQ6IHVuZm91bmRTb3VyY2Uuc291cmNlSWQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBuZXdJbnB1dCBvZiBuZXdJbnB1dHMpIHtcbiAgICAgICAgY29udGV4dC5jYWxlbmRhckFwaS5hZGRFdmVudFNvdXJjZShuZXdJbnB1dCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVEYXRlUHJvZmlsZShkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdkYXRlc1NldCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYnVpbGRSYW5nZUFwaVdpdGhUaW1lWm9uZShkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgY29udGV4dC5kYXRlRW52KSksIHsgdmlldzogY29udGV4dC52aWV3QXBpIH0pKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlRXZlbnRTdG9yZShldmVudFN0b3JlLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgZW1pdHRlciB9ID0gY29udGV4dDtcbiAgICBpZiAoZW1pdHRlci5oYXNIYW5kbGVycygnZXZlbnRzU2V0JykpIHtcbiAgICAgICAgZW1pdHRlci50cmlnZ2VyKCdldmVudHNTZXQnLCBidWlsZEV2ZW50QXBpcyhldmVudFN0b3JlLCBjb250ZXh0KSk7XG4gICAgfVxufVxuXG4vKlxudGhpcyBhcnJheSBpcyBleHBvc2VkIG9uIHRoZSByb290IG5hbWVzcGFjZSBzbyB0aGF0IFVNRCBwbHVnaW5zIGNhbiBhZGQgdG8gaXQuXG5zZWUgdGhlIHJvbGx1cC1idW5kbGVzIHNjcmlwdC5cbiovXG5jb25zdCBnbG9iYWxQbHVnaW5zID0gW1xuICAgIGFycmF5RXZlbnRTb3VyY2VQbHVnaW4sXG4gICAgZnVuY0V2ZW50U291cmNlUGx1Z2luLFxuICAgIGpzb25GZWVkRXZlbnRTb3VyY2VQbHVnaW4sXG4gICAgc2ltcGxlUmVjdXJyaW5nRXZlbnRzUGx1Z2luLFxuICAgIGNoYW5nZUhhbmRsZXJQbHVnaW4sXG4gICAgY3JlYXRlUGx1Z2luKHtcbiAgICAgICAgbmFtZTogJ21pc2MnLFxuICAgICAgICBpc0xvYWRpbmdGdW5jczogW1xuICAgICAgICAgICAgKHN0YXRlKSA9PiBjb21wdXRlRXZlbnRTb3VyY2VzTG9hZGluZyhzdGF0ZS5ldmVudFNvdXJjZXMpLFxuICAgICAgICBdLFxuICAgICAgICBwcm9wU2V0SGFuZGxlcnM6IHtcbiAgICAgICAgICAgIGRhdGVQcm9maWxlOiBoYW5kbGVEYXRlUHJvZmlsZSxcbiAgICAgICAgICAgIGV2ZW50U3RvcmU6IGhhbmRsZUV2ZW50U3RvcmUsXG4gICAgICAgIH0sXG4gICAgfSksXG5dO1xuXG5jbGFzcyBUYXNrUnVubmVyIHtcbiAgICBjb25zdHJ1Y3RvcihydW5UYXNrT3B0aW9uLCBkcmFpbmVkT3B0aW9uKSB7XG4gICAgICAgIHRoaXMucnVuVGFza09wdGlvbiA9IHJ1blRhc2tPcHRpb247XG4gICAgICAgIHRoaXMuZHJhaW5lZE9wdGlvbiA9IGRyYWluZWRPcHRpb247XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5kZWxheWVkUnVubmVyID0gbmV3IERlbGF5ZWRSdW5uZXIodGhpcy5kcmFpbi5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgcmVxdWVzdCh0YXNrLCBkZWxheSkge1xuICAgICAgICB0aGlzLnF1ZXVlLnB1c2godGFzayk7XG4gICAgICAgIHRoaXMuZGVsYXllZFJ1bm5lci5yZXF1ZXN0KGRlbGF5KTtcbiAgICB9XG4gICAgcGF1c2Uoc2NvcGUpIHtcbiAgICAgICAgdGhpcy5kZWxheWVkUnVubmVyLnBhdXNlKHNjb3BlKTtcbiAgICB9XG4gICAgcmVzdW1lKHNjb3BlLCBmb3JjZSkge1xuICAgICAgICB0aGlzLmRlbGF5ZWRSdW5uZXIucmVzdW1lKHNjb3BlLCBmb3JjZSk7XG4gICAgfVxuICAgIGRyYWluKCkge1xuICAgICAgICBsZXQgeyBxdWV1ZSB9ID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGNvbXBsZXRlZFRhc2tzID0gW107XG4gICAgICAgICAgICBsZXQgdGFzaztcbiAgICAgICAgICAgIHdoaWxlICgodGFzayA9IHF1ZXVlLnNoaWZ0KCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5UYXNrKHRhc2spO1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlZFRhc2tzLnB1c2godGFzayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRyYWluZWQoY29tcGxldGVkVGFza3MpO1xuICAgICAgICB9IC8vIGtlZXAgZ29pbmcsIGluIGNhc2UgbmV3IHRhc2tzIHdlcmUgYWRkZWQgaW4gdGhlIGRyYWluZWQgaGFuZGxlclxuICAgIH1cbiAgICBydW5UYXNrKHRhc2spIHtcbiAgICAgICAgaWYgKHRoaXMucnVuVGFza09wdGlvbikge1xuICAgICAgICAgICAgdGhpcy5ydW5UYXNrT3B0aW9uKHRhc2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRyYWluZWQoY29tcGxldGVkVGFza3MpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhaW5lZE9wdGlvbikge1xuICAgICAgICAgICAgdGhpcy5kcmFpbmVkT3B0aW9uKGNvbXBsZXRlZFRhc2tzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gQ29tcHV0ZXMgd2hhdCB0aGUgdGl0bGUgYXQgdGhlIHRvcCBvZiB0aGUgY2FsZW5kYXJBcGkgc2hvdWxkIGJlIGZvciB0aGlzIHZpZXdcbmZ1bmN0aW9uIGJ1aWxkVGl0bGUoZGF0ZVByb2ZpbGUsIHZpZXdPcHRpb25zLCBkYXRlRW52KSB7XG4gICAgbGV0IHJhbmdlO1xuICAgIC8vIGZvciB2aWV3cyB0aGF0IHNwYW4gYSBsYXJnZSB1bml0IG9mIHRpbWUsIHNob3cgdGhlIHByb3BlciBpbnRlcnZhbCwgaWdub3Jpbmcgc3RyYXkgZGF5cyBiZWZvcmUgYW5kIGFmdGVyXG4gICAgaWYgKC9eKHllYXJ8bW9udGgpJC8udGVzdChkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0KSkge1xuICAgICAgICByYW5nZSA9IGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZTtcbiAgICB9XG4gICAgZWxzZSB7IC8vIGZvciBkYXkgdW5pdHMgb3Igc21hbGxlciwgdXNlIHRoZSBhY3R1YWwgZGF5IHJhbmdlXG4gICAgICAgIHJhbmdlID0gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2U7XG4gICAgfVxuICAgIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQsIGNyZWF0ZUZvcm1hdHRlcih2aWV3T3B0aW9ucy50aXRsZUZvcm1hdCB8fCBidWlsZFRpdGxlRm9ybWF0KGRhdGVQcm9maWxlKSksIHtcbiAgICAgICAgaXNFbmRFeGNsdXNpdmU6IGRhdGVQcm9maWxlLmlzUmFuZ2VBbGxEYXksXG4gICAgICAgIGRlZmF1bHRTZXBhcmF0b3I6IHZpZXdPcHRpb25zLnRpdGxlUmFuZ2VTZXBhcmF0b3IsXG4gICAgfSk7XG59XG4vLyBHZW5lcmF0ZXMgdGhlIGZvcm1hdCBzdHJpbmcgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBnZW5lcmF0ZSB0aGUgdGl0bGUgZm9yIHRoZSBjdXJyZW50IGRhdGUgcmFuZ2UuXG4vLyBBdHRlbXB0cyB0byBjb21wdXRlIHRoZSBtb3N0IGFwcHJvcHJpYXRlIGZvcm1hdCBpZiBub3QgZXhwbGljaXRseSBzcGVjaWZpZWQgd2l0aCBgdGl0bGVGb3JtYXRgLlxuZnVuY3Rpb24gYnVpbGRUaXRsZUZvcm1hdChkYXRlUHJvZmlsZSkge1xuICAgIGxldCB7IGN1cnJlbnRSYW5nZVVuaXQgfSA9IGRhdGVQcm9maWxlO1xuICAgIGlmIChjdXJyZW50UmFuZ2VVbml0ID09PSAneWVhcicpIHtcbiAgICAgICAgcmV0dXJuIHsgeWVhcjogJ251bWVyaWMnIH07XG4gICAgfVxuICAgIGlmIChjdXJyZW50UmFuZ2VVbml0ID09PSAnbW9udGgnKSB7XG4gICAgICAgIHJldHVybiB7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdsb25nJyB9OyAvLyBsaWtlIFwiU2VwdGVtYmVyIDIwMTRcIlxuICAgIH1cbiAgICBsZXQgZGF5cyA9IGRpZmZXaG9sZURheXMoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLnN0YXJ0LCBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UuZW5kKTtcbiAgICBpZiAoZGF5cyAhPT0gbnVsbCAmJiBkYXlzID4gMSkge1xuICAgICAgICAvLyBtdWx0aS1kYXkgcmFuZ2UuIHNob3J0ZXIsIGxpa2UgXCJTZXAgOSAtIDEwIDIwMTRcIlxuICAgICAgICByZXR1cm4geyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnc2hvcnQnLCBkYXk6ICdudW1lcmljJyB9O1xuICAgIH1cbiAgICAvLyBvbmUgZGF5LiBsb25nZXIsIGxpa2UgXCJTZXB0ZW1iZXIgOSAyMDE0XCJcbiAgICByZXR1cm4geyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbG9uZycsIGRheTogJ251bWVyaWMnIH07XG59XG5cbi8vIGluIGZ1dHVyZSByZWZhY3RvciwgZG8gdGhlIHJlZHV4LXN0eWxlIGZ1bmN0aW9uKHN0YXRlPWluaXRpYWwpIGZvciBpbml0aWFsLXN0YXRlXG4vLyBhbHNvLCB3aGF0ZXZlciBpcyBoYXBwZW5pbmcgaW4gY29uc3RydWN0b3IsIGhhdmUgaXQgaGFwcGVuIGluIGFjdGlvbiBxdWV1ZSB0b29cbmNsYXNzIENhbGVuZGFyRGF0YU1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHRoaXMuY29tcHV0ZUN1cnJlbnRWaWV3RGF0YSA9IG1lbW9pemUodGhpcy5fY29tcHV0ZUN1cnJlbnRWaWV3RGF0YSk7XG4gICAgICAgIHRoaXMub3JnYW5pemVSYXdMb2NhbGVzID0gbWVtb2l6ZShvcmdhbml6ZVJhd0xvY2FsZXMpO1xuICAgICAgICB0aGlzLmJ1aWxkTG9jYWxlID0gbWVtb2l6ZShidWlsZExvY2FsZSk7XG4gICAgICAgIHRoaXMuYnVpbGRQbHVnaW5Ib29rcyA9IGJ1aWxkQnVpbGRQbHVnaW5Ib29rcygpO1xuICAgICAgICB0aGlzLmJ1aWxkRGF0ZUVudiA9IG1lbW9pemUoYnVpbGREYXRlRW52JDEpO1xuICAgICAgICB0aGlzLmJ1aWxkVGhlbWUgPSBtZW1vaXplKGJ1aWxkVGhlbWUpO1xuICAgICAgICB0aGlzLnBhcnNlVG9vbGJhcnMgPSBtZW1vaXplKHBhcnNlVG9vbGJhcnMpO1xuICAgICAgICB0aGlzLmJ1aWxkVmlld1NwZWNzID0gbWVtb2l6ZShidWlsZFZpZXdTcGVjcyk7XG4gICAgICAgIHRoaXMuYnVpbGREYXRlUHJvZmlsZUdlbmVyYXRvciA9IG1lbW9pemVPYmpBcmcoYnVpbGREYXRlUHJvZmlsZUdlbmVyYXRvcik7XG4gICAgICAgIHRoaXMuYnVpbGRWaWV3QXBpID0gbWVtb2l6ZShidWlsZFZpZXdBcGkpO1xuICAgICAgICB0aGlzLmJ1aWxkVmlld1VpUHJvcHMgPSBtZW1vaXplT2JqQXJnKGJ1aWxkVmlld1VpUHJvcHMpO1xuICAgICAgICB0aGlzLmJ1aWxkRXZlbnRVaUJ5U291cmNlID0gbWVtb2l6ZShidWlsZEV2ZW50VWlCeVNvdXJjZSwgaXNQcm9wc0VxdWFsKTtcbiAgICAgICAgdGhpcy5idWlsZEV2ZW50VWlCYXNlcyA9IG1lbW9pemUoYnVpbGRFdmVudFVpQmFzZXMpO1xuICAgICAgICB0aGlzLnBhcnNlQ29udGV4dEJ1c2luZXNzSG91cnMgPSBtZW1vaXplT2JqQXJnKHBhcnNlQ29udGV4dEJ1c2luZXNzSG91cnMpO1xuICAgICAgICB0aGlzLmJ1aWxkVGl0bGUgPSBtZW1vaXplKGJ1aWxkVGl0bGUpO1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuICAgICAgICB0aGlzLmFjdGlvblJ1bm5lciA9IG5ldyBUYXNrUnVubmVyKHRoaXMuX2hhbmRsZUFjdGlvbi5iaW5kKHRoaXMpLCB0aGlzLnVwZGF0ZURhdGEuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0ID0ge307XG4gICAgICAgIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWQgPSB7fTtcbiAgICAgICAgdGhpcy5jdXJyZW50Vmlld09wdGlvbnNJbnB1dCA9IHt9O1xuICAgICAgICB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc1JlZmluZWQgPSB7fTtcbiAgICAgICAgdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lcnMgPSB7fTtcbiAgICAgICAgdGhpcy5vcHRpb25zRm9yUmVmaW5pbmcgPSBbXTtcbiAgICAgICAgdGhpcy5vcHRpb25zRm9ySGFuZGxpbmcgPSBbXTtcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50RGF0YSA9ICgpID0+IHRoaXMuZGF0YTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCA9IChhY3Rpb24pID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUnVubmVyLnJlcXVlc3QoYWN0aW9uKTsgLy8gcHJvdGVjdHMgYWdhaW5zdCByZWN1cnNpdmUgY2FsbHMgdG8gX2hhbmRsZUFjdGlvblxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuYWN0aW9uUnVubmVyLnBhdXNlKCk7XG4gICAgICAgIGxldCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzID0ge307XG4gICAgICAgIGxldCBvcHRpb25zRGF0YSA9IHRoaXMuY29tcHV0ZU9wdGlvbnNEYXRhKHByb3BzLm9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcywgcHJvcHMuY2FsZW5kYXJBcGkpO1xuICAgICAgICBsZXQgY3VycmVudFZpZXdUeXBlID0gb3B0aW9uc0RhdGEuY2FsZW5kYXJPcHRpb25zLmluaXRpYWxWaWV3IHx8IG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLmluaXRpYWxWaWV3O1xuICAgICAgICBsZXQgY3VycmVudFZpZXdEYXRhID0gdGhpcy5jb21wdXRlQ3VycmVudFZpZXdEYXRhKGN1cnJlbnRWaWV3VHlwZSwgb3B0aW9uc0RhdGEsIHByb3BzLm9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcyk7XG4gICAgICAgIC8vIHdpcmUgdGhpbmdzIHVwXG4gICAgICAgIC8vIFRPRE86IG5vdCBEUllcbiAgICAgICAgcHJvcHMuY2FsZW5kYXJBcGkuY3VycmVudERhdGFNYW5hZ2VyID0gdGhpcztcbiAgICAgICAgdGhpcy5lbWl0dGVyLnNldFRoaXNDb250ZXh0KHByb3BzLmNhbGVuZGFyQXBpKTtcbiAgICAgICAgdGhpcy5lbWl0dGVyLnNldE9wdGlvbnMoY3VycmVudFZpZXdEYXRhLm9wdGlvbnMpO1xuICAgICAgICBsZXQgY3VycmVudERhdGUgPSBnZXRJbml0aWFsRGF0ZShvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMsIG9wdGlvbnNEYXRhLmRhdGVFbnYpO1xuICAgICAgICBsZXQgZGF0ZVByb2ZpbGUgPSBjdXJyZW50Vmlld0RhdGEuZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGQoY3VycmVudERhdGUpO1xuICAgICAgICBpZiAoIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGN1cnJlbnREYXRlKSkge1xuICAgICAgICAgICAgY3VycmVudERhdGUgPSBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2Uuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNhbGVuZGFyQ29udGV4dCA9IHtcbiAgICAgICAgICAgIGRhdGVFbnY6IG9wdGlvbnNEYXRhLmRhdGVFbnYsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMsXG4gICAgICAgICAgICBwbHVnaW5Ib29rczogb3B0aW9uc0RhdGEucGx1Z2luSG9va3MsXG4gICAgICAgICAgICBjYWxlbmRhckFwaTogcHJvcHMuY2FsZW5kYXJBcGksXG4gICAgICAgICAgICBkaXNwYXRjaDogdGhpcy5kaXNwYXRjaCxcbiAgICAgICAgICAgIGVtaXR0ZXI6IHRoaXMuZW1pdHRlcixcbiAgICAgICAgICAgIGdldEN1cnJlbnREYXRhOiB0aGlzLmdldEN1cnJlbnREYXRhLFxuICAgICAgICB9O1xuICAgICAgICAvLyBuZWVkcyB0byBiZSBhZnRlciBzZXRUaGlzQ29udGV4dFxuICAgICAgICBmb3IgKGxldCBjYWxsYmFjayBvZiBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcy5jb250ZXh0SW5pdCkge1xuICAgICAgICAgICAgY2FsbGJhY2soY2FsZW5kYXJDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOT1QgRFJZXG4gICAgICAgIGxldCBldmVudFNvdXJjZXMgPSBpbml0RXZlbnRTb3VyY2VzKG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucywgZGF0ZVByb2ZpbGUsIGNhbGVuZGFyQ29udGV4dCk7XG4gICAgICAgIGxldCBpbml0aWFsU3RhdGUgPSB7XG4gICAgICAgICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICAgICAgY3VycmVudFZpZXdUeXBlLFxuICAgICAgICAgICAgY3VycmVudERhdGUsXG4gICAgICAgICAgICBkYXRlUHJvZmlsZSxcbiAgICAgICAgICAgIGJ1c2luZXNzSG91cnM6IHRoaXMucGFyc2VDb250ZXh0QnVzaW5lc3NIb3VycyhjYWxlbmRhckNvbnRleHQpLFxuICAgICAgICAgICAgZXZlbnRTb3VyY2VzLFxuICAgICAgICAgICAgZXZlbnRVaUJhc2VzOiB7fSxcbiAgICAgICAgICAgIGV2ZW50U3RvcmU6IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpLFxuICAgICAgICAgICAgcmVuZGVyYWJsZUV2ZW50U3RvcmU6IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpLFxuICAgICAgICAgICAgZGF0ZVNlbGVjdGlvbjogbnVsbCxcbiAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uOiAnJyxcbiAgICAgICAgICAgIGV2ZW50RHJhZzogbnVsbCxcbiAgICAgICAgICAgIGV2ZW50UmVzaXplOiBudWxsLFxuICAgICAgICAgICAgc2VsZWN0aW9uQ29uZmlnOiB0aGlzLmJ1aWxkVmlld1VpUHJvcHMoY2FsZW5kYXJDb250ZXh0KS5zZWxlY3Rpb25Db25maWcsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBjb250ZXh0QW5kU3RhdGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNhbGVuZGFyQ29udGV4dCksIGluaXRpYWxTdGF0ZSk7XG4gICAgICAgIGZvciAobGV0IHJlZHVjZXIgb2Ygb3B0aW9uc0RhdGEucGx1Z2luSG9va3MucmVkdWNlcnMpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaW5pdGlhbFN0YXRlLCByZWR1Y2VyKG51bGwsIG51bGwsIGNvbnRleHRBbmRTdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wdXRlSXNMb2FkaW5nKGluaXRpYWxTdGF0ZSwgY2FsZW5kYXJDb250ZXh0KSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2xvYWRpbmcnLCB0cnVlKTsgLy8gTk9UIERSWVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgICAgIHRoaXMudXBkYXRlRGF0YSgpO1xuICAgICAgICB0aGlzLmFjdGlvblJ1bm5lci5yZXN1bWUoKTtcbiAgICB9XG4gICAgcmVzZXRPcHRpb25zKG9wdGlvbk92ZXJyaWRlcywgY2hhbmdlZE9wdGlvbk5hbWVzKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoY2hhbmdlZE9wdGlvbk5hbWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHByb3BzLm9wdGlvbk92ZXJyaWRlcyA9IG9wdGlvbk92ZXJyaWRlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByb3BzLm9wdGlvbk92ZXJyaWRlcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHByb3BzLm9wdGlvbk92ZXJyaWRlcyB8fCB7fSkpLCBvcHRpb25PdmVycmlkZXMpO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zRm9yUmVmaW5pbmcucHVzaCguLi5jaGFuZ2VkT3B0aW9uTmFtZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VkT3B0aW9uTmFtZXMgPT09IHVuZGVmaW5lZCB8fCBjaGFuZ2VkT3B0aW9uTmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGlvblJ1bm5lci5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnTk9USElORycsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaGFuZGxlQWN0aW9uKGFjdGlvbikge1xuICAgICAgICBsZXQgeyBwcm9wcywgc3RhdGUsIGVtaXR0ZXIgfSA9IHRoaXM7XG4gICAgICAgIGxldCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzID0gcmVkdWNlRHluYW1pY09wdGlvbk92ZXJyaWRlcyhzdGF0ZS5keW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBhY3Rpb24pO1xuICAgICAgICBsZXQgb3B0aW9uc0RhdGEgPSB0aGlzLmNvbXB1dGVPcHRpb25zRGF0YShwcm9wcy5vcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIHByb3BzLmNhbGVuZGFyQXBpKTtcbiAgICAgICAgbGV0IGN1cnJlbnRWaWV3VHlwZSA9IHJlZHVjZVZpZXdUeXBlKHN0YXRlLmN1cnJlbnRWaWV3VHlwZSwgYWN0aW9uKTtcbiAgICAgICAgbGV0IGN1cnJlbnRWaWV3RGF0YSA9IHRoaXMuY29tcHV0ZUN1cnJlbnRWaWV3RGF0YShjdXJyZW50Vmlld1R5cGUsIG9wdGlvbnNEYXRhLCBwcm9wcy5vcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpO1xuICAgICAgICAvLyB3aXJlIHRoaW5ncyB1cFxuICAgICAgICAvLyBUT0RPOiBub3QgRFJZXG4gICAgICAgIHByb3BzLmNhbGVuZGFyQXBpLmN1cnJlbnREYXRhTWFuYWdlciA9IHRoaXM7XG4gICAgICAgIGVtaXR0ZXIuc2V0VGhpc0NvbnRleHQocHJvcHMuY2FsZW5kYXJBcGkpO1xuICAgICAgICBlbWl0dGVyLnNldE9wdGlvbnMoY3VycmVudFZpZXdEYXRhLm9wdGlvbnMpO1xuICAgICAgICBsZXQgY2FsZW5kYXJDb250ZXh0ID0ge1xuICAgICAgICAgICAgZGF0ZUVudjogb3B0aW9uc0RhdGEuZGF0ZUVudixcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucyxcbiAgICAgICAgICAgIHBsdWdpbkhvb2tzOiBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcyxcbiAgICAgICAgICAgIGNhbGVuZGFyQXBpOiBwcm9wcy5jYWxlbmRhckFwaSxcbiAgICAgICAgICAgIGRpc3BhdGNoOiB0aGlzLmRpc3BhdGNoLFxuICAgICAgICAgICAgZW1pdHRlcixcbiAgICAgICAgICAgIGdldEN1cnJlbnREYXRhOiB0aGlzLmdldEN1cnJlbnREYXRhLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgeyBjdXJyZW50RGF0ZSwgZGF0ZVByb2ZpbGUgfSA9IHN0YXRlO1xuICAgICAgICBpZiAodGhpcy5kYXRhICYmIHRoaXMuZGF0YS5kYXRlUHJvZmlsZUdlbmVyYXRvciAhPT0gY3VycmVudFZpZXdEYXRhLmRhdGVQcm9maWxlR2VuZXJhdG9yKSB7IC8vIGhhY2tcbiAgICAgICAgICAgIGRhdGVQcm9maWxlID0gY3VycmVudFZpZXdEYXRhLmRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkKGN1cnJlbnREYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50RGF0ZSA9IHJlZHVjZUN1cnJlbnREYXRlKGN1cnJlbnREYXRlLCBhY3Rpb24pO1xuICAgICAgICBkYXRlUHJvZmlsZSA9IHJlZHVjZURhdGVQcm9maWxlKGRhdGVQcm9maWxlLCBhY3Rpb24sIGN1cnJlbnREYXRlLCBjdXJyZW50Vmlld0RhdGEuZGF0ZVByb2ZpbGVHZW5lcmF0b3IpO1xuICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT09ICdQUkVWJyB8fCAvLyBUT0RPOiBtb3ZlIHRoaXMgbG9naWMgaW50byBEYXRlUHJvZmlsZUdlbmVyYXRvclxuICAgICAgICAgICAgYWN0aW9uLnR5cGUgPT09ICdORVhUJyB8fCAvLyBcIlxuICAgICAgICAgICAgIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLCBjdXJyZW50RGF0ZSkpIHtcbiAgICAgICAgICAgIGN1cnJlbnREYXRlID0gZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGxldCBldmVudFNvdXJjZXMgPSByZWR1Y2VFdmVudFNvdXJjZXMoc3RhdGUuZXZlbnRTb3VyY2VzLCBhY3Rpb24sIGRhdGVQcm9maWxlLCBjYWxlbmRhckNvbnRleHQpO1xuICAgICAgICBsZXQgZXZlbnRTdG9yZSA9IHJlZHVjZUV2ZW50U3RvcmUoc3RhdGUuZXZlbnRTdG9yZSwgYWN0aW9uLCBldmVudFNvdXJjZXMsIGRhdGVQcm9maWxlLCBjYWxlbmRhckNvbnRleHQpO1xuICAgICAgICBsZXQgaXNFdmVudHNMb2FkaW5nID0gY29tcHV0ZUV2ZW50U291cmNlc0xvYWRpbmcoZXZlbnRTb3VyY2VzKTsgLy8gQkFELiBhbHNvIGNhbGxlZCBpbiB0aGlzIGZ1bmMgaW4gY29tcHV0ZUlzTG9hZGluZ1xuICAgICAgICBsZXQgcmVuZGVyYWJsZUV2ZW50U3RvcmUgPSAoaXNFdmVudHNMb2FkaW5nICYmICFjdXJyZW50Vmlld0RhdGEub3B0aW9ucy5wcm9ncmVzc2l2ZUV2ZW50UmVuZGVyaW5nKSA/XG4gICAgICAgICAgICAoc3RhdGUucmVuZGVyYWJsZUV2ZW50U3RvcmUgfHwgZXZlbnRTdG9yZSkgOiAvLyB0cnkgZnJvbSBwcmV2aW91cyBzdGF0ZVxuICAgICAgICAgICAgZXZlbnRTdG9yZTtcbiAgICAgICAgbGV0IHsgZXZlbnRVaVNpbmdsZUJhc2UsIHNlbGVjdGlvbkNvbmZpZyB9ID0gdGhpcy5idWlsZFZpZXdVaVByb3BzKGNhbGVuZGFyQ29udGV4dCk7IC8vIHdpbGwgbWVtb2l6ZSBvYmpcbiAgICAgICAgbGV0IGV2ZW50VWlCeVNvdXJjZSA9IHRoaXMuYnVpbGRFdmVudFVpQnlTb3VyY2UoZXZlbnRTb3VyY2VzKTtcbiAgICAgICAgbGV0IGV2ZW50VWlCYXNlcyA9IHRoaXMuYnVpbGRFdmVudFVpQmFzZXMocmVuZGVyYWJsZUV2ZW50U3RvcmUuZGVmcywgZXZlbnRVaVNpbmdsZUJhc2UsIGV2ZW50VWlCeVNvdXJjZSk7XG4gICAgICAgIGxldCBuZXdTdGF0ZSA9IHtcbiAgICAgICAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsXG4gICAgICAgICAgICBjdXJyZW50Vmlld1R5cGUsXG4gICAgICAgICAgICBjdXJyZW50RGF0ZSxcbiAgICAgICAgICAgIGRhdGVQcm9maWxlLFxuICAgICAgICAgICAgZXZlbnRTb3VyY2VzLFxuICAgICAgICAgICAgZXZlbnRTdG9yZSxcbiAgICAgICAgICAgIHJlbmRlcmFibGVFdmVudFN0b3JlLFxuICAgICAgICAgICAgc2VsZWN0aW9uQ29uZmlnLFxuICAgICAgICAgICAgZXZlbnRVaUJhc2VzLFxuICAgICAgICAgICAgYnVzaW5lc3NIb3VyczogdGhpcy5wYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzKGNhbGVuZGFyQ29udGV4dCksXG4gICAgICAgICAgICBkYXRlU2VsZWN0aW9uOiByZWR1Y2VEYXRlU2VsZWN0aW9uKHN0YXRlLmRhdGVTZWxlY3Rpb24sIGFjdGlvbiksXG4gICAgICAgICAgICBldmVudFNlbGVjdGlvbjogcmVkdWNlU2VsZWN0ZWRFdmVudChzdGF0ZS5ldmVudFNlbGVjdGlvbiwgYWN0aW9uKSxcbiAgICAgICAgICAgIGV2ZW50RHJhZzogcmVkdWNlRXZlbnREcmFnKHN0YXRlLmV2ZW50RHJhZywgYWN0aW9uKSxcbiAgICAgICAgICAgIGV2ZW50UmVzaXplOiByZWR1Y2VFdmVudFJlc2l6ZShzdGF0ZS5ldmVudFJlc2l6ZSwgYWN0aW9uKSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGNvbnRleHRBbmRTdGF0ZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY2FsZW5kYXJDb250ZXh0KSwgbmV3U3RhdGUpO1xuICAgICAgICBmb3IgKGxldCByZWR1Y2VyIG9mIG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLnJlZHVjZXJzKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG5ld1N0YXRlLCByZWR1Y2VyKHN0YXRlLCBhY3Rpb24sIGNvbnRleHRBbmRTdGF0ZSkpOyAvLyBnaXZlIHRoZSBPTEQgc3RhdGUsIGZvciBvbGQgdmFsdWVcbiAgICAgICAgfVxuICAgICAgICBsZXQgd2FzTG9hZGluZyA9IGNvbXB1dGVJc0xvYWRpbmcoc3RhdGUsIGNhbGVuZGFyQ29udGV4dCk7XG4gICAgICAgIGxldCBpc0xvYWRpbmcgPSBjb21wdXRlSXNMb2FkaW5nKG5ld1N0YXRlLCBjYWxlbmRhckNvbnRleHQpO1xuICAgICAgICAvLyBUT0RPOiB1c2UgcHJvcFNldEhhbmRsZXJzIGluIHBsdWdpbiBzeXN0ZW1cbiAgICAgICAgaWYgKCF3YXNMb2FkaW5nICYmIGlzTG9hZGluZykge1xuICAgICAgICAgICAgZW1pdHRlci50cmlnZ2VyKCdsb2FkaW5nJywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAod2FzTG9hZGluZyAmJiAhaXNMb2FkaW5nKSB7XG4gICAgICAgICAgICBlbWl0dGVyLnRyaWdnZXIoJ2xvYWRpbmcnLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICBpZiAocHJvcHMub25BY3Rpb24pIHtcbiAgICAgICAgICAgIHByb3BzLm9uQWN0aW9uKGFjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlRGF0YSgpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgb2xkRGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgbGV0IG9wdGlvbnNEYXRhID0gdGhpcy5jb21wdXRlT3B0aW9uc0RhdGEocHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBzdGF0ZS5keW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBwcm9wcy5jYWxlbmRhckFwaSk7XG4gICAgICAgIGxldCBjdXJyZW50Vmlld0RhdGEgPSB0aGlzLmNvbXB1dGVDdXJyZW50Vmlld0RhdGEoc3RhdGUuY3VycmVudFZpZXdUeXBlLCBvcHRpb25zRGF0YSwgcHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBzdGF0ZS5keW5hbWljT3B0aW9uT3ZlcnJpZGVzKTtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmRhdGEgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IHZpZXdUaXRsZTogdGhpcy5idWlsZFRpdGxlKHN0YXRlLmRhdGVQcm9maWxlLCBjdXJyZW50Vmlld0RhdGEub3B0aW9ucywgb3B0aW9uc0RhdGEuZGF0ZUVudiksIGNhbGVuZGFyQXBpOiBwcm9wcy5jYWxlbmRhckFwaSwgZGlzcGF0Y2g6IHRoaXMuZGlzcGF0Y2gsIGVtaXR0ZXI6IHRoaXMuZW1pdHRlciwgZ2V0Q3VycmVudERhdGE6IHRoaXMuZ2V0Q3VycmVudERhdGEgfSwgb3B0aW9uc0RhdGEpLCBjdXJyZW50Vmlld0RhdGEpLCBzdGF0ZSk7XG4gICAgICAgIGxldCBjaGFuZ2VIYW5kbGVycyA9IG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLm9wdGlvbkNoYW5nZUhhbmRsZXJzO1xuICAgICAgICBsZXQgb2xkQ2FsZW5kYXJPcHRpb25zID0gb2xkRGF0YSAmJiBvbGREYXRhLmNhbGVuZGFyT3B0aW9ucztcbiAgICAgICAgbGV0IG5ld0NhbGVuZGFyT3B0aW9ucyA9IG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucztcbiAgICAgICAgaWYgKG9sZENhbGVuZGFyT3B0aW9ucyAmJiBvbGRDYWxlbmRhck9wdGlvbnMgIT09IG5ld0NhbGVuZGFyT3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9sZENhbGVuZGFyT3B0aW9ucy50aW1lWm9uZSAhPT0gbmV3Q2FsZW5kYXJPcHRpb25zLnRpbWVab25lKSB7XG4gICAgICAgICAgICAgICAgLy8gaGFja1xuICAgICAgICAgICAgICAgIHN0YXRlLmV2ZW50U291cmNlcyA9IGRhdGEuZXZlbnRTb3VyY2VzID0gcmVkdWNlRXZlbnRTb3VyY2VzTmV3VGltZVpvbmUoZGF0YS5ldmVudFNvdXJjZXMsIHN0YXRlLmRhdGVQcm9maWxlLCBkYXRhKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5ldmVudFN0b3JlID0gZGF0YS5ldmVudFN0b3JlID0gcmV6b25lRXZlbnRTdG9yZURhdGVzKGRhdGEuZXZlbnRTdG9yZSwgb2xkRGF0YS5kYXRlRW52LCBkYXRhLmRhdGVFbnYpO1xuICAgICAgICAgICAgICAgIHN0YXRlLnJlbmRlcmFibGVFdmVudFN0b3JlID0gZGF0YS5yZW5kZXJhYmxlRXZlbnRTdG9yZSA9IHJlem9uZUV2ZW50U3RvcmVEYXRlcyhkYXRhLnJlbmRlcmFibGVFdmVudFN0b3JlLCBvbGREYXRhLmRhdGVFbnYsIGRhdGEuZGF0ZUVudik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBvcHRpb25OYW1lIGluIGNoYW5nZUhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc0ZvckhhbmRsaW5nLmluZGV4T2Yob3B0aW9uTmFtZSkgIT09IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgIG9sZENhbGVuZGFyT3B0aW9uc1tvcHRpb25OYW1lXSAhPT0gbmV3Q2FsZW5kYXJPcHRpb25zW29wdGlvbk5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUhhbmRsZXJzW29wdGlvbk5hbWVdKG5ld0NhbGVuZGFyT3B0aW9uc1tvcHRpb25OYW1lXSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc0ZvckhhbmRsaW5nID0gW107XG4gICAgICAgIGlmIChwcm9wcy5vbkRhdGEpIHtcbiAgICAgICAgICAgIHByb3BzLm9uRGF0YShkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wdXRlT3B0aW9uc0RhdGEob3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBjYWxlbmRhckFwaSkge1xuICAgICAgICAvLyBUT0RPOiBibGFja2xpc3Qgb3B0aW9ucyB0aGF0IGFyZSBoYW5kbGVkIGJ5IG9wdGlvbkNoYW5nZUhhbmRsZXJzXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zRm9yUmVmaW5pbmcubGVuZ3RoICYmXG4gICAgICAgICAgICBvcHRpb25PdmVycmlkZXMgPT09IHRoaXMuc3RhYmxlT3B0aW9uT3ZlcnJpZGVzICYmXG4gICAgICAgICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzID09PSB0aGlzLnN0YWJsZUR5bmFtaWNPcHRpb25PdmVycmlkZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWJsZUNhbGVuZGFyT3B0aW9uc0RhdGE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgcmVmaW5lZE9wdGlvbnMsIHBsdWdpbkhvb2tzLCBsb2NhbGVEZWZhdWx0cywgYXZhaWxhYmxlTG9jYWxlRGF0YSwgZXh0cmEsIH0gPSB0aGlzLnByb2Nlc3NSYXdDYWxlbmRhck9wdGlvbnMob3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKTtcbiAgICAgICAgd2FyblVua25vd25PcHRpb25zKGV4dHJhKTtcbiAgICAgICAgbGV0IGRhdGVFbnYgPSB0aGlzLmJ1aWxkRGF0ZUVudihyZWZpbmVkT3B0aW9ucy50aW1lWm9uZSwgcmVmaW5lZE9wdGlvbnMubG9jYWxlLCByZWZpbmVkT3B0aW9ucy53ZWVrTnVtYmVyQ2FsY3VsYXRpb24sIHJlZmluZWRPcHRpb25zLmZpcnN0RGF5LCByZWZpbmVkT3B0aW9ucy53ZWVrVGV4dCwgcGx1Z2luSG9va3MsIGF2YWlsYWJsZUxvY2FsZURhdGEsIHJlZmluZWRPcHRpb25zLmRlZmF1bHRSYW5nZVNlcGFyYXRvcik7XG4gICAgICAgIGxldCB2aWV3U3BlY3MgPSB0aGlzLmJ1aWxkVmlld1NwZWNzKHBsdWdpbkhvb2tzLnZpZXdzLCB0aGlzLnN0YWJsZU9wdGlvbk92ZXJyaWRlcywgdGhpcy5zdGFibGVEeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBsb2NhbGVEZWZhdWx0cyk7XG4gICAgICAgIGxldCB0aGVtZSA9IHRoaXMuYnVpbGRUaGVtZShyZWZpbmVkT3B0aW9ucywgcGx1Z2luSG9va3MpO1xuICAgICAgICBsZXQgdG9vbGJhckNvbmZpZyA9IHRoaXMucGFyc2VUb29sYmFycyhyZWZpbmVkT3B0aW9ucywgdGhpcy5zdGFibGVPcHRpb25PdmVycmlkZXMsIHRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhYmxlQ2FsZW5kYXJPcHRpb25zRGF0YSA9IHtcbiAgICAgICAgICAgIGNhbGVuZGFyT3B0aW9uczogcmVmaW5lZE9wdGlvbnMsXG4gICAgICAgICAgICBwbHVnaW5Ib29rcyxcbiAgICAgICAgICAgIGRhdGVFbnYsXG4gICAgICAgICAgICB2aWV3U3BlY3MsXG4gICAgICAgICAgICB0aGVtZSxcbiAgICAgICAgICAgIHRvb2xiYXJDb25maWcsXG4gICAgICAgICAgICBsb2NhbGVEZWZhdWx0cyxcbiAgICAgICAgICAgIGF2YWlsYWJsZVJhd0xvY2FsZXM6IGF2YWlsYWJsZUxvY2FsZURhdGEubWFwLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBhbHdheXMgY2FsbGVkIGZyb20gYmVoaW5kIGEgbWVtb2l6ZXJcbiAgICBwcm9jZXNzUmF3Q2FsZW5kYXJPcHRpb25zKG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcykge1xuICAgICAgICBsZXQgeyBsb2NhbGVzLCBsb2NhbGUgfSA9IG1lcmdlUmF3T3B0aW9ucyhbXG4gICAgICAgICAgICBCQVNFX09QVElPTl9ERUZBVUxUUyxcbiAgICAgICAgICAgIG9wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsXG4gICAgICAgIF0pO1xuICAgICAgICBsZXQgYXZhaWxhYmxlTG9jYWxlRGF0YSA9IHRoaXMub3JnYW5pemVSYXdMb2NhbGVzKGxvY2FsZXMpO1xuICAgICAgICBsZXQgYXZhaWxhYmxlUmF3TG9jYWxlcyA9IGF2YWlsYWJsZUxvY2FsZURhdGEubWFwO1xuICAgICAgICBsZXQgbG9jYWxlRGVmYXVsdHMgPSB0aGlzLmJ1aWxkTG9jYWxlKGxvY2FsZSB8fCBhdmFpbGFibGVMb2NhbGVEYXRhLmRlZmF1bHRDb2RlLCBhdmFpbGFibGVSYXdMb2NhbGVzKS5vcHRpb25zO1xuICAgICAgICBsZXQgcGx1Z2luSG9va3MgPSB0aGlzLmJ1aWxkUGx1Z2luSG9va3Mob3B0aW9uT3ZlcnJpZGVzLnBsdWdpbnMgfHwgW10sIGdsb2JhbFBsdWdpbnMpO1xuICAgICAgICBsZXQgcmVmaW5lcnMgPSB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgQkFTRV9PUFRJT05fUkVGSU5FUlMpLCBDQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUyksIENBTEVOREFSX09QVElPTl9SRUZJTkVSUyksIHBsdWdpbkhvb2tzLmxpc3RlbmVyUmVmaW5lcnMpLCBwbHVnaW5Ib29rcy5vcHRpb25SZWZpbmVycyk7XG4gICAgICAgIGxldCBleHRyYSA9IHt9O1xuICAgICAgICBsZXQgcmF3ID0gbWVyZ2VSYXdPcHRpb25zKFtcbiAgICAgICAgICAgIEJBU0VfT1BUSU9OX0RFRkFVTFRTLFxuICAgICAgICAgICAgbG9jYWxlRGVmYXVsdHMsXG4gICAgICAgICAgICBvcHRpb25PdmVycmlkZXMsXG4gICAgICAgICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICBdKTtcbiAgICAgICAgbGV0IHJlZmluZWQgPSB7fTtcbiAgICAgICAgbGV0IGN1cnJlbnRSYXcgPSB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dDtcbiAgICAgICAgbGV0IGN1cnJlbnRSZWZpbmVkID0gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZDtcbiAgICAgICAgbGV0IGFueUNoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgb3B0aW9uTmFtZSBpbiByYXcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNGb3JSZWZpbmluZy5pbmRleE9mKG9wdGlvbk5hbWUpID09PSAtMSAmJiAocmF3W29wdGlvbk5hbWVdID09PSBjdXJyZW50UmF3W29wdGlvbk5hbWVdIHx8IChDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXSAmJlxuICAgICAgICAgICAgICAgIChvcHRpb25OYW1lIGluIGN1cnJlbnRSYXcpICYmXG4gICAgICAgICAgICAgICAgQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlNbb3B0aW9uTmFtZV0oY3VycmVudFJhd1tvcHRpb25OYW1lXSwgcmF3W29wdGlvbk5hbWVdKSkpKSB7XG4gICAgICAgICAgICAgICAgcmVmaW5lZFtvcHRpb25OYW1lXSA9IGN1cnJlbnRSZWZpbmVkW29wdGlvbk5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVmaW5lcnNbb3B0aW9uTmFtZV0pIHtcbiAgICAgICAgICAgICAgICByZWZpbmVkW29wdGlvbk5hbWVdID0gcmVmaW5lcnNbb3B0aW9uTmFtZV0ocmF3W29wdGlvbk5hbWVdKTtcbiAgICAgICAgICAgICAgICBhbnlDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4dHJhW29wdGlvbk5hbWVdID0gY3VycmVudFJhd1tvcHRpb25OYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYW55Q2hhbmdlcykge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXQgPSByYXc7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkID0gcmVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc3RhYmxlT3B0aW9uT3ZlcnJpZGVzID0gb3B0aW9uT3ZlcnJpZGVzO1xuICAgICAgICAgICAgdGhpcy5zdGFibGVEeW5hbWljT3B0aW9uT3ZlcnJpZGVzID0gZHluYW1pY09wdGlvbk92ZXJyaWRlcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNGb3JIYW5kbGluZy5wdXNoKC4uLnRoaXMub3B0aW9uc0ZvclJlZmluaW5nKTtcbiAgICAgICAgdGhpcy5vcHRpb25zRm9yUmVmaW5pbmcgPSBbXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhd09wdGlvbnM6IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0LFxuICAgICAgICAgICAgcmVmaW5lZE9wdGlvbnM6IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWQsXG4gICAgICAgICAgICBwbHVnaW5Ib29rcyxcbiAgICAgICAgICAgIGF2YWlsYWJsZUxvY2FsZURhdGEsXG4gICAgICAgICAgICBsb2NhbGVEZWZhdWx0cyxcbiAgICAgICAgICAgIGV4dHJhLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfY29tcHV0ZUN1cnJlbnRWaWV3RGF0YSh2aWV3VHlwZSwgb3B0aW9uc0RhdGEsIG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcykge1xuICAgICAgICBsZXQgdmlld1NwZWMgPSBvcHRpb25zRGF0YS52aWV3U3BlY3Nbdmlld1R5cGVdO1xuICAgICAgICBpZiAoIXZpZXdTcGVjKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHZpZXdUeXBlIFwiJHt2aWV3VHlwZX1cIiBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgbWFrZSBzdXJlIHlvdSd2ZSBsb2FkZWQgYWxsIG5lY2Nlc3NhcnkgcGx1Z2luc2ApO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IHJlZmluZWRPcHRpb25zLCBleHRyYSB9ID0gdGhpcy5wcm9jZXNzUmF3Vmlld09wdGlvbnModmlld1NwZWMsIG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLCBvcHRpb25zRGF0YS5sb2NhbGVEZWZhdWx0cywgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKTtcbiAgICAgICAgd2FyblVua25vd25PcHRpb25zKGV4dHJhKTtcbiAgICAgICAgbGV0IGRhdGVQcm9maWxlR2VuZXJhdG9yID0gdGhpcy5idWlsZERhdGVQcm9maWxlR2VuZXJhdG9yKHtcbiAgICAgICAgICAgIGRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3M6IHZpZXdTcGVjLm9wdGlvbkRlZmF1bHRzLmRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MsXG4gICAgICAgICAgICBkdXJhdGlvbjogdmlld1NwZWMuZHVyYXRpb24sXG4gICAgICAgICAgICBkdXJhdGlvblVuaXQ6IHZpZXdTcGVjLmR1cmF0aW9uVW5pdCxcbiAgICAgICAgICAgIHVzZXNNaW5NYXhUaW1lOiB2aWV3U3BlYy5vcHRpb25EZWZhdWx0cy51c2VzTWluTWF4VGltZSxcbiAgICAgICAgICAgIGRhdGVFbnY6IG9wdGlvbnNEYXRhLmRhdGVFbnYsXG4gICAgICAgICAgICBjYWxlbmRhckFwaTogdGhpcy5wcm9wcy5jYWxlbmRhckFwaSxcbiAgICAgICAgICAgIHNsb3RNaW5UaW1lOiByZWZpbmVkT3B0aW9ucy5zbG90TWluVGltZSxcbiAgICAgICAgICAgIHNsb3RNYXhUaW1lOiByZWZpbmVkT3B0aW9ucy5zbG90TWF4VGltZSxcbiAgICAgICAgICAgIHNob3dOb25DdXJyZW50RGF0ZXM6IHJlZmluZWRPcHRpb25zLnNob3dOb25DdXJyZW50RGF0ZXMsXG4gICAgICAgICAgICBkYXlDb3VudDogcmVmaW5lZE9wdGlvbnMuZGF5Q291bnQsXG4gICAgICAgICAgICBkYXRlQWxpZ25tZW50OiByZWZpbmVkT3B0aW9ucy5kYXRlQWxpZ25tZW50LFxuICAgICAgICAgICAgZGF0ZUluY3JlbWVudDogcmVmaW5lZE9wdGlvbnMuZGF0ZUluY3JlbWVudCxcbiAgICAgICAgICAgIGhpZGRlbkRheXM6IHJlZmluZWRPcHRpb25zLmhpZGRlbkRheXMsXG4gICAgICAgICAgICB3ZWVrZW5kczogcmVmaW5lZE9wdGlvbnMud2Vla2VuZHMsXG4gICAgICAgICAgICBub3dJbnB1dDogcmVmaW5lZE9wdGlvbnMubm93LFxuICAgICAgICAgICAgdmFsaWRSYW5nZUlucHV0OiByZWZpbmVkT3B0aW9ucy52YWxpZFJhbmdlLFxuICAgICAgICAgICAgdmlzaWJsZVJhbmdlSW5wdXQ6IHJlZmluZWRPcHRpb25zLnZpc2libGVSYW5nZSxcbiAgICAgICAgICAgIGZpeGVkV2Vla0NvdW50OiByZWZpbmVkT3B0aW9ucy5maXhlZFdlZWtDb3VudCxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCB2aWV3QXBpID0gdGhpcy5idWlsZFZpZXdBcGkodmlld1R5cGUsIHRoaXMuZ2V0Q3VycmVudERhdGEsIG9wdGlvbnNEYXRhLmRhdGVFbnYpO1xuICAgICAgICByZXR1cm4geyB2aWV3U3BlYywgb3B0aW9uczogcmVmaW5lZE9wdGlvbnMsIGRhdGVQcm9maWxlR2VuZXJhdG9yLCB2aWV3QXBpIH07XG4gICAgfVxuICAgIHByb2Nlc3NSYXdWaWV3T3B0aW9ucyh2aWV3U3BlYywgcGx1Z2luSG9va3MsIGxvY2FsZURlZmF1bHRzLCBvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpIHtcbiAgICAgICAgbGV0IHJhdyA9IG1lcmdlUmF3T3B0aW9ucyhbXG4gICAgICAgICAgICBCQVNFX09QVElPTl9ERUZBVUxUUyxcbiAgICAgICAgICAgIHZpZXdTcGVjLm9wdGlvbkRlZmF1bHRzLFxuICAgICAgICAgICAgbG9jYWxlRGVmYXVsdHMsXG4gICAgICAgICAgICBvcHRpb25PdmVycmlkZXMsXG4gICAgICAgICAgICB2aWV3U3BlYy5vcHRpb25PdmVycmlkZXMsXG4gICAgICAgICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICBdKTtcbiAgICAgICAgbGV0IHJlZmluZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEJBU0VfT1BUSU9OX1JFRklORVJTKSwgQ0FMRU5EQVJfTElTVEVORVJfUkVGSU5FUlMpLCBDQUxFTkRBUl9PUFRJT05fUkVGSU5FUlMpLCBWSUVXX09QVElPTl9SRUZJTkVSUyksIHBsdWdpbkhvb2tzLmxpc3RlbmVyUmVmaW5lcnMpLCBwbHVnaW5Ib29rcy5vcHRpb25SZWZpbmVycyk7XG4gICAgICAgIGxldCByZWZpbmVkID0ge307XG4gICAgICAgIGxldCBjdXJyZW50UmF3ID0gdGhpcy5jdXJyZW50Vmlld09wdGlvbnNJbnB1dDtcbiAgICAgICAgbGV0IGN1cnJlbnRSZWZpbmVkID0gdGhpcy5jdXJyZW50Vmlld09wdGlvbnNSZWZpbmVkO1xuICAgICAgICBsZXQgYW55Q2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICBsZXQgZXh0cmEgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgb3B0aW9uTmFtZSBpbiByYXcpIHtcbiAgICAgICAgICAgIGlmIChyYXdbb3B0aW9uTmFtZV0gPT09IGN1cnJlbnRSYXdbb3B0aW9uTmFtZV0gfHxcbiAgICAgICAgICAgICAgICAoQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlNbb3B0aW9uTmFtZV0gJiZcbiAgICAgICAgICAgICAgICAgICAgQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlNbb3B0aW9uTmFtZV0ocmF3W29wdGlvbk5hbWVdLCBjdXJyZW50UmF3W29wdGlvbk5hbWVdKSkpIHtcbiAgICAgICAgICAgICAgICByZWZpbmVkW29wdGlvbk5hbWVdID0gY3VycmVudFJlZmluZWRbb3B0aW9uTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocmF3W29wdGlvbk5hbWVdID09PSB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dFtvcHRpb25OYW1lXSB8fFxuICAgICAgICAgICAgICAgICAgICAoQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlNbb3B0aW9uTmFtZV0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTW29wdGlvbk5hbWVdKHJhd1tvcHRpb25OYW1lXSwgdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXRbb3B0aW9uTmFtZV0pKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9uTmFtZSBpbiB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkKSB7IC8vIG1pZ2h0IGJlIGFuIFwiZXh0cmFcIiBwcm9wXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZpbmVkW29wdGlvbk5hbWVdID0gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZFtvcHRpb25OYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWZpbmVyc1tvcHRpb25OYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICByZWZpbmVkW29wdGlvbk5hbWVdID0gcmVmaW5lcnNbb3B0aW9uTmFtZV0ocmF3W29wdGlvbk5hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhW29wdGlvbk5hbWVdID0gcmF3W29wdGlvbk5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhbnlDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYW55Q2hhbmdlcykge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Vmlld09wdGlvbnNJbnB1dCA9IHJhdztcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZpZXdPcHRpb25zUmVmaW5lZCA9IHJlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhd09wdGlvbnM6IHRoaXMuY3VycmVudFZpZXdPcHRpb25zSW5wdXQsXG4gICAgICAgICAgICByZWZpbmVkT3B0aW9uczogdGhpcy5jdXJyZW50Vmlld09wdGlvbnNSZWZpbmVkLFxuICAgICAgICAgICAgZXh0cmEsXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGREYXRlRW52JDEodGltZVpvbmUsIGV4cGxpY2l0TG9jYWxlLCB3ZWVrTnVtYmVyQ2FsY3VsYXRpb24sIGZpcnN0RGF5LCB3ZWVrVGV4dCwgcGx1Z2luSG9va3MsIGF2YWlsYWJsZUxvY2FsZURhdGEsIGRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICBsZXQgbG9jYWxlID0gYnVpbGRMb2NhbGUoZXhwbGljaXRMb2NhbGUgfHwgYXZhaWxhYmxlTG9jYWxlRGF0YS5kZWZhdWx0Q29kZSwgYXZhaWxhYmxlTG9jYWxlRGF0YS5tYXApO1xuICAgIHJldHVybiBuZXcgRGF0ZUVudih7XG4gICAgICAgIGNhbGVuZGFyU3lzdGVtOiAnZ3JlZ29yeScsXG4gICAgICAgIHRpbWVab25lLFxuICAgICAgICBuYW1lZFRpbWVab25lSW1wbDogcGx1Z2luSG9va3MubmFtZWRUaW1lWm9uZWRJbXBsLFxuICAgICAgICBsb2NhbGUsXG4gICAgICAgIHdlZWtOdW1iZXJDYWxjdWxhdGlvbixcbiAgICAgICAgZmlyc3REYXksXG4gICAgICAgIHdlZWtUZXh0LFxuICAgICAgICBjbWRGb3JtYXR0ZXI6IHBsdWdpbkhvb2tzLmNtZEZvcm1hdHRlcixcbiAgICAgICAgZGVmYXVsdFNlcGFyYXRvcixcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVGhlbWUob3B0aW9ucywgcGx1Z2luSG9va3MpIHtcbiAgICBsZXQgVGhlbWVDbGFzcyA9IHBsdWdpbkhvb2tzLnRoZW1lQ2xhc3Nlc1tvcHRpb25zLnRoZW1lU3lzdGVtXSB8fCBTdGFuZGFyZFRoZW1lO1xuICAgIHJldHVybiBuZXcgVGhlbWVDbGFzcyhvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRGF0ZVByb2ZpbGVHZW5lcmF0b3IocHJvcHMpIHtcbiAgICBsZXQgRGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyA9IHByb3BzLmRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MgfHwgRGF0ZVByb2ZpbGVHZW5lcmF0b3I7XG4gICAgcmV0dXJuIG5ldyBEYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzKHByb3BzKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVmlld0FwaSh0eXBlLCBnZXRDdXJyZW50RGF0YSwgZGF0ZUVudikge1xuICAgIHJldHVybiBuZXcgVmlld0ltcGwodHlwZSwgZ2V0Q3VycmVudERhdGEsIGRhdGVFbnYpO1xufVxuZnVuY3Rpb24gYnVpbGRFdmVudFVpQnlTb3VyY2UoZXZlbnRTb3VyY2VzKSB7XG4gICAgcmV0dXJuIG1hcEhhc2goZXZlbnRTb3VyY2VzLCAoZXZlbnRTb3VyY2UpID0+IGV2ZW50U291cmNlLnVpKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRVaUJhc2VzKGV2ZW50RGVmcywgZXZlbnRVaVNpbmdsZUJhc2UsIGV2ZW50VWlCeVNvdXJjZSkge1xuICAgIGxldCBldmVudFVpQmFzZXMgPSB7ICcnOiBldmVudFVpU2luZ2xlQmFzZSB9O1xuICAgIGZvciAobGV0IGRlZklkIGluIGV2ZW50RGVmcykge1xuICAgICAgICBsZXQgZGVmID0gZXZlbnREZWZzW2RlZklkXTtcbiAgICAgICAgaWYgKGRlZi5zb3VyY2VJZCAmJiBldmVudFVpQnlTb3VyY2VbZGVmLnNvdXJjZUlkXSkge1xuICAgICAgICAgICAgZXZlbnRVaUJhc2VzW2RlZklkXSA9IGV2ZW50VWlCeVNvdXJjZVtkZWYuc291cmNlSWRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBldmVudFVpQmFzZXM7XG59XG5mdW5jdGlvbiBidWlsZFZpZXdVaVByb3BzKGNhbGVuZGFyQ29udGV4dCkge1xuICAgIGxldCB7IG9wdGlvbnMgfSA9IGNhbGVuZGFyQ29udGV4dDtcbiAgICByZXR1cm4ge1xuICAgICAgICBldmVudFVpU2luZ2xlQmFzZTogY3JlYXRlRXZlbnRVaSh7XG4gICAgICAgICAgICBkaXNwbGF5OiBvcHRpb25zLmV2ZW50RGlzcGxheSxcbiAgICAgICAgICAgIGVkaXRhYmxlOiBvcHRpb25zLmVkaXRhYmxlLFxuICAgICAgICAgICAgc3RhcnRFZGl0YWJsZTogb3B0aW9ucy5ldmVudFN0YXJ0RWRpdGFibGUsXG4gICAgICAgICAgICBkdXJhdGlvbkVkaXRhYmxlOiBvcHRpb25zLmV2ZW50RHVyYXRpb25FZGl0YWJsZSxcbiAgICAgICAgICAgIGNvbnN0cmFpbnQ6IG9wdGlvbnMuZXZlbnRDb25zdHJhaW50LFxuICAgICAgICAgICAgb3ZlcmxhcDogdHlwZW9mIG9wdGlvbnMuZXZlbnRPdmVybGFwID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmV2ZW50T3ZlcmxhcCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFsbG93OiBvcHRpb25zLmV2ZW50QWxsb3csXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuZXZlbnRCYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogb3B0aW9ucy5ldmVudEJvcmRlckNvbG9yLFxuICAgICAgICAgICAgdGV4dENvbG9yOiBvcHRpb25zLmV2ZW50VGV4dENvbG9yLFxuICAgICAgICAgICAgY29sb3I6IG9wdGlvbnMuZXZlbnRDb2xvcixcbiAgICAgICAgICAgIC8vIGNsYXNzTmFtZXM6IG9wdGlvbnMuZXZlbnRDbGFzc05hbWVzIC8vIHJlbmRlciBob29rIHdpbGwgaGFuZGxlIHRoaXNcbiAgICAgICAgfSwgY2FsZW5kYXJDb250ZXh0KSxcbiAgICAgICAgc2VsZWN0aW9uQ29uZmlnOiBjcmVhdGVFdmVudFVpKHtcbiAgICAgICAgICAgIGNvbnN0cmFpbnQ6IG9wdGlvbnMuc2VsZWN0Q29uc3RyYWludCxcbiAgICAgICAgICAgIG92ZXJsYXA6IHR5cGVvZiBvcHRpb25zLnNlbGVjdE92ZXJsYXAgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuc2VsZWN0T3ZlcmxhcCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFsbG93OiBvcHRpb25zLnNlbGVjdEFsbG93LFxuICAgICAgICB9LCBjYWxlbmRhckNvbnRleHQpLFxuICAgIH07XG59XG5mdW5jdGlvbiBjb21wdXRlSXNMb2FkaW5nKHN0YXRlLCBjb250ZXh0KSB7XG4gICAgZm9yIChsZXQgaXNMb2FkaW5nRnVuYyBvZiBjb250ZXh0LnBsdWdpbkhvb2tzLmlzTG9hZGluZ0Z1bmNzKSB7XG4gICAgICAgIGlmIChpc0xvYWRpbmdGdW5jKHN0YXRlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcGFyc2VDb250ZXh0QnVzaW5lc3NIb3VycyhjYWxlbmRhckNvbnRleHQpIHtcbiAgICByZXR1cm4gcGFyc2VCdXNpbmVzc0hvdXJzKGNhbGVuZGFyQ29udGV4dC5vcHRpb25zLmJ1c2luZXNzSG91cnMsIGNhbGVuZGFyQ29udGV4dCk7XG59XG5mdW5jdGlvbiB3YXJuVW5rbm93bk9wdGlvbnMob3B0aW9ucywgdmlld05hbWUpIHtcbiAgICBmb3IgKGxldCBvcHRpb25OYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBVbmtub3duIG9wdGlvbiAnJHtvcHRpb25OYW1lfSdgICtcbiAgICAgICAgICAgICh2aWV3TmFtZSA/IGAgZm9yIHZpZXcgJyR7dmlld05hbWV9J2AgOiAnJykpO1xuICAgIH1cbn1cblxuY2xhc3MgVG9vbGJhclNlY3Rpb24gZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IHRoaXMucHJvcHMud2lkZ2V0R3JvdXBzLm1hcCgod2lkZ2V0R3JvdXApID0+IHRoaXMucmVuZGVyV2lkZ2V0R3JvdXAod2lkZ2V0R3JvdXApKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHsgY2xhc3NOYW1lOiAnZmMtdG9vbGJhci1jaHVuaycgfSwgLi4uY2hpbGRyZW4pO1xuICAgIH1cbiAgICByZW5kZXJXaWRnZXRHcm91cCh3aWRnZXRHcm91cCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgdGhlbWUgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW107XG4gICAgICAgIGxldCBpc09ubHlCdXR0b25zID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgd2lkZ2V0IG9mIHdpZGdldEdyb3VwKSB7XG4gICAgICAgICAgICBsZXQgeyBidXR0b25OYW1lLCBidXR0b25DbGljaywgYnV0dG9uVGV4dCwgYnV0dG9uSWNvbiwgYnV0dG9uSGludCB9ID0gd2lkZ2V0O1xuICAgICAgICAgICAgaWYgKGJ1dHRvbk5hbWUgPT09ICd0aXRsZScpIHtcbiAgICAgICAgICAgICAgICBpc09ubHlCdXR0b25zID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjcmVhdGVFbGVtZW50KFwiaDJcIiwgeyBjbGFzc05hbWU6IFwiZmMtdG9vbGJhci10aXRsZVwiLCBpZDogcHJvcHMudGl0bGVJZCB9LCBwcm9wcy50aXRsZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGlzUHJlc3NlZCA9IGJ1dHRvbk5hbWUgPT09IHByb3BzLmFjdGl2ZUJ1dHRvbjtcbiAgICAgICAgICAgICAgICBsZXQgaXNEaXNhYmxlZCA9ICghcHJvcHMuaXNUb2RheUVuYWJsZWQgJiYgYnV0dG9uTmFtZSA9PT0gJ3RvZGF5JykgfHxcbiAgICAgICAgICAgICAgICAgICAgKCFwcm9wcy5pc1ByZXZFbmFibGVkICYmIGJ1dHRvbk5hbWUgPT09ICdwcmV2JykgfHxcbiAgICAgICAgICAgICAgICAgICAgKCFwcm9wcy5pc05leHRFbmFibGVkICYmIGJ1dHRvbk5hbWUgPT09ICduZXh0Jyk7XG4gICAgICAgICAgICAgICAgbGV0IGJ1dHRvbkNsYXNzZXMgPSBbYGZjLSR7YnV0dG9uTmFtZX0tYnV0dG9uYCwgdGhlbWUuZ2V0Q2xhc3MoJ2J1dHRvbicpXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbkNsYXNzZXMucHVzaCh0aGVtZS5nZXRDbGFzcygnYnV0dG9uQWN0aXZlJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgeyB0eXBlOiBcImJ1dHRvblwiLCB0aXRsZTogdHlwZW9mIGJ1dHRvbkhpbnQgPT09ICdmdW5jdGlvbicgPyBidXR0b25IaW50KHByb3BzLm5hdlVuaXQpIDogYnV0dG9uSGludCwgZGlzYWJsZWQ6IGlzRGlzYWJsZWQsIFwiYXJpYS1wcmVzc2VkXCI6IGlzUHJlc3NlZCwgY2xhc3NOYW1lOiBidXR0b25DbGFzc2VzLmpvaW4oJyAnKSwgb25DbGljazogYnV0dG9uQ2xpY2sgfSwgYnV0dG9uVGV4dCB8fCAoYnV0dG9uSWNvbiA/IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBidXR0b25JY29uLCByb2xlOiBcImltZ1wiIH0pIDogJycpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxldCBncm91cENsYXNzTmFtZSA9IChpc09ubHlCdXR0b25zICYmIHRoZW1lLmdldENsYXNzKCdidXR0b25Hcm91cCcpKSB8fCAnJztcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdkaXYnLCB7IGNsYXNzTmFtZTogZ3JvdXBDbGFzc05hbWUgfSwgLi4uY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZHJlblswXTtcbiAgICB9XG59XG5cbmNsYXNzIFRvb2xiYXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IG1vZGVsLCBleHRyYUNsYXNzTmFtZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IGZvcmNlTHRyID0gZmFsc2U7XG4gICAgICAgIGxldCBzdGFydENvbnRlbnQ7XG4gICAgICAgIGxldCBlbmRDb250ZW50O1xuICAgICAgICBsZXQgc2VjdGlvbldpZGdldHMgPSBtb2RlbC5zZWN0aW9uV2lkZ2V0cztcbiAgICAgICAgbGV0IGNlbnRlckNvbnRlbnQgPSBzZWN0aW9uV2lkZ2V0cy5jZW50ZXI7XG4gICAgICAgIGlmIChzZWN0aW9uV2lkZ2V0cy5sZWZ0KSB7XG4gICAgICAgICAgICBmb3JjZUx0ciA9IHRydWU7XG4gICAgICAgICAgICBzdGFydENvbnRlbnQgPSBzZWN0aW9uV2lkZ2V0cy5sZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRDb250ZW50ID0gc2VjdGlvbldpZGdldHMuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlY3Rpb25XaWRnZXRzLnJpZ2h0KSB7XG4gICAgICAgICAgICBmb3JjZUx0ciA9IHRydWU7XG4gICAgICAgICAgICBlbmRDb250ZW50ID0gc2VjdGlvbldpZGdldHMucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbmRDb250ZW50ID0gc2VjdGlvbldpZGdldHMuZW5kO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgICAgICAgZXh0cmFDbGFzc05hbWUgfHwgJycsXG4gICAgICAgICAgICAnZmMtdG9vbGJhcicsXG4gICAgICAgICAgICBmb3JjZUx0ciA/ICdmYy10b29sYmFyLWx0cicgOiAnJyxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSB9LFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJTZWN0aW9uKCdzdGFydCcsIHN0YXJ0Q29udGVudCB8fCBbXSksXG4gICAgICAgICAgICB0aGlzLnJlbmRlclNlY3Rpb24oJ2NlbnRlcicsIGNlbnRlckNvbnRlbnQgfHwgW10pLFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJTZWN0aW9uKCdlbmQnLCBlbmRDb250ZW50IHx8IFtdKSkpO1xuICAgIH1cbiAgICByZW5kZXJTZWN0aW9uKGtleSwgd2lkZ2V0R3JvdXBzKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVG9vbGJhclNlY3Rpb24sIHsga2V5OiBrZXksIHdpZGdldEdyb3Vwczogd2lkZ2V0R3JvdXBzLCB0aXRsZTogcHJvcHMudGl0bGUsIG5hdlVuaXQ6IHByb3BzLm5hdlVuaXQsIGFjdGl2ZUJ1dHRvbjogcHJvcHMuYWN0aXZlQnV0dG9uLCBpc1RvZGF5RW5hYmxlZDogcHJvcHMuaXNUb2RheUVuYWJsZWQsIGlzUHJldkVuYWJsZWQ6IHByb3BzLmlzUHJldkVuYWJsZWQsIGlzTmV4dEVuYWJsZWQ6IHByb3BzLmlzTmV4dEVuYWJsZWQsIHRpdGxlSWQ6IHByb3BzLnRpdGxlSWQgfSkpO1xuICAgIH1cbn1cblxuY2xhc3MgVmlld0hhcm5lc3MgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGF2YWlsYWJsZVdpZHRoOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUVsID0gKGVsKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgICAgICBzZXRSZWYodGhpcy5wcm9wcy5lbFJlZiwgZWwpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVBdmFpbGFibGVXaWR0aCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQXZhaWxhYmxlV2lkdGgoKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGFzcGVjdFJhdGlvIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICAgICAnZmMtdmlldy1oYXJuZXNzJyxcbiAgICAgICAgICAgIChhc3BlY3RSYXRpbyB8fCBwcm9wcy5saXF1aWQgfHwgcHJvcHMuaGVpZ2h0KVxuICAgICAgICAgICAgICAgID8gJ2ZjLXZpZXctaGFybmVzcy1hY3RpdmUnIC8vIGhhcm5lc3MgY29udHJvbHMgdGhlIGhlaWdodFxuICAgICAgICAgICAgICAgIDogJ2ZjLXZpZXctaGFybmVzcy1wYXNzaXZlJywgLy8gbGV0IHRoZSB2aWV3IGRvIHRoZSBoZWlnaHRcbiAgICAgICAgXTtcbiAgICAgICAgbGV0IGhlaWdodCA9ICcnO1xuICAgICAgICBsZXQgcGFkZGluZ0JvdHRvbSA9ICcnO1xuICAgICAgICBpZiAoYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5hdmFpbGFibGVXaWR0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IHN0YXRlLmF2YWlsYWJsZVdpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB3aGlsZSB3YWl0aW5nIHRvIGtub3cgYXZhaWxhYmxlV2lkdGgsIHdlIGNhbid0IHNldCBoZWlnaHQgdG8gKnplcm8qXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSB3aWxsIGNhdXNlIGxvdHMgb2YgdW5uZWNlc3Nhcnkgc2Nyb2xsYmFycyB3aXRoaW4gc2Nyb2xsZ3JpZC5cbiAgICAgICAgICAgICAgICAvLyBCRVRURVI6IGRvbid0IHN0YXJ0IHJlbmRlcmluZyBBTllUSElORyB5ZXQgdW50aWwgd2Uga25vdyBjb250YWluZXIgd2lkdGhcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiB3aHkgbm90IGFsd2F5cyB1c2UgcGFkZGluZ0JvdHRvbT8gQ2F1c2VzIGhlaWdodCBvc2NpbGxhdGlvbiAoaXNzdWUgNTYwNilcbiAgICAgICAgICAgICAgICBwYWRkaW5nQm90dG9tID0gYCR7KDEgLyBhc3BlY3RSYXRpbykgKiAxMDB9JWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBwcm9wcy5oZWlnaHQgfHwgJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJhcmlhLWxhYmVsbGVkYnlcIjogcHJvcHMubGFiZWxlZEJ5SWQsIHJlZjogdGhpcy5oYW5kbGVFbCwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSwgc3R5bGU6IHsgaGVpZ2h0LCBwYWRkaW5nQm90dG9tIH0gfSwgcHJvcHMuY2hpbGRyZW4pKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5hZGRSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlUmVzaXplKTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5yZW1vdmVSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlUmVzaXplKTtcbiAgICB9XG4gICAgdXBkYXRlQXZhaWxhYmxlV2lkdGgoKSB7XG4gICAgICAgIGlmICh0aGlzLmVsICYmIC8vIG5lZWRlZC4gYnV0IHdoeT9cbiAgICAgICAgICAgIHRoaXMucHJvcHMuYXNwZWN0UmF0aW8gLy8gYXNwZWN0UmF0aW8gaXMgdGhlIG9ubHkgaGVpZ2h0IHNldHRpbmcgdGhhdCBuZWVkcyBhdmFpbGFibGVXaWR0aFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBhdmFpbGFibGVXaWR0aDogdGhpcy5lbC5vZmZzZXRXaWR0aCB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLypcbkRldGVjdHMgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gYW4gZXZlbnQgd2l0aGluIGEgRGF0ZUNvbXBvbmVudFxuKi9cbmNsYXNzIEV2ZW50Q2xpY2tpbmcgZXh0ZW5kcyBJbnRlcmFjdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICAgICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgICAgICB0aGlzLmhhbmRsZVNlZ0NsaWNrID0gKGV2LCBzZWdFbCkgPT4ge1xuICAgICAgICAgICAgbGV0IHsgY29tcG9uZW50IH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IHsgY29udGV4dCB9ID0gY29tcG9uZW50O1xuICAgICAgICAgICAgbGV0IHNlZyA9IGdldEVsU2VnKHNlZ0VsKTtcbiAgICAgICAgICAgIGlmIChzZWcgJiYgLy8gbWlnaHQgYmUgdGhlIDxkaXY+IHN1cnJvdW5kaW5nIHRoZSBtb3JlIGxpbmtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuaXNWYWxpZFNlZ0Rvd25FbChldi50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgLy8gb3VyIHdheSB0byBzaW11bGF0ZSBhIGxpbmsgY2xpY2sgZm9yIGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgPGE+IHRhZ3NcbiAgICAgICAgICAgICAgICAvLyBncmFiIGJlZm9yZSB0cmlnZ2VyIGZpcmVkIGluIGNhc2UgdHJpZ2dlciB0cmFzaGVzIERPTSB0aHJ1IHJlcmVuZGVyaW5nXG4gICAgICAgICAgICAgICAgbGV0IGhhc1VybENvbnRhaW5lciA9IGVsZW1lbnRDbG9zZXN0KGV2LnRhcmdldCwgJy5mYy1ldmVudC1mb3JjZWQtdXJsJyk7XG4gICAgICAgICAgICAgICAgbGV0IHVybCA9IGhhc1VybENvbnRhaW5lciA/IGhhc1VybENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCdhW2hyZWZdJykuaHJlZiA6ICcnO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudENsaWNrJywge1xuICAgICAgICAgICAgICAgICAgICBlbDogc2VnRWwsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRJbXBsKGNvbXBvbmVudC5jb250ZXh0LCBzZWcuZXZlbnRSYW5nZS5kZWYsIHNlZy5ldmVudFJhbmdlLmluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAganNFdmVudDogZXYsXG4gICAgICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAodXJsICYmICFldi5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZXN0cm95ID0gbGlzdGVuQnlTZWxlY3RvcihzZXR0aW5ncy5lbCwgJ2NsaWNrJywgJy5mYy1ldmVudCcsIC8vIG9uIGJvdGggZmcgYW5kIGJnIGV2ZW50c1xuICAgICAgICB0aGlzLmhhbmRsZVNlZ0NsaWNrKTtcbiAgICB9XG59XG5cbi8qXG5UcmlnZ2VycyBldmVudHMgYW5kIGFkZHMvcmVtb3ZlcyBjb3JlIGNsYXNzTmFtZXMgd2hlbiB0aGUgdXNlcidzIHBvaW50ZXJcbmVudGVycy9sZWF2ZXMgZXZlbnQtZWxlbWVudHMgb2YgYSBjb21wb25lbnQuXG4qL1xuY2xhc3MgRXZlbnRIb3ZlcmluZyBleHRlbmRzIEludGVyYWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgICAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgICAgIC8vIGZvciBzaW11bGF0aW5nIGFuIGV2ZW50TW91c2VMZWF2ZSB3aGVuIHRoZSBldmVudCBlbCBpcyBkZXN0cm95ZWQgd2hpbGUgbW91c2UgaXMgb3ZlciBpdFxuICAgICAgICB0aGlzLmhhbmRsZUV2ZW50RWxSZW1vdmUgPSAoZWwpID0+IHtcbiAgICAgICAgICAgIGlmIChlbCA9PT0gdGhpcy5jdXJyZW50U2VnRWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNlZ0xlYXZlKG51bGwsIHRoaXMuY3VycmVudFNlZ0VsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVTZWdFbnRlciA9IChldiwgc2VnRWwpID0+IHtcbiAgICAgICAgICAgIGlmIChnZXRFbFNlZyhzZWdFbCkpIHsgLy8gVE9ETzogYmV0dGVyIHdheSB0byBtYWtlIHN1cmUgbm90IGhvdmVyaW5nIG92ZXIgbW9yZSsgbGluayBvciBpdHMgd3JhcHBlclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNlZ0VsID0gc2VnRWw7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQoJ2V2ZW50TW91c2VFbnRlcicsIGV2LCBzZWdFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlU2VnTGVhdmUgPSAoZXYsIHNlZ0VsKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U2VnRWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTZWdFbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQoJ2V2ZW50TW91c2VMZWF2ZScsIGV2LCBzZWdFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVtb3ZlSG92ZXJMaXN0ZW5lcnMgPSBsaXN0ZW5Ub0hvdmVyQnlTZWxlY3RvcihzZXR0aW5ncy5lbCwgJy5mYy1ldmVudCcsIC8vIG9uIGJvdGggZmcgYW5kIGJnIGV2ZW50c1xuICAgICAgICB0aGlzLmhhbmRsZVNlZ0VudGVyLCB0aGlzLmhhbmRsZVNlZ0xlYXZlKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVIb3Zlckxpc3RlbmVycygpO1xuICAgIH1cbiAgICB0cmlnZ2VyRXZlbnQocHVibGljRXZOYW1lLCBldiwgc2VnRWwpIHtcbiAgICAgICAgbGV0IHsgY29tcG9uZW50IH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSBjb21wb25lbnQ7XG4gICAgICAgIGxldCBzZWcgPSBnZXRFbFNlZyhzZWdFbCk7XG4gICAgICAgIGlmICghZXYgfHwgY29tcG9uZW50LmlzVmFsaWRTZWdEb3duRWwoZXYudGFyZ2V0KSkge1xuICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIocHVibGljRXZOYW1lLCB7XG4gICAgICAgICAgICAgICAgZWw6IHNlZ0VsLFxuICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIHNlZy5ldmVudFJhbmdlLmRlZiwgc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2LFxuICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBDYWxlbmRhckNvbnRlbnQgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5idWlsZFZpZXdDb250ZXh0ID0gbWVtb2l6ZShidWlsZFZpZXdDb250ZXh0KTtcbiAgICAgICAgdGhpcy5idWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzID0gbWVtb2l6ZShidWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzKTtcbiAgICAgICAgdGhpcy5idWlsZFRvb2xiYXJQcm9wcyA9IG1lbW9pemUoYnVpbGRUb29sYmFyUHJvcHMpO1xuICAgICAgICB0aGlzLmhlYWRlclJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLmZvb3RlclJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLmludGVyYWN0aW9uc1N0b3JlID0ge307XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgdmlld0xhYmVsSWQ6IGdldFVuaXF1ZURvbUlkKCksXG4gICAgICAgIH07XG4gICAgICAgIC8vIENvbXBvbmVudCBSZWdpc3RyYXRpb25cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgdGhpcy5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50ID0gKGNvbXBvbmVudCwgc2V0dGluZ3NJbnB1dCkgPT4ge1xuICAgICAgICAgICAgbGV0IHNldHRpbmdzID0gcGFyc2VJbnRlcmFjdGlvblNldHRpbmdzKGNvbXBvbmVudCwgc2V0dGluZ3NJbnB1dCk7XG4gICAgICAgICAgICBsZXQgREVGQVVMVF9JTlRFUkFDVElPTlMgPSBbXG4gICAgICAgICAgICAgICAgRXZlbnRDbGlja2luZyxcbiAgICAgICAgICAgICAgICBFdmVudEhvdmVyaW5nLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbkNsYXNzZXMgPSBERUZBVUxUX0lOVEVSQUNUSU9OUy5jb25jYXQodGhpcy5wcm9wcy5wbHVnaW5Ib29rcy5jb21wb25lbnRJbnRlcmFjdGlvbnMpO1xuICAgICAgICAgICAgbGV0IGludGVyYWN0aW9ucyA9IGludGVyYWN0aW9uQ2xhc3Nlcy5tYXAoKFRoZUludGVyYWN0aW9uQ2xhc3MpID0+IG5ldyBUaGVJbnRlcmFjdGlvbkNsYXNzKHNldHRpbmdzKSk7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uc1N0b3JlW2NvbXBvbmVudC51aWRdID0gaW50ZXJhY3Rpb25zO1xuICAgICAgICAgICAgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlW2NvbXBvbmVudC51aWRdID0gc2V0dGluZ3M7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50ID0gKGNvbXBvbmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IGxpc3RlbmVycyA9IHRoaXMuaW50ZXJhY3Rpb25zU3RvcmVbY29tcG9uZW50LnVpZF07XG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuaW50ZXJhY3Rpb25zU3RvcmVbY29tcG9uZW50LnVpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlW2NvbXBvbmVudC51aWRdO1xuICAgICAgICB9O1xuICAgICAgICAvLyBSZXNpemluZ1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB0aGlzLnJlc2l6ZVJ1bm5lciA9IG5ldyBEZWxheWVkUnVubmVyKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMuZW1pdHRlci50cmlnZ2VyKCdfcmVzaXplJywgdHJ1ZSk7IC8vIHNob3VsZCB3aW5kb3cgcmVzaXplcyBiZSBjb25zaWRlcmVkIFwiZm9yY2VkXCIgP1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5lbWl0dGVyLnRyaWdnZXIoJ3dpbmRvd1Jlc2l6ZScsIHsgdmlldzogdGhpcy5wcm9wcy52aWV3QXBpIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5oYW5kbGVXaW5kb3dSZXNpemUgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oYW5kbGVXaW5kb3dSZXNpemUgJiZcbiAgICAgICAgICAgICAgICBldi50YXJnZXQgPT09IHdpbmRvdyAvLyBhdm9pZCBqcXVpIGV2ZW50c1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemVSdW5uZXIucmVxdWVzdChvcHRpb25zLndpbmRvd1Jlc2l6ZURlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLypcbiAgICByZW5kZXJzIElOU0lERSBvZiBhbiBvdXRlciBkaXZcbiAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHRvb2xiYXJDb25maWcsIG9wdGlvbnMgfSA9IHByb3BzO1xuICAgICAgICBsZXQgdG9vbGJhclByb3BzID0gdGhpcy5idWlsZFRvb2xiYXJQcm9wcyhwcm9wcy52aWV3U3BlYywgcHJvcHMuZGF0ZVByb2ZpbGUsIHByb3BzLmRhdGVQcm9maWxlR2VuZXJhdG9yLCBwcm9wcy5jdXJyZW50RGF0ZSwgZ2V0Tm93KHByb3BzLm9wdGlvbnMubm93LCBwcm9wcy5kYXRlRW52KSwgLy8gVE9ETzogdXNlIE5vd1RpbWVyPz8/P1xuICAgICAgICBwcm9wcy52aWV3VGl0bGUpO1xuICAgICAgICBsZXQgdmlld1ZHcm93ID0gZmFsc2U7XG4gICAgICAgIGxldCB2aWV3SGVpZ2h0ID0gJyc7XG4gICAgICAgIGxldCB2aWV3QXNwZWN0UmF0aW87XG4gICAgICAgIGlmIChwcm9wcy5pc0hlaWdodEF1dG8gfHwgcHJvcHMuZm9yUHJpbnQpIHtcbiAgICAgICAgICAgIHZpZXdIZWlnaHQgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLmhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2aWV3Vkdyb3cgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuY29udGVudEhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2aWV3SGVpZ2h0ID0gb3B0aW9ucy5jb250ZW50SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmlld0FzcGVjdFJhdGlvID0gTWF0aC5tYXgob3B0aW9ucy5hc3BlY3RSYXRpbywgMC41KTsgLy8gcHJldmVudCBmcm9tIGdldHRpbmcgdG9vIHRhbGxcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmlld0NvbnRleHQgPSB0aGlzLmJ1aWxkVmlld0NvbnRleHQocHJvcHMudmlld1NwZWMsIHByb3BzLnZpZXdBcGksIHByb3BzLm9wdGlvbnMsIHByb3BzLmRhdGVQcm9maWxlR2VuZXJhdG9yLCBwcm9wcy5kYXRlRW52LCBwcm9wcy50aGVtZSwgcHJvcHMucGx1Z2luSG9va3MsIHByb3BzLmRpc3BhdGNoLCBwcm9wcy5nZXRDdXJyZW50RGF0YSwgcHJvcHMuZW1pdHRlciwgcHJvcHMuY2FsZW5kYXJBcGksIHRoaXMucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCwgdGhpcy51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQpO1xuICAgICAgICBsZXQgdmlld0xhYmVsSWQgPSAodG9vbGJhckNvbmZpZy5oZWFkZXIgJiYgdG9vbGJhckNvbmZpZy5oZWFkZXIuaGFzVGl0bGUpXG4gICAgICAgICAgICA/IHRoaXMuc3RhdGUudmlld0xhYmVsSWRcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVmlld0NvbnRleHRUeXBlLlByb3ZpZGVyLCB7IHZhbHVlOiB2aWV3Q29udGV4dCB9LFxuICAgICAgICAgICAgdG9vbGJhckNvbmZpZy5oZWFkZXIgJiYgKGNyZWF0ZUVsZW1lbnQoVG9vbGJhciwgT2JqZWN0LmFzc2lnbih7IHJlZjogdGhpcy5oZWFkZXJSZWYsIGV4dHJhQ2xhc3NOYW1lOiBcImZjLWhlYWRlci10b29sYmFyXCIsIG1vZGVsOiB0b29sYmFyQ29uZmlnLmhlYWRlciwgdGl0bGVJZDogdmlld0xhYmVsSWQgfSwgdG9vbGJhclByb3BzKSkpLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChWaWV3SGFybmVzcywgeyBsaXF1aWQ6IHZpZXdWR3JvdywgaGVpZ2h0OiB2aWV3SGVpZ2h0LCBhc3BlY3RSYXRpbzogdmlld0FzcGVjdFJhdGlvLCBsYWJlbGVkQnlJZDogdmlld0xhYmVsSWQgfSxcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclZpZXcocHJvcHMpLFxuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRBcHBlbmRDb250ZW50KCkpLFxuICAgICAgICAgICAgdG9vbGJhckNvbmZpZy5mb290ZXIgJiYgKGNyZWF0ZUVsZW1lbnQoVG9vbGJhciwgT2JqZWN0LmFzc2lnbih7IHJlZjogdGhpcy5mb290ZXJSZWYsIGV4dHJhQ2xhc3NOYW1lOiBcImZjLWZvb3Rlci10b29sYmFyXCIsIG1vZGVsOiB0b29sYmFyQ29uZmlnLmZvb3RlciwgdGl0bGVJZDogXCJcIiB9LCB0b29sYmFyUHJvcHMpKSkpKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmNhbGVuZGFySW50ZXJhY3Rpb25zID0gcHJvcHMucGx1Z2luSG9va3MuY2FsZW5kYXJJbnRlcmFjdGlvbnNcbiAgICAgICAgICAgIC5tYXAoKENhbGVuZGFySW50ZXJhY3Rpb25DbGFzcykgPT4gbmV3IENhbGVuZGFySW50ZXJhY3Rpb25DbGFzcyhwcm9wcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5oYW5kbGVXaW5kb3dSZXNpemUpO1xuICAgICAgICBsZXQgeyBwcm9wU2V0SGFuZGxlcnMgfSA9IHByb3BzLnBsdWdpbkhvb2tzO1xuICAgICAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBwcm9wU2V0SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHByb3BTZXRIYW5kbGVyc1twcm9wTmFtZV0ocHJvcHNbcHJvcE5hbWVdLCBwcm9wcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcHJvcFNldEhhbmRsZXJzIH0gPSBwcm9wcy5wbHVnaW5Ib29rcztcbiAgICAgICAgZm9yIChsZXQgcHJvcE5hbWUgaW4gcHJvcFNldEhhbmRsZXJzKSB7XG4gICAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdICE9PSBwcmV2UHJvcHNbcHJvcE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgcHJvcFNldEhhbmRsZXJzW3Byb3BOYW1lXShwcm9wc1twcm9wTmFtZV0sIHByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuaGFuZGxlV2luZG93UmVzaXplKTtcbiAgICAgICAgdGhpcy5yZXNpemVSdW5uZXIuY2xlYXIoKTtcbiAgICAgICAgZm9yIChsZXQgaW50ZXJhY3Rpb24gb2YgdGhpcy5jYWxlbmRhckludGVyYWN0aW9ucykge1xuICAgICAgICAgICAgaW50ZXJhY3Rpb24uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvcHMuZW1pdHRlci50cmlnZ2VyKCdfdW5tb3VudCcpO1xuICAgIH1cbiAgICBidWlsZEFwcGVuZENvbnRlbnQoKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBwcm9wcy5wbHVnaW5Ib29rcy52aWV3Q29udGFpbmVyQXBwZW5kcy5tYXAoKGJ1aWxkQXBwZW5kQ29udGVudCkgPT4gYnVpbGRBcHBlbmRDb250ZW50KHByb3BzKSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCB7fSwgLi4uY2hpbGRyZW4pO1xuICAgIH1cbiAgICByZW5kZXJWaWV3KHByb3BzKSB7XG4gICAgICAgIGxldCB7IHBsdWdpbkhvb2tzIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IHsgdmlld1NwZWMgfSA9IHByb3BzO1xuICAgICAgICBsZXQgdmlld1Byb3BzID0ge1xuICAgICAgICAgICAgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLFxuICAgICAgICAgICAgYnVzaW5lc3NIb3VyczogcHJvcHMuYnVzaW5lc3NIb3VycyxcbiAgICAgICAgICAgIGV2ZW50U3RvcmU6IHByb3BzLnJlbmRlcmFibGVFdmVudFN0b3JlLFxuICAgICAgICAgICAgZXZlbnRVaUJhc2VzOiBwcm9wcy5ldmVudFVpQmFzZXMsXG4gICAgICAgICAgICBkYXRlU2VsZWN0aW9uOiBwcm9wcy5kYXRlU2VsZWN0aW9uLFxuICAgICAgICAgICAgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLFxuICAgICAgICAgICAgZXZlbnREcmFnOiBwcm9wcy5ldmVudERyYWcsXG4gICAgICAgICAgICBldmVudFJlc2l6ZTogcHJvcHMuZXZlbnRSZXNpemUsXG4gICAgICAgICAgICBpc0hlaWdodEF1dG86IHByb3BzLmlzSGVpZ2h0QXV0byxcbiAgICAgICAgICAgIGZvclByaW50OiBwcm9wcy5mb3JQcmludCxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVycyA9IHRoaXMuYnVpbGRWaWV3UHJvcFRyYW5zZm9ybWVycyhwbHVnaW5Ib29rcy52aWV3UHJvcHNUcmFuc2Zvcm1lcnMpO1xuICAgICAgICBmb3IgKGxldCB0cmFuc2Zvcm1lciBvZiB0cmFuc2Zvcm1lcnMpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odmlld1Byb3BzLCB0cmFuc2Zvcm1lci50cmFuc2Zvcm0odmlld1Byb3BzLCBwcm9wcykpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBWaWV3Q29tcG9uZW50ID0gdmlld1NwZWMuY29tcG9uZW50O1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVmlld0NvbXBvbmVudCwgT2JqZWN0LmFzc2lnbih7fSwgdmlld1Byb3BzKSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkVG9vbGJhclByb3BzKHZpZXdTcGVjLCBkYXRlUHJvZmlsZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IsIGN1cnJlbnREYXRlLCBub3csIHRpdGxlKSB7XG4gICAgLy8gZG9uJ3QgZm9yY2UgYW55IGRhdGUtcHJvZmlsZXMgdG8gdmFsaWQgZGF0ZSBwcm9maWxlcyAodGhlIGBmYWxzZWApIHNvIHRoYXQgd2UgY2FuIHRlbGwgaWYgaXQncyBpbnZhbGlkXG4gICAgbGV0IHRvZGF5SW5mbyA9IGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkKG5vdywgdW5kZWZpbmVkLCBmYWxzZSk7IC8vIFRPRE86IG5lZWQgYHVuZGVmaW5lZGAgb3IgZWxzZSBJTkZJTklURSBMT09QIGZvciBzb21lIHJlYXNvblxuICAgIGxldCBwcmV2SW5mbyA9IGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkUHJldihkYXRlUHJvZmlsZSwgY3VycmVudERhdGUsIGZhbHNlKTtcbiAgICBsZXQgbmV4dEluZm8gPSBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZE5leHQoZGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlLCBmYWxzZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIGFjdGl2ZUJ1dHRvbjogdmlld1NwZWMudHlwZSxcbiAgICAgICAgbmF2VW5pdDogdmlld1NwZWMuc2luZ2xlVW5pdCxcbiAgICAgICAgaXNUb2RheUVuYWJsZWQ6IHRvZGF5SW5mby5pc1ZhbGlkICYmICFyYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZSwgbm93KSxcbiAgICAgICAgaXNQcmV2RW5hYmxlZDogcHJldkluZm8uaXNWYWxpZCxcbiAgICAgICAgaXNOZXh0RW5hYmxlZDogbmV4dEluZm8uaXNWYWxpZCxcbiAgICB9O1xufVxuLy8gUGx1Z2luXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gYnVpbGRWaWV3UHJvcFRyYW5zZm9ybWVycyh0aGVDbGFzc2VzKSB7XG4gICAgcmV0dXJuIHRoZUNsYXNzZXMubWFwKChUaGVDbGFzcykgPT4gbmV3IFRoZUNsYXNzKCkpO1xufVxuXG5jbGFzcyBDYWxlbmRhciBleHRlbmRzIENhbGVuZGFySW1wbCB7XG4gICAgY29uc3RydWN0b3IoZWwsIG9wdGlvbk92ZXJyaWRlcyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaXNSZW5kZXJpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1JlbmRlcmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3VycmVudENsYXNzTmFtZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jdXN0b21Db250ZW50UmVuZGVySWQgPSAwO1xuICAgICAgICB0aGlzLmhhbmRsZUFjdGlvbiA9IChhY3Rpb24pID0+IHtcbiAgICAgICAgICAgIC8vIGFjdGlvbnMgd2Uga25vdyB3ZSB3YW50IHRvIHJlbmRlciBpbW1lZGlhdGVseVxuICAgICAgICAgICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ1NFVF9FVkVOVF9EUkFHJzpcbiAgICAgICAgICAgICAgICBjYXNlICdTRVRfRVZFTlRfUkVTSVpFJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJSdW5uZXIudHJ5RHJhaW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEYXRhID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERhdGEgPSBkYXRhO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJSdW5uZXIucmVxdWVzdChkYXRhLmNhbGVuZGFyT3B0aW9ucy5yZXJlbmRlckRlbGF5KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVSZW5kZXJSZXF1ZXN0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzUmVuZGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxldCB7IGN1cnJlbnREYXRhIH0gPSB0aGlzO1xuICAgICAgICAgICAgICAgIGZsdXNoU3luYygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcihjcmVhdGVFbGVtZW50KENhbGVuZGFyUm9vdCwgeyBvcHRpb25zOiBjdXJyZW50RGF0YS5jYWxlbmRhck9wdGlvbnMsIHRoZW1lOiBjdXJyZW50RGF0YS50aGVtZSwgZW1pdHRlcjogY3VycmVudERhdGEuZW1pdHRlciB9LCAoY2xhc3NOYW1lcywgaGVpZ2h0LCBpc0hlaWdodEF1dG8sIGZvclByaW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldENsYXNzTmFtZXMoY2xhc3NOYW1lcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEhlaWdodChoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFJlbmRlcklkLlByb3ZpZGVyLCB7IHZhbHVlOiB0aGlzLmN1c3RvbUNvbnRlbnRSZW5kZXJJZCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoQ2FsZW5kYXJDb250ZW50LCBPYmplY3QuYXNzaWduKHsgaXNIZWlnaHRBdXRvOiBpc0hlaWdodEF1dG8sIGZvclByaW50OiBmb3JQcmludCB9LCBjdXJyZW50RGF0YSkpKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pLCB0aGlzLmVsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNSZW5kZXJlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNSZW5kZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJlbmRlcihudWxsLCB0aGlzLmVsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldENsYXNzTmFtZXMoW10pO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KCcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZW5zdXJlRWxIYXNTdHlsZXMoZWwpO1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMucmVuZGVyUnVubmVyID0gbmV3IERlbGF5ZWRSdW5uZXIodGhpcy5oYW5kbGVSZW5kZXJSZXF1ZXN0KTtcbiAgICAgICAgbmV3IENhbGVuZGFyRGF0YU1hbmFnZXIoe1xuICAgICAgICAgICAgb3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICAgICAgY2FsZW5kYXJBcGk6IHRoaXMsXG4gICAgICAgICAgICBvbkFjdGlvbjogdGhpcy5oYW5kbGVBY3Rpb24sXG4gICAgICAgICAgICBvbkRhdGE6IHRoaXMuaGFuZGxlRGF0YSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHdhc1JlbmRlcmluZyA9IHRoaXMuaXNSZW5kZXJpbmc7XG4gICAgICAgIGlmICghd2FzUmVuZGVyaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmlzUmVuZGVyaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tQ29udGVudFJlbmRlcklkICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW5kZXJSdW5uZXIucmVxdWVzdCgpO1xuICAgICAgICBpZiAod2FzUmVuZGVyaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNpemUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5pc1JlbmRlcmluZykge1xuICAgICAgICAgICAgdGhpcy5pc1JlbmRlcmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJSdW5uZXIucmVxdWVzdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVNpemUoKSB7XG4gICAgICAgIGZsdXNoU3luYygoKSA9PiB7XG4gICAgICAgICAgICBzdXBlci51cGRhdGVTaXplKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBiYXRjaFJlbmRlcmluZyhmdW5jKSB7XG4gICAgICAgIHRoaXMucmVuZGVyUnVubmVyLnBhdXNlKCdiYXRjaFJlbmRlcmluZycpO1xuICAgICAgICBmdW5jKCk7XG4gICAgICAgIHRoaXMucmVuZGVyUnVubmVyLnJlc3VtZSgnYmF0Y2hSZW5kZXJpbmcnKTtcbiAgICB9XG4gICAgcGF1c2VSZW5kZXJpbmcoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyUnVubmVyLnBhdXNlKCdwYXVzZVJlbmRlcmluZycpO1xuICAgIH1cbiAgICByZXN1bWVSZW5kZXJpbmcoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyUnVubmVyLnJlc3VtZSgncGF1c2VSZW5kZXJpbmcnLCB0cnVlKTtcbiAgICB9XG4gICAgcmVzZXRPcHRpb25zKG9wdGlvbk92ZXJyaWRlcywgY2hhbmdlZE9wdGlvbk5hbWVzKSB7XG4gICAgICAgIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLnJlc2V0T3B0aW9ucyhvcHRpb25PdmVycmlkZXMsIGNoYW5nZWRPcHRpb25OYW1lcyk7XG4gICAgfVxuICAgIHNldENsYXNzTmFtZXMoY2xhc3NOYW1lcykge1xuICAgICAgICBpZiAoIWlzQXJyYXlzRXF1YWwoY2xhc3NOYW1lcywgdGhpcy5jdXJyZW50Q2xhc3NOYW1lcykpIHtcbiAgICAgICAgICAgIGxldCB7IGNsYXNzTGlzdCB9ID0gdGhpcy5lbDtcbiAgICAgICAgICAgIGZvciAobGV0IGNsYXNzTmFtZSBvZiB0aGlzLmN1cnJlbnRDbGFzc05hbWVzKSB7XG4gICAgICAgICAgICAgICAgY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgY2xhc3NOYW1lIG9mIGNsYXNzTmFtZXMpIHtcbiAgICAgICAgICAgICAgICBjbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDbGFzc05hbWVzID0gY2xhc3NOYW1lcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIGFwcGx5U3R5bGVQcm9wKHRoaXMuZWwsICdoZWlnaHQnLCBoZWlnaHQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlSW5wdXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBkYXRlRW52ID0gYnVpbGREYXRlRW52KG9wdGlvbnMpO1xuICAgIGxldCBmb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIob3B0aW9ucyk7XG4gICAgbGV0IGRhdGVNZXRhID0gZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKGRhdGVJbnB1dCk7XG4gICAgaWYgKCFkYXRlTWV0YSkgeyAvLyBUT0RPOiB3YXJuaW5nP1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBkYXRlRW52LmZvcm1hdChkYXRlTWV0YS5tYXJrZXIsIGZvcm1hdHRlciwge1xuICAgICAgICBmb3JjZWRUem86IGRhdGVNZXRhLmZvcmNlZFR6byxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFJhbmdlKHN0YXJ0SW5wdXQsIGVuZElucHV0LCBvcHRpb25zKSB7XG4gICAgbGV0IGRhdGVFbnYgPSBidWlsZERhdGVFbnYodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMgPyBvcHRpb25zIDoge30pOyAvLyBwYXNzIGluIGlmIG5vbi1udWxsIG9iamVjdFxuICAgIGxldCBmb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIob3B0aW9ucyk7XG4gICAgbGV0IHN0YXJ0TWV0YSA9IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShzdGFydElucHV0KTtcbiAgICBsZXQgZW5kTWV0YSA9IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShlbmRJbnB1dCk7XG4gICAgaWYgKCFzdGFydE1ldGEgfHwgIWVuZE1ldGEpIHsgLy8gVE9ETzogd2FybmluZz9cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShzdGFydE1ldGEubWFya2VyLCBlbmRNZXRhLm1hcmtlciwgZm9ybWF0dGVyLCB7XG4gICAgICAgIGZvcmNlZFN0YXJ0VHpvOiBzdGFydE1ldGEuZm9yY2VkVHpvLFxuICAgICAgICBmb3JjZWRFbmRUem86IGVuZE1ldGEuZm9yY2VkVHpvLFxuICAgICAgICBpc0VuZEV4Y2x1c2l2ZTogb3B0aW9ucy5pc0VuZEV4Y2x1c2l2ZSxcbiAgICAgICAgZGVmYXVsdFNlcGFyYXRvcjogQkFTRV9PUFRJT05fREVGQVVMVFMuZGVmYXVsdFJhbmdlU2VwYXJhdG9yLFxuICAgIH0pO1xufVxuLy8gVE9ETzogbW9yZSBEUlkgYW5kIG9wdGltaXplZFxuZnVuY3Rpb24gYnVpbGREYXRlRW52KHNldHRpbmdzKSB7XG4gICAgbGV0IGxvY2FsZSA9IGJ1aWxkTG9jYWxlKHNldHRpbmdzLmxvY2FsZSB8fCAnZW4nLCBvcmdhbml6ZVJhd0xvY2FsZXMoW10pLm1hcCk7IC8vIFRPRE86IGRvbid0IGhhcmRjb2RlICdlbicgZXZlcnl3aGVyZVxuICAgIHJldHVybiBuZXcgRGF0ZUVudihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyB0aW1lWm9uZTogQkFTRV9PUFRJT05fREVGQVVMVFMudGltZVpvbmUsIGNhbGVuZGFyU3lzdGVtOiAnZ3JlZ29yeScgfSwgc2V0dGluZ3MpLCB7IGxvY2FsZSB9KSk7XG59XG5cbi8vIEhFTFBFUlNcbi8qXG5pZiBuZXh0RGF5VGhyZXNob2xkIGlzIHNwZWNpZmllZCwgc2xpY2luZyBpcyBkb25lIGluIGFuIGFsbC1kYXkgZmFzaGlvbi5cbnlvdSBjYW4gZ2V0IG5leHREYXlUaHJlc2hvbGQgZnJvbSBjb250ZXh0Lm5leHREYXlUaHJlc2hvbGRcbiovXG5mdW5jdGlvbiBzbGljZUV2ZW50cyhwcm9wcywgYWxsRGF5KSB7XG4gICAgcmV0dXJuIHNsaWNlRXZlbnRTdG9yZShwcm9wcy5ldmVudFN0b3JlLCBwcm9wcy5ldmVudFVpQmFzZXMsIHByb3BzLmRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBhbGxEYXkgPyBwcm9wcy5uZXh0RGF5VGhyZXNob2xkIDogbnVsbCkuZmc7XG59XG5cbmNvbnN0IHZlcnNpb24gPSAnNi4xLjE1JztcblxuZXhwb3J0IHsgQ2FsZW5kYXIsIGNyZWF0ZVBsdWdpbiwgZm9ybWF0RGF0ZSwgZm9ybWF0UmFuZ2UsIGdsb2JhbExvY2FsZXMsIGdsb2JhbFBsdWdpbnMsIHNsaWNlRXZlbnRzLCB2ZXJzaW9uIH07XG4iXSwibmFtZXMiOlsibSIsIm1lcmdlUHJvcHMiLCJnIiwiZ3VpZCIsImkiLCJpc0FycmF5c0VxdWFsIiwiVCIsIlRoZW1lIiwiYSIsIm1hcEhhc2giLCJCIiwiQmFzZUNvbXBvbmVudCIsIlYiLCJWaWV3Q29udGV4dFR5cGUiLCJDIiwiQ29udGVudENvbnRhaW5lciIsImIiLCJidWlsZFZpZXdDbGFzc05hbWVzIiwiYyIsImdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvciIsImQiLCJjcmVhdGVEdXJhdGlvbiIsImUiLCJCQVNFX09QVElPTl9ERUZBVUxUUyIsImYiLCJhcnJheVRvSGFzaCIsImgiLCJmaWx0ZXJIYXNoIiwiaiIsImJ1aWxkRXZlbnRTb3VyY2VSZWZpbmVycyIsInAiLCJwYXJzZUV2ZW50U291cmNlIiwiayIsImZvcm1hdFdpdGhPcmRpbmFscyIsInUiLCJ1bnByb21pc2lmeSIsImwiLCJidWlsZFJhbmdlQXBpV2l0aFRpbWVab25lIiwibiIsImlkZW50aXR5IiwiciIsInJlcXVlc3RKc29uIiwicyIsInN1YnRyYWN0RHVyYXRpb25zIiwibyIsImludGVyc2VjdFJhbmdlcyIsInEiLCJzdGFydE9mRGF5IiwidCIsImFkZERheXMiLCJ2IiwiaGFzaFZhbHVlc1RvQXJyYXkiLCJ3IiwiYnVpbGRFdmVudEFwaXMiLCJEIiwiRGVsYXllZFJ1bm5lciIsIngiLCJjcmVhdGVGb3JtYXR0ZXIiLCJ5IiwiZGlmZldob2xlRGF5cyIsInoiLCJtZW1vaXplIiwiQSIsIm1lbW9pemVPYmpBcmciLCJFIiwiaXNQcm9wc0VxdWFsIiwiRiIsIkVtaXR0ZXIiLCJHIiwiZ2V0SW5pdGlhbERhdGUiLCJIIiwicmFuZ2VDb250YWluc01hcmtlciIsIkkiLCJjcmVhdGVFbXB0eUV2ZW50U3RvcmUiLCJKIiwicmVkdWNlQ3VycmVudERhdGUiLCJLIiwicmVkdWNlRXZlbnRTdG9yZSIsIkwiLCJyZXpvbmVFdmVudFN0b3JlRGF0ZXMiLCJNIiwibWVyZ2VSYXdPcHRpb25zIiwiTiIsIkJBU0VfT1BUSU9OX1JFRklORVJTIiwiTyIsIkNBTEVOREFSX0xJU1RFTkVSX1JFRklORVJTIiwiUCIsIkNBTEVOREFSX09QVElPTl9SRUZJTkVSUyIsIlEiLCJDT01QTEVYX09QVElPTl9DT01QQVJBVE9SUyIsIlIiLCJWSUVXX09QVElPTl9SRUZJTkVSUyIsIlMiLCJEYXRlRW52IiwiVSIsIkRhdGVQcm9maWxlR2VuZXJhdG9yIiwiVyIsImNyZWF0ZUV2ZW50VWkiLCJYIiwicGFyc2VCdXNpbmVzc0hvdXJzIiwiWSIsInNldFJlZiIsIloiLCJJbnRlcmFjdGlvbiIsIl8iLCJnZXRFbFNlZyIsIiQiLCJlbGVtZW50Q2xvc2VzdCIsImEwIiwiRXZlbnRJbXBsIiwiYTEiLCJsaXN0ZW5CeVNlbGVjdG9yIiwiYTIiLCJsaXN0ZW5Ub0hvdmVyQnlTZWxlY3RvciIsImEzIiwiUHVyZUNvbXBvbmVudCIsImE0IiwiYnVpbGRWaWV3Q29udGV4dCIsImE1IiwiZ2V0VW5pcXVlRG9tSWQiLCJhNiIsInBhcnNlSW50ZXJhY3Rpb25TZXR0aW5ncyIsImE3IiwiaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlIiwiYTgiLCJnZXROb3ciLCJhOSIsIkNhbGVuZGFySW1wbCIsImFhIiwiZmx1c2hTeW5jIiwiYWIiLCJDYWxlbmRhclJvb3QiLCJhYyIsIlJlbmRlcklkIiwiYWQiLCJlbnN1cmVFbEhhc1N0eWxlcyIsImFlIiwiYXBwbHlTdHlsZVByb3AiLCJhZiIsInNsaWNlRXZlbnRTdG9yZSIsImFnIiwiSnNvblJlcXVlc3RFcnJvciIsImNyZWF0ZUVsZW1lbnQiLCJjcmVhdGVSZWYiLCJGcmFnbWVudCIsInJlbmRlciIsImdsb2JhbExvY2FsZXMiLCJNSU5JTUFMX1JBV19FTl9MT0NBTEUiLCJjb2RlIiwid2VlayIsImRvdyIsImRveSIsImRpcmVjdGlvbiIsImJ1dHRvblRleHQiLCJwcmV2IiwibmV4dCIsInByZXZZZWFyIiwibmV4dFllYXIiLCJ5ZWFyIiwidG9kYXkiLCJtb250aCIsImRheSIsImxpc3QiLCJ3ZWVrVGV4dCIsIndlZWtUZXh0TG9uZyIsImNsb3NlSGludCIsInRpbWVIaW50IiwiZXZlbnRIaW50IiwiYWxsRGF5VGV4dCIsIm1vcmVMaW5rVGV4dCIsIm5vRXZlbnRzVGV4dCIsIlJBV19FTl9MT0NBTEUiLCJPYmplY3QiLCJhc3NpZ24iLCJidXR0b25IaW50cyIsInVuaXQiLCJ2aWV3SGludCIsIm5hdkxpbmtIaW50IiwibW9yZUxpbmtIaW50IiwiZXZlbnRDbnQiLCJvcmdhbml6ZVJhd0xvY2FsZXMiLCJleHBsaWNpdFJhd0xvY2FsZXMiLCJkZWZhdWx0Q29kZSIsImxlbmd0aCIsImFsbFJhd0xvY2FsZXMiLCJjb25jYXQiLCJyYXdMb2NhbGVNYXAiLCJlbiIsInJhd0xvY2FsZSIsIm1hcCIsImJ1aWxkTG9jYWxlIiwiaW5wdXRTaW5ndWxhciIsImF2YWlsYWJsZSIsIkFycmF5IiwiaXNBcnJheSIsInBhcnNlTG9jYWxlIiwicXVlcnlMb2NhbGUiLCJjb2RlQXJnIiwiY29kZXMiLCJyYXciLCJxdWVyeVJhd0xvY2FsZSIsInBhcnRzIiwidG9Mb2NhbGVMb3dlckNhc2UiLCJzcGxpdCIsInNpbXBsZUlkIiwic2xpY2UiLCJqb2luIiwibWVyZ2VkIiwic2ltcGxlTnVtYmVyRm9ybWF0IiwiSW50bCIsIk51bWJlckZvcm1hdCIsIm9wdGlvbnMiLCJjcmVhdGVQbHVnaW4iLCJpbnB1dCIsImlkIiwibmFtZSIsInByZW1pdW1SZWxlYXNlRGF0ZSIsIkRhdGUiLCJ1bmRlZmluZWQiLCJkZXBzIiwicmVkdWNlcnMiLCJpc0xvYWRpbmdGdW5jcyIsImNvbnRleHRJbml0IiwiZXZlbnRSZWZpbmVycyIsImV2ZW50RGVmTWVtYmVyQWRkZXJzIiwiZXZlbnRTb3VyY2VSZWZpbmVycyIsImlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzIiwiZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnMiLCJldmVudERlZk11dGF0aW9uQXBwbGllcnMiLCJkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzIiwiZGF0ZVBvaW50VHJhbnNmb3JtcyIsImRhdGVTcGFuVHJhbnNmb3JtcyIsInZpZXdzIiwidmlld1Byb3BzVHJhbnNmb3JtZXJzIiwiaXNQcm9wc1ZhbGlkIiwiZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zIiwidmlld0NvbnRhaW5lckFwcGVuZHMiLCJldmVudERyb3BUcmFuc2Zvcm1lcnMiLCJjb21wb25lbnRJbnRlcmFjdGlvbnMiLCJjYWxlbmRhckludGVyYWN0aW9ucyIsInRoZW1lQ2xhc3NlcyIsImV2ZW50U291cmNlRGVmcyIsImNtZEZvcm1hdHRlciIsInJlY3VycmluZ1R5cGVzIiwibmFtZWRUaW1lWm9uZWRJbXBsIiwiaW5pdGlhbFZpZXciLCJlbGVtZW50RHJhZ2dpbmdJbXBsIiwib3B0aW9uQ2hhbmdlSGFuZGxlcnMiLCJzY3JvbGxHcmlkSW1wbCIsImxpc3RlbmVyUmVmaW5lcnMiLCJvcHRpb25SZWZpbmVycyIsInByb3BTZXRIYW5kbGVycyIsImJ1aWxkUGx1Z2luSG9va3MiLCJwbHVnaW5EZWZzIiwiZ2xvYmFsRGVmcyIsImN1cnJlbnRQbHVnaW5JZHMiLCJob29rcyIsImFkZERlZnMiLCJkZWZzIiwiZGVmIiwicGx1Z2luTmFtZSIsImN1cnJlbnRJZCIsImNvbWJpbmVIb29rcyIsImNvbnNvbGUiLCJ3YXJuIiwiYnVpbGRCdWlsZFBsdWdpbkhvb2tzIiwiY3VycmVudE92ZXJyaWRlRGVmcyIsImN1cnJlbnRHbG9iYWxEZWZzIiwiY3VycmVudEhvb2tzIiwib3ZlcnJpZGVEZWZzIiwiaG9va3MwIiwiaG9va3MxIiwiY29tcGFyZU9wdGlvbmFsRGF0ZXMiLCJkYXRlMCIsImRhdGUxIiwiTWF0aCIsIm1heCIsInZhbHVlT2YiLCJTdGFuZGFyZFRoZW1lIiwicHJvdG90eXBlIiwiY2xhc3NlcyIsInJvb3QiLCJ0YWJsZUNlbGxTaGFkZWQiLCJidXR0b25Hcm91cCIsImJ1dHRvbiIsImJ1dHRvbkFjdGl2ZSIsImJhc2VJY29uQ2xhc3MiLCJpY29uQ2xhc3NlcyIsImNsb3NlIiwicnRsSWNvbkNsYXNzZXMiLCJpY29uT3ZlcnJpZGVPcHRpb24iLCJpY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb24iLCJpY29uT3ZlcnJpZGVQcmVmaXgiLCJjb21waWxlVmlld0RlZnMiLCJkZWZhdWx0Q29uZmlncyIsIm92ZXJyaWRlQ29uZmlncyIsImhhc2giLCJ2aWV3VHlwZSIsImVuc3VyZVZpZXdEZWYiLCJ2aWV3RGVmIiwiYnVpbGRWaWV3RGVmIiwiZGVmYXVsdENvbmZpZyIsIm92ZXJyaWRlQ29uZmlnIiwicXVlcnlQcm9wIiwidGhlQ29tcG9uZW50Iiwic3VwZXJUeXBlIiwic3VwZXJEZWYiLCJFcnJvciIsImNvbXBvbmVudCIsInR5cGUiLCJkZWZhdWx0cyIsInJhd09wdGlvbnMiLCJvdmVycmlkZXMiLCJwYXJzZVZpZXdDb25maWdzIiwiaW5wdXRzIiwicGFyc2VWaWV3Q29uZmlnIiwiY29udGVudCIsImNyZWF0ZVZpZXdIb29rQ29tcG9uZW50Iiwidmlld1Byb3BzIiwiQ29uc3VtZXIiLCJjb250ZXh0IiwiZWxUYWciLCJlbENsYXNzZXMiLCJ2aWV3U3BlYyIsInJlbmRlclByb3BzIiwibmV4dERheVRocmVzaG9sZCIsImdlbmVyYXRvck5hbWUiLCJjdXN0b21HZW5lcmF0b3IiLCJjbGFzc05hbWVHZW5lcmF0b3IiLCJjbGFzc05hbWVzIiwiZGlkTW91bnQiLCJ3aWxsVW5tb3VudCIsImJ1aWxkVmlld1NwZWNzIiwiZGVmYXVsdElucHV0cyIsIm9wdGlvbk92ZXJyaWRlcyIsImR5bmFtaWNPcHRpb25PdmVycmlkZXMiLCJsb2NhbGVEZWZhdWx0cyIsInZpZXdEZWZzIiwiYnVpbGRWaWV3U3BlYyIsImR1cmF0aW9uSW5wdXQiLCJkdXJhdGlvbiIsImR1cmF0aW9uVW5pdCIsInNpbmdsZVVuaXQiLCJzaW5nbGVVbml0T3ZlcnJpZGVzIiwiY3JlYXRlRHVyYXRpb25DYWNoZWQiLCJkZW5vbSIsInZhbHVlIiwicXVlcnlCdXR0b25UZXh0Iiwib3B0aW9uc1N1YnNldCIsImJ1dHRvblRleHRNYXAiLCJidXR0b25UZXh0S2V5IiwicXVlcnlCdXR0b25UaXRsZSIsImJ1dHRvbktleSIsIm9wdGlvbkRlZmF1bHRzIiwiYnV0dG9uVGV4dE92ZXJyaWRlIiwiYnV0dG9uVGV4dERlZmF1bHQiLCJidXR0b25UaXRsZU92ZXJyaWRlIiwiYnV0dG9uSGludCIsImJ1dHRvblRpdGxlRGVmYXVsdCIsImR1cmF0aW9uSW5wdXRNYXAiLCJqc29uIiwiSlNPTiIsInN0cmluZ2lmeSIsInJlcyIsInJlZHVjZVZpZXdUeXBlIiwiYWN0aW9uIiwicmVkdWNlRHluYW1pY09wdGlvbk92ZXJyaWRlcyIsIm9wdGlvbk5hbWUiLCJyYXdPcHRpb25WYWx1ZSIsInJlZHVjZURhdGVQcm9maWxlIiwiY3VycmVudERhdGVQcm9maWxlIiwiY3VycmVudERhdGUiLCJkYXRlUHJvZmlsZUdlbmVyYXRvciIsImRwIiwiYnVpbGQiLCJkYXRlTWFya2VyIiwiYnVpbGRQcmV2IiwiaXNWYWxpZCIsImJ1aWxkTmV4dCIsImluaXRFdmVudFNvdXJjZXMiLCJjYWxlbmRhck9wdGlvbnMiLCJkYXRlUHJvZmlsZSIsImFjdGl2ZVJhbmdlIiwiYWRkU291cmNlcyIsInBhcnNlSW5pdGlhbFNvdXJjZXMiLCJyZWR1Y2VFdmVudFNvdXJjZXMiLCJldmVudFNvdXJjZXMiLCJzb3VyY2VzIiwicmVtb3ZlU291cmNlIiwic291cmNlSWQiLCJmZXRjaERpcnR5U291cmNlcyIsImZldGNoU291cmNlc0J5SWRzIiwic291cmNlSWRzIiwiZXhjbHVkZVN0YXRpY1NvdXJjZXMiLCJpc1JlZmV0Y2giLCJyZWNlaXZlUmVzcG9uc2UiLCJmZXRjaElkIiwiZmV0Y2hSYW5nZSIsInJlZHVjZUV2ZW50U291cmNlc05ld1RpbWVab25lIiwiY29tcHV0ZUV2ZW50U291cmNlc0xvYWRpbmciLCJpc0ZldGNoaW5nIiwiZXZlbnRTb3VyY2VIYXNoIiwic291cmNlIiwiZXZlbnRTb3VyY2UiLCJzb3VyY2VIYXNoIiwiaXNTb3VyY2VEaXJ0eSIsImRvZXNTb3VyY2VOZWVkUmFuZ2UiLCJsYXRlc3RGZXRjaElkIiwibGF6eUZldGNoaW5nIiwic3RhcnQiLCJlbmQiLCJwcmV2U291cmNlcyIsInNvdXJjZUlkSGFzaCIsIm5leHRTb3VyY2VzIiwiZmV0Y2hTb3VyY2UiLCJjYWxlbmRhckFwaSIsInNvdXJjZURlZiIsInBsdWdpbkhvb2tzIiwic291cmNlRGVmSWQiLCJmZXRjaCIsInJhbmdlIiwicmF3RXZlbnRzIiwiZXZlbnRTb3VyY2VTdWNjZXNzIiwiY2FsbCIsInJlc3BvbnNlIiwic3VjY2VzcyIsImRpc3BhdGNoIiwiZXJyb3IiLCJlcnJvckhhbmRsZWQiLCJldmVudFNvdXJjZUZhaWx1cmUiLCJmYWlsdXJlIiwibWVzc2FnZSIsInJlZmluZXJzIiwicmF3U291cmNlcyIsImluaXRpYWxFdmVudHMiLCJ1bnNoaWZ0IiwiZXZlbnRzIiwicmF3U291cmNlIiwicHVzaCIsImlnbm9yZVJhbmdlIiwicmVkdWNlRGF0ZVNlbGVjdGlvbiIsImN1cnJlbnRTZWxlY3Rpb24iLCJzZWxlY3Rpb24iLCJyZWR1Y2VTZWxlY3RlZEV2ZW50IiwiY3VycmVudEluc3RhbmNlSWQiLCJldmVudEluc3RhbmNlSWQiLCJyZWR1Y2VFdmVudERyYWciLCJjdXJyZW50RHJhZyIsIm5ld0RyYWciLCJzdGF0ZSIsImFmZmVjdGVkRXZlbnRzIiwibXV0YXRlZEV2ZW50cyIsImlzRXZlbnQiLCJyZWR1Y2VFdmVudFJlc2l6ZSIsImN1cnJlbnRSZXNpemUiLCJuZXdSZXNpemUiLCJwYXJzZVRvb2xiYXJzIiwiY2FsZW5kYXJPcHRpb25PdmVycmlkZXMiLCJ0aGVtZSIsInZpZXdTcGVjcyIsImhlYWRlciIsImhlYWRlclRvb2xiYXIiLCJwYXJzZVRvb2xiYXIiLCJmb290ZXIiLCJmb290ZXJUb29sYmFyIiwic2VjdGlvblN0ckhhc2giLCJzZWN0aW9uV2lkZ2V0cyIsInZpZXdzV2l0aEJ1dHRvbnMiLCJoYXNUaXRsZSIsInNlY3Rpb25OYW1lIiwic2VjdGlvblN0ciIsInNlY3Rpb25SZXMiLCJwYXJzZVNlY3Rpb24iLCJ3aWRnZXRzIiwiaXNSdGwiLCJjYWxlbmRhckN1c3RvbUJ1dHRvbnMiLCJjdXN0b21CdXR0b25zIiwiY2FsZW5kYXJCdXR0b25UZXh0T3ZlcnJpZGVzIiwiY2FsZW5kYXJCdXR0b25UZXh0IiwiY2FsZW5kYXJCdXR0b25IaW50T3ZlcnJpZGVzIiwiY2FsZW5kYXJCdXR0b25IaW50cyIsInNlY3Rpb25TdWJzdHJzIiwiYnV0dG9uR3JvdXBTdHIiLCJidXR0b25OYW1lIiwiY3VzdG9tQnV0dG9uUHJvcHMiLCJidXR0b25DbGljayIsImJ1dHRvbkljb24iLCJldiIsImNsaWNrIiwidGFyZ2V0IiwiZ2V0Q3VzdG9tQnV0dG9uSWNvbkNsYXNzIiwiZ2V0SWNvbkNsYXNzIiwidGV4dCIsImhpbnQiLCJjaGFuZ2VWaWV3IiwidGV4dEZhbGxiYWNrIiwicHJldk9yTmV4dCIsIm5hdlVuaXQiLCJWaWV3SW1wbCIsImNvbnN0cnVjdG9yIiwiZ2V0Q3VycmVudERhdGEiLCJkYXRlRW52IiwiY2FsZW5kYXIiLCJ0aXRsZSIsInZpZXdUaXRsZSIsImFjdGl2ZVN0YXJ0IiwidG9EYXRlIiwiYWN0aXZlRW5kIiwiY3VycmVudFN0YXJ0IiwiY3VycmVudFJhbmdlIiwiY3VycmVudEVuZCIsImdldE9wdGlvbiIsImV2ZW50U291cmNlRGVmJDIiLCJwYXJzZU1ldGEiLCJyZWZpbmVkIiwiYXJnIiwic3VjY2Vzc0NhbGxiYWNrIiwibWV0YSIsImFycmF5RXZlbnRTb3VyY2VQbHVnaW4iLCJldmVudFNvdXJjZURlZiQxIiwiZXJyb3JDYWxsYmFjayIsImZ1bmMiLCJiaW5kIiwiZnVuY0V2ZW50U291cmNlUGx1Z2luIiwiSlNPTl9GRUVEX0VWRU5UX1NPVVJDRV9SRUZJTkVSUyIsIm1ldGhvZCIsIlN0cmluZyIsImV4dHJhUGFyYW1zIiwic3RhcnRQYXJhbSIsImVuZFBhcmFtIiwidGltZVpvbmVQYXJhbSIsImV2ZW50U291cmNlRGVmIiwidXJsIiwiZm9ybWF0IiwidG9VcHBlckNhc2UiLCJyZXF1ZXN0UGFyYW1zIiwiYnVpbGRSZXF1ZXN0UGFyYW1zIiwidGhlbiIsImpzb25GZWVkRXZlbnRTb3VyY2VQbHVnaW4iLCJjdXN0b21SZXF1ZXN0UGFyYW1zIiwicGFyYW1zIiwiZm9ybWF0SXNvIiwidGltZVpvbmUiLCJTSU1QTEVfUkVDVVJSSU5HX1JFRklORVJTIiwiZGF5c09mV2VlayIsInN0YXJ0VGltZSIsImVuZFRpbWUiLCJzdGFydFJlY3VyIiwiZW5kUmVjdXIiLCJyZWN1cnJpbmciLCJwYXJzZSIsInJlY3VycmluZ0RhdGEiLCJjcmVhdGVNYXJrZXIiLCJhbGxEYXlHdWVzcyIsIkJvb2xlYW4iLCJ0eXBlRGF0YSIsImV4cGFuZCIsImZyYW1pbmdSYW5nZSIsImNsaXBwZWRGcmFtaW5nUmFuZ2UiLCJleHBhbmRSYW5nZXMiLCJzaW1wbGVSZWN1cnJpbmdFdmVudHNQbHVnaW4iLCJkb3dIYXNoIiwiZGF5TWFya2VyIiwiZW5kTWFya2VyIiwiaW5zdGFuY2VTdGFydHMiLCJpbnN0YW5jZVN0YXJ0IiwiZ2V0VVRDRGF5IiwiYWRkIiwiY2hhbmdlSGFuZGxlclBsdWdpbiIsImhhbmRsZUV2ZW50U291cmNlcyIsInVuZm91bmRTb3VyY2VzIiwiX3JhdyIsIm5ld0lucHV0cyIsImlucHV0Rm91bmQiLCJzcGxpY2UiLCJ1bmZvdW5kU291cmNlIiwibmV3SW5wdXQiLCJhZGRFdmVudFNvdXJjZSIsImhhbmRsZURhdGVQcm9maWxlIiwiZW1pdHRlciIsInRyaWdnZXIiLCJ2aWV3Iiwidmlld0FwaSIsImhhbmRsZUV2ZW50U3RvcmUiLCJldmVudFN0b3JlIiwiaGFzSGFuZGxlcnMiLCJnbG9iYWxQbHVnaW5zIiwiVGFza1J1bm5lciIsInJ1blRhc2tPcHRpb24iLCJkcmFpbmVkT3B0aW9uIiwicXVldWUiLCJkZWxheWVkUnVubmVyIiwiZHJhaW4iLCJyZXF1ZXN0IiwidGFzayIsImRlbGF5IiwicGF1c2UiLCJzY29wZSIsInJlc3VtZSIsImZvcmNlIiwiY29tcGxldGVkVGFza3MiLCJzaGlmdCIsInJ1blRhc2siLCJkcmFpbmVkIiwiYnVpbGRUaXRsZSIsInZpZXdPcHRpb25zIiwidGVzdCIsImN1cnJlbnRSYW5nZVVuaXQiLCJmb3JtYXRSYW5nZSIsInRpdGxlRm9ybWF0IiwiYnVpbGRUaXRsZUZvcm1hdCIsImlzRW5kRXhjbHVzaXZlIiwiaXNSYW5nZUFsbERheSIsImRlZmF1bHRTZXBhcmF0b3IiLCJ0aXRsZVJhbmdlU2VwYXJhdG9yIiwiZGF5cyIsIkNhbGVuZGFyRGF0YU1hbmFnZXIiLCJwcm9wcyIsImNvbXB1dGVDdXJyZW50Vmlld0RhdGEiLCJfY29tcHV0ZUN1cnJlbnRWaWV3RGF0YSIsImJ1aWxkRGF0ZUVudiIsImJ1aWxkRGF0ZUVudiQxIiwiYnVpbGRUaGVtZSIsImJ1aWxkRGF0ZVByb2ZpbGVHZW5lcmF0b3IiLCJidWlsZFZpZXdBcGkiLCJidWlsZFZpZXdVaVByb3BzIiwiYnVpbGRFdmVudFVpQnlTb3VyY2UiLCJidWlsZEV2ZW50VWlCYXNlcyIsInBhcnNlQ29udGV4dEJ1c2luZXNzSG91cnMiLCJhY3Rpb25SdW5uZXIiLCJfaGFuZGxlQWN0aW9uIiwidXBkYXRlRGF0YSIsImN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dCIsImN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkIiwiY3VycmVudFZpZXdPcHRpb25zSW5wdXQiLCJjdXJyZW50Vmlld09wdGlvbnNSZWZpbmVkIiwiY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZXJzIiwib3B0aW9uc0ZvclJlZmluaW5nIiwib3B0aW9uc0ZvckhhbmRsaW5nIiwiZGF0YSIsIm9wdGlvbnNEYXRhIiwiY29tcHV0ZU9wdGlvbnNEYXRhIiwiY3VycmVudFZpZXdUeXBlIiwiY3VycmVudFZpZXdEYXRhIiwiY3VycmVudERhdGFNYW5hZ2VyIiwic2V0VGhpc0NvbnRleHQiLCJzZXRPcHRpb25zIiwiY2FsZW5kYXJDb250ZXh0IiwiY2FsbGJhY2siLCJpbml0aWFsU3RhdGUiLCJidXNpbmVzc0hvdXJzIiwiZXZlbnRVaUJhc2VzIiwicmVuZGVyYWJsZUV2ZW50U3RvcmUiLCJkYXRlU2VsZWN0aW9uIiwiZXZlbnRTZWxlY3Rpb24iLCJldmVudERyYWciLCJldmVudFJlc2l6ZSIsInNlbGVjdGlvbkNvbmZpZyIsImNvbnRleHRBbmRTdGF0ZSIsInJlZHVjZXIiLCJjb21wdXRlSXNMb2FkaW5nIiwicmVzZXRPcHRpb25zIiwiY2hhbmdlZE9wdGlvbk5hbWVzIiwiaXNFdmVudHNMb2FkaW5nIiwicHJvZ3Jlc3NpdmVFdmVudFJlbmRlcmluZyIsImV2ZW50VWlTaW5nbGVCYXNlIiwiZXZlbnRVaUJ5U291cmNlIiwibmV3U3RhdGUiLCJ3YXNMb2FkaW5nIiwiaXNMb2FkaW5nIiwib25BY3Rpb24iLCJvbGREYXRhIiwiY2hhbmdlSGFuZGxlcnMiLCJvbGRDYWxlbmRhck9wdGlvbnMiLCJuZXdDYWxlbmRhck9wdGlvbnMiLCJpbmRleE9mIiwib25EYXRhIiwic3RhYmxlT3B0aW9uT3ZlcnJpZGVzIiwic3RhYmxlRHluYW1pY09wdGlvbk92ZXJyaWRlcyIsInN0YWJsZUNhbGVuZGFyT3B0aW9uc0RhdGEiLCJyZWZpbmVkT3B0aW9ucyIsImF2YWlsYWJsZUxvY2FsZURhdGEiLCJleHRyYSIsInByb2Nlc3NSYXdDYWxlbmRhck9wdGlvbnMiLCJ3YXJuVW5rbm93bk9wdGlvbnMiLCJsb2NhbGUiLCJ3ZWVrTnVtYmVyQ2FsY3VsYXRpb24iLCJmaXJzdERheSIsImRlZmF1bHRSYW5nZVNlcGFyYXRvciIsInRvb2xiYXJDb25maWciLCJhdmFpbGFibGVSYXdMb2NhbGVzIiwibG9jYWxlcyIsInBsdWdpbnMiLCJjdXJyZW50UmF3IiwiY3VycmVudFJlZmluZWQiLCJhbnlDaGFuZ2VzIiwicHJvY2Vzc1Jhd1ZpZXdPcHRpb25zIiwiZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyIsInVzZXNNaW5NYXhUaW1lIiwic2xvdE1pblRpbWUiLCJzbG90TWF4VGltZSIsInNob3dOb25DdXJyZW50RGF0ZXMiLCJkYXlDb3VudCIsImRhdGVBbGlnbm1lbnQiLCJkYXRlSW5jcmVtZW50IiwiaGlkZGVuRGF5cyIsIndlZWtlbmRzIiwibm93SW5wdXQiLCJub3ciLCJ2YWxpZFJhbmdlSW5wdXQiLCJ2YWxpZFJhbmdlIiwidmlzaWJsZVJhbmdlSW5wdXQiLCJ2aXNpYmxlUmFuZ2UiLCJmaXhlZFdlZWtDb3VudCIsImV4cGxpY2l0TG9jYWxlIiwiY2FsZW5kYXJTeXN0ZW0iLCJuYW1lZFRpbWVab25lSW1wbCIsIlRoZW1lQ2xhc3MiLCJ0aGVtZVN5c3RlbSIsIkRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MiLCJ1aSIsImV2ZW50RGVmcyIsImRlZklkIiwiZGlzcGxheSIsImV2ZW50RGlzcGxheSIsImVkaXRhYmxlIiwic3RhcnRFZGl0YWJsZSIsImV2ZW50U3RhcnRFZGl0YWJsZSIsImR1cmF0aW9uRWRpdGFibGUiLCJldmVudER1cmF0aW9uRWRpdGFibGUiLCJjb25zdHJhaW50IiwiZXZlbnRDb25zdHJhaW50Iiwib3ZlcmxhcCIsImV2ZW50T3ZlcmxhcCIsImFsbG93IiwiZXZlbnRBbGxvdyIsImJhY2tncm91bmRDb2xvciIsImV2ZW50QmFja2dyb3VuZENvbG9yIiwiYm9yZGVyQ29sb3IiLCJldmVudEJvcmRlckNvbG9yIiwidGV4dENvbG9yIiwiZXZlbnRUZXh0Q29sb3IiLCJjb2xvciIsImV2ZW50Q29sb3IiLCJzZWxlY3RDb25zdHJhaW50Iiwic2VsZWN0T3ZlcmxhcCIsInNlbGVjdEFsbG93IiwiaXNMb2FkaW5nRnVuYyIsInZpZXdOYW1lIiwiVG9vbGJhclNlY3Rpb24iLCJjaGlsZHJlbiIsIndpZGdldEdyb3VwcyIsIndpZGdldEdyb3VwIiwicmVuZGVyV2lkZ2V0R3JvdXAiLCJjbGFzc05hbWUiLCJpc09ubHlCdXR0b25zIiwid2lkZ2V0IiwidGl0bGVJZCIsImlzUHJlc3NlZCIsImFjdGl2ZUJ1dHRvbiIsImlzRGlzYWJsZWQiLCJpc1RvZGF5RW5hYmxlZCIsImlzUHJldkVuYWJsZWQiLCJpc05leHRFbmFibGVkIiwiYnV0dG9uQ2xhc3NlcyIsImdldENsYXNzIiwiZGlzYWJsZWQiLCJvbkNsaWNrIiwicm9sZSIsImdyb3VwQ2xhc3NOYW1lIiwiVG9vbGJhciIsIm1vZGVsIiwiZXh0cmFDbGFzc05hbWUiLCJmb3JjZUx0ciIsInN0YXJ0Q29udGVudCIsImVuZENvbnRlbnQiLCJjZW50ZXJDb250ZW50IiwiY2VudGVyIiwibGVmdCIsInJpZ2h0IiwicmVuZGVyU2VjdGlvbiIsImtleSIsIlZpZXdIYXJuZXNzIiwiYXJndW1lbnRzIiwiYXZhaWxhYmxlV2lkdGgiLCJoYW5kbGVFbCIsImVsIiwiZWxSZWYiLCJ1cGRhdGVBdmFpbGFibGVXaWR0aCIsImhhbmRsZVJlc2l6ZSIsImFzcGVjdFJhdGlvIiwibGlxdWlkIiwiaGVpZ2h0IiwicGFkZGluZ0JvdHRvbSIsImxhYmVsZWRCeUlkIiwicmVmIiwic3R5bGUiLCJjb21wb25lbnREaWRNb3VudCIsImFkZFJlc2l6ZUhhbmRsZXIiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInJlbW92ZVJlc2l6ZUhhbmRsZXIiLCJzZXRTdGF0ZSIsIm9mZnNldFdpZHRoIiwiRXZlbnRDbGlja2luZyIsInNldHRpbmdzIiwiaGFuZGxlU2VnQ2xpY2siLCJzZWdFbCIsInNlZyIsImlzVmFsaWRTZWdEb3duRWwiLCJoYXNVcmxDb250YWluZXIiLCJxdWVyeVNlbGVjdG9yIiwiaHJlZiIsImV2ZW50IiwiZXZlbnRSYW5nZSIsImluc3RhbmNlIiwianNFdmVudCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImRlc3Ryb3kiLCJFdmVudEhvdmVyaW5nIiwiaGFuZGxlRXZlbnRFbFJlbW92ZSIsImN1cnJlbnRTZWdFbCIsImhhbmRsZVNlZ0xlYXZlIiwiaGFuZGxlU2VnRW50ZXIiLCJ0cmlnZ2VyRXZlbnQiLCJyZW1vdmVIb3Zlckxpc3RlbmVycyIsInB1YmxpY0V2TmFtZSIsIkNhbGVuZGFyQ29udGVudCIsImJ1aWxkVmlld1Byb3BUcmFuc2Zvcm1lcnMiLCJidWlsZFRvb2xiYXJQcm9wcyIsImhlYWRlclJlZiIsImZvb3RlclJlZiIsImludGVyYWN0aW9uc1N0b3JlIiwidmlld0xhYmVsSWQiLCJyZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50Iiwic2V0dGluZ3NJbnB1dCIsIkRFRkFVTFRfSU5URVJBQ1RJT05TIiwiaW50ZXJhY3Rpb25DbGFzc2VzIiwiaW50ZXJhY3Rpb25zIiwiVGhlSW50ZXJhY3Rpb25DbGFzcyIsInVpZCIsInVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCIsImxpc3RlbmVycyIsImxpc3RlbmVyIiwicmVzaXplUnVubmVyIiwiaGFuZGxlV2luZG93UmVzaXplIiwid2luZG93UmVzaXplRGVsYXkiLCJ0b29sYmFyUHJvcHMiLCJ2aWV3Vkdyb3ciLCJ2aWV3SGVpZ2h0Iiwidmlld0FzcGVjdFJhdGlvIiwiaXNIZWlnaHRBdXRvIiwiZm9yUHJpbnQiLCJjb250ZW50SGVpZ2h0Iiwidmlld0NvbnRleHQiLCJQcm92aWRlciIsInJlbmRlclZpZXciLCJidWlsZEFwcGVuZENvbnRlbnQiLCJDYWxlbmRhckludGVyYWN0aW9uQ2xhc3MiLCJhZGRFdmVudExpc3RlbmVyIiwicHJvcE5hbWUiLCJjb21wb25lbnREaWRVcGRhdGUiLCJwcmV2UHJvcHMiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2xlYXIiLCJpbnRlcmFjdGlvbiIsInRyYW5zZm9ybWVycyIsInRyYW5zZm9ybWVyIiwidHJhbnNmb3JtIiwiVmlld0NvbXBvbmVudCIsInRvZGF5SW5mbyIsInByZXZJbmZvIiwibmV4dEluZm8iLCJ0aGVDbGFzc2VzIiwiVGhlQ2xhc3MiLCJDYWxlbmRhciIsImlzUmVuZGVyaW5nIiwiaXNSZW5kZXJlZCIsImN1cnJlbnRDbGFzc05hbWVzIiwiY3VzdG9tQ29udGVudFJlbmRlcklkIiwiaGFuZGxlQWN0aW9uIiwicmVuZGVyUnVubmVyIiwidHJ5RHJhaW4iLCJoYW5kbGVEYXRhIiwiY3VycmVudERhdGEiLCJyZXJlbmRlckRlbGF5IiwiaGFuZGxlUmVuZGVyUmVxdWVzdCIsInNldENsYXNzTmFtZXMiLCJzZXRIZWlnaHQiLCJ3YXNSZW5kZXJpbmciLCJ1cGRhdGVTaXplIiwiYmF0Y2hSZW5kZXJpbmciLCJwYXVzZVJlbmRlcmluZyIsInJlc3VtZVJlbmRlcmluZyIsImNsYXNzTGlzdCIsInJlbW92ZSIsImZvcm1hdERhdGUiLCJkYXRlSW5wdXQiLCJmb3JtYXR0ZXIiLCJkYXRlTWV0YSIsImNyZWF0ZU1hcmtlck1ldGEiLCJtYXJrZXIiLCJmb3JjZWRUem8iLCJzdGFydElucHV0IiwiZW5kSW5wdXQiLCJzdGFydE1ldGEiLCJlbmRNZXRhIiwiZm9yY2VkU3RhcnRUem8iLCJmb3JjZWRFbmRUem8iLCJzbGljZUV2ZW50cyIsImFsbERheSIsImZnIiwidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@fullcalendar/core/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@fullcalendar/core/internal-common.js":
/*!************************************************************!*\
  !*** ./node_modules/@fullcalendar/core/internal-common.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: () => (/* binding */ elementClosest),\n/* harmony export */   A: () => (/* binding */ memoizeObjArg),\n/* harmony export */   B: () => (/* binding */ BaseComponent),\n/* harmony export */   C: () => (/* binding */ ContentContainer),\n/* harmony export */   D: () => (/* binding */ DelayedRunner),\n/* harmony export */   E: () => (/* binding */ isPropsEqual),\n/* harmony export */   F: () => (/* binding */ Emitter),\n/* harmony export */   G: () => (/* binding */ getInitialDate),\n/* harmony export */   H: () => (/* binding */ rangeContainsMarker),\n/* harmony export */   I: () => (/* binding */ createEmptyEventStore),\n/* harmony export */   J: () => (/* binding */ reduceCurrentDate),\n/* harmony export */   K: () => (/* binding */ reduceEventStore),\n/* harmony export */   L: () => (/* binding */ rezoneEventStoreDates),\n/* harmony export */   M: () => (/* binding */ mergeRawOptions),\n/* harmony export */   N: () => (/* binding */ BASE_OPTION_REFINERS),\n/* harmony export */   O: () => (/* binding */ CALENDAR_LISTENER_REFINERS),\n/* harmony export */   P: () => (/* binding */ CALENDAR_OPTION_REFINERS),\n/* harmony export */   Q: () => (/* binding */ COMPLEX_OPTION_COMPARATORS),\n/* harmony export */   R: () => (/* binding */ VIEW_OPTION_REFINERS),\n/* harmony export */   S: () => (/* binding */ DateEnv),\n/* harmony export */   T: () => (/* binding */ Theme),\n/* harmony export */   U: () => (/* binding */ DateProfileGenerator),\n/* harmony export */   V: () => (/* binding */ ViewContextType),\n/* harmony export */   W: () => (/* binding */ createEventUi),\n/* harmony export */   X: () => (/* binding */ parseBusinessHours),\n/* harmony export */   Y: () => (/* binding */ setRef),\n/* harmony export */   Z: () => (/* binding */ Interaction),\n/* harmony export */   _: () => (/* binding */ getElSeg),\n/* harmony export */   a: () => (/* binding */ mapHash),\n/* harmony export */   a$: () => (/* binding */ getSlotClassNames),\n/* harmony export */   a0: () => (/* binding */ EventImpl),\n/* harmony export */   a1: () => (/* binding */ listenBySelector),\n/* harmony export */   a2: () => (/* binding */ listenToHoverBySelector),\n/* harmony export */   a3: () => (/* binding */ PureComponent),\n/* harmony export */   a4: () => (/* binding */ buildViewContext),\n/* harmony export */   a5: () => (/* binding */ getUniqueDomId),\n/* harmony export */   a6: () => (/* binding */ parseInteractionSettings),\n/* harmony export */   a7: () => (/* binding */ interactionSettingsStore),\n/* harmony export */   a8: () => (/* binding */ getNow),\n/* harmony export */   a9: () => (/* binding */ CalendarImpl),\n/* harmony export */   aA: () => (/* binding */ diffDates),\n/* harmony export */   aB: () => (/* binding */ removeExact),\n/* harmony export */   aC: () => (/* binding */ memoizeArraylike),\n/* harmony export */   aD: () => (/* binding */ memoizeHashlike),\n/* harmony export */   aE: () => (/* binding */ intersectRects),\n/* harmony export */   aF: () => (/* binding */ pointInsideRect),\n/* harmony export */   aG: () => (/* binding */ constrainPoint),\n/* harmony export */   aH: () => (/* binding */ getRectCenter),\n/* harmony export */   aI: () => (/* binding */ diffPoints),\n/* harmony export */   aJ: () => (/* binding */ translateRect),\n/* harmony export */   aK: () => (/* binding */ compareObjs),\n/* harmony export */   aL: () => (/* binding */ collectFromHash),\n/* harmony export */   aM: () => (/* binding */ findElements),\n/* harmony export */   aN: () => (/* binding */ findDirectChildren),\n/* harmony export */   aO: () => (/* binding */ removeElement),\n/* harmony export */   aP: () => (/* binding */ applyStyle),\n/* harmony export */   aQ: () => (/* binding */ elementMatches),\n/* harmony export */   aR: () => (/* binding */ getEventTargetViaRoot),\n/* harmony export */   aS: () => (/* binding */ parseClassNames),\n/* harmony export */   aT: () => (/* binding */ getCanVGrowWithinCell),\n/* harmony export */   aU: () => (/* binding */ mergeEventStores),\n/* harmony export */   aV: () => (/* binding */ getRelevantEvents),\n/* harmony export */   aW: () => (/* binding */ eventTupleToStore),\n/* harmony export */   aX: () => (/* binding */ combineEventUis),\n/* harmony export */   aY: () => (/* binding */ Splitter),\n/* harmony export */   aZ: () => (/* binding */ getDayClassNames),\n/* harmony export */   a_: () => (/* binding */ getDateMeta),\n/* harmony export */   aa: () => (/* binding */ flushSync),\n/* harmony export */   ab: () => (/* binding */ CalendarRoot),\n/* harmony export */   ac: () => (/* binding */ RenderId),\n/* harmony export */   ad: () => (/* binding */ ensureElHasStyles),\n/* harmony export */   ae: () => (/* binding */ applyStyleProp),\n/* harmony export */   af: () => (/* binding */ sliceEventStore),\n/* harmony export */   ag: () => (/* binding */ JsonRequestError),\n/* harmony export */   ah: () => (/* binding */ createContext),\n/* harmony export */   ai: () => (/* binding */ refineProps),\n/* harmony export */   aj: () => (/* binding */ createEventInstance),\n/* harmony export */   ak: () => (/* binding */ parseEventDef),\n/* harmony export */   al: () => (/* binding */ refineEventDef),\n/* harmony export */   am: () => (/* binding */ padStart),\n/* harmony export */   an: () => (/* binding */ isInt),\n/* harmony export */   ao: () => (/* binding */ parseFieldSpecs),\n/* harmony export */   ap: () => (/* binding */ compareByFieldSpecs),\n/* harmony export */   aq: () => (/* binding */ flexibleCompare),\n/* harmony export */   ar: () => (/* binding */ preventSelection),\n/* harmony export */   as: () => (/* binding */ allowSelection),\n/* harmony export */   at: () => (/* binding */ preventContextMenu),\n/* harmony export */   au: () => (/* binding */ allowContextMenu),\n/* harmony export */   av: () => (/* binding */ compareNumbers),\n/* harmony export */   aw: () => (/* binding */ enableCursor),\n/* harmony export */   ax: () => (/* binding */ disableCursor),\n/* harmony export */   ay: () => (/* binding */ computeVisibleDayRange),\n/* harmony export */   az: () => (/* binding */ isMultiDayRange),\n/* harmony export */   b: () => (/* binding */ buildViewClassNames),\n/* harmony export */   b$: () => (/* binding */ SimpleScrollGrid),\n/* harmony export */   b0: () => (/* binding */ buildNavLinkAttrs),\n/* harmony export */   b1: () => (/* binding */ preventDefault),\n/* harmony export */   b2: () => (/* binding */ whenTransitionDone),\n/* harmony export */   b3: () => (/* binding */ computeInnerRect),\n/* harmony export */   b4: () => (/* binding */ computeEdges),\n/* harmony export */   b5: () => (/* binding */ getClippingParents),\n/* harmony export */   b6: () => (/* binding */ computeRect),\n/* harmony export */   b7: () => (/* binding */ rangesEqual),\n/* harmony export */   b8: () => (/* binding */ rangesIntersect),\n/* harmony export */   b9: () => (/* binding */ rangeContainsRange),\n/* harmony export */   bA: () => (/* binding */ SegHierarchy),\n/* harmony export */   bB: () => (/* binding */ buildEntryKey),\n/* harmony export */   bC: () => (/* binding */ getEntrySpanEnd),\n/* harmony export */   bD: () => (/* binding */ binarySearch),\n/* harmony export */   bE: () => (/* binding */ groupIntersectingEntries),\n/* harmony export */   bF: () => (/* binding */ intersectSpans),\n/* harmony export */   bG: () => (/* binding */ interactionSettingsToStore),\n/* harmony export */   bH: () => (/* binding */ ElementDragging),\n/* harmony export */   bI: () => (/* binding */ config),\n/* harmony export */   bJ: () => (/* binding */ parseDragMeta),\n/* harmony export */   bK: () => (/* binding */ DayHeader),\n/* harmony export */   bL: () => (/* binding */ computeFallbackHeaderFormat),\n/* harmony export */   bM: () => (/* binding */ TableDateCell),\n/* harmony export */   bN: () => (/* binding */ TableDowCell),\n/* harmony export */   bO: () => (/* binding */ DaySeriesModel),\n/* harmony export */   bP: () => (/* binding */ hasBgRendering),\n/* harmony export */   bQ: () => (/* binding */ buildSegTimeText),\n/* harmony export */   bR: () => (/* binding */ sortEventSegs),\n/* harmony export */   bS: () => (/* binding */ getSegMeta),\n/* harmony export */   bT: () => (/* binding */ buildEventRangeKey),\n/* harmony export */   bU: () => (/* binding */ getSegAnchorAttrs),\n/* harmony export */   bV: () => (/* binding */ DayTableModel),\n/* harmony export */   bW: () => (/* binding */ Slicer),\n/* harmony export */   bX: () => (/* binding */ applyMutationToEventStore),\n/* harmony export */   bY: () => (/* binding */ isPropsValid),\n/* harmony export */   bZ: () => (/* binding */ isInteractionValid),\n/* harmony export */   b_: () => (/* binding */ isDateSelectionValid),\n/* harmony export */   ba: () => (/* binding */ PositionCache),\n/* harmony export */   bb: () => (/* binding */ ScrollController),\n/* harmony export */   bc: () => (/* binding */ ElementScrollController),\n/* harmony export */   bd: () => (/* binding */ WindowScrollController),\n/* harmony export */   be: () => (/* binding */ DateComponent),\n/* harmony export */   bf: () => (/* binding */ isDateSpansEqual),\n/* harmony export */   bg: () => (/* binding */ addMs),\n/* harmony export */   bh: () => (/* binding */ addWeeks),\n/* harmony export */   bi: () => (/* binding */ diffWeeks),\n/* harmony export */   bj: () => (/* binding */ diffWholeWeeks),\n/* harmony export */   bk: () => (/* binding */ diffDayAndTime),\n/* harmony export */   bl: () => (/* binding */ diffDays),\n/* harmony export */   bm: () => (/* binding */ isValidDate),\n/* harmony export */   bn: () => (/* binding */ asCleanDays),\n/* harmony export */   bo: () => (/* binding */ multiplyDuration),\n/* harmony export */   bp: () => (/* binding */ addDurations),\n/* harmony export */   bq: () => (/* binding */ asRoughMinutes),\n/* harmony export */   br: () => (/* binding */ asRoughSeconds),\n/* harmony export */   bs: () => (/* binding */ asRoughMs),\n/* harmony export */   bt: () => (/* binding */ wholeDivideDurations),\n/* harmony export */   bu: () => (/* binding */ formatIsoTimeString),\n/* harmony export */   bv: () => (/* binding */ formatDayString),\n/* harmony export */   bw: () => (/* binding */ buildIsoString),\n/* harmony export */   bx: () => (/* binding */ formatIsoMonthStr),\n/* harmony export */   by: () => (/* binding */ NamedTimeZoneImpl),\n/* harmony export */   bz: () => (/* binding */ parse),\n/* harmony export */   c: () => (/* binding */ greatestDurationDenominator),\n/* harmony export */   c0: () => (/* binding */ hasShrinkWidth),\n/* harmony export */   c1: () => (/* binding */ renderMicroColGroup),\n/* harmony export */   c2: () => (/* binding */ getScrollGridClassNames),\n/* harmony export */   c3: () => (/* binding */ getSectionClassNames),\n/* harmony export */   c4: () => (/* binding */ getSectionHasLiquidHeight),\n/* harmony export */   c5: () => (/* binding */ getAllowYScrolling),\n/* harmony export */   c6: () => (/* binding */ renderChunkContent),\n/* harmony export */   c7: () => (/* binding */ computeShrinkWidth),\n/* harmony export */   c8: () => (/* binding */ sanitizeShrinkWidth),\n/* harmony export */   c9: () => (/* binding */ isColPropsEqual),\n/* harmony export */   ca: () => (/* binding */ renderScrollShim),\n/* harmony export */   cb: () => (/* binding */ getStickyFooterScrollbar),\n/* harmony export */   cc: () => (/* binding */ getStickyHeaderDates),\n/* harmony export */   cd: () => (/* binding */ Scroller),\n/* harmony export */   ce: () => (/* binding */ getScrollbarWidths),\n/* harmony export */   cf: () => (/* binding */ RefMap),\n/* harmony export */   cg: () => (/* binding */ getIsRtlScrollbarOnLeft),\n/* harmony export */   ch: () => (/* binding */ NowTimer),\n/* harmony export */   ci: () => (/* binding */ ScrollResponder),\n/* harmony export */   cj: () => (/* binding */ StandardEvent),\n/* harmony export */   ck: () => (/* binding */ NowIndicatorContainer),\n/* harmony export */   cl: () => (/* binding */ DayCellContainer),\n/* harmony export */   cm: () => (/* binding */ hasCustomDayCellContent),\n/* harmony export */   cn: () => (/* binding */ EventContainer),\n/* harmony export */   co: () => (/* binding */ renderFill),\n/* harmony export */   cp: () => (/* binding */ BgEvent),\n/* harmony export */   cq: () => (/* binding */ WeekNumberContainer),\n/* harmony export */   cr: () => (/* binding */ MoreLinkContainer),\n/* harmony export */   cs: () => (/* binding */ computeEarliestSegStart),\n/* harmony export */   ct: () => (/* binding */ ViewContainer),\n/* harmony export */   cu: () => (/* binding */ triggerDateSelect),\n/* harmony export */   cv: () => (/* binding */ getDefaultEventEnd),\n/* harmony export */   cw: () => (/* binding */ injectStyles),\n/* harmony export */   cx: () => (/* binding */ buildElAttrs),\n/* harmony export */   cy: () => (/* binding */ CustomRenderingStore),\n/* harmony export */   d: () => (/* binding */ createDuration),\n/* harmony export */   e: () => (/* binding */ BASE_OPTION_DEFAULTS),\n/* harmony export */   f: () => (/* binding */ arrayToHash),\n/* harmony export */   g: () => (/* binding */ guid),\n/* harmony export */   h: () => (/* binding */ filterHash),\n/* harmony export */   i: () => (/* binding */ isArraysEqual),\n/* harmony export */   j: () => (/* binding */ buildEventSourceRefiners),\n/* harmony export */   k: () => (/* binding */ formatWithOrdinals),\n/* harmony export */   l: () => (/* binding */ buildRangeApiWithTimeZone),\n/* harmony export */   m: () => (/* binding */ mergeProps),\n/* harmony export */   n: () => (/* binding */ identity),\n/* harmony export */   o: () => (/* binding */ intersectRanges),\n/* harmony export */   p: () => (/* binding */ parseEventSource),\n/* harmony export */   q: () => (/* binding */ startOfDay),\n/* harmony export */   r: () => (/* binding */ requestJson),\n/* harmony export */   s: () => (/* binding */ subtractDurations),\n/* harmony export */   t: () => (/* binding */ addDays),\n/* harmony export */   u: () => (/* binding */ unpromisify),\n/* harmony export */   v: () => (/* binding */ hashValuesToArray),\n/* harmony export */   w: () => (/* binding */ buildEventApis),\n/* harmony export */   x: () => (/* binding */ createFormatter),\n/* harmony export */   y: () => (/* binding */ diffWholeDays),\n/* harmony export */   z: () => (/* binding */ memoize)\n/* harmony export */ });\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ \"(ssr)/./node_modules/preact/dist/preact.mjs\");\n/* harmony import */ var preact_compat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! preact/compat */ \"(ssr)/./node_modules/preact/compat/dist/compat.mjs\");\n\n\n\nconst styleTexts = [];\nconst styleEls = new Map();\nfunction injectStyles(styleText) {\n    styleTexts.push(styleText);\n    styleEls.forEach((styleEl)=>{\n        appendStylesTo(styleEl, styleText);\n    });\n}\nfunction ensureElHasStyles(el) {\n    if (el.isConnected && // sometimes true if SSR system simulates DOM\n    el.getRootNode // sometimes undefined if SSR system simulates DOM\n    ) {\n        registerStylesRoot(el.getRootNode());\n    }\n}\nfunction registerStylesRoot(rootNode) {\n    let styleEl = styleEls.get(rootNode);\n    if (!styleEl || !styleEl.isConnected) {\n        styleEl = rootNode.querySelector(\"style[data-fullcalendar]\");\n        if (!styleEl) {\n            styleEl = document.createElement(\"style\");\n            styleEl.setAttribute(\"data-fullcalendar\", \"\");\n            const nonce = getNonceValue();\n            if (nonce) {\n                styleEl.nonce = nonce;\n            }\n            const parentEl = rootNode === document ? document.head : rootNode;\n            const insertBefore = rootNode === document ? parentEl.querySelector(\"script,link[rel=stylesheet],link[as=style],style\") : parentEl.firstChild;\n            parentEl.insertBefore(styleEl, insertBefore);\n        }\n        styleEls.set(rootNode, styleEl);\n        hydrateStylesRoot(styleEl);\n    }\n}\nfunction hydrateStylesRoot(styleEl) {\n    for (const styleText of styleTexts){\n        appendStylesTo(styleEl, styleText);\n    }\n}\nfunction appendStylesTo(styleEl, styleText) {\n    const { sheet } = styleEl;\n    const ruleCnt = sheet.cssRules.length;\n    styleText.split(\"}\").forEach((styleStr, i)=>{\n        styleStr = styleStr.trim();\n        if (styleStr) {\n            sheet.insertRule(styleStr + \"}\", ruleCnt + i);\n        }\n    });\n}\n// nonce\n// -------------------------------------------------------------------------------------------------\nlet queriedNonceValue;\nfunction getNonceValue() {\n    if (queriedNonceValue === undefined) {\n        queriedNonceValue = queryNonceValue();\n    }\n    return queriedNonceValue;\n}\n/*\nTODO: discourage meta tag and instead put nonce attribute on placeholder <style> tag\n*/ function queryNonceValue() {\n    const metaWithNonce = document.querySelector('meta[name=\"csp-nonce\"]');\n    if (metaWithNonce && metaWithNonce.hasAttribute(\"content\")) {\n        return metaWithNonce.getAttribute(\"content\");\n    }\n    const elWithNonce = document.querySelector(\"script[nonce]\");\n    if (elWithNonce) {\n        return elWithNonce.nonce || \"\";\n    }\n    return \"\";\n}\n// main\n// -------------------------------------------------------------------------------------------------\nif (typeof document !== \"undefined\") {\n    registerStylesRoot(document);\n}\nvar css_248z = ':root{--fc-small-font-size:.85em;--fc-page-bg-color:#fff;--fc-neutral-bg-color:hsla(0,0%,82%,.3);--fc-neutral-text-color:grey;--fc-border-color:#ddd;--fc-button-text-color:#fff;--fc-button-bg-color:#2c3e50;--fc-button-border-color:#2c3e50;--fc-button-hover-bg-color:#1e2b37;--fc-button-hover-border-color:#1a252f;--fc-button-active-bg-color:#1a252f;--fc-button-active-border-color:#151e27;--fc-event-bg-color:#3788d8;--fc-event-border-color:#3788d8;--fc-event-text-color:#fff;--fc-event-selected-overlay-color:rgba(0,0,0,.25);--fc-more-link-bg-color:#d0d0d0;--fc-more-link-text-color:inherit;--fc-event-resizer-thickness:8px;--fc-event-resizer-dot-total-width:8px;--fc-event-resizer-dot-border-width:1px;--fc-non-business-color:hsla(0,0%,84%,.3);--fc-bg-event-color:#8fdf82;--fc-bg-event-opacity:0.3;--fc-highlight-color:rgba(188,232,241,.3);--fc-today-bg-color:rgba(255,220,40,.15);--fc-now-indicator-color:red}.fc-not-allowed,.fc-not-allowed .fc-event{cursor:not-allowed}.fc{display:flex;flex-direction:column;font-size:1em}.fc,.fc *,.fc :after,.fc :before{box-sizing:border-box}.fc table{border-collapse:collapse;border-spacing:0;font-size:1em}.fc th{text-align:center}.fc td,.fc th{padding:0;vertical-align:top}.fc a[data-navlink]{cursor:pointer}.fc a[data-navlink]:hover{text-decoration:underline}.fc-direction-ltr{direction:ltr;text-align:left}.fc-direction-rtl{direction:rtl;text-align:right}.fc-theme-standard td,.fc-theme-standard th{border:1px solid var(--fc-border-color)}.fc-liquid-hack td,.fc-liquid-hack th{position:relative}@font-face{font-family:fcicons;font-style:normal;font-weight:400;src:url(\"data:application/x-font-ttf;charset=utf-8;base64,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\") format(\"truetype\")}.fc-icon{speak:none;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;display:inline-block;font-family:fcicons!important;font-style:normal;font-variant:normal;font-weight:400;height:1em;line-height:1;text-align:center;text-transform:none;-moz-user-select:none;user-select:none;width:1em}.fc-icon-chevron-left:before{content:\"\\\\e900\"}.fc-icon-chevron-right:before{content:\"\\\\e901\"}.fc-icon-chevrons-left:before{content:\"\\\\e902\"}.fc-icon-chevrons-right:before{content:\"\\\\e903\"}.fc-icon-minus-square:before{content:\"\\\\e904\"}.fc-icon-plus-square:before{content:\"\\\\e905\"}.fc-icon-x:before{content:\"\\\\e906\"}.fc .fc-button{border-radius:0;font-family:inherit;font-size:inherit;line-height:inherit;margin:0;overflow:visible;text-transform:none}.fc .fc-button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}.fc .fc-button{-webkit-appearance:button}.fc .fc-button:not(:disabled){cursor:pointer}.fc .fc-button{background-color:transparent;border:1px solid transparent;border-radius:.25em;display:inline-block;font-size:1em;font-weight:400;line-height:1.5;padding:.4em .65em;text-align:center;-moz-user-select:none;user-select:none;vertical-align:middle}.fc .fc-button:hover{text-decoration:none}.fc .fc-button:focus{box-shadow:0 0 0 .2rem rgba(44,62,80,.25);outline:0}.fc .fc-button:disabled{opacity:.65}.fc .fc-button-primary{background-color:var(--fc-button-bg-color);border-color:var(--fc-button-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:hover{background-color:var(--fc-button-hover-bg-color);border-color:var(--fc-button-hover-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:disabled{background-color:var(--fc-button-bg-color);border-color:var(--fc-button-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:focus{box-shadow:0 0 0 .2rem rgba(76,91,106,.5)}.fc .fc-button-primary:not(:disabled).fc-button-active,.fc .fc-button-primary:not(:disabled):active{background-color:var(--fc-button-active-bg-color);border-color:var(--fc-button-active-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:not(:disabled).fc-button-active:focus,.fc .fc-button-primary:not(:disabled):active:focus{box-shadow:0 0 0 .2rem rgba(76,91,106,.5)}.fc .fc-button .fc-icon{font-size:1.5em;vertical-align:middle}.fc .fc-button-group{display:inline-flex;position:relative;vertical-align:middle}.fc .fc-button-group>.fc-button{flex:1 1 auto;position:relative}.fc .fc-button-group>.fc-button.fc-button-active,.fc .fc-button-group>.fc-button:active,.fc .fc-button-group>.fc-button:focus,.fc .fc-button-group>.fc-button:hover{z-index:1}.fc-direction-ltr .fc-button-group>.fc-button:not(:first-child){border-bottom-left-radius:0;border-top-left-radius:0;margin-left:-1px}.fc-direction-ltr .fc-button-group>.fc-button:not(:last-child){border-bottom-right-radius:0;border-top-right-radius:0}.fc-direction-rtl .fc-button-group>.fc-button:not(:first-child){border-bottom-right-radius:0;border-top-right-radius:0;margin-right:-1px}.fc-direction-rtl .fc-button-group>.fc-button:not(:last-child){border-bottom-left-radius:0;border-top-left-radius:0}.fc .fc-toolbar{align-items:center;display:flex;justify-content:space-between}.fc .fc-toolbar.fc-header-toolbar{margin-bottom:1.5em}.fc .fc-toolbar.fc-footer-toolbar{margin-top:1.5em}.fc .fc-toolbar-title{font-size:1.75em;margin:0}.fc-direction-ltr .fc-toolbar>*>:not(:first-child){margin-left:.75em}.fc-direction-rtl .fc-toolbar>*>:not(:first-child){margin-right:.75em}.fc-direction-rtl .fc-toolbar-ltr{flex-direction:row-reverse}.fc .fc-scroller{-webkit-overflow-scrolling:touch;position:relative}.fc .fc-scroller-liquid{height:100%}.fc .fc-scroller-liquid-absolute{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-scroller-harness{direction:ltr;overflow:hidden;position:relative}.fc .fc-scroller-harness-liquid{height:100%}.fc-direction-rtl .fc-scroller-harness>.fc-scroller{direction:rtl}.fc-theme-standard .fc-scrollgrid{border:1px solid var(--fc-border-color)}.fc .fc-scrollgrid,.fc .fc-scrollgrid table{table-layout:fixed;width:100%}.fc .fc-scrollgrid table{border-left-style:hidden;border-right-style:hidden;border-top-style:hidden}.fc .fc-scrollgrid{border-bottom-width:0;border-collapse:separate;border-right-width:0}.fc .fc-scrollgrid-liquid{height:100%}.fc .fc-scrollgrid-section,.fc .fc-scrollgrid-section table,.fc .fc-scrollgrid-section>td{height:1px}.fc .fc-scrollgrid-section-liquid>td{height:100%}.fc .fc-scrollgrid-section>*{border-left-width:0;border-top-width:0}.fc .fc-scrollgrid-section-footer>*,.fc .fc-scrollgrid-section-header>*{border-bottom-width:0}.fc .fc-scrollgrid-section-body table,.fc .fc-scrollgrid-section-footer table{border-bottom-style:hidden}.fc .fc-scrollgrid-section-sticky>*{background:var(--fc-page-bg-color);position:sticky;z-index:3}.fc .fc-scrollgrid-section-header.fc-scrollgrid-section-sticky>*{top:0}.fc .fc-scrollgrid-section-footer.fc-scrollgrid-section-sticky>*{bottom:0}.fc .fc-scrollgrid-sticky-shim{height:1px;margin-bottom:-1px}.fc-sticky{position:sticky}.fc .fc-view-harness{flex-grow:1;position:relative}.fc .fc-view-harness-active>.fc-view{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-col-header-cell-cushion{display:inline-block;padding:2px 4px}.fc .fc-bg-event,.fc .fc-highlight,.fc .fc-non-business{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-non-business{background:var(--fc-non-business-color)}.fc .fc-bg-event{background:var(--fc-bg-event-color);opacity:var(--fc-bg-event-opacity)}.fc .fc-bg-event .fc-event-title{font-size:var(--fc-small-font-size);font-style:italic;margin:.5em}.fc .fc-highlight{background:var(--fc-highlight-color)}.fc .fc-cell-shaded,.fc .fc-day-disabled{background:var(--fc-neutral-bg-color)}a.fc-event,a.fc-event:hover{text-decoration:none}.fc-event.fc-event-draggable,.fc-event[href]{cursor:pointer}.fc-event .fc-event-main{position:relative;z-index:2}.fc-event-dragging:not(.fc-event-selected){opacity:.75}.fc-event-dragging.fc-event-selected{box-shadow:0 2px 7px rgba(0,0,0,.3)}.fc-event .fc-event-resizer{display:none;position:absolute;z-index:4}.fc-event-selected .fc-event-resizer,.fc-event:hover .fc-event-resizer{display:block}.fc-event-selected .fc-event-resizer{background:var(--fc-page-bg-color);border-color:inherit;border-radius:calc(var(--fc-event-resizer-dot-total-width)/2);border-style:solid;border-width:var(--fc-event-resizer-dot-border-width);height:var(--fc-event-resizer-dot-total-width);width:var(--fc-event-resizer-dot-total-width)}.fc-event-selected .fc-event-resizer:before{bottom:-20px;content:\"\";left:-20px;position:absolute;right:-20px;top:-20px}.fc-event-selected,.fc-event:focus{box-shadow:0 2px 5px rgba(0,0,0,.2)}.fc-event-selected:before,.fc-event:focus:before{bottom:0;content:\"\";left:0;position:absolute;right:0;top:0;z-index:3}.fc-event-selected:after,.fc-event:focus:after{background:var(--fc-event-selected-overlay-color);bottom:-1px;content:\"\";left:-1px;position:absolute;right:-1px;top:-1px;z-index:1}.fc-h-event{background-color:var(--fc-event-bg-color);border:1px solid var(--fc-event-border-color);display:block}.fc-h-event .fc-event-main{color:var(--fc-event-text-color)}.fc-h-event .fc-event-main-frame{display:flex}.fc-h-event .fc-event-time{max-width:100%;overflow:hidden}.fc-h-event .fc-event-title-container{flex-grow:1;flex-shrink:1;min-width:0}.fc-h-event .fc-event-title{display:inline-block;left:0;max-width:100%;overflow:hidden;right:0;vertical-align:top}.fc-h-event.fc-event-selected:before{bottom:-10px;top:-10px}.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-start),.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-end){border-bottom-left-radius:0;border-left-width:0;border-top-left-radius:0}.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-end),.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-start){border-bottom-right-radius:0;border-right-width:0;border-top-right-radius:0}.fc-h-event:not(.fc-event-selected) .fc-event-resizer{bottom:0;top:0;width:var(--fc-event-resizer-thickness)}.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start,.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end{cursor:w-resize;left:calc(var(--fc-event-resizer-thickness)*-.5)}.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end,.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start{cursor:e-resize;right:calc(var(--fc-event-resizer-thickness)*-.5)}.fc-h-event.fc-event-selected .fc-event-resizer{margin-top:calc(var(--fc-event-resizer-dot-total-width)*-.5);top:50%}.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-start,.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-end{left:calc(var(--fc-event-resizer-dot-total-width)*-.5)}.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-end,.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-start{right:calc(var(--fc-event-resizer-dot-total-width)*-.5)}.fc .fc-popover{box-shadow:0 2px 6px rgba(0,0,0,.15);position:absolute;z-index:9999}.fc .fc-popover-header{align-items:center;display:flex;flex-direction:row;justify-content:space-between;padding:3px 4px}.fc .fc-popover-title{margin:0 2px}.fc .fc-popover-close{cursor:pointer;font-size:1.1em;opacity:.65}.fc-theme-standard .fc-popover{background:var(--fc-page-bg-color);border:1px solid var(--fc-border-color)}.fc-theme-standard .fc-popover-header{background:var(--fc-neutral-bg-color)}';\ninjectStyles(css_248z);\nclass DelayedRunner {\n    constructor(drainedOption){\n        this.drainedOption = drainedOption;\n        this.isRunning = false;\n        this.isDirty = false;\n        this.pauseDepths = {};\n        this.timeoutId = 0;\n    }\n    request(delay) {\n        this.isDirty = true;\n        if (!this.isPaused()) {\n            this.clearTimeout();\n            if (delay == null) {\n                this.tryDrain();\n            } else {\n                this.timeoutId = setTimeout(this.tryDrain.bind(this), delay);\n            }\n        }\n    }\n    pause(scope = \"\") {\n        let { pauseDepths } = this;\n        pauseDepths[scope] = (pauseDepths[scope] || 0) + 1;\n        this.clearTimeout();\n    }\n    resume(scope = \"\", force) {\n        let { pauseDepths } = this;\n        if (scope in pauseDepths) {\n            if (force) {\n                delete pauseDepths[scope];\n            } else {\n                pauseDepths[scope] -= 1;\n                let depth = pauseDepths[scope];\n                if (depth <= 0) {\n                    delete pauseDepths[scope];\n                }\n            }\n            this.tryDrain();\n        }\n    }\n    isPaused() {\n        return Object.keys(this.pauseDepths).length;\n    }\n    tryDrain() {\n        if (!this.isRunning && !this.isPaused()) {\n            this.isRunning = true;\n            while(this.isDirty){\n                this.isDirty = false;\n                this.drained(); // might set isDirty to true again\n            }\n            this.isRunning = false;\n        }\n    }\n    clear() {\n        this.clearTimeout();\n        this.isDirty = false;\n        this.pauseDepths = {};\n    }\n    clearTimeout() {\n        if (this.timeoutId) {\n            clearTimeout(this.timeoutId);\n            this.timeoutId = 0;\n        }\n    }\n    drained() {\n        if (this.drainedOption) {\n            this.drainedOption();\n        }\n    }\n}\nfunction removeElement(el) {\n    if (el.parentNode) {\n        el.parentNode.removeChild(el);\n    }\n}\n// Querying\n// ----------------------------------------------------------------------------------------------------------------\nfunction elementClosest(el, selector) {\n    if (el.closest) {\n        return el.closest(selector);\n    // really bad fallback for IE\n    // from https://developer.mozilla.org/en-US/docs/Web/API/Element/closest\n    }\n    if (!document.documentElement.contains(el)) {\n        return null;\n    }\n    do {\n        if (elementMatches(el, selector)) {\n            return el;\n        }\n        el = el.parentElement || el.parentNode;\n    }while (el !== null && el.nodeType === 1);\n    return null;\n}\nfunction elementMatches(el, selector) {\n    let method = el.matches || el.matchesSelector || el.msMatchesSelector;\n    return method.call(el, selector);\n}\n// accepts multiple subject els\n// returns a real array. good for methods like forEach\n// TODO: accept the document\nfunction findElements(container, selector) {\n    let containers = container instanceof HTMLElement ? [\n        container\n    ] : container;\n    let allMatches = [];\n    for(let i = 0; i < containers.length; i += 1){\n        let matches = containers[i].querySelectorAll(selector);\n        for(let j = 0; j < matches.length; j += 1){\n            allMatches.push(matches[j]);\n        }\n    }\n    return allMatches;\n}\n// accepts multiple subject els\n// only queries direct child elements // TODO: rename to findDirectChildren!\nfunction findDirectChildren(parent, selector) {\n    let parents = parent instanceof HTMLElement ? [\n        parent\n    ] : parent;\n    let allMatches = [];\n    for(let i = 0; i < parents.length; i += 1){\n        let childNodes = parents[i].children; // only ever elements\n        for(let j = 0; j < childNodes.length; j += 1){\n            let childNode = childNodes[j];\n            if (!selector || elementMatches(childNode, selector)) {\n                allMatches.push(childNode);\n            }\n        }\n    }\n    return allMatches;\n}\n// Style\n// ----------------------------------------------------------------------------------------------------------------\nconst PIXEL_PROP_RE = /(top|left|right|bottom|width|height)$/i;\nfunction applyStyle(el, props) {\n    for(let propName in props){\n        applyStyleProp(el, propName, props[propName]);\n    }\n}\nfunction applyStyleProp(el, name, val) {\n    if (val == null) {\n        el.style[name] = \"\";\n    } else if (typeof val === \"number\" && PIXEL_PROP_RE.test(name)) {\n        el.style[name] = `${val}px`;\n    } else {\n        el.style[name] = val;\n    }\n}\n// Event Handling\n// ----------------------------------------------------------------------------------------------------------------\n// if intercepting bubbled events at the document/window/body level,\n// and want to see originating element (the 'target'), use this util instead\n// of `ev.target` because it goes within web-component boundaries.\nfunction getEventTargetViaRoot(ev) {\n    var _a, _b;\n    return (_b = (_a = ev.composedPath) === null || _a === void 0 ? void 0 : _a.call(ev)[0]) !== null && _b !== void 0 ? _b : ev.target;\n}\n// Unique ID for DOM attribute\nlet guid$1 = 0;\nfunction getUniqueDomId() {\n    guid$1 += 1;\n    return \"fc-dom-\" + guid$1;\n}\n// Stops a mouse/touch event from doing it's native browser action\nfunction preventDefault(ev) {\n    ev.preventDefault();\n}\n// Event Delegation\n// ----------------------------------------------------------------------------------------------------------------\nfunction buildDelegationHandler(selector, handler) {\n    return (ev)=>{\n        let matchedChild = elementClosest(ev.target, selector);\n        if (matchedChild) {\n            handler.call(matchedChild, ev, matchedChild);\n        }\n    };\n}\nfunction listenBySelector(container, eventType, selector, handler) {\n    let attachedHandler = buildDelegationHandler(selector, handler);\n    container.addEventListener(eventType, attachedHandler);\n    return ()=>{\n        container.removeEventListener(eventType, attachedHandler);\n    };\n}\nfunction listenToHoverBySelector(container, selector, onMouseEnter, onMouseLeave) {\n    let currentMatchedChild;\n    return listenBySelector(container, \"mouseover\", selector, (mouseOverEv, matchedChild)=>{\n        if (matchedChild !== currentMatchedChild) {\n            currentMatchedChild = matchedChild;\n            onMouseEnter(mouseOverEv, matchedChild);\n            let realOnMouseLeave = (mouseLeaveEv)=>{\n                currentMatchedChild = null;\n                onMouseLeave(mouseLeaveEv, matchedChild);\n                matchedChild.removeEventListener(\"mouseleave\", realOnMouseLeave);\n            };\n            // listen to the next mouseleave, and then unattach\n            matchedChild.addEventListener(\"mouseleave\", realOnMouseLeave);\n        }\n    });\n}\n// Animation\n// ----------------------------------------------------------------------------------------------------------------\nconst transitionEventNames = [\n    \"webkitTransitionEnd\",\n    \"otransitionend\",\n    \"oTransitionEnd\",\n    \"msTransitionEnd\",\n    \"transitionend\"\n];\n// triggered only when the next single subsequent transition finishes\nfunction whenTransitionDone(el, callback) {\n    let realCallback = (ev)=>{\n        callback(ev);\n        transitionEventNames.forEach((eventName)=>{\n            el.removeEventListener(eventName, realCallback);\n        });\n    };\n    transitionEventNames.forEach((eventName)=>{\n        el.addEventListener(eventName, realCallback); // cross-browser way to determine when the transition finishes\n    });\n}\n// ARIA workarounds\n// ----------------------------------------------------------------------------------------------------------------\nfunction createAriaClickAttrs(handler) {\n    return Object.assign({\n        onClick: handler\n    }, createAriaKeyboardAttrs(handler));\n}\nfunction createAriaKeyboardAttrs(handler) {\n    return {\n        tabIndex: 0,\n        onKeyDown (ev) {\n            if (ev.key === \"Enter\" || ev.key === \" \") {\n                handler(ev);\n                ev.preventDefault(); // if space, don't scroll down page\n            }\n        }\n    };\n}\nlet guidNumber = 0;\nfunction guid() {\n    guidNumber += 1;\n    return String(guidNumber);\n}\n/* FullCalendar-specific DOM Utilities\n----------------------------------------------------------------------------------------------------------------------*/ // Make the mouse cursor express that an event is not allowed in the current area\nfunction disableCursor() {\n    document.body.classList.add(\"fc-not-allowed\");\n}\n// Returns the mouse cursor to its original look\nfunction enableCursor() {\n    document.body.classList.remove(\"fc-not-allowed\");\n}\n/* Selection\n----------------------------------------------------------------------------------------------------------------------*/ function preventSelection(el) {\n    el.style.userSelect = \"none\";\n    el.style.webkitUserSelect = \"none\";\n    el.addEventListener(\"selectstart\", preventDefault);\n}\nfunction allowSelection(el) {\n    el.style.userSelect = \"\";\n    el.style.webkitUserSelect = \"\";\n    el.removeEventListener(\"selectstart\", preventDefault);\n}\n/* Context Menu\n----------------------------------------------------------------------------------------------------------------------*/ function preventContextMenu(el) {\n    el.addEventListener(\"contextmenu\", preventDefault);\n}\nfunction allowContextMenu(el) {\n    el.removeEventListener(\"contextmenu\", preventDefault);\n}\nfunction parseFieldSpecs(input) {\n    let specs = [];\n    let tokens = [];\n    let i;\n    let token;\n    if (typeof input === \"string\") {\n        tokens = input.split(/\\s*,\\s*/);\n    } else if (typeof input === \"function\") {\n        tokens = [\n            input\n        ];\n    } else if (Array.isArray(input)) {\n        tokens = input;\n    }\n    for(i = 0; i < tokens.length; i += 1){\n        token = tokens[i];\n        if (typeof token === \"string\") {\n            specs.push(token.charAt(0) === \"-\" ? {\n                field: token.substring(1),\n                order: -1\n            } : {\n                field: token,\n                order: 1\n            });\n        } else if (typeof token === \"function\") {\n            specs.push({\n                func: token\n            });\n        }\n    }\n    return specs;\n}\nfunction compareByFieldSpecs(obj0, obj1, fieldSpecs) {\n    let i;\n    let cmp;\n    for(i = 0; i < fieldSpecs.length; i += 1){\n        cmp = compareByFieldSpec(obj0, obj1, fieldSpecs[i]);\n        if (cmp) {\n            return cmp;\n        }\n    }\n    return 0;\n}\nfunction compareByFieldSpec(obj0, obj1, fieldSpec) {\n    if (fieldSpec.func) {\n        return fieldSpec.func(obj0, obj1);\n    }\n    return flexibleCompare(obj0[fieldSpec.field], obj1[fieldSpec.field]) * (fieldSpec.order || 1);\n}\nfunction flexibleCompare(a, b) {\n    if (!a && !b) {\n        return 0;\n    }\n    if (b == null) {\n        return -1;\n    }\n    if (a == null) {\n        return 1;\n    }\n    if (typeof a === \"string\" || typeof b === \"string\") {\n        return String(a).localeCompare(String(b));\n    }\n    return a - b;\n}\n/* String Utilities\n----------------------------------------------------------------------------------------------------------------------*/ function padStart(val, len) {\n    let s = String(val);\n    return \"000\".substr(0, len - s.length) + s;\n}\nfunction formatWithOrdinals(formatter, args, fallbackText) {\n    if (typeof formatter === \"function\") {\n        return formatter(...args);\n    }\n    if (typeof formatter === \"string\") {\n        return args.reduce((str, arg, index)=>str.replace(\"$\" + index, arg || \"\"), formatter);\n    }\n    return fallbackText;\n}\n/* Number Utilities\n----------------------------------------------------------------------------------------------------------------------*/ function compareNumbers(a, b) {\n    return a - b;\n}\nfunction isInt(n) {\n    return n % 1 === 0;\n}\n/* FC-specific DOM dimension stuff\n----------------------------------------------------------------------------------------------------------------------*/ function computeSmallestCellWidth(cellEl) {\n    let allWidthEl = cellEl.querySelector(\".fc-scrollgrid-shrink-frame\");\n    let contentWidthEl = cellEl.querySelector(\".fc-scrollgrid-shrink-cushion\");\n    if (!allWidthEl) {\n        throw new Error(\"needs fc-scrollgrid-shrink-frame className\"); // TODO: use const\n    }\n    if (!contentWidthEl) {\n        throw new Error(\"needs fc-scrollgrid-shrink-cushion className\");\n    }\n    return cellEl.getBoundingClientRect().width - allWidthEl.getBoundingClientRect().width + // the cell padding+border\n    contentWidthEl.getBoundingClientRect().width;\n}\nconst INTERNAL_UNITS = [\n    \"years\",\n    \"months\",\n    \"days\",\n    \"milliseconds\"\n];\nconst PARSE_RE = /^(-?)(?:(\\d+)\\.)?(\\d+):(\\d\\d)(?::(\\d\\d)(?:\\.(\\d\\d\\d))?)?/;\n// Parsing and Creation\nfunction createDuration(input, unit) {\n    if (typeof input === \"string\") {\n        return parseString(input);\n    }\n    if (typeof input === \"object\" && input) {\n        return parseObject(input);\n    }\n    if (typeof input === \"number\") {\n        return parseObject({\n            [unit || \"milliseconds\"]: input\n        });\n    }\n    return null;\n}\nfunction parseString(s) {\n    let m = PARSE_RE.exec(s);\n    if (m) {\n        let sign = m[1] ? -1 : 1;\n        return {\n            years: 0,\n            months: 0,\n            days: sign * (m[2] ? parseInt(m[2], 10) : 0),\n            milliseconds: sign * ((m[3] ? parseInt(m[3], 10) : 0) * 60 * 60 * 1000 + // hours\n            (m[4] ? parseInt(m[4], 10) : 0) * 60 * 1000 + // minutes\n            (m[5] ? parseInt(m[5], 10) : 0) * 1000 + // seconds\n            (m[6] ? parseInt(m[6], 10) : 0 // ms\n            ))\n        };\n    }\n    return null;\n}\nfunction parseObject(obj) {\n    let duration = {\n        years: obj.years || obj.year || 0,\n        months: obj.months || obj.month || 0,\n        days: obj.days || obj.day || 0,\n        milliseconds: (obj.hours || obj.hour || 0) * 60 * 60 * 1000 + // hours\n        (obj.minutes || obj.minute || 0) * 60 * 1000 + // minutes\n        (obj.seconds || obj.second || 0) * 1000 + // seconds\n        (obj.milliseconds || obj.millisecond || obj.ms || 0)\n    };\n    let weeks = obj.weeks || obj.week;\n    if (weeks) {\n        duration.days += weeks * 7;\n        duration.specifiedWeeks = true;\n    }\n    return duration;\n}\n// Equality\nfunction durationsEqual(d0, d1) {\n    return d0.years === d1.years && d0.months === d1.months && d0.days === d1.days && d0.milliseconds === d1.milliseconds;\n}\nfunction asCleanDays(dur) {\n    if (!dur.years && !dur.months && !dur.milliseconds) {\n        return dur.days;\n    }\n    return 0;\n}\n// Simple Math\nfunction addDurations(d0, d1) {\n    return {\n        years: d0.years + d1.years,\n        months: d0.months + d1.months,\n        days: d0.days + d1.days,\n        milliseconds: d0.milliseconds + d1.milliseconds\n    };\n}\nfunction subtractDurations(d1, d0) {\n    return {\n        years: d1.years - d0.years,\n        months: d1.months - d0.months,\n        days: d1.days - d0.days,\n        milliseconds: d1.milliseconds - d0.milliseconds\n    };\n}\nfunction multiplyDuration(d, n) {\n    return {\n        years: d.years * n,\n        months: d.months * n,\n        days: d.days * n,\n        milliseconds: d.milliseconds * n\n    };\n}\n// Conversions\n// \"Rough\" because they are based on average-case Gregorian months/years\nfunction asRoughYears(dur) {\n    return asRoughDays(dur) / 365;\n}\nfunction asRoughMonths(dur) {\n    return asRoughDays(dur) / 30;\n}\nfunction asRoughDays(dur) {\n    return asRoughMs(dur) / 864e5;\n}\nfunction asRoughMinutes(dur) {\n    return asRoughMs(dur) / (1000 * 60);\n}\nfunction asRoughSeconds(dur) {\n    return asRoughMs(dur) / 1000;\n}\nfunction asRoughMs(dur) {\n    return dur.years * (365 * 864e5) + dur.months * (30 * 864e5) + dur.days * 864e5 + dur.milliseconds;\n}\n// Advanced Math\nfunction wholeDivideDurations(numerator, denominator) {\n    let res = null;\n    for(let i = 0; i < INTERNAL_UNITS.length; i += 1){\n        let unit = INTERNAL_UNITS[i];\n        if (denominator[unit]) {\n            let localRes = numerator[unit] / denominator[unit];\n            if (!isInt(localRes) || res !== null && res !== localRes) {\n                return null;\n            }\n            res = localRes;\n        } else if (numerator[unit]) {\n            // needs to divide by something but can't!\n            return null;\n        }\n    }\n    return res;\n}\nfunction greatestDurationDenominator(dur) {\n    let ms = dur.milliseconds;\n    if (ms) {\n        if (ms % 1000 !== 0) {\n            return {\n                unit: \"millisecond\",\n                value: ms\n            };\n        }\n        if (ms % (1000 * 60) !== 0) {\n            return {\n                unit: \"second\",\n                value: ms / 1000\n            };\n        }\n        if (ms % (1000 * 60 * 60) !== 0) {\n            return {\n                unit: \"minute\",\n                value: ms / (1000 * 60)\n            };\n        }\n        if (ms) {\n            return {\n                unit: \"hour\",\n                value: ms / (1000 * 60 * 60)\n            };\n        }\n    }\n    if (dur.days) {\n        if (dur.specifiedWeeks && dur.days % 7 === 0) {\n            return {\n                unit: \"week\",\n                value: dur.days / 7\n            };\n        }\n        return {\n            unit: \"day\",\n            value: dur.days\n        };\n    }\n    if (dur.months) {\n        return {\n            unit: \"month\",\n            value: dur.months\n        };\n    }\n    if (dur.years) {\n        return {\n            unit: \"year\",\n            value: dur.years\n        };\n    }\n    return {\n        unit: \"millisecond\",\n        value: 0\n    };\n}\n// TODO: new util arrayify?\nfunction removeExact(array, exactVal) {\n    let removeCnt = 0;\n    let i = 0;\n    while(i < array.length){\n        if (array[i] === exactVal) {\n            array.splice(i, 1);\n            removeCnt += 1;\n        } else {\n            i += 1;\n        }\n    }\n    return removeCnt;\n}\nfunction isArraysEqual(a0, a1, equalityFunc) {\n    if (a0 === a1) {\n        return true;\n    }\n    let len = a0.length;\n    let i;\n    if (len !== a1.length) {\n        return false;\n    }\n    for(i = 0; i < len; i += 1){\n        if (!(equalityFunc ? equalityFunc(a0[i], a1[i]) : a0[i] === a1[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nconst DAY_IDS = [\n    \"sun\",\n    \"mon\",\n    \"tue\",\n    \"wed\",\n    \"thu\",\n    \"fri\",\n    \"sat\"\n];\n// Adding\nfunction addWeeks(m, n) {\n    let a = dateToUtcArray(m);\n    a[2] += n * 7;\n    return arrayToUtcDate(a);\n}\nfunction addDays(m, n) {\n    let a = dateToUtcArray(m);\n    a[2] += n;\n    return arrayToUtcDate(a);\n}\nfunction addMs(m, n) {\n    let a = dateToUtcArray(m);\n    a[6] += n;\n    return arrayToUtcDate(a);\n}\n// Diffing (all return floats)\n// TODO: why not use ranges?\nfunction diffWeeks(m0, m1) {\n    return diffDays(m0, m1) / 7;\n}\nfunction diffDays(m0, m1) {\n    return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60 * 24);\n}\nfunction diffHours(m0, m1) {\n    return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60);\n}\nfunction diffMinutes(m0, m1) {\n    return (m1.valueOf() - m0.valueOf()) / (1000 * 60);\n}\nfunction diffSeconds(m0, m1) {\n    return (m1.valueOf() - m0.valueOf()) / 1000;\n}\nfunction diffDayAndTime(m0, m1) {\n    let m0day = startOfDay(m0);\n    let m1day = startOfDay(m1);\n    return {\n        years: 0,\n        months: 0,\n        days: Math.round(diffDays(m0day, m1day)),\n        milliseconds: m1.valueOf() - m1day.valueOf() - (m0.valueOf() - m0day.valueOf())\n    };\n}\n// Diffing Whole Units\nfunction diffWholeWeeks(m0, m1) {\n    let d = diffWholeDays(m0, m1);\n    if (d !== null && d % 7 === 0) {\n        return d / 7;\n    }\n    return null;\n}\nfunction diffWholeDays(m0, m1) {\n    if (timeAsMs(m0) === timeAsMs(m1)) {\n        return Math.round(diffDays(m0, m1));\n    }\n    return null;\n}\n// Start-Of\nfunction startOfDay(m) {\n    return arrayToUtcDate([\n        m.getUTCFullYear(),\n        m.getUTCMonth(),\n        m.getUTCDate()\n    ]);\n}\nfunction startOfHour(m) {\n    return arrayToUtcDate([\n        m.getUTCFullYear(),\n        m.getUTCMonth(),\n        m.getUTCDate(),\n        m.getUTCHours()\n    ]);\n}\nfunction startOfMinute(m) {\n    return arrayToUtcDate([\n        m.getUTCFullYear(),\n        m.getUTCMonth(),\n        m.getUTCDate(),\n        m.getUTCHours(),\n        m.getUTCMinutes()\n    ]);\n}\nfunction startOfSecond(m) {\n    return arrayToUtcDate([\n        m.getUTCFullYear(),\n        m.getUTCMonth(),\n        m.getUTCDate(),\n        m.getUTCHours(),\n        m.getUTCMinutes(),\n        m.getUTCSeconds()\n    ]);\n}\n// Week Computation\nfunction weekOfYear(marker, dow, doy) {\n    let y = marker.getUTCFullYear();\n    let w = weekOfGivenYear(marker, y, dow, doy);\n    if (w < 1) {\n        return weekOfGivenYear(marker, y - 1, dow, doy);\n    }\n    let nextW = weekOfGivenYear(marker, y + 1, dow, doy);\n    if (nextW >= 1) {\n        return Math.min(w, nextW);\n    }\n    return w;\n}\nfunction weekOfGivenYear(marker, year, dow, doy) {\n    let firstWeekStart = arrayToUtcDate([\n        year,\n        0,\n        1 + firstWeekOffset(year, dow, doy)\n    ]);\n    let dayStart = startOfDay(marker);\n    let days = Math.round(diffDays(firstWeekStart, dayStart));\n    return Math.floor(days / 7) + 1; // zero-indexed\n}\n// start-of-first-week - start-of-year\nfunction firstWeekOffset(year, dow, doy) {\n    // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n    let fwd = 7 + dow - doy;\n    // first-week day local weekday -- which local weekday is fwd\n    let fwdlw = (7 + arrayToUtcDate([\n        year,\n        0,\n        fwd\n    ]).getUTCDay() - dow) % 7;\n    return -fwdlw + fwd - 1;\n}\n// Array Conversion\nfunction dateToLocalArray(date) {\n    return [\n        date.getFullYear(),\n        date.getMonth(),\n        date.getDate(),\n        date.getHours(),\n        date.getMinutes(),\n        date.getSeconds(),\n        date.getMilliseconds()\n    ];\n}\nfunction arrayToLocalDate(a) {\n    return new Date(a[0], a[1] || 0, a[2] == null ? 1 : a[2], a[3] || 0, a[4] || 0, a[5] || 0);\n}\nfunction dateToUtcArray(date) {\n    return [\n        date.getUTCFullYear(),\n        date.getUTCMonth(),\n        date.getUTCDate(),\n        date.getUTCHours(),\n        date.getUTCMinutes(),\n        date.getUTCSeconds(),\n        date.getUTCMilliseconds()\n    ];\n}\nfunction arrayToUtcDate(a) {\n    // according to web standards (and Safari), a month index is required.\n    // massage if only given a year.\n    if (a.length === 1) {\n        a = a.concat([\n            0\n        ]);\n    }\n    return new Date(Date.UTC(...a));\n}\n// Other Utils\nfunction isValidDate(m) {\n    return !isNaN(m.valueOf());\n}\nfunction timeAsMs(m) {\n    return m.getUTCHours() * 1000 * 60 * 60 + m.getUTCMinutes() * 1000 * 60 + m.getUTCSeconds() * 1000 + m.getUTCMilliseconds();\n}\n// timeZoneOffset is in minutes\nfunction buildIsoString(marker, timeZoneOffset, stripZeroTime = false) {\n    let s = marker.toISOString();\n    s = s.replace(\".000\", \"\");\n    if (stripZeroTime) {\n        s = s.replace(\"T00:00:00Z\", \"\");\n    }\n    if (s.length > 10) {\n        if (timeZoneOffset == null) {\n            s = s.replace(\"Z\", \"\");\n        } else if (timeZoneOffset !== 0) {\n            s = s.replace(\"Z\", formatTimeZoneOffset(timeZoneOffset, true));\n        }\n    // otherwise, its UTC-0 and we want to keep the Z\n    }\n    return s;\n}\n// formats the date, but with no time part\n// TODO: somehow merge with buildIsoString and stripZeroTime\n// TODO: rename. omit \"string\"\nfunction formatDayString(marker) {\n    return marker.toISOString().replace(/T.*$/, \"\");\n}\nfunction formatIsoMonthStr(marker) {\n    return marker.toISOString().match(/^\\d{4}-\\d{2}/)[0];\n}\n// TODO: use Date::toISOString and use everything after the T?\nfunction formatIsoTimeString(marker) {\n    return padStart(marker.getUTCHours(), 2) + \":\" + padStart(marker.getUTCMinutes(), 2) + \":\" + padStart(marker.getUTCSeconds(), 2);\n}\nfunction formatTimeZoneOffset(minutes, doIso = false) {\n    let sign = minutes < 0 ? \"-\" : \"+\";\n    let abs = Math.abs(minutes);\n    let hours = Math.floor(abs / 60);\n    let mins = Math.round(abs % 60);\n    if (doIso) {\n        return `${sign + padStart(hours, 2)}:${padStart(mins, 2)}`;\n    }\n    return `GMT${sign}${hours}${mins ? `:${padStart(mins, 2)}` : \"\"}`;\n}\nfunction memoize(workerFunc, resEquality, teardownFunc) {\n    let currentArgs;\n    let currentRes;\n    return function(...newArgs) {\n        if (!currentArgs) {\n            currentRes = workerFunc.apply(this, newArgs);\n        } else if (!isArraysEqual(currentArgs, newArgs)) {\n            if (teardownFunc) {\n                teardownFunc(currentRes);\n            }\n            let res = workerFunc.apply(this, newArgs);\n            if (!resEquality || !resEquality(res, currentRes)) {\n                currentRes = res;\n            }\n        }\n        currentArgs = newArgs;\n        return currentRes;\n    };\n}\nfunction memoizeObjArg(workerFunc, resEquality, teardownFunc) {\n    let currentArg;\n    let currentRes;\n    return (newArg)=>{\n        if (!currentArg) {\n            currentRes = workerFunc.call(this, newArg);\n        } else if (!isPropsEqual(currentArg, newArg)) {\n            if (teardownFunc) {\n                teardownFunc(currentRes);\n            }\n            let res = workerFunc.call(this, newArg);\n            if (!resEquality || !resEquality(res, currentRes)) {\n                currentRes = res;\n            }\n        }\n        currentArg = newArg;\n        return currentRes;\n    };\n}\nfunction memoizeArraylike(workerFunc, resEquality, teardownFunc) {\n    let currentArgSets = [];\n    let currentResults = [];\n    return (newArgSets)=>{\n        let currentLen = currentArgSets.length;\n        let newLen = newArgSets.length;\n        let i = 0;\n        for(; i < currentLen; i += 1){\n            if (!newArgSets[i]) {\n                if (teardownFunc) {\n                    teardownFunc(currentResults[i]);\n                }\n            } else if (!isArraysEqual(currentArgSets[i], newArgSets[i])) {\n                if (teardownFunc) {\n                    teardownFunc(currentResults[i]);\n                }\n                let res = workerFunc.apply(this, newArgSets[i]);\n                if (!resEquality || !resEquality(res, currentResults[i])) {\n                    currentResults[i] = res;\n                }\n            }\n        }\n        for(; i < newLen; i += 1){\n            currentResults[i] = workerFunc.apply(this, newArgSets[i]);\n        }\n        currentArgSets = newArgSets;\n        currentResults.splice(newLen); // remove excess\n        return currentResults;\n    };\n}\nfunction memoizeHashlike(workerFunc, resEquality, teardownFunc) {\n    let currentArgHash = {};\n    let currentResHash = {};\n    return (newArgHash)=>{\n        let newResHash = {};\n        for(let key in newArgHash){\n            if (!currentResHash[key]) {\n                newResHash[key] = workerFunc.apply(this, newArgHash[key]);\n            } else if (!isArraysEqual(currentArgHash[key], newArgHash[key])) {\n                if (teardownFunc) {\n                    teardownFunc(currentResHash[key]);\n                }\n                let res = workerFunc.apply(this, newArgHash[key]);\n                newResHash[key] = resEquality && resEquality(res, currentResHash[key]) ? currentResHash[key] : res;\n            } else {\n                newResHash[key] = currentResHash[key];\n            }\n        }\n        currentArgHash = newArgHash;\n        currentResHash = newResHash;\n        return newResHash;\n    };\n}\nconst EXTENDED_SETTINGS_AND_SEVERITIES = {\n    week: 3,\n    separator: 0,\n    omitZeroMinute: 0,\n    meridiem: 0,\n    omitCommas: 0\n};\nconst STANDARD_DATE_PROP_SEVERITIES = {\n    timeZoneName: 7,\n    era: 6,\n    year: 5,\n    month: 4,\n    day: 2,\n    weekday: 2,\n    hour: 1,\n    minute: 1,\n    second: 1\n};\nconst MERIDIEM_RE = /\\s*([ap])\\.?m\\.?/i; // eats up leading spaces too\nconst COMMA_RE = /,/g; // we need re for globalness\nconst MULTI_SPACE_RE = /\\s+/g;\nconst LTR_RE = /\\u200e/g; // control character\nconst UTC_RE = /UTC|GMT/;\nclass NativeFormatter {\n    constructor(formatSettings){\n        let standardDateProps = {};\n        let extendedSettings = {};\n        let severity = 0;\n        for(let name in formatSettings){\n            if (name in EXTENDED_SETTINGS_AND_SEVERITIES) {\n                extendedSettings[name] = formatSettings[name];\n                severity = Math.max(EXTENDED_SETTINGS_AND_SEVERITIES[name], severity);\n            } else {\n                standardDateProps[name] = formatSettings[name];\n                if (name in STANDARD_DATE_PROP_SEVERITIES) {\n                    severity = Math.max(STANDARD_DATE_PROP_SEVERITIES[name], severity);\n                }\n            }\n        }\n        this.standardDateProps = standardDateProps;\n        this.extendedSettings = extendedSettings;\n        this.severity = severity;\n        this.buildFormattingFunc = memoize(buildFormattingFunc);\n    }\n    format(date, context) {\n        return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, context)(date);\n    }\n    formatRange(start, end, context, betterDefaultSeparator) {\n        let { standardDateProps, extendedSettings } = this;\n        let diffSeverity = computeMarkerDiffSeverity(start.marker, end.marker, context.calendarSystem);\n        if (!diffSeverity) {\n            return this.format(start, context);\n        }\n        let biggestUnitForPartial = diffSeverity;\n        if (biggestUnitForPartial > 1 && // the two dates are different in a way that's larger scale than time\n        (standardDateProps.year === \"numeric\" || standardDateProps.year === \"2-digit\") && (standardDateProps.month === \"numeric\" || standardDateProps.month === \"2-digit\") && (standardDateProps.day === \"numeric\" || standardDateProps.day === \"2-digit\")) {\n            biggestUnitForPartial = 1; // make it look like the dates are only different in terms of time\n        }\n        let full0 = this.format(start, context);\n        let full1 = this.format(end, context);\n        if (full0 === full1) {\n            return full0;\n        }\n        let partialDateProps = computePartialFormattingOptions(standardDateProps, biggestUnitForPartial);\n        let partialFormattingFunc = buildFormattingFunc(partialDateProps, extendedSettings, context);\n        let partial0 = partialFormattingFunc(start);\n        let partial1 = partialFormattingFunc(end);\n        let insertion = findCommonInsertion(full0, partial0, full1, partial1);\n        let separator = extendedSettings.separator || betterDefaultSeparator || context.defaultSeparator || \"\";\n        if (insertion) {\n            return insertion.before + partial0 + separator + partial1 + insertion.after;\n        }\n        return full0 + separator + full1;\n    }\n    getLargestUnit() {\n        switch(this.severity){\n            case 7:\n            case 6:\n            case 5:\n                return \"year\";\n            case 4:\n                return \"month\";\n            case 3:\n                return \"week\";\n            case 2:\n                return \"day\";\n            default:\n                return \"time\"; // really?\n        }\n    }\n}\nfunction buildFormattingFunc(standardDateProps, extendedSettings, context) {\n    let standardDatePropCnt = Object.keys(standardDateProps).length;\n    if (standardDatePropCnt === 1 && standardDateProps.timeZoneName === \"short\") {\n        return (date)=>formatTimeZoneOffset(date.timeZoneOffset);\n    }\n    if (standardDatePropCnt === 0 && extendedSettings.week) {\n        return (date)=>formatWeekNumber(context.computeWeekNumber(date.marker), context.weekText, context.weekTextLong, context.locale, extendedSettings.week);\n    }\n    return buildNativeFormattingFunc(standardDateProps, extendedSettings, context);\n}\nfunction buildNativeFormattingFunc(standardDateProps, extendedSettings, context) {\n    standardDateProps = Object.assign({}, standardDateProps); // copy\n    extendedSettings = Object.assign({}, extendedSettings); // copy\n    sanitizeSettings(standardDateProps, extendedSettings);\n    standardDateProps.timeZone = \"UTC\"; // we leverage the only guaranteed timeZone for our UTC markers\n    let normalFormat = new Intl.DateTimeFormat(context.locale.codes, standardDateProps);\n    let zeroFormat; // needed?\n    if (extendedSettings.omitZeroMinute) {\n        let zeroProps = Object.assign({}, standardDateProps);\n        delete zeroProps.minute; // seconds and ms were already considered in sanitizeSettings\n        zeroFormat = new Intl.DateTimeFormat(context.locale.codes, zeroProps);\n    }\n    return (date)=>{\n        let { marker } = date;\n        let format;\n        if (zeroFormat && !marker.getUTCMinutes()) {\n            format = zeroFormat;\n        } else {\n            format = normalFormat;\n        }\n        let s = format.format(marker);\n        return postProcess(s, date, standardDateProps, extendedSettings, context);\n    };\n}\nfunction sanitizeSettings(standardDateProps, extendedSettings) {\n    // deal with a browser inconsistency where formatting the timezone\n    // requires that the hour/minute be present.\n    if (standardDateProps.timeZoneName) {\n        if (!standardDateProps.hour) {\n            standardDateProps.hour = \"2-digit\";\n        }\n        if (!standardDateProps.minute) {\n            standardDateProps.minute = \"2-digit\";\n        }\n    }\n    // only support short timezone names\n    if (standardDateProps.timeZoneName === \"long\") {\n        standardDateProps.timeZoneName = \"short\";\n    }\n    // if requesting to display seconds, MUST display minutes\n    if (extendedSettings.omitZeroMinute && (standardDateProps.second || standardDateProps.millisecond)) {\n        delete extendedSettings.omitZeroMinute;\n    }\n}\nfunction postProcess(s, date, standardDateProps, extendedSettings, context) {\n    s = s.replace(LTR_RE, \"\"); // remove left-to-right control chars. do first. good for other regexes\n    if (standardDateProps.timeZoneName === \"short\") {\n        s = injectTzoStr(s, context.timeZone === \"UTC\" || date.timeZoneOffset == null ? \"UTC\" : formatTimeZoneOffset(date.timeZoneOffset));\n    }\n    if (extendedSettings.omitCommas) {\n        s = s.replace(COMMA_RE, \"\").trim();\n    }\n    if (extendedSettings.omitZeroMinute) {\n        s = s.replace(\":00\", \"\"); // zeroFormat doesn't always achieve this\n    }\n    // ^ do anything that might create adjacent spaces before this point,\n    // because MERIDIEM_RE likes to eat up loading spaces\n    if (extendedSettings.meridiem === false) {\n        s = s.replace(MERIDIEM_RE, \"\").trim();\n    } else if (extendedSettings.meridiem === \"narrow\") {\n        s = s.replace(MERIDIEM_RE, (m0, m1)=>m1.toLocaleLowerCase());\n    } else if (extendedSettings.meridiem === \"short\") {\n        s = s.replace(MERIDIEM_RE, (m0, m1)=>`${m1.toLocaleLowerCase()}m`);\n    } else if (extendedSettings.meridiem === \"lowercase\") {\n        s = s.replace(MERIDIEM_RE, (m0)=>m0.toLocaleLowerCase());\n    }\n    s = s.replace(MULTI_SPACE_RE, \" \");\n    s = s.trim();\n    return s;\n}\nfunction injectTzoStr(s, tzoStr) {\n    let replaced = false;\n    s = s.replace(UTC_RE, ()=>{\n        replaced = true;\n        return tzoStr;\n    });\n    // IE11 doesn't include UTC/GMT in the original string, so append to end\n    if (!replaced) {\n        s += ` ${tzoStr}`;\n    }\n    return s;\n}\nfunction formatWeekNumber(num, weekText, weekTextLong, locale, display) {\n    let parts = [];\n    if (display === \"long\") {\n        parts.push(weekTextLong);\n    } else if (display === \"short\" || display === \"narrow\") {\n        parts.push(weekText);\n    }\n    if (display === \"long\" || display === \"short\") {\n        parts.push(\" \");\n    }\n    parts.push(locale.simpleNumberFormat.format(num));\n    if (locale.options.direction === \"rtl\") {\n        parts.reverse();\n    }\n    return parts.join(\"\");\n}\n// Range Formatting Utils\n// 0 = exactly the same\n// 1 = different by time\n// and bigger\nfunction computeMarkerDiffSeverity(d0, d1, ca) {\n    if (ca.getMarkerYear(d0) !== ca.getMarkerYear(d1)) {\n        return 5;\n    }\n    if (ca.getMarkerMonth(d0) !== ca.getMarkerMonth(d1)) {\n        return 4;\n    }\n    if (ca.getMarkerDay(d0) !== ca.getMarkerDay(d1)) {\n        return 2;\n    }\n    if (timeAsMs(d0) !== timeAsMs(d1)) {\n        return 1;\n    }\n    return 0;\n}\nfunction computePartialFormattingOptions(options, biggestUnit) {\n    let partialOptions = {};\n    for(let name in options){\n        if (!(name in STANDARD_DATE_PROP_SEVERITIES) || // not a date part prop (like timeZone)\n        STANDARD_DATE_PROP_SEVERITIES[name] <= biggestUnit) {\n            partialOptions[name] = options[name];\n        }\n    }\n    return partialOptions;\n}\nfunction findCommonInsertion(full0, partial0, full1, partial1) {\n    let i0 = 0;\n    while(i0 < full0.length){\n        let found0 = full0.indexOf(partial0, i0);\n        if (found0 === -1) {\n            break;\n        }\n        let before0 = full0.substr(0, found0);\n        i0 = found0 + partial0.length;\n        let after0 = full0.substr(i0);\n        let i1 = 0;\n        while(i1 < full1.length){\n            let found1 = full1.indexOf(partial1, i1);\n            if (found1 === -1) {\n                break;\n            }\n            let before1 = full1.substr(0, found1);\n            i1 = found1 + partial1.length;\n            let after1 = full1.substr(i1);\n            if (before0 === before1 && after0 === after1) {\n                return {\n                    before: before0,\n                    after: after0\n                };\n            }\n        }\n    }\n    return null;\n}\nfunction expandZonedMarker(dateInfo, calendarSystem) {\n    let a = calendarSystem.markerToArray(dateInfo.marker);\n    return {\n        marker: dateInfo.marker,\n        timeZoneOffset: dateInfo.timeZoneOffset,\n        array: a,\n        year: a[0],\n        month: a[1],\n        day: a[2],\n        hour: a[3],\n        minute: a[4],\n        second: a[5],\n        millisecond: a[6]\n    };\n}\nfunction createVerboseFormattingArg(start, end, context, betterDefaultSeparator) {\n    let startInfo = expandZonedMarker(start, context.calendarSystem);\n    let endInfo = end ? expandZonedMarker(end, context.calendarSystem) : null;\n    return {\n        date: startInfo,\n        start: startInfo,\n        end: endInfo,\n        timeZone: context.timeZone,\n        localeCodes: context.locale.codes,\n        defaultSeparator: betterDefaultSeparator || context.defaultSeparator\n    };\n}\n/*\nTODO: fix the terminology of \"formatter\" vs \"formatting func\"\n*/ /*\nAt the time of instantiation, this object does not know which cmd-formatting system it will use.\nIt receives this at the time of formatting, as a setting.\n*/ class CmdFormatter {\n    constructor(cmdStr){\n        this.cmdStr = cmdStr;\n    }\n    format(date, context, betterDefaultSeparator) {\n        return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(date, null, context, betterDefaultSeparator));\n    }\n    formatRange(start, end, context, betterDefaultSeparator) {\n        return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(start, end, context, betterDefaultSeparator));\n    }\n}\nclass FuncFormatter {\n    constructor(func){\n        this.func = func;\n    }\n    format(date, context, betterDefaultSeparator) {\n        return this.func(createVerboseFormattingArg(date, null, context, betterDefaultSeparator));\n    }\n    formatRange(start, end, context, betterDefaultSeparator) {\n        return this.func(createVerboseFormattingArg(start, end, context, betterDefaultSeparator));\n    }\n}\nfunction createFormatter(input) {\n    if (typeof input === \"object\" && input) {\n        return new NativeFormatter(input);\n    }\n    if (typeof input === \"string\") {\n        return new CmdFormatter(input);\n    }\n    if (typeof input === \"function\") {\n        return new FuncFormatter(input);\n    }\n    return null;\n}\n// base options\n// ------------\nconst BASE_OPTION_REFINERS = {\n    navLinkDayClick: identity,\n    navLinkWeekClick: identity,\n    duration: createDuration,\n    bootstrapFontAwesome: identity,\n    buttonIcons: identity,\n    customButtons: identity,\n    defaultAllDayEventDuration: createDuration,\n    defaultTimedEventDuration: createDuration,\n    nextDayThreshold: createDuration,\n    scrollTime: createDuration,\n    scrollTimeReset: Boolean,\n    slotMinTime: createDuration,\n    slotMaxTime: createDuration,\n    dayPopoverFormat: createFormatter,\n    slotDuration: createDuration,\n    snapDuration: createDuration,\n    headerToolbar: identity,\n    footerToolbar: identity,\n    defaultRangeSeparator: String,\n    titleRangeSeparator: String,\n    forceEventDuration: Boolean,\n    dayHeaders: Boolean,\n    dayHeaderFormat: createFormatter,\n    dayHeaderClassNames: identity,\n    dayHeaderContent: identity,\n    dayHeaderDidMount: identity,\n    dayHeaderWillUnmount: identity,\n    dayCellClassNames: identity,\n    dayCellContent: identity,\n    dayCellDidMount: identity,\n    dayCellWillUnmount: identity,\n    initialView: String,\n    aspectRatio: Number,\n    weekends: Boolean,\n    weekNumberCalculation: identity,\n    weekNumbers: Boolean,\n    weekNumberClassNames: identity,\n    weekNumberContent: identity,\n    weekNumberDidMount: identity,\n    weekNumberWillUnmount: identity,\n    editable: Boolean,\n    viewClassNames: identity,\n    viewDidMount: identity,\n    viewWillUnmount: identity,\n    nowIndicator: Boolean,\n    nowIndicatorClassNames: identity,\n    nowIndicatorContent: identity,\n    nowIndicatorDidMount: identity,\n    nowIndicatorWillUnmount: identity,\n    showNonCurrentDates: Boolean,\n    lazyFetching: Boolean,\n    startParam: String,\n    endParam: String,\n    timeZoneParam: String,\n    timeZone: String,\n    locales: identity,\n    locale: identity,\n    themeSystem: String,\n    dragRevertDuration: Number,\n    dragScroll: Boolean,\n    allDayMaintainDuration: Boolean,\n    unselectAuto: Boolean,\n    dropAccept: identity,\n    eventOrder: parseFieldSpecs,\n    eventOrderStrict: Boolean,\n    handleWindowResize: Boolean,\n    windowResizeDelay: Number,\n    longPressDelay: Number,\n    eventDragMinDistance: Number,\n    expandRows: Boolean,\n    height: identity,\n    contentHeight: identity,\n    direction: String,\n    weekNumberFormat: createFormatter,\n    eventResizableFromStart: Boolean,\n    displayEventTime: Boolean,\n    displayEventEnd: Boolean,\n    weekText: String,\n    weekTextLong: String,\n    progressiveEventRendering: Boolean,\n    businessHours: identity,\n    initialDate: identity,\n    now: identity,\n    eventDataTransform: identity,\n    stickyHeaderDates: identity,\n    stickyFooterScrollbar: identity,\n    viewHeight: identity,\n    defaultAllDay: Boolean,\n    eventSourceFailure: identity,\n    eventSourceSuccess: identity,\n    eventDisplay: String,\n    eventStartEditable: Boolean,\n    eventDurationEditable: Boolean,\n    eventOverlap: identity,\n    eventConstraint: identity,\n    eventAllow: identity,\n    eventBackgroundColor: String,\n    eventBorderColor: String,\n    eventTextColor: String,\n    eventColor: String,\n    eventClassNames: identity,\n    eventContent: identity,\n    eventDidMount: identity,\n    eventWillUnmount: identity,\n    selectConstraint: identity,\n    selectOverlap: identity,\n    selectAllow: identity,\n    droppable: Boolean,\n    unselectCancel: String,\n    slotLabelFormat: identity,\n    slotLaneClassNames: identity,\n    slotLaneContent: identity,\n    slotLaneDidMount: identity,\n    slotLaneWillUnmount: identity,\n    slotLabelClassNames: identity,\n    slotLabelContent: identity,\n    slotLabelDidMount: identity,\n    slotLabelWillUnmount: identity,\n    dayMaxEvents: identity,\n    dayMaxEventRows: identity,\n    dayMinWidth: Number,\n    slotLabelInterval: createDuration,\n    allDayText: String,\n    allDayClassNames: identity,\n    allDayContent: identity,\n    allDayDidMount: identity,\n    allDayWillUnmount: identity,\n    slotMinWidth: Number,\n    navLinks: Boolean,\n    eventTimeFormat: createFormatter,\n    rerenderDelay: Number,\n    moreLinkText: identity,\n    moreLinkHint: identity,\n    selectMinDistance: Number,\n    selectable: Boolean,\n    selectLongPressDelay: Number,\n    eventLongPressDelay: Number,\n    selectMirror: Boolean,\n    eventMaxStack: Number,\n    eventMinHeight: Number,\n    eventMinWidth: Number,\n    eventShortHeight: Number,\n    slotEventOverlap: Boolean,\n    plugins: identity,\n    firstDay: Number,\n    dayCount: Number,\n    dateAlignment: String,\n    dateIncrement: createDuration,\n    hiddenDays: identity,\n    fixedWeekCount: Boolean,\n    validRange: identity,\n    visibleRange: identity,\n    titleFormat: identity,\n    eventInteractive: Boolean,\n    // only used by list-view, but languages define the value, so we need it in base options\n    noEventsText: String,\n    viewHint: identity,\n    navLinkHint: identity,\n    closeHint: String,\n    timeHint: String,\n    eventHint: String,\n    moreLinkClick: identity,\n    moreLinkClassNames: identity,\n    moreLinkContent: identity,\n    moreLinkDidMount: identity,\n    moreLinkWillUnmount: identity,\n    monthStartFormat: createFormatter,\n    // for connectors\n    // (can't be part of plugin system b/c must be provided at runtime)\n    handleCustomRendering: identity,\n    customRenderingMetaMap: identity,\n    customRenderingReplaces: Boolean\n};\n// do NOT give a type here. need `typeof BASE_OPTION_DEFAULTS` to give real results.\n// raw values.\nconst BASE_OPTION_DEFAULTS = {\n    eventDisplay: \"auto\",\n    defaultRangeSeparator: \" - \",\n    titleRangeSeparator: \"  \",\n    defaultTimedEventDuration: \"01:00:00\",\n    defaultAllDayEventDuration: {\n        day: 1\n    },\n    forceEventDuration: false,\n    nextDayThreshold: \"00:00:00\",\n    dayHeaders: true,\n    initialView: \"\",\n    aspectRatio: 1.35,\n    headerToolbar: {\n        start: \"title\",\n        center: \"\",\n        end: \"today prev,next\"\n    },\n    weekends: true,\n    weekNumbers: false,\n    weekNumberCalculation: \"local\",\n    editable: false,\n    nowIndicator: false,\n    scrollTime: \"06:00:00\",\n    scrollTimeReset: true,\n    slotMinTime: \"00:00:00\",\n    slotMaxTime: \"24:00:00\",\n    showNonCurrentDates: true,\n    lazyFetching: true,\n    startParam: \"start\",\n    endParam: \"end\",\n    timeZoneParam: \"timeZone\",\n    timeZone: \"local\",\n    locales: [],\n    locale: \"\",\n    themeSystem: \"standard\",\n    dragRevertDuration: 500,\n    dragScroll: true,\n    allDayMaintainDuration: false,\n    unselectAuto: true,\n    dropAccept: \"*\",\n    eventOrder: \"start,-duration,allDay,title\",\n    dayPopoverFormat: {\n        month: \"long\",\n        day: \"numeric\",\n        year: \"numeric\"\n    },\n    handleWindowResize: true,\n    windowResizeDelay: 100,\n    longPressDelay: 1000,\n    eventDragMinDistance: 5,\n    expandRows: false,\n    navLinks: false,\n    selectable: false,\n    eventMinHeight: 15,\n    eventMinWidth: 30,\n    eventShortHeight: 30,\n    monthStartFormat: {\n        month: \"long\",\n        day: \"numeric\"\n    }\n};\n// calendar listeners\n// ------------------\nconst CALENDAR_LISTENER_REFINERS = {\n    datesSet: identity,\n    eventsSet: identity,\n    eventAdd: identity,\n    eventChange: identity,\n    eventRemove: identity,\n    windowResize: identity,\n    eventClick: identity,\n    eventMouseEnter: identity,\n    eventMouseLeave: identity,\n    select: identity,\n    unselect: identity,\n    loading: identity,\n    // internal\n    _unmount: identity,\n    _beforeprint: identity,\n    _afterprint: identity,\n    _noEventDrop: identity,\n    _noEventResize: identity,\n    _resize: identity,\n    _scrollRequest: identity\n};\n// calendar-specific options\n// -------------------------\nconst CALENDAR_OPTION_REFINERS = {\n    buttonText: identity,\n    buttonHints: identity,\n    views: identity,\n    plugins: identity,\n    initialEvents: identity,\n    events: identity,\n    eventSources: identity\n};\nconst COMPLEX_OPTION_COMPARATORS = {\n    headerToolbar: isMaybeObjectsEqual,\n    footerToolbar: isMaybeObjectsEqual,\n    buttonText: isMaybeObjectsEqual,\n    buttonHints: isMaybeObjectsEqual,\n    buttonIcons: isMaybeObjectsEqual,\n    dateIncrement: isMaybeObjectsEqual,\n    plugins: isMaybeArraysEqual,\n    events: isMaybeArraysEqual,\n    eventSources: isMaybeArraysEqual,\n    [\"resources\"]: isMaybeArraysEqual\n};\nfunction isMaybeObjectsEqual(a, b) {\n    if (typeof a === \"object\" && typeof b === \"object\" && a && b) {\n        return isPropsEqual(a, b);\n    }\n    return a === b;\n}\nfunction isMaybeArraysEqual(a, b) {\n    if (Array.isArray(a) && Array.isArray(b)) {\n        return isArraysEqual(a, b);\n    }\n    return a === b;\n}\n// view-specific options\n// ---------------------\nconst VIEW_OPTION_REFINERS = {\n    type: String,\n    component: identity,\n    buttonText: String,\n    buttonTextKey: String,\n    dateProfileGeneratorClass: identity,\n    usesMinMaxTime: Boolean,\n    classNames: identity,\n    content: identity,\n    didMount: identity,\n    willUnmount: identity\n};\n// util funcs\n// ----------------------------------------------------------------------------------------------------\nfunction mergeRawOptions(optionSets) {\n    return mergeProps(optionSets, COMPLEX_OPTION_COMPARATORS);\n}\nfunction refineProps(input, refiners) {\n    let refined = {};\n    let extra = {};\n    for(let propName in refiners){\n        if (propName in input) {\n            refined[propName] = refiners[propName](input[propName]);\n        }\n    }\n    for(let propName in input){\n        if (!(propName in refiners)) {\n            extra[propName] = input[propName];\n        }\n    }\n    return {\n        refined,\n        extra\n    };\n}\nfunction identity(raw) {\n    return raw;\n}\nconst { hasOwnProperty } = Object.prototype;\n// Merges an array of objects into a single object.\n// The second argument allows for an array of property names who's object values will be merged together.\nfunction mergeProps(propObjs, complexPropsMap) {\n    let dest = {};\n    if (complexPropsMap) {\n        for(let name in complexPropsMap){\n            if (complexPropsMap[name] === isMaybeObjectsEqual) {\n                let complexObjs = [];\n                // collect the trailing object values, stopping when a non-object is discovered\n                for(let i = propObjs.length - 1; i >= 0; i -= 1){\n                    let val = propObjs[i][name];\n                    if (typeof val === \"object\" && val) {\n                        complexObjs.unshift(val);\n                    } else if (val !== undefined) {\n                        dest[name] = val; // if there were no objects, this value will be used\n                        break;\n                    }\n                }\n                // if the trailing values were objects, use the merged value\n                if (complexObjs.length) {\n                    dest[name] = mergeProps(complexObjs);\n                }\n            }\n        }\n    }\n    // copy values into the destination, going from last to first\n    for(let i = propObjs.length - 1; i >= 0; i -= 1){\n        let props = propObjs[i];\n        for(let name in props){\n            if (!(name in dest)) {\n                dest[name] = props[name];\n            }\n        }\n    }\n    return dest;\n}\nfunction filterHash(hash, func) {\n    let filtered = {};\n    for(let key in hash){\n        if (func(hash[key], key)) {\n            filtered[key] = hash[key];\n        }\n    }\n    return filtered;\n}\nfunction mapHash(hash, func) {\n    let newHash = {};\n    for(let key in hash){\n        newHash[key] = func(hash[key], key);\n    }\n    return newHash;\n}\nfunction arrayToHash(a) {\n    let hash = {};\n    for (let item of a){\n        hash[item] = true;\n    }\n    return hash;\n}\n// TODO: reassess browser support\n// https://caniuse.com/?search=object.values\nfunction hashValuesToArray(obj) {\n    let a = [];\n    for(let key in obj){\n        a.push(obj[key]);\n    }\n    return a;\n}\nfunction isPropsEqual(obj0, obj1) {\n    if (obj0 === obj1) {\n        return true;\n    }\n    for(let key in obj0){\n        if (hasOwnProperty.call(obj0, key)) {\n            if (!(key in obj1)) {\n                return false;\n            }\n        }\n    }\n    for(let key in obj1){\n        if (hasOwnProperty.call(obj1, key)) {\n            if (obj0[key] !== obj1[key]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nconst HANDLER_RE = /^on[A-Z]/;\nfunction isNonHandlerPropsEqual(obj0, obj1) {\n    const keys = getUnequalProps(obj0, obj1);\n    for (let key of keys){\n        if (!HANDLER_RE.test(key)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction getUnequalProps(obj0, obj1) {\n    let keys = [];\n    for(let key in obj0){\n        if (hasOwnProperty.call(obj0, key)) {\n            if (!(key in obj1)) {\n                keys.push(key);\n            }\n        }\n    }\n    for(let key in obj1){\n        if (hasOwnProperty.call(obj1, key)) {\n            if (obj0[key] !== obj1[key]) {\n                keys.push(key);\n            }\n        }\n    }\n    return keys;\n}\nfunction compareObjs(oldProps, newProps, equalityFuncs = {}) {\n    if (oldProps === newProps) {\n        return true;\n    }\n    for(let key in newProps){\n        if (key in oldProps && isObjValsEqual(oldProps[key], newProps[key], equalityFuncs[key])) ;\n        else {\n            return false;\n        }\n    }\n    // check for props that were omitted in the new\n    for(let key in oldProps){\n        if (!(key in newProps)) {\n            return false;\n        }\n    }\n    return true;\n}\n/*\nassumed \"true\" equality for handler names like \"onReceiveSomething\"\n*/ function isObjValsEqual(val0, val1, comparator) {\n    if (val0 === val1 || comparator === true) {\n        return true;\n    }\n    if (comparator) {\n        return comparator(val0, val1);\n    }\n    return false;\n}\nfunction collectFromHash(hash, startIndex = 0, endIndex, step = 1) {\n    let res = [];\n    if (endIndex == null) {\n        endIndex = Object.keys(hash).length;\n    }\n    for(let i = startIndex; i < endIndex; i += step){\n        let val = hash[i];\n        if (val !== undefined) {\n            res.push(val);\n        }\n    }\n    return res;\n}\nlet calendarSystemClassMap = {};\nfunction registerCalendarSystem(name, theClass) {\n    calendarSystemClassMap[name] = theClass;\n}\nfunction createCalendarSystem(name) {\n    return new calendarSystemClassMap[name]();\n}\nclass GregorianCalendarSystem {\n    getMarkerYear(d) {\n        return d.getUTCFullYear();\n    }\n    getMarkerMonth(d) {\n        return d.getUTCMonth();\n    }\n    getMarkerDay(d) {\n        return d.getUTCDate();\n    }\n    arrayToMarker(arr) {\n        return arrayToUtcDate(arr);\n    }\n    markerToArray(marker) {\n        return dateToUtcArray(marker);\n    }\n}\nregisterCalendarSystem(\"gregory\", GregorianCalendarSystem);\nconst ISO_RE = /^\\s*(\\d{4})(-?(\\d{2})(-?(\\d{2})([T ](\\d{2}):?(\\d{2})(:?(\\d{2})(\\.(\\d+))?)?(Z|(([-+])(\\d{2})(:?(\\d{2}))?))?)?)?)?$/;\nfunction parse(str) {\n    let m = ISO_RE.exec(str);\n    if (m) {\n        let marker = new Date(Date.UTC(Number(m[1]), m[3] ? Number(m[3]) - 1 : 0, Number(m[5] || 1), Number(m[7] || 0), Number(m[8] || 0), Number(m[10] || 0), m[12] ? Number(`0.${m[12]}`) * 1000 : 0));\n        if (isValidDate(marker)) {\n            let timeZoneOffset = null;\n            if (m[13]) {\n                timeZoneOffset = (m[15] === \"-\" ? -1 : 1) * (Number(m[16] || 0) * 60 + Number(m[18] || 0));\n            }\n            return {\n                marker,\n                isTimeUnspecified: !m[6],\n                timeZoneOffset\n            };\n        }\n    }\n    return null;\n}\nclass DateEnv {\n    constructor(settings){\n        let timeZone = this.timeZone = settings.timeZone;\n        let isNamedTimeZone = timeZone !== \"local\" && timeZone !== \"UTC\";\n        if (settings.namedTimeZoneImpl && isNamedTimeZone) {\n            this.namedTimeZoneImpl = new settings.namedTimeZoneImpl(timeZone);\n        }\n        this.canComputeOffset = Boolean(!isNamedTimeZone || this.namedTimeZoneImpl);\n        this.calendarSystem = createCalendarSystem(settings.calendarSystem);\n        this.locale = settings.locale;\n        this.weekDow = settings.locale.week.dow;\n        this.weekDoy = settings.locale.week.doy;\n        if (settings.weekNumberCalculation === \"ISO\") {\n            this.weekDow = 1;\n            this.weekDoy = 4;\n        }\n        if (typeof settings.firstDay === \"number\") {\n            this.weekDow = settings.firstDay;\n        }\n        if (typeof settings.weekNumberCalculation === \"function\") {\n            this.weekNumberFunc = settings.weekNumberCalculation;\n        }\n        this.weekText = settings.weekText != null ? settings.weekText : settings.locale.options.weekText;\n        this.weekTextLong = (settings.weekTextLong != null ? settings.weekTextLong : settings.locale.options.weekTextLong) || this.weekText;\n        this.cmdFormatter = settings.cmdFormatter;\n        this.defaultSeparator = settings.defaultSeparator;\n    }\n    // Creating / Parsing\n    createMarker(input) {\n        let meta = this.createMarkerMeta(input);\n        if (meta === null) {\n            return null;\n        }\n        return meta.marker;\n    }\n    createNowMarker() {\n        if (this.canComputeOffset) {\n            return this.timestampToMarker(new Date().valueOf());\n        }\n        // if we can't compute the current date val for a timezone,\n        // better to give the current local date vals than UTC\n        return arrayToUtcDate(dateToLocalArray(new Date()));\n    }\n    createMarkerMeta(input) {\n        if (typeof input === \"string\") {\n            return this.parse(input);\n        }\n        let marker = null;\n        if (typeof input === \"number\") {\n            marker = this.timestampToMarker(input);\n        } else if (input instanceof Date) {\n            input = input.valueOf();\n            if (!isNaN(input)) {\n                marker = this.timestampToMarker(input);\n            }\n        } else if (Array.isArray(input)) {\n            marker = arrayToUtcDate(input);\n        }\n        if (marker === null || !isValidDate(marker)) {\n            return null;\n        }\n        return {\n            marker,\n            isTimeUnspecified: false,\n            forcedTzo: null\n        };\n    }\n    parse(s) {\n        let parts = parse(s);\n        if (parts === null) {\n            return null;\n        }\n        let { marker } = parts;\n        let forcedTzo = null;\n        if (parts.timeZoneOffset !== null) {\n            if (this.canComputeOffset) {\n                marker = this.timestampToMarker(marker.valueOf() - parts.timeZoneOffset * 60 * 1000);\n            } else {\n                forcedTzo = parts.timeZoneOffset;\n            }\n        }\n        return {\n            marker,\n            isTimeUnspecified: parts.isTimeUnspecified,\n            forcedTzo\n        };\n    }\n    // Accessors\n    getYear(marker) {\n        return this.calendarSystem.getMarkerYear(marker);\n    }\n    getMonth(marker) {\n        return this.calendarSystem.getMarkerMonth(marker);\n    }\n    getDay(marker) {\n        return this.calendarSystem.getMarkerDay(marker);\n    }\n    // Adding / Subtracting\n    add(marker, dur) {\n        let a = this.calendarSystem.markerToArray(marker);\n        a[0] += dur.years;\n        a[1] += dur.months;\n        a[2] += dur.days;\n        a[6] += dur.milliseconds;\n        return this.calendarSystem.arrayToMarker(a);\n    }\n    subtract(marker, dur) {\n        let a = this.calendarSystem.markerToArray(marker);\n        a[0] -= dur.years;\n        a[1] -= dur.months;\n        a[2] -= dur.days;\n        a[6] -= dur.milliseconds;\n        return this.calendarSystem.arrayToMarker(a);\n    }\n    addYears(marker, n) {\n        let a = this.calendarSystem.markerToArray(marker);\n        a[0] += n;\n        return this.calendarSystem.arrayToMarker(a);\n    }\n    addMonths(marker, n) {\n        let a = this.calendarSystem.markerToArray(marker);\n        a[1] += n;\n        return this.calendarSystem.arrayToMarker(a);\n    }\n    // Diffing Whole Units\n    diffWholeYears(m0, m1) {\n        let { calendarSystem } = this;\n        if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1) && calendarSystem.getMarkerMonth(m0) === calendarSystem.getMarkerMonth(m1)) {\n            return calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0);\n        }\n        return null;\n    }\n    diffWholeMonths(m0, m1) {\n        let { calendarSystem } = this;\n        if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1)) {\n            return calendarSystem.getMarkerMonth(m1) - calendarSystem.getMarkerMonth(m0) + (calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0)) * 12;\n        }\n        return null;\n    }\n    // Range / Duration\n    greatestWholeUnit(m0, m1) {\n        let n = this.diffWholeYears(m0, m1);\n        if (n !== null) {\n            return {\n                unit: \"year\",\n                value: n\n            };\n        }\n        n = this.diffWholeMonths(m0, m1);\n        if (n !== null) {\n            return {\n                unit: \"month\",\n                value: n\n            };\n        }\n        n = diffWholeWeeks(m0, m1);\n        if (n !== null) {\n            return {\n                unit: \"week\",\n                value: n\n            };\n        }\n        n = diffWholeDays(m0, m1);\n        if (n !== null) {\n            return {\n                unit: \"day\",\n                value: n\n            };\n        }\n        n = diffHours(m0, m1);\n        if (isInt(n)) {\n            return {\n                unit: \"hour\",\n                value: n\n            };\n        }\n        n = diffMinutes(m0, m1);\n        if (isInt(n)) {\n            return {\n                unit: \"minute\",\n                value: n\n            };\n        }\n        n = diffSeconds(m0, m1);\n        if (isInt(n)) {\n            return {\n                unit: \"second\",\n                value: n\n            };\n        }\n        return {\n            unit: \"millisecond\",\n            value: m1.valueOf() - m0.valueOf()\n        };\n    }\n    countDurationsBetween(m0, m1, d) {\n        // TODO: can use greatestWholeUnit\n        let diff;\n        if (d.years) {\n            diff = this.diffWholeYears(m0, m1);\n            if (diff !== null) {\n                return diff / asRoughYears(d);\n            }\n        }\n        if (d.months) {\n            diff = this.diffWholeMonths(m0, m1);\n            if (diff !== null) {\n                return diff / asRoughMonths(d);\n            }\n        }\n        if (d.days) {\n            diff = diffWholeDays(m0, m1);\n            if (diff !== null) {\n                return diff / asRoughDays(d);\n            }\n        }\n        return (m1.valueOf() - m0.valueOf()) / asRoughMs(d);\n    }\n    // Start-Of\n    // these DON'T return zoned-dates. only UTC start-of dates\n    startOf(m, unit) {\n        if (unit === \"year\") {\n            return this.startOfYear(m);\n        }\n        if (unit === \"month\") {\n            return this.startOfMonth(m);\n        }\n        if (unit === \"week\") {\n            return this.startOfWeek(m);\n        }\n        if (unit === \"day\") {\n            return startOfDay(m);\n        }\n        if (unit === \"hour\") {\n            return startOfHour(m);\n        }\n        if (unit === \"minute\") {\n            return startOfMinute(m);\n        }\n        if (unit === \"second\") {\n            return startOfSecond(m);\n        }\n        return null;\n    }\n    startOfYear(m) {\n        return this.calendarSystem.arrayToMarker([\n            this.calendarSystem.getMarkerYear(m)\n        ]);\n    }\n    startOfMonth(m) {\n        return this.calendarSystem.arrayToMarker([\n            this.calendarSystem.getMarkerYear(m),\n            this.calendarSystem.getMarkerMonth(m)\n        ]);\n    }\n    startOfWeek(m) {\n        return this.calendarSystem.arrayToMarker([\n            this.calendarSystem.getMarkerYear(m),\n            this.calendarSystem.getMarkerMonth(m),\n            m.getUTCDate() - (m.getUTCDay() - this.weekDow + 7) % 7\n        ]);\n    }\n    // Week Number\n    computeWeekNumber(marker) {\n        if (this.weekNumberFunc) {\n            return this.weekNumberFunc(this.toDate(marker));\n        }\n        return weekOfYear(marker, this.weekDow, this.weekDoy);\n    }\n    // TODO: choke on timeZoneName: long\n    format(marker, formatter, dateOptions = {}) {\n        return formatter.format({\n            marker,\n            timeZoneOffset: dateOptions.forcedTzo != null ? dateOptions.forcedTzo : this.offsetForMarker(marker)\n        }, this);\n    }\n    formatRange(start, end, formatter, dateOptions = {}) {\n        if (dateOptions.isEndExclusive) {\n            end = addMs(end, -1);\n        }\n        return formatter.formatRange({\n            marker: start,\n            timeZoneOffset: dateOptions.forcedStartTzo != null ? dateOptions.forcedStartTzo : this.offsetForMarker(start)\n        }, {\n            marker: end,\n            timeZoneOffset: dateOptions.forcedEndTzo != null ? dateOptions.forcedEndTzo : this.offsetForMarker(end)\n        }, this, dateOptions.defaultSeparator);\n    }\n    /*\n    DUMB: the omitTime arg is dumb. if we omit the time, we want to omit the timezone offset. and if we do that,\n    might as well use buildIsoString or some other util directly\n    */ formatIso(marker, extraOptions = {}) {\n        let timeZoneOffset = null;\n        if (!extraOptions.omitTimeZoneOffset) {\n            if (extraOptions.forcedTzo != null) {\n                timeZoneOffset = extraOptions.forcedTzo;\n            } else {\n                timeZoneOffset = this.offsetForMarker(marker);\n            }\n        }\n        return buildIsoString(marker, timeZoneOffset, extraOptions.omitTime);\n    }\n    // TimeZone\n    timestampToMarker(ms) {\n        if (this.timeZone === \"local\") {\n            return arrayToUtcDate(dateToLocalArray(new Date(ms)));\n        }\n        if (this.timeZone === \"UTC\" || !this.namedTimeZoneImpl) {\n            return new Date(ms);\n        }\n        return arrayToUtcDate(this.namedTimeZoneImpl.timestampToArray(ms));\n    }\n    offsetForMarker(m) {\n        if (this.timeZone === \"local\") {\n            return -arrayToLocalDate(dateToUtcArray(m)).getTimezoneOffset(); // convert \"inverse\" offset to \"normal\" offset\n        }\n        if (this.timeZone === \"UTC\") {\n            return 0;\n        }\n        if (this.namedTimeZoneImpl) {\n            return this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m));\n        }\n        return null;\n    }\n    // Conversion\n    toDate(m, forcedTzo) {\n        if (this.timeZone === \"local\") {\n            return arrayToLocalDate(dateToUtcArray(m));\n        }\n        if (this.timeZone === \"UTC\") {\n            return new Date(m.valueOf()); // make sure it's a copy\n        }\n        if (!this.namedTimeZoneImpl) {\n            return new Date(m.valueOf() - (forcedTzo || 0));\n        }\n        return new Date(m.valueOf() - this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m)) * 1000 * 60);\n    }\n}\nclass Theme {\n    constructor(calendarOptions){\n        if (this.iconOverrideOption) {\n            this.setIconOverride(calendarOptions[this.iconOverrideOption]);\n        }\n    }\n    setIconOverride(iconOverrideHash) {\n        let iconClassesCopy;\n        let buttonName;\n        if (typeof iconOverrideHash === \"object\" && iconOverrideHash) {\n            iconClassesCopy = Object.assign({}, this.iconClasses);\n            for(buttonName in iconOverrideHash){\n                iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);\n            }\n            this.iconClasses = iconClassesCopy;\n        } else if (iconOverrideHash === false) {\n            this.iconClasses = {};\n        }\n    }\n    applyIconOverridePrefix(className) {\n        let prefix = this.iconOverridePrefix;\n        if (prefix && className.indexOf(prefix) !== 0) {\n            className = prefix + className;\n        }\n        return className;\n    }\n    getClass(key) {\n        return this.classes[key] || \"\";\n    }\n    getIconClass(buttonName, isRtl) {\n        let className;\n        if (isRtl && this.rtlIconClasses) {\n            className = this.rtlIconClasses[buttonName] || this.iconClasses[buttonName];\n        } else {\n            className = this.iconClasses[buttonName];\n        }\n        if (className) {\n            return `${this.baseIconClass} ${className}`;\n        }\n        return \"\";\n    }\n    getCustomButtonIconClass(customButtonProps) {\n        let className;\n        if (this.iconOverrideCustomButtonOption) {\n            className = customButtonProps[this.iconOverrideCustomButtonOption];\n            if (className) {\n                return `${this.baseIconClass} ${this.applyIconOverridePrefix(className)}`;\n            }\n        }\n        return \"\";\n    }\n}\nTheme.prototype.classes = {};\nTheme.prototype.iconClasses = {};\nTheme.prototype.baseIconClass = \"\";\nTheme.prototype.iconOverridePrefix = \"\";\n/*\nNOTE: this can be a public API, especially createElement for hooks.\nSee examples/typescript-scheduler/src/index.ts\n*/ function flushSync(runBeforeFlush) {\n    runBeforeFlush();\n    let oldDebounceRendering = preact__WEBPACK_IMPORTED_MODULE_0__.options.debounceRendering; // orig\n    let callbackQ = [];\n    function execCallbackSync(callback) {\n        callbackQ.push(callback);\n    }\n    preact__WEBPACK_IMPORTED_MODULE_0__.options.debounceRendering = execCallbackSync;\n    preact__WEBPACK_IMPORTED_MODULE_0__.render(preact__WEBPACK_IMPORTED_MODULE_0__.createElement(FakeComponent, {}), document.createElement(\"div\"));\n    while(callbackQ.length){\n        callbackQ.shift()();\n    }\n    preact__WEBPACK_IMPORTED_MODULE_0__.options.debounceRendering = oldDebounceRendering;\n}\nclass FakeComponent extends preact__WEBPACK_IMPORTED_MODULE_0__.Component {\n    render() {\n        return preact__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {});\n    }\n    componentDidMount() {\n        this.setState({});\n    }\n}\n// TODO: use preact/compat instead?\nfunction createContext(defaultValue) {\n    let ContextType = preact__WEBPACK_IMPORTED_MODULE_0__.createContext(defaultValue);\n    let origProvider = ContextType.Provider;\n    ContextType.Provider = function() {\n        let isNew = !this.getChildContext;\n        let children = origProvider.apply(this, arguments); // eslint-disable-line prefer-rest-params\n        if (isNew) {\n            let subs = [];\n            this.shouldComponentUpdate = (_props)=>{\n                if (this.props.value !== _props.value) {\n                    subs.forEach((c)=>{\n                        c.context = _props.value;\n                        c.forceUpdate();\n                    });\n                }\n            };\n            this.sub = (c)=>{\n                subs.push(c);\n                let old = c.componentWillUnmount;\n                c.componentWillUnmount = ()=>{\n                    subs.splice(subs.indexOf(c), 1);\n                    old && old.call(c);\n                };\n            };\n        }\n        return children;\n    };\n    return ContextType;\n}\nclass ScrollResponder {\n    constructor(execFunc, emitter, scrollTime, scrollTimeReset){\n        this.execFunc = execFunc;\n        this.emitter = emitter;\n        this.scrollTime = scrollTime;\n        this.scrollTimeReset = scrollTimeReset;\n        this.handleScrollRequest = (request)=>{\n            this.queuedRequest = Object.assign({}, this.queuedRequest || {}, request);\n            this.drain();\n        };\n        emitter.on(\"_scrollRequest\", this.handleScrollRequest);\n        this.fireInitialScroll();\n    }\n    detach() {\n        this.emitter.off(\"_scrollRequest\", this.handleScrollRequest);\n    }\n    update(isDatesNew) {\n        if (isDatesNew && this.scrollTimeReset) {\n            this.fireInitialScroll(); // will drain\n        } else {\n            this.drain();\n        }\n    }\n    fireInitialScroll() {\n        this.handleScrollRequest({\n            time: this.scrollTime\n        });\n    }\n    drain() {\n        if (this.queuedRequest && this.execFunc(this.queuedRequest)) {\n            this.queuedRequest = null;\n        }\n    }\n}\nconst ViewContextType = createContext({}); // for Components\nfunction buildViewContext(viewSpec, viewApi, viewOptions, dateProfileGenerator, dateEnv, theme, pluginHooks, dispatch, getCurrentData, emitter, calendarApi, registerInteractiveComponent, unregisterInteractiveComponent) {\n    return {\n        dateEnv,\n        options: viewOptions,\n        pluginHooks,\n        emitter,\n        dispatch,\n        getCurrentData,\n        calendarApi,\n        viewSpec,\n        viewApi,\n        dateProfileGenerator,\n        theme,\n        isRtl: viewOptions.direction === \"rtl\",\n        addResizeHandler (handler) {\n            emitter.on(\"_resize\", handler);\n        },\n        removeResizeHandler (handler) {\n            emitter.off(\"_resize\", handler);\n        },\n        createScrollResponder (execFunc) {\n            return new ScrollResponder(execFunc, emitter, createDuration(viewOptions.scrollTime), viewOptions.scrollTimeReset);\n        },\n        registerInteractiveComponent,\n        unregisterInteractiveComponent\n    };\n}\n/* eslint max-classes-per-file: off */ class PureComponent extends preact__WEBPACK_IMPORTED_MODULE_0__.Component {\n    shouldComponentUpdate(nextProps, nextState) {\n        if (this.debug) {\n            // eslint-disable-next-line no-console\n            console.log(getUnequalProps(nextProps, this.props), getUnequalProps(nextState, this.state));\n        }\n        return !compareObjs(this.props, nextProps, this.propEquality) || !compareObjs(this.state, nextState, this.stateEquality);\n    }\n    // HACK for freakin' React StrictMode\n    safeSetState(newState) {\n        if (!compareObjs(this.state, Object.assign(Object.assign({}, this.state), newState), this.stateEquality)) {\n            this.setState(newState);\n        }\n    }\n}\nPureComponent.addPropsEquality = addPropsEquality;\nPureComponent.addStateEquality = addStateEquality;\nPureComponent.contextType = ViewContextType;\nPureComponent.prototype.propEquality = {};\nPureComponent.prototype.stateEquality = {};\nclass BaseComponent extends PureComponent {\n}\nBaseComponent.contextType = ViewContextType;\nfunction addPropsEquality(propEquality) {\n    let hash = Object.create(this.prototype.propEquality);\n    Object.assign(hash, propEquality);\n    this.prototype.propEquality = hash;\n}\nfunction addStateEquality(stateEquality) {\n    let hash = Object.create(this.prototype.stateEquality);\n    Object.assign(hash, stateEquality);\n    this.prototype.stateEquality = hash;\n}\n// use other one\nfunction setRef(ref, current) {\n    if (typeof ref === \"function\") {\n        ref(current);\n    } else if (ref) {\n        // see https://github.com/facebook/react/issues/13029\n        ref.current = current;\n    }\n}\nclass ContentInjector extends BaseComponent {\n    constructor(){\n        super(...arguments);\n        this.id = guid();\n        this.queuedDomNodes = [];\n        this.currentDomNodes = [];\n        this.handleEl = (el)=>{\n            const { options } = this.context;\n            const { generatorName } = this.props;\n            if (!options.customRenderingReplaces || !hasCustomRenderingHandler(generatorName, options)) {\n                this.updateElRef(el);\n            }\n        };\n        this.updateElRef = (el)=>{\n            if (this.props.elRef) {\n                setRef(this.props.elRef, el);\n            }\n        };\n    }\n    render() {\n        const { props, context } = this;\n        const { options } = context;\n        const { customGenerator, defaultGenerator, renderProps } = props;\n        const attrs = buildElAttrs(props, [], this.handleEl);\n        let useDefault = false;\n        let innerContent;\n        let queuedDomNodes = [];\n        let currentGeneratorMeta;\n        if (customGenerator != null) {\n            const customGeneratorRes = typeof customGenerator === \"function\" ? customGenerator(renderProps, preact__WEBPACK_IMPORTED_MODULE_0__.createElement) : customGenerator;\n            if (customGeneratorRes === true) {\n                useDefault = true;\n            } else {\n                const isObject = customGeneratorRes && typeof customGeneratorRes === \"object\"; // non-null\n                if (isObject && \"html\" in customGeneratorRes) {\n                    attrs.dangerouslySetInnerHTML = {\n                        __html: customGeneratorRes.html\n                    };\n                } else if (isObject && \"domNodes\" in customGeneratorRes) {\n                    queuedDomNodes = Array.prototype.slice.call(customGeneratorRes.domNodes);\n                } else if (isObject ? (0,preact__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(customGeneratorRes) // vdom node\n                 : typeof customGeneratorRes !== \"function\" // primitive value (like string or number)\n                ) {\n                    // use in vdom\n                    innerContent = customGeneratorRes;\n                } else {\n                    // an exotic object for handleCustomRendering\n                    currentGeneratorMeta = customGeneratorRes;\n                }\n            }\n        } else {\n            useDefault = !hasCustomRenderingHandler(props.generatorName, options);\n        }\n        if (useDefault && defaultGenerator) {\n            innerContent = defaultGenerator(renderProps);\n        }\n        this.queuedDomNodes = queuedDomNodes;\n        this.currentGeneratorMeta = currentGeneratorMeta;\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(props.elTag, attrs, innerContent);\n    }\n    componentDidMount() {\n        this.applyQueueudDomNodes();\n        this.triggerCustomRendering(true);\n    }\n    componentDidUpdate() {\n        this.applyQueueudDomNodes();\n        this.triggerCustomRendering(true);\n    }\n    componentWillUnmount() {\n        this.triggerCustomRendering(false); // TODO: different API for removal?\n    }\n    triggerCustomRendering(isActive) {\n        var _a;\n        const { props, context } = this;\n        const { handleCustomRendering, customRenderingMetaMap } = context.options;\n        if (handleCustomRendering) {\n            const generatorMeta = (_a = this.currentGeneratorMeta) !== null && _a !== void 0 ? _a : customRenderingMetaMap === null || customRenderingMetaMap === void 0 ? void 0 : customRenderingMetaMap[props.generatorName];\n            if (generatorMeta) {\n                handleCustomRendering(Object.assign(Object.assign({\n                    id: this.id,\n                    isActive,\n                    containerEl: this.base,\n                    reportNewContainerEl: this.updateElRef,\n                    generatorMeta\n                }, props), {\n                    elClasses: (props.elClasses || []).filter(isTruthy)\n                }));\n            }\n        }\n    }\n    applyQueueudDomNodes() {\n        const { queuedDomNodes, currentDomNodes } = this;\n        const el = this.base;\n        if (!isArraysEqual(queuedDomNodes, currentDomNodes)) {\n            currentDomNodes.forEach(removeElement);\n            for (let newNode of queuedDomNodes){\n                el.appendChild(newNode);\n            }\n            this.currentDomNodes = queuedDomNodes;\n        }\n    }\n}\nContentInjector.addPropsEquality({\n    elClasses: isArraysEqual,\n    elStyle: isPropsEqual,\n    elAttrs: isNonHandlerPropsEqual,\n    renderProps: isPropsEqual\n});\n// Util\n/*\nDoes UI-framework provide custom way of rendering that does not use Preact VDOM\nAND does the calendar's options define custom rendering?\nAKA. Should we NOT render the default content?\n*/ function hasCustomRenderingHandler(generatorName, options) {\n    var _a;\n    return Boolean(options.handleCustomRendering && generatorName && ((_a = options.customRenderingMetaMap) === null || _a === void 0 ? void 0 : _a[generatorName]));\n}\nfunction buildElAttrs(props, extraClassNames, elRef) {\n    const attrs = Object.assign(Object.assign({}, props.elAttrs), {\n        ref: elRef\n    });\n    if (props.elClasses || extraClassNames) {\n        attrs.className = (props.elClasses || []).concat(extraClassNames || []).concat(attrs.className || []).filter(Boolean).join(\" \");\n    }\n    if (props.elStyle) {\n        attrs.style = props.elStyle;\n    }\n    return attrs;\n}\nfunction isTruthy(val) {\n    return Boolean(val);\n}\nconst RenderId = createContext(0);\nclass ContentContainer extends preact__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(){\n        super(...arguments);\n        this.InnerContent = InnerContentInjector.bind(undefined, this);\n        this.handleEl = (el)=>{\n            this.el = el;\n            if (this.props.elRef) {\n                setRef(this.props.elRef, el);\n                if (el && this.didMountMisfire) {\n                    this.componentDidMount();\n                }\n            }\n        };\n    }\n    render() {\n        const { props } = this;\n        const generatedClassNames = generateClassNames(props.classNameGenerator, props.renderProps);\n        if (props.children) {\n            const elAttrs = buildElAttrs(props, generatedClassNames, this.handleEl);\n            const children = props.children(this.InnerContent, props.renderProps, elAttrs);\n            if (props.elTag) {\n                return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(props.elTag, elAttrs, children);\n            } else {\n                return children;\n            }\n        } else {\n            return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentInjector, Object.assign(Object.assign({}, props), {\n                elRef: this.handleEl,\n                elTag: props.elTag || \"div\",\n                elClasses: (props.elClasses || []).concat(generatedClassNames),\n                renderId: this.context\n            }));\n        }\n    }\n    componentDidMount() {\n        var _a, _b;\n        if (this.el) {\n            (_b = (_a = this.props).didMount) === null || _b === void 0 ? void 0 : _b.call(_a, Object.assign(Object.assign({}, this.props.renderProps), {\n                el: this.el\n            }));\n        } else {\n            this.didMountMisfire = true;\n        }\n    }\n    componentWillUnmount() {\n        var _a, _b;\n        (_b = (_a = this.props).willUnmount) === null || _b === void 0 ? void 0 : _b.call(_a, Object.assign(Object.assign({}, this.props.renderProps), {\n            el: this.el\n        }));\n    }\n}\nContentContainer.contextType = RenderId;\nfunction InnerContentInjector(containerComponent, props) {\n    const parentProps = containerComponent.props;\n    return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentInjector, Object.assign({\n        renderProps: parentProps.renderProps,\n        generatorName: parentProps.generatorName,\n        customGenerator: parentProps.customGenerator,\n        defaultGenerator: parentProps.defaultGenerator,\n        renderId: containerComponent.context\n    }, props));\n}\n// Utils\nfunction generateClassNames(classNameGenerator, renderProps) {\n    const classNames = typeof classNameGenerator === \"function\" ? classNameGenerator(renderProps) : classNameGenerator || [];\n    return typeof classNames === \"string\" ? [\n        classNames\n    ] : classNames;\n}\nclass ViewContainer extends BaseComponent {\n    render() {\n        let { props, context } = this;\n        let { options } = context;\n        let renderProps = {\n            view: context.viewApi\n        };\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentContainer, Object.assign({}, props, {\n            elTag: props.elTag || \"div\",\n            elClasses: [\n                ...buildViewClassNames(props.viewSpec),\n                ...props.elClasses || []\n            ],\n            renderProps: renderProps,\n            classNameGenerator: options.viewClassNames,\n            generatorName: undefined,\n            didMount: options.viewDidMount,\n            willUnmount: options.viewWillUnmount\n        }), ()=>props.children);\n    }\n}\nfunction buildViewClassNames(viewSpec) {\n    return [\n        `fc-${viewSpec.type}-view`,\n        \"fc-view\"\n    ];\n}\nfunction parseRange(input, dateEnv) {\n    let start = null;\n    let end = null;\n    if (input.start) {\n        start = dateEnv.createMarker(input.start);\n    }\n    if (input.end) {\n        end = dateEnv.createMarker(input.end);\n    }\n    if (!start && !end) {\n        return null;\n    }\n    if (start && end && end < start) {\n        return null;\n    }\n    return {\n        start,\n        end\n    };\n}\n// SIDE-EFFECT: will mutate ranges.\n// Will return a new array result.\nfunction invertRanges(ranges, constraintRange) {\n    let invertedRanges = [];\n    let { start } = constraintRange; // the end of the previous range. the start of the new range\n    let i;\n    let dateRange;\n    // ranges need to be in order. required for our date-walking algorithm\n    ranges.sort(compareRanges);\n    for(i = 0; i < ranges.length; i += 1){\n        dateRange = ranges[i];\n        // add the span of time before the event (if there is any)\n        if (dateRange.start > start) {\n            invertedRanges.push({\n                start,\n                end: dateRange.start\n            });\n        }\n        if (dateRange.end > start) {\n            start = dateRange.end;\n        }\n    }\n    // add the span of time after the last event (if there is any)\n    if (start < constraintRange.end) {\n        invertedRanges.push({\n            start,\n            end: constraintRange.end\n        });\n    }\n    return invertedRanges;\n}\nfunction compareRanges(range0, range1) {\n    return range0.start.valueOf() - range1.start.valueOf(); // earlier ranges go first\n}\nfunction intersectRanges(range0, range1) {\n    let { start, end } = range0;\n    let newRange = null;\n    if (range1.start !== null) {\n        if (start === null) {\n            start = range1.start;\n        } else {\n            start = new Date(Math.max(start.valueOf(), range1.start.valueOf()));\n        }\n    }\n    if (range1.end != null) {\n        if (end === null) {\n            end = range1.end;\n        } else {\n            end = new Date(Math.min(end.valueOf(), range1.end.valueOf()));\n        }\n    }\n    if (start === null || end === null || start < end) {\n        newRange = {\n            start,\n            end\n        };\n    }\n    return newRange;\n}\nfunction rangesEqual(range0, range1) {\n    return (range0.start === null ? null : range0.start.valueOf()) === (range1.start === null ? null : range1.start.valueOf()) && (range0.end === null ? null : range0.end.valueOf()) === (range1.end === null ? null : range1.end.valueOf());\n}\nfunction rangesIntersect(range0, range1) {\n    return (range0.end === null || range1.start === null || range0.end > range1.start) && (range0.start === null || range1.end === null || range0.start < range1.end);\n}\nfunction rangeContainsRange(outerRange, innerRange) {\n    return (outerRange.start === null || innerRange.start !== null && innerRange.start >= outerRange.start) && (outerRange.end === null || innerRange.end !== null && innerRange.end <= outerRange.end);\n}\nfunction rangeContainsMarker(range, date) {\n    return (range.start === null || date >= range.start) && (range.end === null || date < range.end);\n}\n// If the given date is not within the given range, move it inside.\n// (If it's past the end, make it one millisecond before the end).\nfunction constrainMarkerToRange(date, range) {\n    if (range.start != null && date < range.start) {\n        return range.start;\n    }\n    if (range.end != null && date >= range.end) {\n        return new Date(range.end.valueOf() - 1);\n    }\n    return date;\n}\n/* Date stuff that doesn't belong in datelib core\n----------------------------------------------------------------------------------------------------------------------*/ // given a timed range, computes an all-day range that has the same exact duration,\n// but whose start time is aligned with the start of the day.\nfunction computeAlignedDayRange(timedRange) {\n    let dayCnt = Math.floor(diffDays(timedRange.start, timedRange.end)) || 1;\n    let start = startOfDay(timedRange.start);\n    let end = addDays(start, dayCnt);\n    return {\n        start,\n        end\n    };\n}\n// given a timed range, computes an all-day range based on how for the end date bleeds into the next day\n// TODO: give nextDayThreshold a default arg\nfunction computeVisibleDayRange(timedRange, nextDayThreshold = createDuration(0)) {\n    let startDay = null;\n    let endDay = null;\n    if (timedRange.end) {\n        endDay = startOfDay(timedRange.end);\n        let endTimeMS = timedRange.end.valueOf() - endDay.valueOf(); // # of milliseconds into `endDay`\n        // If the end time is actually inclusively part of the next day and is equal to or\n        // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.\n        // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.\n        if (endTimeMS && endTimeMS >= asRoughMs(nextDayThreshold)) {\n            endDay = addDays(endDay, 1);\n        }\n    }\n    if (timedRange.start) {\n        startDay = startOfDay(timedRange.start); // the beginning of the day the range starts\n        // If end is within `startDay` but not past nextDayThreshold, assign the default duration of one day.\n        if (endDay && endDay <= startDay) {\n            endDay = addDays(startDay, 1);\n        }\n    }\n    return {\n        start: startDay,\n        end: endDay\n    };\n}\n// spans from one day into another?\nfunction isMultiDayRange(range) {\n    let visibleRange = computeVisibleDayRange(range);\n    return diffDays(visibleRange.start, visibleRange.end) > 1;\n}\nfunction diffDates(date0, date1, dateEnv, largeUnit) {\n    if (largeUnit === \"year\") {\n        return createDuration(dateEnv.diffWholeYears(date0, date1), \"year\");\n    }\n    if (largeUnit === \"month\") {\n        return createDuration(dateEnv.diffWholeMonths(date0, date1), \"month\");\n    }\n    return diffDayAndTime(date0, date1); // returns a duration\n}\nfunction reduceCurrentDate(currentDate, action) {\n    switch(action.type){\n        case \"CHANGE_DATE\":\n            return action.dateMarker;\n        default:\n            return currentDate;\n    }\n}\nfunction getInitialDate(options, dateEnv) {\n    let initialDateInput = options.initialDate;\n    // compute the initial ambig-timezone date\n    if (initialDateInput != null) {\n        return dateEnv.createMarker(initialDateInput);\n    }\n    return getNow(options.now, dateEnv); // getNow already returns unzoned\n}\nfunction getNow(nowInput, dateEnv) {\n    if (typeof nowInput === \"function\") {\n        nowInput = nowInput();\n    }\n    if (nowInput == null) {\n        return dateEnv.createNowMarker();\n    }\n    return dateEnv.createMarker(nowInput);\n}\nclass DateProfileGenerator {\n    constructor(props){\n        this.props = props;\n        this.nowDate = getNow(props.nowInput, props.dateEnv);\n        this.initHiddenDays();\n    }\n    /* Date Range Computation\n    ------------------------------------------------------------------------------------------------------------------*/ // Builds a structure with info about what the dates/ranges will be for the \"prev\" view.\n    buildPrev(currentDateProfile, currentDate, forceToValid) {\n        let { dateEnv } = this.props;\n        let prevDate = dateEnv.subtract(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), currentDateProfile.dateIncrement);\n        return this.build(prevDate, -1, forceToValid);\n    }\n    // Builds a structure with info about what the dates/ranges will be for the \"next\" view.\n    buildNext(currentDateProfile, currentDate, forceToValid) {\n        let { dateEnv } = this.props;\n        let nextDate = dateEnv.add(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), currentDateProfile.dateIncrement);\n        return this.build(nextDate, 1, forceToValid);\n    }\n    // Builds a structure holding dates/ranges for rendering around the given date.\n    // Optional direction param indicates whether the date is being incremented/decremented\n    // from its previous value. decremented = -1, incremented = 1 (default).\n    build(currentDate, direction, forceToValid = true) {\n        let { props } = this;\n        let validRange;\n        let currentInfo;\n        let isRangeAllDay;\n        let renderRange;\n        let activeRange;\n        let isValid;\n        validRange = this.buildValidRange();\n        validRange = this.trimHiddenDays(validRange);\n        if (forceToValid) {\n            currentDate = constrainMarkerToRange(currentDate, validRange);\n        }\n        currentInfo = this.buildCurrentRangeInfo(currentDate, direction);\n        isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);\n        renderRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.range), currentInfo.unit, isRangeAllDay);\n        renderRange = this.trimHiddenDays(renderRange);\n        activeRange = renderRange;\n        if (!props.showNonCurrentDates) {\n            activeRange = intersectRanges(activeRange, currentInfo.range);\n        }\n        activeRange = this.adjustActiveRange(activeRange);\n        activeRange = intersectRanges(activeRange, validRange); // might return null\n        // it's invalid if the originally requested date is not contained,\n        // or if the range is completely outside of the valid range.\n        isValid = rangesIntersect(currentInfo.range, validRange);\n        // HACK: constrain to render-range so `currentDate` is more useful to view rendering\n        if (!rangeContainsMarker(renderRange, currentDate)) {\n            currentDate = renderRange.start;\n        }\n        return {\n            currentDate,\n            // constraint for where prev/next operations can go and where events can be dragged/resized to.\n            // an object with optional start and end properties.\n            validRange,\n            // range the view is formally responsible for.\n            // for example, a month view might have 1st-31st, excluding padded dates\n            currentRange: currentInfo.range,\n            // name of largest unit being displayed, like \"month\" or \"week\"\n            currentRangeUnit: currentInfo.unit,\n            isRangeAllDay,\n            // dates that display events and accept drag-n-drop\n            // will be `null` if no dates accept events\n            activeRange,\n            // date range with a rendered skeleton\n            // includes not-active days that need some sort of DOM\n            renderRange,\n            // Duration object that denotes the first visible time of any given day\n            slotMinTime: props.slotMinTime,\n            // Duration object that denotes the exclusive visible end time of any given day\n            slotMaxTime: props.slotMaxTime,\n            isValid,\n            // how far the current date will move for a prev/next operation\n            dateIncrement: this.buildDateIncrement(currentInfo.duration)\n        };\n    }\n    // Builds an object with optional start/end properties.\n    // Indicates the minimum/maximum dates to display.\n    // not responsible for trimming hidden days.\n    buildValidRange() {\n        let input = this.props.validRangeInput;\n        let simpleInput = typeof input === \"function\" ? input.call(this.props.calendarApi, this.nowDate) : input;\n        return this.refineRange(simpleInput) || {\n            start: null,\n            end: null\n        }; // completely open-ended\n    }\n    // Builds a structure with info about the \"current\" range, the range that is\n    // highlighted as being the current month for example.\n    // See build() for a description of `direction`.\n    // Guaranteed to have `range` and `unit` properties. `duration` is optional.\n    buildCurrentRangeInfo(date, direction) {\n        let { props } = this;\n        let duration = null;\n        let unit = null;\n        let range = null;\n        let dayCount;\n        if (props.duration) {\n            duration = props.duration;\n            unit = props.durationUnit;\n            range = this.buildRangeFromDuration(date, direction, duration, unit);\n        } else if (dayCount = this.props.dayCount) {\n            unit = \"day\";\n            range = this.buildRangeFromDayCount(date, direction, dayCount);\n        } else if (range = this.buildCustomVisibleRange(date)) {\n            unit = props.dateEnv.greatestWholeUnit(range.start, range.end).unit;\n        } else {\n            duration = this.getFallbackDuration();\n            unit = greatestDurationDenominator(duration).unit;\n            range = this.buildRangeFromDuration(date, direction, duration, unit);\n        }\n        return {\n            duration,\n            unit,\n            range\n        };\n    }\n    getFallbackDuration() {\n        return createDuration({\n            day: 1\n        });\n    }\n    // Returns a new activeRange to have time values (un-ambiguate)\n    // slotMinTime or slotMaxTime causes the range to expand.\n    adjustActiveRange(range) {\n        let { dateEnv, usesMinMaxTime, slotMinTime, slotMaxTime } = this.props;\n        let { start, end } = range;\n        if (usesMinMaxTime) {\n            // expand active range if slotMinTime is negative (why not when positive?)\n            if (asRoughDays(slotMinTime) < 0) {\n                start = startOfDay(start); // necessary?\n                start = dateEnv.add(start, slotMinTime);\n            }\n            // expand active range if slotMaxTime is beyond one day (why not when negative?)\n            if (asRoughDays(slotMaxTime) > 1) {\n                end = startOfDay(end); // necessary?\n                end = addDays(end, -1);\n                end = dateEnv.add(end, slotMaxTime);\n            }\n        }\n        return {\n            start,\n            end\n        };\n    }\n    // Builds the \"current\" range when it is specified as an explicit duration.\n    // `unit` is the already-computed greatestDurationDenominator unit of duration.\n    buildRangeFromDuration(date, direction, duration, unit) {\n        let { dateEnv, dateAlignment } = this.props;\n        let start;\n        let end;\n        let res;\n        // compute what the alignment should be\n        if (!dateAlignment) {\n            let { dateIncrement } = this.props;\n            if (dateIncrement) {\n                // use the smaller of the two units\n                if (asRoughMs(dateIncrement) < asRoughMs(duration)) {\n                    dateAlignment = greatestDurationDenominator(dateIncrement).unit;\n                } else {\n                    dateAlignment = unit;\n                }\n            } else {\n                dateAlignment = unit;\n            }\n        }\n        // if the view displays a single day or smaller\n        if (asRoughDays(duration) <= 1) {\n            if (this.isHiddenDay(start)) {\n                start = this.skipHiddenDays(start, direction);\n                start = startOfDay(start);\n            }\n        }\n        function computeRes() {\n            start = dateEnv.startOf(date, dateAlignment);\n            end = dateEnv.add(start, duration);\n            res = {\n                start,\n                end\n            };\n        }\n        computeRes();\n        // if range is completely enveloped by hidden days, go past the hidden days\n        if (!this.trimHiddenDays(res)) {\n            date = this.skipHiddenDays(date, direction);\n            computeRes();\n        }\n        return res;\n    }\n    // Builds the \"current\" range when a dayCount is specified.\n    buildRangeFromDayCount(date, direction, dayCount) {\n        let { dateEnv, dateAlignment } = this.props;\n        let runningCount = 0;\n        let start = date;\n        let end;\n        if (dateAlignment) {\n            start = dateEnv.startOf(start, dateAlignment);\n        }\n        start = startOfDay(start);\n        start = this.skipHiddenDays(start, direction);\n        end = start;\n        do {\n            end = addDays(end, 1);\n            if (!this.isHiddenDay(end)) {\n                runningCount += 1;\n            }\n        }while (runningCount < dayCount);\n        return {\n            start,\n            end\n        };\n    }\n    // Builds a normalized range object for the \"visible\" range,\n    // which is a way to define the currentRange and activeRange at the same time.\n    buildCustomVisibleRange(date) {\n        let { props } = this;\n        let input = props.visibleRangeInput;\n        let simpleInput = typeof input === \"function\" ? input.call(props.calendarApi, props.dateEnv.toDate(date)) : input;\n        let range = this.refineRange(simpleInput);\n        if (range && (range.start == null || range.end == null)) {\n            return null;\n        }\n        return range;\n    }\n    // Computes the range that will represent the element/cells for *rendering*,\n    // but which may have voided days/times.\n    // not responsible for trimming hidden days.\n    buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay) {\n        return currentRange;\n    }\n    // Compute the duration value that should be added/substracted to the current date\n    // when a prev/next operation happens.\n    buildDateIncrement(fallback) {\n        let { dateIncrement } = this.props;\n        let customAlignment;\n        if (dateIncrement) {\n            return dateIncrement;\n        }\n        if (customAlignment = this.props.dateAlignment) {\n            return createDuration(1, customAlignment);\n        }\n        if (fallback) {\n            return fallback;\n        }\n        return createDuration({\n            days: 1\n        });\n    }\n    refineRange(rangeInput) {\n        if (rangeInput) {\n            let range = parseRange(rangeInput, this.props.dateEnv);\n            if (range) {\n                range = computeVisibleDayRange(range);\n            }\n            return range;\n        }\n        return null;\n    }\n    /* Hidden Days\n    ------------------------------------------------------------------------------------------------------------------*/ // Initializes internal variables related to calculating hidden days-of-week\n    initHiddenDays() {\n        let hiddenDays = this.props.hiddenDays || []; // array of day-of-week indices that are hidden\n        let isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)\n        let dayCnt = 0;\n        let i;\n        if (this.props.weekends === false) {\n            hiddenDays.push(0, 6); // 0=sunday, 6=saturday\n        }\n        for(i = 0; i < 7; i += 1){\n            if (!(isHiddenDayHash[i] = hiddenDays.indexOf(i) !== -1)) {\n                dayCnt += 1;\n            }\n        }\n        if (!dayCnt) {\n            throw new Error(\"invalid hiddenDays\"); // all days were hidden? bad.\n        }\n        this.isHiddenDayHash = isHiddenDayHash;\n    }\n    // Remove days from the beginning and end of the range that are computed as hidden.\n    // If the whole range is trimmed off, returns null\n    trimHiddenDays(range) {\n        let { start, end } = range;\n        if (start) {\n            start = this.skipHiddenDays(start);\n        }\n        if (end) {\n            end = this.skipHiddenDays(end, -1, true);\n        }\n        if (start == null || end == null || start < end) {\n            return {\n                start,\n                end\n            };\n        }\n        return null;\n    }\n    // Is the current day hidden?\n    // `day` is a day-of-week index (0-6), or a Date (used for UTC)\n    isHiddenDay(day) {\n        if (day instanceof Date) {\n            day = day.getUTCDay();\n        }\n        return this.isHiddenDayHash[day];\n    }\n    // Incrementing the current day until it is no longer a hidden day, returning a copy.\n    // DOES NOT CONSIDER validRange!\n    // If the initial value of `date` is not a hidden day, don't do anything.\n    // Pass `isExclusive` as `true` if you are dealing with an end date.\n    // `inc` defaults to `1` (increment one day forward each time)\n    skipHiddenDays(date, inc = 1, isExclusive = false) {\n        while(this.isHiddenDayHash[(date.getUTCDay() + (isExclusive ? inc : 0) + 7) % 7]){\n            date = addDays(date, inc);\n        }\n        return date;\n    }\n}\nfunction createEventInstance(defId, range, forcedStartTzo, forcedEndTzo) {\n    return {\n        instanceId: guid(),\n        defId,\n        range,\n        forcedStartTzo: forcedStartTzo == null ? null : forcedStartTzo,\n        forcedEndTzo: forcedEndTzo == null ? null : forcedEndTzo\n    };\n}\nfunction parseRecurring(refined, defaultAllDay, dateEnv, recurringTypes) {\n    for(let i = 0; i < recurringTypes.length; i += 1){\n        let parsed = recurringTypes[i].parse(refined, dateEnv);\n        if (parsed) {\n            let { allDay } = refined;\n            if (allDay == null) {\n                allDay = defaultAllDay;\n                if (allDay == null) {\n                    allDay = parsed.allDayGuess;\n                    if (allDay == null) {\n                        allDay = false;\n                    }\n                }\n            }\n            return {\n                allDay,\n                duration: parsed.duration,\n                typeData: parsed.typeData,\n                typeId: i\n            };\n        }\n    }\n    return null;\n}\nfunction expandRecurring(eventStore, framingRange, context) {\n    let { dateEnv, pluginHooks, options } = context;\n    let { defs, instances } = eventStore;\n    // remove existing recurring instances\n    // TODO: bad. always expand events as a second step\n    instances = filterHash(instances, (instance)=>!defs[instance.defId].recurringDef);\n    for(let defId in defs){\n        let def = defs[defId];\n        if (def.recurringDef) {\n            let { duration } = def.recurringDef;\n            if (!duration) {\n                duration = def.allDay ? options.defaultAllDayEventDuration : options.defaultTimedEventDuration;\n            }\n            let starts = expandRecurringRanges(def, duration, framingRange, dateEnv, pluginHooks.recurringTypes);\n            for (let start of starts){\n                let instance = createEventInstance(defId, {\n                    start,\n                    end: dateEnv.add(start, duration)\n                });\n                instances[instance.instanceId] = instance;\n            }\n        }\n    }\n    return {\n        defs,\n        instances\n    };\n}\n/*\nEvent MUST have a recurringDef\n*/ function expandRecurringRanges(eventDef, duration, framingRange, dateEnv, recurringTypes) {\n    let typeDef = recurringTypes[eventDef.recurringDef.typeId];\n    let markers = typeDef.expand(eventDef.recurringDef.typeData, {\n        start: dateEnv.subtract(framingRange.start, duration),\n        end: framingRange.end\n    }, dateEnv);\n    // the recurrence plugins don't guarantee that all-day events are start-of-day, so we have to\n    if (eventDef.allDay) {\n        markers = markers.map(startOfDay);\n    }\n    return markers;\n}\nconst EVENT_NON_DATE_REFINERS = {\n    id: String,\n    groupId: String,\n    title: String,\n    url: String,\n    interactive: Boolean\n};\nconst EVENT_DATE_REFINERS = {\n    start: identity,\n    end: identity,\n    date: identity,\n    allDay: Boolean\n};\nconst EVENT_REFINERS = Object.assign(Object.assign(Object.assign({}, EVENT_NON_DATE_REFINERS), EVENT_DATE_REFINERS), {\n    extendedProps: identity\n});\nfunction parseEvent(raw, eventSource, context, allowOpenRange, refiners = buildEventRefiners(context), defIdMap, instanceIdMap) {\n    let { refined, extra } = refineEventDef(raw, context, refiners);\n    let defaultAllDay = computeIsDefaultAllDay(eventSource, context);\n    let recurringRes = parseRecurring(refined, defaultAllDay, context.dateEnv, context.pluginHooks.recurringTypes);\n    if (recurringRes) {\n        let def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : \"\", recurringRes.allDay, Boolean(recurringRes.duration), context, defIdMap);\n        def.recurringDef = {\n            typeId: recurringRes.typeId,\n            typeData: recurringRes.typeData,\n            duration: recurringRes.duration\n        };\n        return {\n            def,\n            instance: null\n        };\n    }\n    let singleRes = parseSingle(refined, defaultAllDay, context, allowOpenRange);\n    if (singleRes) {\n        let def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : \"\", singleRes.allDay, singleRes.hasEnd, context, defIdMap);\n        let instance = createEventInstance(def.defId, singleRes.range, singleRes.forcedStartTzo, singleRes.forcedEndTzo);\n        if (instanceIdMap && def.publicId && instanceIdMap[def.publicId]) {\n            instance.instanceId = instanceIdMap[def.publicId];\n        }\n        return {\n            def,\n            instance\n        };\n    }\n    return null;\n}\nfunction refineEventDef(raw, context, refiners = buildEventRefiners(context)) {\n    return refineProps(raw, refiners);\n}\nfunction buildEventRefiners(context) {\n    return Object.assign(Object.assign(Object.assign({}, EVENT_UI_REFINERS), EVENT_REFINERS), context.pluginHooks.eventRefiners);\n}\n/*\nWill NOT populate extendedProps with the leftover properties.\nWill NOT populate date-related props.\n*/ function parseEventDef(refined, extra, sourceId, allDay, hasEnd, context, defIdMap) {\n    let def = {\n        title: refined.title || \"\",\n        groupId: refined.groupId || \"\",\n        publicId: refined.id || \"\",\n        url: refined.url || \"\",\n        recurringDef: null,\n        defId: (defIdMap && refined.id ? defIdMap[refined.id] : \"\") || guid(),\n        sourceId,\n        allDay,\n        hasEnd,\n        interactive: refined.interactive,\n        ui: createEventUi(refined, context),\n        extendedProps: Object.assign(Object.assign({}, refined.extendedProps || {}), extra)\n    };\n    for (let memberAdder of context.pluginHooks.eventDefMemberAdders){\n        Object.assign(def, memberAdder(refined));\n    }\n    // help out EventImpl from having user modify props\n    Object.freeze(def.ui.classNames);\n    Object.freeze(def.extendedProps);\n    return def;\n}\nfunction parseSingle(refined, defaultAllDay, context, allowOpenRange) {\n    let { allDay } = refined;\n    let startMeta;\n    let startMarker = null;\n    let hasEnd = false;\n    let endMeta;\n    let endMarker = null;\n    let startInput = refined.start != null ? refined.start : refined.date;\n    startMeta = context.dateEnv.createMarkerMeta(startInput);\n    if (startMeta) {\n        startMarker = startMeta.marker;\n    } else if (!allowOpenRange) {\n        return null;\n    }\n    if (refined.end != null) {\n        endMeta = context.dateEnv.createMarkerMeta(refined.end);\n    }\n    if (allDay == null) {\n        if (defaultAllDay != null) {\n            allDay = defaultAllDay;\n        } else {\n            // fall back to the date props LAST\n            allDay = (!startMeta || startMeta.isTimeUnspecified) && (!endMeta || endMeta.isTimeUnspecified);\n        }\n    }\n    if (allDay && startMarker) {\n        startMarker = startOfDay(startMarker);\n    }\n    if (endMeta) {\n        endMarker = endMeta.marker;\n        if (allDay) {\n            endMarker = startOfDay(endMarker);\n        }\n        if (startMarker && endMarker <= startMarker) {\n            endMarker = null;\n        }\n    }\n    if (endMarker) {\n        hasEnd = true;\n    } else if (!allowOpenRange) {\n        hasEnd = context.options.forceEventDuration || false;\n        endMarker = context.dateEnv.add(startMarker, allDay ? context.options.defaultAllDayEventDuration : context.options.defaultTimedEventDuration);\n    }\n    return {\n        allDay,\n        hasEnd,\n        range: {\n            start: startMarker,\n            end: endMarker\n        },\n        forcedStartTzo: startMeta ? startMeta.forcedTzo : null,\n        forcedEndTzo: endMeta ? endMeta.forcedTzo : null\n    };\n}\nfunction computeIsDefaultAllDay(eventSource, context) {\n    let res = null;\n    if (eventSource) {\n        res = eventSource.defaultAllDay;\n    }\n    if (res == null) {\n        res = context.options.defaultAllDay;\n    }\n    return res;\n}\nfunction parseEvents(rawEvents, eventSource, context, allowOpenRange, defIdMap, instanceIdMap) {\n    let eventStore = createEmptyEventStore();\n    let eventRefiners = buildEventRefiners(context);\n    for (let rawEvent of rawEvents){\n        let tuple = parseEvent(rawEvent, eventSource, context, allowOpenRange, eventRefiners, defIdMap, instanceIdMap);\n        if (tuple) {\n            eventTupleToStore(tuple, eventStore);\n        }\n    }\n    return eventStore;\n}\nfunction eventTupleToStore(tuple, eventStore = createEmptyEventStore()) {\n    eventStore.defs[tuple.def.defId] = tuple.def;\n    if (tuple.instance) {\n        eventStore.instances[tuple.instance.instanceId] = tuple.instance;\n    }\n    return eventStore;\n}\n// retrieves events that have the same groupId as the instance specified by `instanceId`\n// or they are the same as the instance.\n// why might instanceId not be in the store? an event from another calendar?\nfunction getRelevantEvents(eventStore, instanceId) {\n    let instance = eventStore.instances[instanceId];\n    if (instance) {\n        let def = eventStore.defs[instance.defId];\n        // get events/instances with same group\n        let newStore = filterEventStoreDefs(eventStore, (lookDef)=>isEventDefsGrouped(def, lookDef));\n        // add the original\n        // TODO: wish we could use eventTupleToStore or something like it\n        newStore.defs[def.defId] = def;\n        newStore.instances[instance.instanceId] = instance;\n        return newStore;\n    }\n    return createEmptyEventStore();\n}\nfunction isEventDefsGrouped(def0, def1) {\n    return Boolean(def0.groupId && def0.groupId === def1.groupId);\n}\nfunction createEmptyEventStore() {\n    return {\n        defs: {},\n        instances: {}\n    };\n}\nfunction mergeEventStores(store0, store1) {\n    return {\n        defs: Object.assign(Object.assign({}, store0.defs), store1.defs),\n        instances: Object.assign(Object.assign({}, store0.instances), store1.instances)\n    };\n}\nfunction filterEventStoreDefs(eventStore, filterFunc) {\n    let defs = filterHash(eventStore.defs, filterFunc);\n    let instances = filterHash(eventStore.instances, (instance)=>defs[instance.defId] // still exists?\n    );\n    return {\n        defs,\n        instances\n    };\n}\nfunction excludeSubEventStore(master, sub) {\n    let { defs, instances } = master;\n    let filteredDefs = {};\n    let filteredInstances = {};\n    for(let defId in defs){\n        if (!sub.defs[defId]) {\n            filteredDefs[defId] = defs[defId];\n        }\n    }\n    for(let instanceId in instances){\n        if (!sub.instances[instanceId] && // not explicitly excluded\n        filteredDefs[instances[instanceId].defId] // def wasn't filtered away\n        ) {\n            filteredInstances[instanceId] = instances[instanceId];\n        }\n    }\n    return {\n        defs: filteredDefs,\n        instances: filteredInstances\n    };\n}\nfunction normalizeConstraint(input, context) {\n    if (Array.isArray(input)) {\n        return parseEvents(input, null, context, true); // allowOpenRange=true\n    }\n    if (typeof input === \"object\" && input) {\n        return parseEvents([\n            input\n        ], null, context, true); // allowOpenRange=true\n    }\n    if (input != null) {\n        return String(input);\n    }\n    return null;\n}\nfunction parseClassNames(raw) {\n    if (Array.isArray(raw)) {\n        return raw;\n    }\n    if (typeof raw === \"string\") {\n        return raw.split(/\\s+/);\n    }\n    return [];\n}\n// TODO: better called \"EventSettings\" or \"EventConfig\"\n// TODO: move this file into structs\n// TODO: separate constraint/overlap/allow, because selection uses only that, not other props\nconst EVENT_UI_REFINERS = {\n    display: String,\n    editable: Boolean,\n    startEditable: Boolean,\n    durationEditable: Boolean,\n    constraint: identity,\n    overlap: identity,\n    allow: identity,\n    className: parseClassNames,\n    classNames: parseClassNames,\n    color: String,\n    backgroundColor: String,\n    borderColor: String,\n    textColor: String\n};\nconst EMPTY_EVENT_UI = {\n    display: null,\n    startEditable: null,\n    durationEditable: null,\n    constraints: [],\n    overlap: null,\n    allows: [],\n    backgroundColor: \"\",\n    borderColor: \"\",\n    textColor: \"\",\n    classNames: []\n};\nfunction createEventUi(refined, context) {\n    let constraint = normalizeConstraint(refined.constraint, context);\n    return {\n        display: refined.display || null,\n        startEditable: refined.startEditable != null ? refined.startEditable : refined.editable,\n        durationEditable: refined.durationEditable != null ? refined.durationEditable : refined.editable,\n        constraints: constraint != null ? [\n            constraint\n        ] : [],\n        overlap: refined.overlap != null ? refined.overlap : null,\n        allows: refined.allow != null ? [\n            refined.allow\n        ] : [],\n        backgroundColor: refined.backgroundColor || refined.color || \"\",\n        borderColor: refined.borderColor || refined.color || \"\",\n        textColor: refined.textColor || \"\",\n        classNames: (refined.className || []).concat(refined.classNames || [])\n    };\n}\n// TODO: prevent against problems with <2 args!\nfunction combineEventUis(uis) {\n    return uis.reduce(combineTwoEventUis, EMPTY_EVENT_UI);\n}\nfunction combineTwoEventUis(item0, item1) {\n    return {\n        display: item1.display != null ? item1.display : item0.display,\n        startEditable: item1.startEditable != null ? item1.startEditable : item0.startEditable,\n        durationEditable: item1.durationEditable != null ? item1.durationEditable : item0.durationEditable,\n        constraints: item0.constraints.concat(item1.constraints),\n        overlap: typeof item1.overlap === \"boolean\" ? item1.overlap : item0.overlap,\n        allows: item0.allows.concat(item1.allows),\n        backgroundColor: item1.backgroundColor || item0.backgroundColor,\n        borderColor: item1.borderColor || item0.borderColor,\n        textColor: item1.textColor || item0.textColor,\n        classNames: item0.classNames.concat(item1.classNames)\n    };\n}\nconst EVENT_SOURCE_REFINERS = {\n    id: String,\n    defaultAllDay: Boolean,\n    url: String,\n    format: String,\n    events: identity,\n    eventDataTransform: identity,\n    // for any network-related sources\n    success: identity,\n    failure: identity\n};\nfunction parseEventSource(raw, context, refiners = buildEventSourceRefiners(context)) {\n    let rawObj;\n    if (typeof raw === \"string\") {\n        rawObj = {\n            url: raw\n        };\n    } else if (typeof raw === \"function\" || Array.isArray(raw)) {\n        rawObj = {\n            events: raw\n        };\n    } else if (typeof raw === \"object\" && raw) {\n        rawObj = raw;\n    }\n    if (rawObj) {\n        let { refined, extra } = refineProps(rawObj, refiners);\n        let metaRes = buildEventSourceMeta(refined, context);\n        if (metaRes) {\n            return {\n                _raw: raw,\n                isFetching: false,\n                latestFetchId: \"\",\n                fetchRange: null,\n                defaultAllDay: refined.defaultAllDay,\n                eventDataTransform: refined.eventDataTransform,\n                success: refined.success,\n                failure: refined.failure,\n                publicId: refined.id || \"\",\n                sourceId: guid(),\n                sourceDefId: metaRes.sourceDefId,\n                meta: metaRes.meta,\n                ui: createEventUi(refined, context),\n                extendedProps: extra\n            };\n        }\n    }\n    return null;\n}\nfunction buildEventSourceRefiners(context) {\n    return Object.assign(Object.assign(Object.assign({}, EVENT_UI_REFINERS), EVENT_SOURCE_REFINERS), context.pluginHooks.eventSourceRefiners);\n}\nfunction buildEventSourceMeta(raw, context) {\n    let defs = context.pluginHooks.eventSourceDefs;\n    for(let i = defs.length - 1; i >= 0; i -= 1){\n        let def = defs[i];\n        let meta = def.parseMeta(raw);\n        if (meta) {\n            return {\n                sourceDefId: i,\n                meta\n            };\n        }\n    }\n    return null;\n}\nfunction reduceEventStore(eventStore, action, eventSources, dateProfile, context) {\n    switch(action.type){\n        case \"RECEIVE_EVENTS\":\n            return receiveRawEvents(eventStore, eventSources[action.sourceId], action.fetchId, action.fetchRange, action.rawEvents, context);\n        case \"RESET_RAW_EVENTS\":\n            return resetRawEvents(eventStore, eventSources[action.sourceId], action.rawEvents, dateProfile.activeRange, context);\n        case \"ADD_EVENTS\":\n            return addEvent(eventStore, action.eventStore, dateProfile ? dateProfile.activeRange : null, context);\n        case \"RESET_EVENTS\":\n            return action.eventStore;\n        case \"MERGE_EVENTS\":\n            return mergeEventStores(eventStore, action.eventStore);\n        case \"PREV\":\n        case \"NEXT\":\n        case \"CHANGE_DATE\":\n        case \"CHANGE_VIEW_TYPE\":\n            if (dateProfile) {\n                return expandRecurring(eventStore, dateProfile.activeRange, context);\n            }\n            return eventStore;\n        case \"REMOVE_EVENTS\":\n            return excludeSubEventStore(eventStore, action.eventStore);\n        case \"REMOVE_EVENT_SOURCE\":\n            return excludeEventsBySourceId(eventStore, action.sourceId);\n        case \"REMOVE_ALL_EVENT_SOURCES\":\n            return filterEventStoreDefs(eventStore, (eventDef)=>!eventDef.sourceId // only keep events with no source id\n            );\n        case \"REMOVE_ALL_EVENTS\":\n            return createEmptyEventStore();\n        default:\n            return eventStore;\n    }\n}\nfunction receiveRawEvents(eventStore, eventSource, fetchId, fetchRange, rawEvents, context) {\n    if (eventSource && // not already removed\n    fetchId === eventSource.latestFetchId // TODO: wish this logic was always in event-sources\n    ) {\n        let subset = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context);\n        if (fetchRange) {\n            subset = expandRecurring(subset, fetchRange, context);\n        }\n        return mergeEventStores(excludeEventsBySourceId(eventStore, eventSource.sourceId), subset);\n    }\n    return eventStore;\n}\nfunction resetRawEvents(existingEventStore, eventSource, rawEvents, activeRange, context) {\n    const { defIdMap, instanceIdMap } = buildPublicIdMaps(existingEventStore);\n    let newEventStore = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context, false, defIdMap, instanceIdMap);\n    return expandRecurring(newEventStore, activeRange, context);\n}\nfunction transformRawEvents(rawEvents, eventSource, context) {\n    let calEachTransform = context.options.eventDataTransform;\n    let sourceEachTransform = eventSource ? eventSource.eventDataTransform : null;\n    if (sourceEachTransform) {\n        rawEvents = transformEachRawEvent(rawEvents, sourceEachTransform);\n    }\n    if (calEachTransform) {\n        rawEvents = transformEachRawEvent(rawEvents, calEachTransform);\n    }\n    return rawEvents;\n}\nfunction transformEachRawEvent(rawEvents, func) {\n    let refinedEvents;\n    if (!func) {\n        refinedEvents = rawEvents;\n    } else {\n        refinedEvents = [];\n        for (let rawEvent of rawEvents){\n            let refinedEvent = func(rawEvent);\n            if (refinedEvent) {\n                refinedEvents.push(refinedEvent);\n            } else if (refinedEvent == null) {\n                refinedEvents.push(rawEvent);\n            } // if a different falsy value, do nothing\n        }\n    }\n    return refinedEvents;\n}\nfunction addEvent(eventStore, subset, expandRange, context) {\n    if (expandRange) {\n        subset = expandRecurring(subset, expandRange, context);\n    }\n    return mergeEventStores(eventStore, subset);\n}\nfunction rezoneEventStoreDates(eventStore, oldDateEnv, newDateEnv) {\n    let { defs } = eventStore;\n    let instances = mapHash(eventStore.instances, (instance)=>{\n        let def = defs[instance.defId];\n        if (def.allDay) {\n            return instance; // isn't dependent on timezone\n        }\n        return Object.assign(Object.assign({}, instance), {\n            range: {\n                start: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.start, instance.forcedStartTzo)),\n                end: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.end, instance.forcedEndTzo))\n            },\n            forcedStartTzo: newDateEnv.canComputeOffset ? null : instance.forcedStartTzo,\n            forcedEndTzo: newDateEnv.canComputeOffset ? null : instance.forcedEndTzo\n        });\n    });\n    return {\n        defs,\n        instances\n    };\n}\nfunction excludeEventsBySourceId(eventStore, sourceId) {\n    return filterEventStoreDefs(eventStore, (eventDef)=>eventDef.sourceId !== sourceId);\n}\n// QUESTION: why not just return instances? do a general object-property-exclusion util\nfunction excludeInstances(eventStore, removals) {\n    return {\n        defs: eventStore.defs,\n        instances: filterHash(eventStore.instances, (instance)=>!removals[instance.instanceId])\n    };\n}\nfunction buildPublicIdMaps(eventStore) {\n    const { defs, instances } = eventStore;\n    const defIdMap = {};\n    const instanceIdMap = {};\n    for(let defId in defs){\n        const def = defs[defId];\n        const { publicId } = def;\n        if (publicId) {\n            defIdMap[publicId] = defId;\n        }\n    }\n    for(let instanceId in instances){\n        const instance = instances[instanceId];\n        const def = defs[instance.defId];\n        const { publicId } = def;\n        if (publicId) {\n            instanceIdMap[publicId] = instanceId;\n        }\n    }\n    return {\n        defIdMap,\n        instanceIdMap\n    };\n}\nclass Emitter {\n    constructor(){\n        this.handlers = {};\n        this.thisContext = null;\n    }\n    setThisContext(thisContext) {\n        this.thisContext = thisContext;\n    }\n    setOptions(options) {\n        this.options = options;\n    }\n    on(type, handler) {\n        addToHash(this.handlers, type, handler);\n    }\n    off(type, handler) {\n        removeFromHash(this.handlers, type, handler);\n    }\n    trigger(type, ...args) {\n        let attachedHandlers = this.handlers[type] || [];\n        let optionHandler = this.options && this.options[type];\n        let handlers = [].concat(optionHandler || [], attachedHandlers);\n        for (let handler of handlers){\n            handler.apply(this.thisContext, args);\n        }\n    }\n    hasHandlers(type) {\n        return Boolean(this.handlers[type] && this.handlers[type].length || this.options && this.options[type]);\n    }\n}\nfunction addToHash(hash, type, handler) {\n    (hash[type] || (hash[type] = [])).push(handler);\n}\nfunction removeFromHash(hash, type, handler) {\n    if (handler) {\n        if (hash[type]) {\n            hash[type] = hash[type].filter((func)=>func !== handler);\n        }\n    } else {\n        delete hash[type]; // remove all handler funcs for this type\n    }\n}\nconst DEF_DEFAULTS = {\n    startTime: \"09:00\",\n    endTime: \"17:00\",\n    daysOfWeek: [\n        1,\n        2,\n        3,\n        4,\n        5\n    ],\n    display: \"inverse-background\",\n    classNames: \"fc-non-business\",\n    groupId: \"_businessHours\"\n};\n/*\nTODO: pass around as EventDefHash!!!\n*/ function parseBusinessHours(input, context) {\n    return parseEvents(refineInputs(input), null, context);\n}\nfunction refineInputs(input) {\n    let rawDefs;\n    if (input === true) {\n        rawDefs = [\n            {}\n        ]; // will get DEF_DEFAULTS verbatim\n    } else if (Array.isArray(input)) {\n        // if specifying an array, every sub-definition NEEDS a day-of-week\n        rawDefs = input.filter((rawDef)=>rawDef.daysOfWeek);\n    } else if (typeof input === \"object\" && input) {\n        rawDefs = [\n            input\n        ];\n    } else {\n        rawDefs = [];\n    }\n    rawDefs = rawDefs.map((rawDef)=>Object.assign(Object.assign({}, DEF_DEFAULTS), rawDef));\n    return rawDefs;\n}\nfunction triggerDateSelect(selection, pev, context) {\n    context.emitter.trigger(\"select\", Object.assign(Object.assign({}, buildDateSpanApiWithContext(selection, context)), {\n        jsEvent: pev ? pev.origEvent : null,\n        view: context.viewApi || context.calendarApi.view\n    }));\n}\nfunction triggerDateUnselect(pev, context) {\n    context.emitter.trigger(\"unselect\", {\n        jsEvent: pev ? pev.origEvent : null,\n        view: context.viewApi || context.calendarApi.view\n    });\n}\nfunction buildDateSpanApiWithContext(dateSpan, context) {\n    let props = {};\n    for (let transform of context.pluginHooks.dateSpanTransforms){\n        Object.assign(props, transform(dateSpan, context));\n    }\n    Object.assign(props, buildDateSpanApi(dateSpan, context.dateEnv));\n    return props;\n}\n// Given an event's allDay status and start date, return what its fallback end date should be.\n// TODO: rename to computeDefaultEventEnd\nfunction getDefaultEventEnd(allDay, marker, context) {\n    let { dateEnv, options } = context;\n    let end = marker;\n    if (allDay) {\n        end = startOfDay(end);\n        end = dateEnv.add(end, options.defaultAllDayEventDuration);\n    } else {\n        end = dateEnv.add(end, options.defaultTimedEventDuration);\n    }\n    return end;\n}\n// applies the mutation to ALL defs/instances within the event store\nfunction applyMutationToEventStore(eventStore, eventConfigBase, mutation, context) {\n    let eventConfigs = compileEventUis(eventStore.defs, eventConfigBase);\n    let dest = createEmptyEventStore();\n    for(let defId in eventStore.defs){\n        let def = eventStore.defs[defId];\n        dest.defs[defId] = applyMutationToEventDef(def, eventConfigs[defId], mutation, context);\n    }\n    for(let instanceId in eventStore.instances){\n        let instance = eventStore.instances[instanceId];\n        let def = dest.defs[instance.defId]; // important to grab the newly modified def\n        dest.instances[instanceId] = applyMutationToEventInstance(instance, def, eventConfigs[instance.defId], mutation, context);\n    }\n    return dest;\n}\nfunction applyMutationToEventDef(eventDef, eventConfig, mutation, context) {\n    let standardProps = mutation.standardProps || {};\n    // if hasEnd has not been specified, guess a good value based on deltas.\n    // if duration will change, there's no way the default duration will persist,\n    // and thus, we need to mark the event as having a real end\n    if (standardProps.hasEnd == null && eventConfig.durationEditable && (mutation.startDelta || mutation.endDelta)) {\n        standardProps.hasEnd = true; // TODO: is this mutation okay?\n    }\n    let copy = Object.assign(Object.assign(Object.assign({}, eventDef), standardProps), {\n        ui: Object.assign(Object.assign({}, eventDef.ui), standardProps.ui)\n    });\n    if (mutation.extendedProps) {\n        copy.extendedProps = Object.assign(Object.assign({}, copy.extendedProps), mutation.extendedProps);\n    }\n    for (let applier of context.pluginHooks.eventDefMutationAppliers){\n        applier(copy, mutation, context);\n    }\n    if (!copy.hasEnd && context.options.forceEventDuration) {\n        copy.hasEnd = true;\n    }\n    return copy;\n}\nfunction applyMutationToEventInstance(eventInstance, eventDef, eventConfig, mutation, context) {\n    let { dateEnv } = context;\n    let forceAllDay = mutation.standardProps && mutation.standardProps.allDay === true;\n    let clearEnd = mutation.standardProps && mutation.standardProps.hasEnd === false;\n    let copy = Object.assign({}, eventInstance);\n    if (forceAllDay) {\n        copy.range = computeAlignedDayRange(copy.range);\n    }\n    if (mutation.datesDelta && eventConfig.startEditable) {\n        copy.range = {\n            start: dateEnv.add(copy.range.start, mutation.datesDelta),\n            end: dateEnv.add(copy.range.end, mutation.datesDelta)\n        };\n    }\n    if (mutation.startDelta && eventConfig.durationEditable) {\n        copy.range = {\n            start: dateEnv.add(copy.range.start, mutation.startDelta),\n            end: copy.range.end\n        };\n    }\n    if (mutation.endDelta && eventConfig.durationEditable) {\n        copy.range = {\n            start: copy.range.start,\n            end: dateEnv.add(copy.range.end, mutation.endDelta)\n        };\n    }\n    if (clearEnd) {\n        copy.range = {\n            start: copy.range.start,\n            end: getDefaultEventEnd(eventDef.allDay, copy.range.start, context)\n        };\n    }\n    // in case event was all-day but the supplied deltas were not\n    // better util for this?\n    if (eventDef.allDay) {\n        copy.range = {\n            start: startOfDay(copy.range.start),\n            end: startOfDay(copy.range.end)\n        };\n    }\n    // handle invalid durations\n    if (copy.range.end < copy.range.start) {\n        copy.range.end = getDefaultEventEnd(eventDef.allDay, copy.range.start, context);\n    }\n    return copy;\n}\nclass EventSourceImpl {\n    constructor(context, internalEventSource){\n        this.context = context;\n        this.internalEventSource = internalEventSource;\n    }\n    remove() {\n        this.context.dispatch({\n            type: \"REMOVE_EVENT_SOURCE\",\n            sourceId: this.internalEventSource.sourceId\n        });\n    }\n    refetch() {\n        this.context.dispatch({\n            type: \"FETCH_EVENT_SOURCES\",\n            sourceIds: [\n                this.internalEventSource.sourceId\n            ],\n            isRefetch: true\n        });\n    }\n    get id() {\n        return this.internalEventSource.publicId;\n    }\n    get url() {\n        return this.internalEventSource.meta.url;\n    }\n    get format() {\n        return this.internalEventSource.meta.format; // TODO: bad. not guaranteed\n    }\n}\nclass EventImpl {\n    // instance will be null if expressing a recurring event that has no current instances,\n    // OR if trying to validate an incoming external event that has no dates assigned\n    constructor(context, def, instance){\n        this._context = context;\n        this._def = def;\n        this._instance = instance || null;\n    }\n    /*\n    TODO: make event struct more responsible for this\n    */ setProp(name, val) {\n        if (name in EVENT_DATE_REFINERS) {\n            console.warn(\"Could not set date-related prop 'name'. Use one of the date-related methods instead.\");\n        // TODO: make proper aliasing system?\n        } else if (name === \"id\") {\n            val = EVENT_NON_DATE_REFINERS[name](val);\n            this.mutate({\n                standardProps: {\n                    publicId: val\n                }\n            });\n        } else if (name in EVENT_NON_DATE_REFINERS) {\n            val = EVENT_NON_DATE_REFINERS[name](val);\n            this.mutate({\n                standardProps: {\n                    [name]: val\n                }\n            });\n        } else if (name in EVENT_UI_REFINERS) {\n            let ui = EVENT_UI_REFINERS[name](val);\n            if (name === \"color\") {\n                ui = {\n                    backgroundColor: val,\n                    borderColor: val\n                };\n            } else if (name === \"editable\") {\n                ui = {\n                    startEditable: val,\n                    durationEditable: val\n                };\n            } else {\n                ui = {\n                    [name]: val\n                };\n            }\n            this.mutate({\n                standardProps: {\n                    ui\n                }\n            });\n        } else {\n            console.warn(`Could not set prop '${name}'. Use setExtendedProp instead.`);\n        }\n    }\n    setExtendedProp(name, val) {\n        this.mutate({\n            extendedProps: {\n                [name]: val\n            }\n        });\n    }\n    setStart(startInput, options = {}) {\n        let { dateEnv } = this._context;\n        let start = dateEnv.createMarker(startInput);\n        if (start && this._instance) {\n            let instanceRange = this._instance.range;\n            let startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity); // what if parsed bad!?\n            if (options.maintainDuration) {\n                this.mutate({\n                    datesDelta: startDelta\n                });\n            } else {\n                this.mutate({\n                    startDelta\n                });\n            }\n        }\n    }\n    setEnd(endInput, options = {}) {\n        let { dateEnv } = this._context;\n        let end;\n        if (endInput != null) {\n            end = dateEnv.createMarker(endInput);\n            if (!end) {\n                return; // TODO: warning if parsed bad\n            }\n        }\n        if (this._instance) {\n            if (end) {\n                let endDelta = diffDates(this._instance.range.end, end, dateEnv, options.granularity);\n                this.mutate({\n                    endDelta\n                });\n            } else {\n                this.mutate({\n                    standardProps: {\n                        hasEnd: false\n                    }\n                });\n            }\n        }\n    }\n    setDates(startInput, endInput, options = {}) {\n        let { dateEnv } = this._context;\n        let standardProps = {\n            allDay: options.allDay\n        };\n        let start = dateEnv.createMarker(startInput);\n        let end;\n        if (!start) {\n            return; // TODO: warning if parsed bad\n        }\n        if (endInput != null) {\n            end = dateEnv.createMarker(endInput);\n            if (!end) {\n                return;\n            }\n        }\n        if (this._instance) {\n            let instanceRange = this._instance.range;\n            // when computing the diff for an event being converted to all-day,\n            // compute diff off of the all-day values the way event-mutation does.\n            if (options.allDay === true) {\n                instanceRange = computeAlignedDayRange(instanceRange);\n            }\n            let startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity);\n            if (end) {\n                let endDelta = diffDates(instanceRange.end, end, dateEnv, options.granularity);\n                if (durationsEqual(startDelta, endDelta)) {\n                    this.mutate({\n                        datesDelta: startDelta,\n                        standardProps\n                    });\n                } else {\n                    this.mutate({\n                        startDelta,\n                        endDelta,\n                        standardProps\n                    });\n                }\n            } else {\n                standardProps.hasEnd = false;\n                this.mutate({\n                    datesDelta: startDelta,\n                    standardProps\n                });\n            }\n        }\n    }\n    moveStart(deltaInput) {\n        let delta = createDuration(deltaInput);\n        if (delta) {\n            this.mutate({\n                startDelta: delta\n            });\n        }\n    }\n    moveEnd(deltaInput) {\n        let delta = createDuration(deltaInput);\n        if (delta) {\n            this.mutate({\n                endDelta: delta\n            });\n        }\n    }\n    moveDates(deltaInput) {\n        let delta = createDuration(deltaInput);\n        if (delta) {\n            this.mutate({\n                datesDelta: delta\n            });\n        }\n    }\n    setAllDay(allDay, options = {}) {\n        let standardProps = {\n            allDay\n        };\n        let { maintainDuration } = options;\n        if (maintainDuration == null) {\n            maintainDuration = this._context.options.allDayMaintainDuration;\n        }\n        if (this._def.allDay !== allDay) {\n            standardProps.hasEnd = maintainDuration;\n        }\n        this.mutate({\n            standardProps\n        });\n    }\n    formatRange(formatInput) {\n        let { dateEnv } = this._context;\n        let instance = this._instance;\n        let formatter = createFormatter(formatInput);\n        if (this._def.hasEnd) {\n            return dateEnv.formatRange(instance.range.start, instance.range.end, formatter, {\n                forcedStartTzo: instance.forcedStartTzo,\n                forcedEndTzo: instance.forcedEndTzo\n            });\n        }\n        return dateEnv.format(instance.range.start, formatter, {\n            forcedTzo: instance.forcedStartTzo\n        });\n    }\n    mutate(mutation) {\n        let instance = this._instance;\n        if (instance) {\n            let def = this._def;\n            let context = this._context;\n            let { eventStore } = context.getCurrentData();\n            let relevantEvents = getRelevantEvents(eventStore, instance.instanceId);\n            let eventConfigBase = {\n                \"\": {\n                    display: \"\",\n                    startEditable: true,\n                    durationEditable: true,\n                    constraints: [],\n                    overlap: null,\n                    allows: [],\n                    backgroundColor: \"\",\n                    borderColor: \"\",\n                    textColor: \"\",\n                    classNames: []\n                }\n            };\n            relevantEvents = applyMutationToEventStore(relevantEvents, eventConfigBase, mutation, context);\n            let oldEvent = new EventImpl(context, def, instance); // snapshot\n            this._def = relevantEvents.defs[def.defId];\n            this._instance = relevantEvents.instances[instance.instanceId];\n            context.dispatch({\n                type: \"MERGE_EVENTS\",\n                eventStore: relevantEvents\n            });\n            context.emitter.trigger(\"eventChange\", {\n                oldEvent,\n                event: this,\n                relatedEvents: buildEventApis(relevantEvents, context, instance),\n                revert () {\n                    context.dispatch({\n                        type: \"RESET_EVENTS\",\n                        eventStore\n                    });\n                }\n            });\n        }\n    }\n    remove() {\n        let context = this._context;\n        let asStore = eventApiToStore(this);\n        context.dispatch({\n            type: \"REMOVE_EVENTS\",\n            eventStore: asStore\n        });\n        context.emitter.trigger(\"eventRemove\", {\n            event: this,\n            relatedEvents: [],\n            revert () {\n                context.dispatch({\n                    type: \"MERGE_EVENTS\",\n                    eventStore: asStore\n                });\n            }\n        });\n    }\n    get source() {\n        let { sourceId } = this._def;\n        if (sourceId) {\n            return new EventSourceImpl(this._context, this._context.getCurrentData().eventSources[sourceId]);\n        }\n        return null;\n    }\n    get start() {\n        return this._instance ? this._context.dateEnv.toDate(this._instance.range.start) : null;\n    }\n    get end() {\n        return this._instance && this._def.hasEnd ? this._context.dateEnv.toDate(this._instance.range.end) : null;\n    }\n    get startStr() {\n        let instance = this._instance;\n        if (instance) {\n            return this._context.dateEnv.formatIso(instance.range.start, {\n                omitTime: this._def.allDay,\n                forcedTzo: instance.forcedStartTzo\n            });\n        }\n        return \"\";\n    }\n    get endStr() {\n        let instance = this._instance;\n        if (instance && this._def.hasEnd) {\n            return this._context.dateEnv.formatIso(instance.range.end, {\n                omitTime: this._def.allDay,\n                forcedTzo: instance.forcedEndTzo\n            });\n        }\n        return \"\";\n    }\n    // computable props that all access the def\n    // TODO: find a TypeScript-compatible way to do this at scale\n    get id() {\n        return this._def.publicId;\n    }\n    get groupId() {\n        return this._def.groupId;\n    }\n    get allDay() {\n        return this._def.allDay;\n    }\n    get title() {\n        return this._def.title;\n    }\n    get url() {\n        return this._def.url;\n    }\n    get display() {\n        return this._def.ui.display || \"auto\";\n    }\n    get startEditable() {\n        return this._def.ui.startEditable;\n    }\n    get durationEditable() {\n        return this._def.ui.durationEditable;\n    }\n    get constraint() {\n        return this._def.ui.constraints[0] || null;\n    }\n    get overlap() {\n        return this._def.ui.overlap;\n    }\n    get allow() {\n        return this._def.ui.allows[0] || null;\n    }\n    get backgroundColor() {\n        return this._def.ui.backgroundColor;\n    }\n    get borderColor() {\n        return this._def.ui.borderColor;\n    }\n    get textColor() {\n        return this._def.ui.textColor;\n    }\n    // NOTE: user can't modify these because Object.freeze was called in event-def parsing\n    get classNames() {\n        return this._def.ui.classNames;\n    }\n    get extendedProps() {\n        return this._def.extendedProps;\n    }\n    toPlainObject(settings = {}) {\n        let def = this._def;\n        let { ui } = def;\n        let { startStr, endStr } = this;\n        let res = {\n            allDay: def.allDay\n        };\n        if (def.title) {\n            res.title = def.title;\n        }\n        if (startStr) {\n            res.start = startStr;\n        }\n        if (endStr) {\n            res.end = endStr;\n        }\n        if (def.publicId) {\n            res.id = def.publicId;\n        }\n        if (def.groupId) {\n            res.groupId = def.groupId;\n        }\n        if (def.url) {\n            res.url = def.url;\n        }\n        if (ui.display && ui.display !== \"auto\") {\n            res.display = ui.display;\n        }\n        // TODO: what about recurring-event properties???\n        // TODO: include startEditable/durationEditable/constraint/overlap/allow\n        if (settings.collapseColor && ui.backgroundColor && ui.backgroundColor === ui.borderColor) {\n            res.color = ui.backgroundColor;\n        } else {\n            if (ui.backgroundColor) {\n                res.backgroundColor = ui.backgroundColor;\n            }\n            if (ui.borderColor) {\n                res.borderColor = ui.borderColor;\n            }\n        }\n        if (ui.textColor) {\n            res.textColor = ui.textColor;\n        }\n        if (ui.classNames.length) {\n            res.classNames = ui.classNames;\n        }\n        if (Object.keys(def.extendedProps).length) {\n            if (settings.collapseExtendedProps) {\n                Object.assign(res, def.extendedProps);\n            } else {\n                res.extendedProps = def.extendedProps;\n            }\n        }\n        return res;\n    }\n    toJSON() {\n        return this.toPlainObject();\n    }\n}\nfunction eventApiToStore(eventApi) {\n    let def = eventApi._def;\n    let instance = eventApi._instance;\n    return {\n        defs: {\n            [def.defId]: def\n        },\n        instances: instance ? {\n            [instance.instanceId]: instance\n        } : {}\n    };\n}\nfunction buildEventApis(eventStore, context, excludeInstance) {\n    let { defs, instances } = eventStore;\n    let eventApis = [];\n    let excludeInstanceId = excludeInstance ? excludeInstance.instanceId : \"\";\n    for(let id in instances){\n        let instance = instances[id];\n        let def = defs[instance.defId];\n        if (instance.instanceId !== excludeInstanceId) {\n            eventApis.push(new EventImpl(context, def, instance));\n        }\n    }\n    return eventApis;\n}\n/*\nSpecifying nextDayThreshold signals that all-day ranges should be sliced.\n*/ function sliceEventStore(eventStore, eventUiBases, framingRange, nextDayThreshold) {\n    let inverseBgByGroupId = {};\n    let inverseBgByDefId = {};\n    let defByGroupId = {};\n    let bgRanges = [];\n    let fgRanges = [];\n    let eventUis = compileEventUis(eventStore.defs, eventUiBases);\n    for(let defId in eventStore.defs){\n        let def = eventStore.defs[defId];\n        let ui = eventUis[def.defId];\n        if (ui.display === \"inverse-background\") {\n            if (def.groupId) {\n                inverseBgByGroupId[def.groupId] = [];\n                if (!defByGroupId[def.groupId]) {\n                    defByGroupId[def.groupId] = def;\n                }\n            } else {\n                inverseBgByDefId[defId] = [];\n            }\n        }\n    }\n    for(let instanceId in eventStore.instances){\n        let instance = eventStore.instances[instanceId];\n        let def = eventStore.defs[instance.defId];\n        let ui = eventUis[def.defId];\n        let origRange = instance.range;\n        let normalRange = !def.allDay && nextDayThreshold ? computeVisibleDayRange(origRange, nextDayThreshold) : origRange;\n        let slicedRange = intersectRanges(normalRange, framingRange);\n        if (slicedRange) {\n            if (ui.display === \"inverse-background\") {\n                if (def.groupId) {\n                    inverseBgByGroupId[def.groupId].push(slicedRange);\n                } else {\n                    inverseBgByDefId[instance.defId].push(slicedRange);\n                }\n            } else if (ui.display !== \"none\") {\n                (ui.display === \"background\" ? bgRanges : fgRanges).push({\n                    def,\n                    ui,\n                    instance,\n                    range: slicedRange,\n                    isStart: normalRange.start && normalRange.start.valueOf() === slicedRange.start.valueOf(),\n                    isEnd: normalRange.end && normalRange.end.valueOf() === slicedRange.end.valueOf()\n                });\n            }\n        }\n    }\n    for(let groupId in inverseBgByGroupId){\n        let ranges = inverseBgByGroupId[groupId];\n        let invertedRanges = invertRanges(ranges, framingRange);\n        for (let invertedRange of invertedRanges){\n            let def = defByGroupId[groupId];\n            let ui = eventUis[def.defId];\n            bgRanges.push({\n                def,\n                ui,\n                instance: null,\n                range: invertedRange,\n                isStart: false,\n                isEnd: false\n            });\n        }\n    }\n    for(let defId in inverseBgByDefId){\n        let ranges = inverseBgByDefId[defId];\n        let invertedRanges = invertRanges(ranges, framingRange);\n        for (let invertedRange of invertedRanges){\n            bgRanges.push({\n                def: eventStore.defs[defId],\n                ui: eventUis[defId],\n                instance: null,\n                range: invertedRange,\n                isStart: false,\n                isEnd: false\n            });\n        }\n    }\n    return {\n        bg: bgRanges,\n        fg: fgRanges\n    };\n}\nfunction hasBgRendering(def) {\n    return def.ui.display === \"background\" || def.ui.display === \"inverse-background\";\n}\nfunction setElSeg(el, seg) {\n    el.fcSeg = seg;\n}\nfunction getElSeg(el) {\n    return el.fcSeg || el.parentNode.fcSeg || // for the harness\n    null;\n}\n// event ui computation\nfunction compileEventUis(eventDefs, eventUiBases) {\n    return mapHash(eventDefs, (eventDef)=>compileEventUi(eventDef, eventUiBases));\n}\nfunction compileEventUi(eventDef, eventUiBases) {\n    let uis = [];\n    if (eventUiBases[\"\"]) {\n        uis.push(eventUiBases[\"\"]);\n    }\n    if (eventUiBases[eventDef.defId]) {\n        uis.push(eventUiBases[eventDef.defId]);\n    }\n    uis.push(eventDef.ui);\n    return combineEventUis(uis);\n}\nfunction sortEventSegs(segs, eventOrderSpecs) {\n    let objs = segs.map(buildSegCompareObj);\n    objs.sort((obj0, obj1)=>compareByFieldSpecs(obj0, obj1, eventOrderSpecs));\n    return objs.map((c)=>c._seg);\n}\n// returns a object with all primitive props that can be compared\nfunction buildSegCompareObj(seg) {\n    let { eventRange } = seg;\n    let eventDef = eventRange.def;\n    let range = eventRange.instance ? eventRange.instance.range : eventRange.range;\n    let start = range.start ? range.start.valueOf() : 0; // TODO: better support for open-range events\n    let end = range.end ? range.end.valueOf() : 0; // \"\n    return Object.assign(Object.assign(Object.assign({}, eventDef.extendedProps), eventDef), {\n        id: eventDef.publicId,\n        start,\n        end,\n        duration: end - start,\n        allDay: Number(eventDef.allDay),\n        _seg: seg\n    });\n}\nfunction computeSegDraggable(seg, context) {\n    let { pluginHooks } = context;\n    let transformers = pluginHooks.isDraggableTransformers;\n    let { def, ui } = seg.eventRange;\n    let val = ui.startEditable;\n    for (let transformer of transformers){\n        val = transformer(val, def, ui, context);\n    }\n    return val;\n}\nfunction computeSegStartResizable(seg, context) {\n    return seg.isStart && seg.eventRange.ui.durationEditable && context.options.eventResizableFromStart;\n}\nfunction computeSegEndResizable(seg, context) {\n    return seg.isEnd && seg.eventRange.ui.durationEditable;\n}\nfunction buildSegTimeText(seg, timeFormat, context, defaultDisplayEventTime, defaultDisplayEventEnd, startOverride, endOverride) {\n    let { dateEnv, options } = context;\n    let { displayEventTime, displayEventEnd } = options;\n    let eventDef = seg.eventRange.def;\n    let eventInstance = seg.eventRange.instance;\n    if (displayEventTime == null) {\n        displayEventTime = defaultDisplayEventTime !== false;\n    }\n    if (displayEventEnd == null) {\n        displayEventEnd = defaultDisplayEventEnd !== false;\n    }\n    let wholeEventStart = eventInstance.range.start;\n    let wholeEventEnd = eventInstance.range.end;\n    let segStart = startOverride || seg.start || seg.eventRange.range.start;\n    let segEnd = endOverride || seg.end || seg.eventRange.range.end;\n    let isStartDay = startOfDay(wholeEventStart).valueOf() === startOfDay(segStart).valueOf();\n    let isEndDay = startOfDay(addMs(wholeEventEnd, -1)).valueOf() === startOfDay(addMs(segEnd, -1)).valueOf();\n    if (displayEventTime && !eventDef.allDay && (isStartDay || isEndDay)) {\n        segStart = isStartDay ? wholeEventStart : segStart;\n        segEnd = isEndDay ? wholeEventEnd : segEnd;\n        if (displayEventEnd && eventDef.hasEnd) {\n            return dateEnv.formatRange(segStart, segEnd, timeFormat, {\n                forcedStartTzo: startOverride ? null : eventInstance.forcedStartTzo,\n                forcedEndTzo: endOverride ? null : eventInstance.forcedEndTzo\n            });\n        }\n        return dateEnv.format(segStart, timeFormat, {\n            forcedTzo: startOverride ? null : eventInstance.forcedStartTzo\n        });\n    }\n    return \"\";\n}\nfunction getSegMeta(seg, todayRange, nowDate) {\n    let segRange = seg.eventRange.range;\n    return {\n        isPast: segRange.end <= (nowDate || todayRange.start),\n        isFuture: segRange.start >= (nowDate || todayRange.end),\n        isToday: todayRange && rangeContainsMarker(todayRange, segRange.start)\n    };\n}\nfunction getEventClassNames(props) {\n    let classNames = [\n        \"fc-event\"\n    ];\n    if (props.isMirror) {\n        classNames.push(\"fc-event-mirror\");\n    }\n    if (props.isDraggable) {\n        classNames.push(\"fc-event-draggable\");\n    }\n    if (props.isStartResizable || props.isEndResizable) {\n        classNames.push(\"fc-event-resizable\");\n    }\n    if (props.isDragging) {\n        classNames.push(\"fc-event-dragging\");\n    }\n    if (props.isResizing) {\n        classNames.push(\"fc-event-resizing\");\n    }\n    if (props.isSelected) {\n        classNames.push(\"fc-event-selected\");\n    }\n    if (props.isStart) {\n        classNames.push(\"fc-event-start\");\n    }\n    if (props.isEnd) {\n        classNames.push(\"fc-event-end\");\n    }\n    if (props.isPast) {\n        classNames.push(\"fc-event-past\");\n    }\n    if (props.isToday) {\n        classNames.push(\"fc-event-today\");\n    }\n    if (props.isFuture) {\n        classNames.push(\"fc-event-future\");\n    }\n    return classNames;\n}\nfunction buildEventRangeKey(eventRange) {\n    return eventRange.instance ? eventRange.instance.instanceId : `${eventRange.def.defId}:${eventRange.range.start.toISOString()}`;\n// inverse-background events don't have specific instances. TODO: better solution\n}\nfunction getSegAnchorAttrs(seg, context) {\n    let { def, instance } = seg.eventRange;\n    let { url } = def;\n    if (url) {\n        return {\n            href: url\n        };\n    }\n    let { emitter, options } = context;\n    let { eventInteractive } = options;\n    if (eventInteractive == null) {\n        eventInteractive = def.interactive;\n        if (eventInteractive == null) {\n            eventInteractive = Boolean(emitter.hasHandlers(\"eventClick\"));\n        }\n    }\n    // mock what happens in EventClicking\n    if (eventInteractive) {\n        // only attach keyboard-related handlers because click handler is already done in EventClicking\n        return createAriaKeyboardAttrs((ev)=>{\n            emitter.trigger(\"eventClick\", {\n                el: ev.target,\n                event: new EventImpl(context, def, instance),\n                jsEvent: ev,\n                view: context.viewApi\n            });\n        });\n    }\n    return {};\n}\nconst STANDARD_PROPS = {\n    start: identity,\n    end: identity,\n    allDay: Boolean\n};\nfunction parseDateSpan(raw, dateEnv, defaultDuration) {\n    let span = parseOpenDateSpan(raw, dateEnv);\n    let { range } = span;\n    if (!range.start) {\n        return null;\n    }\n    if (!range.end) {\n        if (defaultDuration == null) {\n            return null;\n        }\n        range.end = dateEnv.add(range.start, defaultDuration);\n    }\n    return span;\n}\n/*\nTODO: somehow combine with parseRange?\nWill return null if the start/end props were present but parsed invalidly.\n*/ function parseOpenDateSpan(raw, dateEnv) {\n    let { refined: standardProps, extra } = refineProps(raw, STANDARD_PROPS);\n    let startMeta = standardProps.start ? dateEnv.createMarkerMeta(standardProps.start) : null;\n    let endMeta = standardProps.end ? dateEnv.createMarkerMeta(standardProps.end) : null;\n    let { allDay } = standardProps;\n    if (allDay == null) {\n        allDay = startMeta && startMeta.isTimeUnspecified && (!endMeta || endMeta.isTimeUnspecified);\n    }\n    return Object.assign({\n        range: {\n            start: startMeta ? startMeta.marker : null,\n            end: endMeta ? endMeta.marker : null\n        },\n        allDay\n    }, extra);\n}\nfunction isDateSpansEqual(span0, span1) {\n    return rangesEqual(span0.range, span1.range) && span0.allDay === span1.allDay && isSpanPropsEqual(span0, span1);\n}\n// the NON-DATE-RELATED props\nfunction isSpanPropsEqual(span0, span1) {\n    for(let propName in span1){\n        if (propName !== \"range\" && propName !== \"allDay\") {\n            if (span0[propName] !== span1[propName]) {\n                return false;\n            }\n        }\n    }\n    // are there any props that span0 has that span1 DOESN'T have?\n    // both have range/allDay, so no need to special-case.\n    for(let propName in span0){\n        if (!(propName in span1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction buildDateSpanApi(span, dateEnv) {\n    return Object.assign(Object.assign({}, buildRangeApi(span.range, dateEnv, span.allDay)), {\n        allDay: span.allDay\n    });\n}\nfunction buildRangeApiWithTimeZone(range, dateEnv, omitTime) {\n    return Object.assign(Object.assign({}, buildRangeApi(range, dateEnv, omitTime)), {\n        timeZone: dateEnv.timeZone\n    });\n}\nfunction buildRangeApi(range, dateEnv, omitTime) {\n    return {\n        start: dateEnv.toDate(range.start),\n        end: dateEnv.toDate(range.end),\n        startStr: dateEnv.formatIso(range.start, {\n            omitTime\n        }),\n        endStr: dateEnv.formatIso(range.end, {\n            omitTime\n        })\n    };\n}\nfunction fabricateEventRange(dateSpan, eventUiBases, context) {\n    let res = refineEventDef({\n        editable: false\n    }, context);\n    let def = parseEventDef(res.refined, res.extra, \"\", dateSpan.allDay, true, context);\n    return {\n        def,\n        ui: compileEventUi(def, eventUiBases),\n        instance: createEventInstance(def.defId, dateSpan.range),\n        range: dateSpan.range,\n        isStart: true,\n        isEnd: true\n    };\n}\n/*\ngiven a function that resolves a result asynchronously.\nthe function can either call passed-in success and failure callbacks,\nor it can return a promise.\nif you need to pass additional params to func, bind them first.\n*/ function unpromisify(func, normalizedSuccessCallback, normalizedFailureCallback) {\n    // guard against success/failure callbacks being called more than once\n    // and guard against a promise AND callback being used together.\n    let isResolved = false;\n    let wrappedSuccess = function(res) {\n        if (!isResolved) {\n            isResolved = true;\n            normalizedSuccessCallback(res);\n        }\n    };\n    let wrappedFailure = function(error) {\n        if (!isResolved) {\n            isResolved = true;\n            normalizedFailureCallback(error);\n        }\n    };\n    let res = func(wrappedSuccess, wrappedFailure);\n    if (res && typeof res.then === \"function\") {\n        res.then(wrappedSuccess, wrappedFailure);\n    }\n}\nclass JsonRequestError extends Error {\n    constructor(message, response){\n        super(message);\n        this.response = response;\n    }\n}\nfunction requestJson(method, url, params) {\n    method = method.toUpperCase();\n    const fetchOptions = {\n        method\n    };\n    if (method === \"GET\") {\n        url += (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + new URLSearchParams(params);\n    } else {\n        fetchOptions.body = new URLSearchParams(params);\n        fetchOptions.headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\"\n        };\n    }\n    return fetch(url, fetchOptions).then((fetchRes)=>{\n        if (fetchRes.ok) {\n            return fetchRes.json().then((parsedResponse)=>{\n                return [\n                    parsedResponse,\n                    fetchRes\n                ];\n            }, ()=>{\n                throw new JsonRequestError(\"Failure parsing JSON\", fetchRes);\n            });\n        } else {\n            throw new JsonRequestError(\"Request failed\", fetchRes);\n        }\n    });\n}\nlet canVGrowWithinCell;\nfunction getCanVGrowWithinCell() {\n    if (canVGrowWithinCell == null) {\n        canVGrowWithinCell = computeCanVGrowWithinCell();\n    }\n    return canVGrowWithinCell;\n}\nfunction computeCanVGrowWithinCell() {\n    // for SSR, because this function is call immediately at top-level\n    // TODO: just make this logic execute top-level, immediately, instead of doing lazily\n    if (typeof document === \"undefined\") {\n        return true;\n    }\n    let el = document.createElement(\"div\");\n    el.style.position = \"absolute\";\n    el.style.top = \"0px\";\n    el.style.left = \"0px\";\n    el.innerHTML = \"<table><tr><td><div></div></td></tr></table>\";\n    el.querySelector(\"table\").style.height = \"100px\";\n    el.querySelector(\"div\").style.height = \"100%\";\n    document.body.appendChild(el);\n    let div = el.querySelector(\"div\");\n    let possible = div.offsetHeight > 0;\n    document.body.removeChild(el);\n    return possible;\n}\nclass CalendarRoot extends BaseComponent {\n    constructor(){\n        super(...arguments);\n        this.state = {\n            forPrint: false\n        };\n        this.handleBeforePrint = ()=>{\n            flushSync(()=>{\n                this.setState({\n                    forPrint: true\n                });\n            });\n        };\n        this.handleAfterPrint = ()=>{\n            flushSync(()=>{\n                this.setState({\n                    forPrint: false\n                });\n            });\n        };\n    }\n    render() {\n        let { props } = this;\n        let { options } = props;\n        let { forPrint } = this.state;\n        let isHeightAuto = forPrint || options.height === \"auto\" || options.contentHeight === \"auto\";\n        let height = !isHeightAuto && options.height != null ? options.height : \"\";\n        let classNames = [\n            \"fc\",\n            forPrint ? \"fc-media-print\" : \"fc-media-screen\",\n            `fc-direction-${options.direction}`,\n            props.theme.getClass(\"root\")\n        ];\n        if (!getCanVGrowWithinCell()) {\n            classNames.push(\"fc-liquid-hack\");\n        }\n        return props.children(classNames, height, isHeightAuto, forPrint);\n    }\n    componentDidMount() {\n        let { emitter } = this.props;\n        emitter.on(\"_beforeprint\", this.handleBeforePrint);\n        emitter.on(\"_afterprint\", this.handleAfterPrint);\n    }\n    componentWillUnmount() {\n        let { emitter } = this.props;\n        emitter.off(\"_beforeprint\", this.handleBeforePrint);\n        emitter.off(\"_afterprint\", this.handleAfterPrint);\n    }\n}\nclass Interaction {\n    constructor(settings){\n        this.component = settings.component;\n        this.isHitComboAllowed = settings.isHitComboAllowed || null;\n    }\n    destroy() {}\n}\nfunction parseInteractionSettings(component, input) {\n    return {\n        component,\n        el: input.el,\n        useEventCenter: input.useEventCenter != null ? input.useEventCenter : true,\n        isHitComboAllowed: input.isHitComboAllowed || null\n    };\n}\nfunction interactionSettingsToStore(settings) {\n    return {\n        [settings.component.uid]: settings\n    };\n}\n// global state\nconst interactionSettingsStore = {};\nclass CalendarImpl {\n    getCurrentData() {\n        return this.currentDataManager.getCurrentData();\n    }\n    dispatch(action) {\n        this.currentDataManager.dispatch(action);\n    }\n    get view() {\n        return this.getCurrentData().viewApi;\n    }\n    batchRendering(callback) {\n        callback();\n    }\n    updateSize() {\n        this.trigger(\"_resize\", true);\n    }\n    // Options\n    // -----------------------------------------------------------------------------------------------------------------\n    setOption(name, val) {\n        this.dispatch({\n            type: \"SET_OPTION\",\n            optionName: name,\n            rawOptionValue: val\n        });\n    }\n    getOption(name) {\n        return this.currentDataManager.currentCalendarOptionsInput[name];\n    }\n    getAvailableLocaleCodes() {\n        return Object.keys(this.getCurrentData().availableRawLocales);\n    }\n    // Trigger\n    // -----------------------------------------------------------------------------------------------------------------\n    on(handlerName, handler) {\n        let { currentDataManager } = this;\n        if (currentDataManager.currentCalendarOptionsRefiners[handlerName]) {\n            currentDataManager.emitter.on(handlerName, handler);\n        } else {\n            console.warn(`Unknown listener name '${handlerName}'`);\n        }\n    }\n    off(handlerName, handler) {\n        this.currentDataManager.emitter.off(handlerName, handler);\n    }\n    // not meant for public use\n    trigger(handlerName, ...args) {\n        this.currentDataManager.emitter.trigger(handlerName, ...args);\n    }\n    // View\n    // -----------------------------------------------------------------------------------------------------------------\n    changeView(viewType, dateOrRange) {\n        this.batchRendering(()=>{\n            this.unselect();\n            if (dateOrRange) {\n                if (dateOrRange.start && dateOrRange.end) {\n                    this.dispatch({\n                        type: \"CHANGE_VIEW_TYPE\",\n                        viewType\n                    });\n                    this.dispatch({\n                        type: \"SET_OPTION\",\n                        optionName: \"visibleRange\",\n                        rawOptionValue: dateOrRange\n                    });\n                } else {\n                    let { dateEnv } = this.getCurrentData();\n                    this.dispatch({\n                        type: \"CHANGE_VIEW_TYPE\",\n                        viewType,\n                        dateMarker: dateEnv.createMarker(dateOrRange)\n                    });\n                }\n            } else {\n                this.dispatch({\n                    type: \"CHANGE_VIEW_TYPE\",\n                    viewType\n                });\n            }\n        });\n    }\n    // Forces navigation to a view for the given date.\n    // `viewType` can be a specific view name or a generic one like \"week\" or \"day\".\n    // needs to change\n    zoomTo(dateMarker, viewType) {\n        let state = this.getCurrentData();\n        let spec;\n        viewType = viewType || \"day\"; // day is default zoom\n        spec = state.viewSpecs[viewType] || this.getUnitViewSpec(viewType);\n        this.unselect();\n        if (spec) {\n            this.dispatch({\n                type: \"CHANGE_VIEW_TYPE\",\n                viewType: spec.type,\n                dateMarker\n            });\n        } else {\n            this.dispatch({\n                type: \"CHANGE_DATE\",\n                dateMarker\n            });\n        }\n    }\n    // Given a duration singular unit, like \"week\" or \"day\", finds a matching view spec.\n    // Preference is given to views that have corresponding buttons.\n    getUnitViewSpec(unit) {\n        let { viewSpecs, toolbarConfig } = this.getCurrentData();\n        let viewTypes = [].concat(toolbarConfig.header ? toolbarConfig.header.viewsWithButtons : [], toolbarConfig.footer ? toolbarConfig.footer.viewsWithButtons : []);\n        let i;\n        let spec;\n        for(let viewType in viewSpecs){\n            viewTypes.push(viewType);\n        }\n        for(i = 0; i < viewTypes.length; i += 1){\n            spec = viewSpecs[viewTypes[i]];\n            if (spec) {\n                if (spec.singleUnit === unit) {\n                    return spec;\n                }\n            }\n        }\n        return null;\n    }\n    // Current Date\n    // -----------------------------------------------------------------------------------------------------------------\n    prev() {\n        this.unselect();\n        this.dispatch({\n            type: \"PREV\"\n        });\n    }\n    next() {\n        this.unselect();\n        this.dispatch({\n            type: \"NEXT\"\n        });\n    }\n    prevYear() {\n        let state = this.getCurrentData();\n        this.unselect();\n        this.dispatch({\n            type: \"CHANGE_DATE\",\n            dateMarker: state.dateEnv.addYears(state.currentDate, -1)\n        });\n    }\n    nextYear() {\n        let state = this.getCurrentData();\n        this.unselect();\n        this.dispatch({\n            type: \"CHANGE_DATE\",\n            dateMarker: state.dateEnv.addYears(state.currentDate, 1)\n        });\n    }\n    today() {\n        let state = this.getCurrentData();\n        this.unselect();\n        this.dispatch({\n            type: \"CHANGE_DATE\",\n            dateMarker: getNow(state.calendarOptions.now, state.dateEnv)\n        });\n    }\n    gotoDate(zonedDateInput) {\n        let state = this.getCurrentData();\n        this.unselect();\n        this.dispatch({\n            type: \"CHANGE_DATE\",\n            dateMarker: state.dateEnv.createMarker(zonedDateInput)\n        });\n    }\n    incrementDate(deltaInput) {\n        let state = this.getCurrentData();\n        let delta = createDuration(deltaInput);\n        if (delta) {\n            this.unselect();\n            this.dispatch({\n                type: \"CHANGE_DATE\",\n                dateMarker: state.dateEnv.add(state.currentDate, delta)\n            });\n        }\n    }\n    getDate() {\n        let state = this.getCurrentData();\n        return state.dateEnv.toDate(state.currentDate);\n    }\n    // Date Formatting Utils\n    // -----------------------------------------------------------------------------------------------------------------\n    formatDate(d, formatter) {\n        let { dateEnv } = this.getCurrentData();\n        return dateEnv.format(dateEnv.createMarker(d), createFormatter(formatter));\n    }\n    // `settings` is for formatter AND isEndExclusive\n    formatRange(d0, d1, settings) {\n        let { dateEnv } = this.getCurrentData();\n        return dateEnv.formatRange(dateEnv.createMarker(d0), dateEnv.createMarker(d1), createFormatter(settings), settings);\n    }\n    formatIso(d, omitTime) {\n        let { dateEnv } = this.getCurrentData();\n        return dateEnv.formatIso(dateEnv.createMarker(d), {\n            omitTime\n        });\n    }\n    // Date Selection / Event Selection / DayClick\n    // -----------------------------------------------------------------------------------------------------------------\n    select(dateOrObj, endDate) {\n        let selectionInput;\n        if (endDate == null) {\n            if (dateOrObj.start != null) {\n                selectionInput = dateOrObj;\n            } else {\n                selectionInput = {\n                    start: dateOrObj,\n                    end: null\n                };\n            }\n        } else {\n            selectionInput = {\n                start: dateOrObj,\n                end: endDate\n            };\n        }\n        let state = this.getCurrentData();\n        let selection = parseDateSpan(selectionInput, state.dateEnv, createDuration({\n            days: 1\n        }));\n        if (selection) {\n            this.dispatch({\n                type: \"SELECT_DATES\",\n                selection\n            });\n            triggerDateSelect(selection, null, state);\n        }\n    }\n    unselect(pev) {\n        let state = this.getCurrentData();\n        if (state.dateSelection) {\n            this.dispatch({\n                type: \"UNSELECT_DATES\"\n            });\n            triggerDateUnselect(pev, state);\n        }\n    }\n    // Public Events API\n    // -----------------------------------------------------------------------------------------------------------------\n    addEvent(eventInput, sourceInput) {\n        if (eventInput instanceof EventImpl) {\n            let def = eventInput._def;\n            let instance = eventInput._instance;\n            let currentData = this.getCurrentData();\n            // not already present? don't want to add an old snapshot\n            if (!currentData.eventStore.defs[def.defId]) {\n                this.dispatch({\n                    type: \"ADD_EVENTS\",\n                    eventStore: eventTupleToStore({\n                        def,\n                        instance\n                    })\n                });\n                this.triggerEventAdd(eventInput);\n            }\n            return eventInput;\n        }\n        let state = this.getCurrentData();\n        let eventSource;\n        if (sourceInput instanceof EventSourceImpl) {\n            eventSource = sourceInput.internalEventSource;\n        } else if (typeof sourceInput === \"boolean\") {\n            if (sourceInput) {\n                [eventSource] = hashValuesToArray(state.eventSources);\n            }\n        } else if (sourceInput != null) {\n            let sourceApi = this.getEventSourceById(sourceInput); // TODO: use an internal function\n            if (!sourceApi) {\n                console.warn(`Could not find an event source with ID \"${sourceInput}\"`); // TODO: test\n                return null;\n            }\n            eventSource = sourceApi.internalEventSource;\n        }\n        let tuple = parseEvent(eventInput, eventSource, state, false);\n        if (tuple) {\n            let newEventApi = new EventImpl(state, tuple.def, tuple.def.recurringDef ? null : tuple.instance);\n            this.dispatch({\n                type: \"ADD_EVENTS\",\n                eventStore: eventTupleToStore(tuple)\n            });\n            this.triggerEventAdd(newEventApi);\n            return newEventApi;\n        }\n        return null;\n    }\n    triggerEventAdd(eventApi) {\n        let { emitter } = this.getCurrentData();\n        emitter.trigger(\"eventAdd\", {\n            event: eventApi,\n            relatedEvents: [],\n            revert: ()=>{\n                this.dispatch({\n                    type: \"REMOVE_EVENTS\",\n                    eventStore: eventApiToStore(eventApi)\n                });\n            }\n        });\n    }\n    // TODO: optimize\n    getEventById(id) {\n        let state = this.getCurrentData();\n        let { defs, instances } = state.eventStore;\n        id = String(id);\n        for(let defId in defs){\n            let def = defs[defId];\n            if (def.publicId === id) {\n                if (def.recurringDef) {\n                    return new EventImpl(state, def, null);\n                }\n                for(let instanceId in instances){\n                    let instance = instances[instanceId];\n                    if (instance.defId === def.defId) {\n                        return new EventImpl(state, def, instance);\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    getEvents() {\n        let currentData = this.getCurrentData();\n        return buildEventApis(currentData.eventStore, currentData);\n    }\n    removeAllEvents() {\n        this.dispatch({\n            type: \"REMOVE_ALL_EVENTS\"\n        });\n    }\n    // Public Event Sources API\n    // -----------------------------------------------------------------------------------------------------------------\n    getEventSources() {\n        let state = this.getCurrentData();\n        let sourceHash = state.eventSources;\n        let sourceApis = [];\n        for(let internalId in sourceHash){\n            sourceApis.push(new EventSourceImpl(state, sourceHash[internalId]));\n        }\n        return sourceApis;\n    }\n    getEventSourceById(id) {\n        let state = this.getCurrentData();\n        let sourceHash = state.eventSources;\n        id = String(id);\n        for(let sourceId in sourceHash){\n            if (sourceHash[sourceId].publicId === id) {\n                return new EventSourceImpl(state, sourceHash[sourceId]);\n            }\n        }\n        return null;\n    }\n    addEventSource(sourceInput) {\n        let state = this.getCurrentData();\n        if (sourceInput instanceof EventSourceImpl) {\n            // not already present? don't want to add an old snapshot\n            if (!state.eventSources[sourceInput.internalEventSource.sourceId]) {\n                this.dispatch({\n                    type: \"ADD_EVENT_SOURCES\",\n                    sources: [\n                        sourceInput.internalEventSource\n                    ]\n                });\n            }\n            return sourceInput;\n        }\n        let eventSource = parseEventSource(sourceInput, state);\n        if (eventSource) {\n            this.dispatch({\n                type: \"ADD_EVENT_SOURCES\",\n                sources: [\n                    eventSource\n                ]\n            });\n            return new EventSourceImpl(state, eventSource);\n        }\n        return null;\n    }\n    removeAllEventSources() {\n        this.dispatch({\n            type: \"REMOVE_ALL_EVENT_SOURCES\"\n        });\n    }\n    refetchEvents() {\n        this.dispatch({\n            type: \"FETCH_EVENT_SOURCES\",\n            isRefetch: true\n        });\n    }\n    // Scroll\n    // -----------------------------------------------------------------------------------------------------------------\n    scrollToTime(timeInput) {\n        let time = createDuration(timeInput);\n        if (time) {\n            this.trigger(\"_scrollRequest\", {\n                time\n            });\n        }\n    }\n}\nfunction pointInsideRect(point, rect) {\n    return point.left >= rect.left && point.left < rect.right && point.top >= rect.top && point.top < rect.bottom;\n}\n// Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false\nfunction intersectRects(rect1, rect2) {\n    let res = {\n        left: Math.max(rect1.left, rect2.left),\n        right: Math.min(rect1.right, rect2.right),\n        top: Math.max(rect1.top, rect2.top),\n        bottom: Math.min(rect1.bottom, rect2.bottom)\n    };\n    if (res.left < res.right && res.top < res.bottom) {\n        return res;\n    }\n    return false;\n}\nfunction translateRect(rect, deltaX, deltaY) {\n    return {\n        left: rect.left + deltaX,\n        right: rect.right + deltaX,\n        top: rect.top + deltaY,\n        bottom: rect.bottom + deltaY\n    };\n}\n// Returns a new point that will have been moved to reside within the given rectangle\nfunction constrainPoint(point, rect) {\n    return {\n        left: Math.min(Math.max(point.left, rect.left), rect.right),\n        top: Math.min(Math.max(point.top, rect.top), rect.bottom)\n    };\n}\n// Returns a point that is the center of the given rectangle\nfunction getRectCenter(rect) {\n    return {\n        left: (rect.left + rect.right) / 2,\n        top: (rect.top + rect.bottom) / 2\n    };\n}\n// Subtracts point2's coordinates from point1's coordinates, returning a delta\nfunction diffPoints(point1, point2) {\n    return {\n        left: point1.left - point2.left,\n        top: point1.top - point2.top\n    };\n}\nconst EMPTY_EVENT_STORE = createEmptyEventStore(); // for purecomponents. TODO: keep elsewhere\nclass Splitter {\n    constructor(){\n        this.getKeysForEventDefs = memoize(this._getKeysForEventDefs);\n        this.splitDateSelection = memoize(this._splitDateSpan);\n        this.splitEventStore = memoize(this._splitEventStore);\n        this.splitIndividualUi = memoize(this._splitIndividualUi);\n        this.splitEventDrag = memoize(this._splitInteraction);\n        this.splitEventResize = memoize(this._splitInteraction);\n        this.eventUiBuilders = {}; // TODO: typescript protection\n    }\n    splitProps(props) {\n        let keyInfos = this.getKeyInfo(props);\n        let defKeys = this.getKeysForEventDefs(props.eventStore);\n        let dateSelections = this.splitDateSelection(props.dateSelection);\n        let individualUi = this.splitIndividualUi(props.eventUiBases, defKeys); // the individual *bases*\n        let eventStores = this.splitEventStore(props.eventStore, defKeys);\n        let eventDrags = this.splitEventDrag(props.eventDrag);\n        let eventResizes = this.splitEventResize(props.eventResize);\n        let splitProps = {};\n        this.eventUiBuilders = mapHash(keyInfos, (info, key)=>this.eventUiBuilders[key] || memoize(buildEventUiForKey));\n        for(let key in keyInfos){\n            let keyInfo = keyInfos[key];\n            let eventStore = eventStores[key] || EMPTY_EVENT_STORE;\n            let buildEventUi = this.eventUiBuilders[key];\n            splitProps[key] = {\n                businessHours: keyInfo.businessHours || props.businessHours,\n                dateSelection: dateSelections[key] || null,\n                eventStore,\n                eventUiBases: buildEventUi(props.eventUiBases[\"\"], keyInfo.ui, individualUi[key]),\n                eventSelection: eventStore.instances[props.eventSelection] ? props.eventSelection : \"\",\n                eventDrag: eventDrags[key] || null,\n                eventResize: eventResizes[key] || null\n            };\n        }\n        return splitProps;\n    }\n    _splitDateSpan(dateSpan) {\n        let dateSpans = {};\n        if (dateSpan) {\n            let keys = this.getKeysForDateSpan(dateSpan);\n            for (let key of keys){\n                dateSpans[key] = dateSpan;\n            }\n        }\n        return dateSpans;\n    }\n    _getKeysForEventDefs(eventStore) {\n        return mapHash(eventStore.defs, (eventDef)=>this.getKeysForEventDef(eventDef));\n    }\n    _splitEventStore(eventStore, defKeys) {\n        let { defs, instances } = eventStore;\n        let splitStores = {};\n        for(let defId in defs){\n            for (let key of defKeys[defId]){\n                if (!splitStores[key]) {\n                    splitStores[key] = createEmptyEventStore();\n                }\n                splitStores[key].defs[defId] = defs[defId];\n            }\n        }\n        for(let instanceId in instances){\n            let instance = instances[instanceId];\n            for (let key of defKeys[instance.defId]){\n                if (splitStores[key]) {\n                    splitStores[key].instances[instanceId] = instance;\n                }\n            }\n        }\n        return splitStores;\n    }\n    _splitIndividualUi(eventUiBases, defKeys) {\n        let splitHashes = {};\n        for(let defId in eventUiBases){\n            if (defId) {\n                for (let key of defKeys[defId]){\n                    if (!splitHashes[key]) {\n                        splitHashes[key] = {};\n                    }\n                    splitHashes[key][defId] = eventUiBases[defId];\n                }\n            }\n        }\n        return splitHashes;\n    }\n    _splitInteraction(interaction) {\n        let splitStates = {};\n        if (interaction) {\n            let affectedStores = this._splitEventStore(interaction.affectedEvents, this._getKeysForEventDefs(interaction.affectedEvents));\n            // can't rely on defKeys because event data is mutated\n            let mutatedKeysByDefId = this._getKeysForEventDefs(interaction.mutatedEvents);\n            let mutatedStores = this._splitEventStore(interaction.mutatedEvents, mutatedKeysByDefId);\n            let populate = (key)=>{\n                if (!splitStates[key]) {\n                    splitStates[key] = {\n                        affectedEvents: affectedStores[key] || EMPTY_EVENT_STORE,\n                        mutatedEvents: mutatedStores[key] || EMPTY_EVENT_STORE,\n                        isEvent: interaction.isEvent\n                    };\n                }\n            };\n            for(let key in affectedStores){\n                populate(key);\n            }\n            for(let key in mutatedStores){\n                populate(key);\n            }\n        }\n        return splitStates;\n    }\n}\nfunction buildEventUiForKey(allUi, eventUiForKey, individualUi) {\n    let baseParts = [];\n    if (allUi) {\n        baseParts.push(allUi);\n    }\n    if (eventUiForKey) {\n        baseParts.push(eventUiForKey);\n    }\n    let stuff = {\n        \"\": combineEventUis(baseParts)\n    };\n    if (individualUi) {\n        Object.assign(stuff, individualUi);\n    }\n    return stuff;\n}\nfunction getDateMeta(date, todayRange, nowDate, dateProfile) {\n    return {\n        dow: date.getUTCDay(),\n        isDisabled: Boolean(dateProfile && !rangeContainsMarker(dateProfile.activeRange, date)),\n        isOther: Boolean(dateProfile && !rangeContainsMarker(dateProfile.currentRange, date)),\n        isToday: Boolean(todayRange && rangeContainsMarker(todayRange, date)),\n        isPast: Boolean(nowDate ? date < nowDate : todayRange ? date < todayRange.start : false),\n        isFuture: Boolean(nowDate ? date > nowDate : todayRange ? date >= todayRange.end : false)\n    };\n}\nfunction getDayClassNames(meta, theme) {\n    let classNames = [\n        \"fc-day\",\n        `fc-day-${DAY_IDS[meta.dow]}`\n    ];\n    if (meta.isDisabled) {\n        classNames.push(\"fc-day-disabled\");\n    } else {\n        if (meta.isToday) {\n            classNames.push(\"fc-day-today\");\n            classNames.push(theme.getClass(\"today\"));\n        }\n        if (meta.isPast) {\n            classNames.push(\"fc-day-past\");\n        }\n        if (meta.isFuture) {\n            classNames.push(\"fc-day-future\");\n        }\n        if (meta.isOther) {\n            classNames.push(\"fc-day-other\");\n        }\n    }\n    return classNames;\n}\nfunction getSlotClassNames(meta, theme) {\n    let classNames = [\n        \"fc-slot\",\n        `fc-slot-${DAY_IDS[meta.dow]}`\n    ];\n    if (meta.isDisabled) {\n        classNames.push(\"fc-slot-disabled\");\n    } else {\n        if (meta.isToday) {\n            classNames.push(\"fc-slot-today\");\n            classNames.push(theme.getClass(\"today\"));\n        }\n        if (meta.isPast) {\n            classNames.push(\"fc-slot-past\");\n        }\n        if (meta.isFuture) {\n            classNames.push(\"fc-slot-future\");\n        }\n    }\n    return classNames;\n}\nconst DAY_FORMAT = createFormatter({\n    year: \"numeric\",\n    month: \"long\",\n    day: \"numeric\"\n});\nconst WEEK_FORMAT = createFormatter({\n    week: \"long\"\n});\nfunction buildNavLinkAttrs(context, dateMarker, viewType = \"day\", isTabbable = true) {\n    const { dateEnv, options, calendarApi } = context;\n    let dateStr = dateEnv.format(dateMarker, viewType === \"week\" ? WEEK_FORMAT : DAY_FORMAT);\n    if (options.navLinks) {\n        let zonedDate = dateEnv.toDate(dateMarker);\n        const handleInteraction = (ev)=>{\n            let customAction = viewType === \"day\" ? options.navLinkDayClick : viewType === \"week\" ? options.navLinkWeekClick : null;\n            if (typeof customAction === \"function\") {\n                customAction.call(calendarApi, dateEnv.toDate(dateMarker), ev);\n            } else {\n                if (typeof customAction === \"string\") {\n                    viewType = customAction;\n                }\n                calendarApi.zoomTo(dateMarker, viewType);\n            }\n        };\n        return Object.assign({\n            title: formatWithOrdinals(options.navLinkHint, [\n                dateStr,\n                zonedDate\n            ], dateStr),\n            \"data-navlink\": \"\"\n        }, isTabbable ? createAriaClickAttrs(handleInteraction) : {\n            onClick: handleInteraction\n        });\n    }\n    return {\n        \"aria-label\": dateStr\n    };\n}\nlet _isRtlScrollbarOnLeft = null;\nfunction getIsRtlScrollbarOnLeft() {\n    if (_isRtlScrollbarOnLeft === null) {\n        _isRtlScrollbarOnLeft = computeIsRtlScrollbarOnLeft();\n    }\n    return _isRtlScrollbarOnLeft;\n}\nfunction computeIsRtlScrollbarOnLeft() {\n    let outerEl = document.createElement(\"div\");\n    applyStyle(outerEl, {\n        position: \"absolute\",\n        top: -1000,\n        left: 0,\n        border: 0,\n        padding: 0,\n        overflow: \"scroll\",\n        direction: \"rtl\"\n    });\n    outerEl.innerHTML = \"<div></div>\";\n    document.body.appendChild(outerEl);\n    let innerEl = outerEl.firstChild;\n    let res = innerEl.getBoundingClientRect().left > outerEl.getBoundingClientRect().left;\n    removeElement(outerEl);\n    return res;\n}\nlet _scrollbarWidths;\nfunction getScrollbarWidths() {\n    if (!_scrollbarWidths) {\n        _scrollbarWidths = computeScrollbarWidths();\n    }\n    return _scrollbarWidths;\n}\nfunction computeScrollbarWidths() {\n    let el = document.createElement(\"div\");\n    el.style.overflow = \"scroll\";\n    el.style.position = \"absolute\";\n    el.style.top = \"-9999px\";\n    el.style.left = \"-9999px\";\n    document.body.appendChild(el);\n    let res = computeScrollbarWidthsForEl(el);\n    document.body.removeChild(el);\n    return res;\n}\n// WARNING: will include border\nfunction computeScrollbarWidthsForEl(el) {\n    return {\n        x: el.offsetHeight - el.clientHeight,\n        y: el.offsetWidth - el.clientWidth\n    };\n}\nfunction computeEdges(el, getPadding = false) {\n    let computedStyle = window.getComputedStyle(el);\n    let borderLeft = parseInt(computedStyle.borderLeftWidth, 10) || 0;\n    let borderRight = parseInt(computedStyle.borderRightWidth, 10) || 0;\n    let borderTop = parseInt(computedStyle.borderTopWidth, 10) || 0;\n    let borderBottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;\n    let badScrollbarWidths = computeScrollbarWidthsForEl(el); // includes border!\n    let scrollbarLeftRight = badScrollbarWidths.y - borderLeft - borderRight;\n    let scrollbarBottom = badScrollbarWidths.x - borderTop - borderBottom;\n    let res = {\n        borderLeft,\n        borderRight,\n        borderTop,\n        borderBottom,\n        scrollbarBottom,\n        scrollbarLeft: 0,\n        scrollbarRight: 0\n    };\n    if (getIsRtlScrollbarOnLeft() && computedStyle.direction === \"rtl\") {\n        res.scrollbarLeft = scrollbarLeftRight;\n    } else {\n        res.scrollbarRight = scrollbarLeftRight;\n    }\n    if (getPadding) {\n        res.paddingLeft = parseInt(computedStyle.paddingLeft, 10) || 0;\n        res.paddingRight = parseInt(computedStyle.paddingRight, 10) || 0;\n        res.paddingTop = parseInt(computedStyle.paddingTop, 10) || 0;\n        res.paddingBottom = parseInt(computedStyle.paddingBottom, 10) || 0;\n    }\n    return res;\n}\nfunction computeInnerRect(el, goWithinPadding = false, doFromWindowViewport) {\n    let outerRect = doFromWindowViewport ? el.getBoundingClientRect() : computeRect(el);\n    let edges = computeEdges(el, goWithinPadding);\n    let res = {\n        left: outerRect.left + edges.borderLeft + edges.scrollbarLeft,\n        right: outerRect.right - edges.borderRight - edges.scrollbarRight,\n        top: outerRect.top + edges.borderTop,\n        bottom: outerRect.bottom - edges.borderBottom - edges.scrollbarBottom\n    };\n    if (goWithinPadding) {\n        res.left += edges.paddingLeft;\n        res.right -= edges.paddingRight;\n        res.top += edges.paddingTop;\n        res.bottom -= edges.paddingBottom;\n    }\n    return res;\n}\nfunction computeRect(el) {\n    let rect = el.getBoundingClientRect();\n    return {\n        left: rect.left + window.scrollX,\n        top: rect.top + window.scrollY,\n        right: rect.right + window.scrollX,\n        bottom: rect.bottom + window.scrollY\n    };\n}\nfunction computeClippedClientRect(el) {\n    let clippingParents = getClippingParents(el);\n    let rect = el.getBoundingClientRect();\n    for (let clippingParent of clippingParents){\n        let intersection = intersectRects(rect, clippingParent.getBoundingClientRect());\n        if (intersection) {\n            rect = intersection;\n        } else {\n            return null;\n        }\n    }\n    return rect;\n}\n// does not return window\nfunction getClippingParents(el) {\n    let parents = [];\n    while(el instanceof HTMLElement){\n        let computedStyle = window.getComputedStyle(el);\n        if (computedStyle.position === \"fixed\") {\n            break;\n        }\n        if (/(auto|scroll)/.test(computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {\n            parents.push(el);\n        }\n        el = el.parentNode;\n    }\n    return parents;\n}\n/*\nRecords offset information for a set of elements, relative to an origin element.\nCan record the left/right OR the top/bottom OR both.\nProvides methods for querying the cache by position.\n*/ class PositionCache {\n    constructor(originEl, els, isHorizontal, isVertical){\n        this.els = els;\n        let originClientRect = this.originClientRect = originEl.getBoundingClientRect(); // relative to viewport top-left\n        if (isHorizontal) {\n            this.buildElHorizontals(originClientRect.left);\n        }\n        if (isVertical) {\n            this.buildElVerticals(originClientRect.top);\n        }\n    }\n    // Populates the left/right internal coordinate arrays\n    buildElHorizontals(originClientLeft) {\n        let lefts = [];\n        let rights = [];\n        for (let el of this.els){\n            let rect = el.getBoundingClientRect();\n            lefts.push(rect.left - originClientLeft);\n            rights.push(rect.right - originClientLeft);\n        }\n        this.lefts = lefts;\n        this.rights = rights;\n    }\n    // Populates the top/bottom internal coordinate arrays\n    buildElVerticals(originClientTop) {\n        let tops = [];\n        let bottoms = [];\n        for (let el of this.els){\n            let rect = el.getBoundingClientRect();\n            tops.push(rect.top - originClientTop);\n            bottoms.push(rect.bottom - originClientTop);\n        }\n        this.tops = tops;\n        this.bottoms = bottoms;\n    }\n    // Given a left offset (from document left), returns the index of the el that it horizontally intersects.\n    // If no intersection is made, returns undefined.\n    leftToIndex(leftPosition) {\n        let { lefts, rights } = this;\n        let len = lefts.length;\n        let i;\n        for(i = 0; i < len; i += 1){\n            if (leftPosition >= lefts[i] && leftPosition < rights[i]) {\n                return i;\n            }\n        }\n        return undefined; // TODO: better\n    }\n    // Given a top offset (from document top), returns the index of the el that it vertically intersects.\n    // If no intersection is made, returns undefined.\n    topToIndex(topPosition) {\n        let { tops, bottoms } = this;\n        let len = tops.length;\n        let i;\n        for(i = 0; i < len; i += 1){\n            if (topPosition >= tops[i] && topPosition < bottoms[i]) {\n                return i;\n            }\n        }\n        return undefined; // TODO: better\n    }\n    // Gets the width of the element at the given index\n    getWidth(leftIndex) {\n        return this.rights[leftIndex] - this.lefts[leftIndex];\n    }\n    // Gets the height of the element at the given index\n    getHeight(topIndex) {\n        return this.bottoms[topIndex] - this.tops[topIndex];\n    }\n    similarTo(otherCache) {\n        return similarNumArrays(this.tops || [], otherCache.tops || []) && similarNumArrays(this.bottoms || [], otherCache.bottoms || []) && similarNumArrays(this.lefts || [], otherCache.lefts || []) && similarNumArrays(this.rights || [], otherCache.rights || []);\n    }\n}\nfunction similarNumArrays(a, b) {\n    const len = a.length;\n    if (len !== b.length) {\n        return false;\n    }\n    for(let i = 0; i < len; i++){\n        if (Math.round(a[i]) !== Math.round(b[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n/* eslint max-classes-per-file: \"off\" */ /*\nAn object for getting/setting scroll-related information for an element.\nInternally, this is done very differently for window versus DOM element,\nso this object serves as a common interface.\n*/ class ScrollController {\n    getMaxScrollTop() {\n        return this.getScrollHeight() - this.getClientHeight();\n    }\n    getMaxScrollLeft() {\n        return this.getScrollWidth() - this.getClientWidth();\n    }\n    canScrollVertically() {\n        return this.getMaxScrollTop() > 0;\n    }\n    canScrollHorizontally() {\n        return this.getMaxScrollLeft() > 0;\n    }\n    canScrollUp() {\n        return this.getScrollTop() > 0;\n    }\n    canScrollDown() {\n        return this.getScrollTop() < this.getMaxScrollTop();\n    }\n    canScrollLeft() {\n        return this.getScrollLeft() > 0;\n    }\n    canScrollRight() {\n        return this.getScrollLeft() < this.getMaxScrollLeft();\n    }\n}\nclass ElementScrollController extends ScrollController {\n    constructor(el){\n        super();\n        this.el = el;\n    }\n    getScrollTop() {\n        return this.el.scrollTop;\n    }\n    getScrollLeft() {\n        return this.el.scrollLeft;\n    }\n    setScrollTop(top) {\n        this.el.scrollTop = top;\n    }\n    setScrollLeft(left) {\n        this.el.scrollLeft = left;\n    }\n    getScrollWidth() {\n        return this.el.scrollWidth;\n    }\n    getScrollHeight() {\n        return this.el.scrollHeight;\n    }\n    getClientHeight() {\n        return this.el.clientHeight;\n    }\n    getClientWidth() {\n        return this.el.clientWidth;\n    }\n}\nclass WindowScrollController extends ScrollController {\n    getScrollTop() {\n        return window.scrollY;\n    }\n    getScrollLeft() {\n        return window.scrollX;\n    }\n    setScrollTop(n) {\n        window.scroll(window.scrollX, n);\n    }\n    setScrollLeft(n) {\n        window.scroll(n, window.scrollY);\n    }\n    getScrollWidth() {\n        return document.documentElement.scrollWidth;\n    }\n    getScrollHeight() {\n        return document.documentElement.scrollHeight;\n    }\n    getClientHeight() {\n        return document.documentElement.clientHeight;\n    }\n    getClientWidth() {\n        return document.documentElement.clientWidth;\n    }\n}\n/*\nan INTERACTABLE date component\n\nPURPOSES:\n- hook up to fg, fill, and mirror renderers\n- interface for dragging and hits\n*/ class DateComponent extends BaseComponent {\n    constructor(){\n        super(...arguments);\n        this.uid = guid();\n    }\n    // Hit System\n    // -----------------------------------------------------------------------------------------------------------------\n    prepareHits() {}\n    queryHit(positionLeft, positionTop, elWidth, elHeight) {\n        return null; // this should be abstract\n    }\n    // Pointer Interaction Utils\n    // -----------------------------------------------------------------------------------------------------------------\n    isValidSegDownEl(el) {\n        return !this.props.eventDrag && // HACK\n        !this.props.eventResize && // HACK\n        !elementClosest(el, \".fc-event-mirror\");\n    }\n    isValidDateDownEl(el) {\n        return !elementClosest(el, \".fc-event:not(.fc-bg-event)\") && !elementClosest(el, \".fc-more-link\") && // a \"more..\" link\n        !elementClosest(el, \"a[data-navlink]\") && // a clickable nav link\n        !elementClosest(el, \".fc-popover\"); // hack\n    }\n}\nclass NamedTimeZoneImpl {\n    constructor(timeZoneName){\n        this.timeZoneName = timeZoneName;\n    }\n}\nclass SegHierarchy {\n    constructor(getEntryThickness = (entry)=>{\n        // if no thickness known, assume 1 (if 0, so small it always fits)\n        return entry.thickness || 1;\n    }){\n        this.getEntryThickness = getEntryThickness;\n        // settings\n        this.strictOrder = false;\n        this.allowReslicing = false;\n        this.maxCoord = -1; // -1 means no max\n        this.maxStackCnt = -1; // -1 means no max\n        this.levelCoords = []; // ordered\n        this.entriesByLevel = []; // parallel with levelCoords\n        this.stackCnts = {}; // TODO: use better technique!?\n    }\n    addSegs(inputs) {\n        let hiddenEntries = [];\n        for (let input of inputs){\n            this.insertEntry(input, hiddenEntries);\n        }\n        return hiddenEntries;\n    }\n    insertEntry(entry, hiddenEntries) {\n        let insertion = this.findInsertion(entry);\n        if (this.isInsertionValid(insertion, entry)) {\n            this.insertEntryAt(entry, insertion);\n        } else {\n            this.handleInvalidInsertion(insertion, entry, hiddenEntries);\n        }\n    }\n    isInsertionValid(insertion, entry) {\n        return (this.maxCoord === -1 || insertion.levelCoord + this.getEntryThickness(entry) <= this.maxCoord) && (this.maxStackCnt === -1 || insertion.stackCnt < this.maxStackCnt);\n    }\n    handleInvalidInsertion(insertion, entry, hiddenEntries) {\n        if (this.allowReslicing && insertion.touchingEntry) {\n            const hiddenEntry = Object.assign(Object.assign({}, entry), {\n                span: intersectSpans(entry.span, insertion.touchingEntry.span)\n            });\n            hiddenEntries.push(hiddenEntry);\n            this.splitEntry(entry, insertion.touchingEntry, hiddenEntries);\n        } else {\n            hiddenEntries.push(entry);\n        }\n    }\n    /*\n    Does NOT add what hit the `barrier` into hiddenEntries. Should already be done.\n    */ splitEntry(entry, barrier, hiddenEntries) {\n        let entrySpan = entry.span;\n        let barrierSpan = barrier.span;\n        if (entrySpan.start < barrierSpan.start) {\n            this.insertEntry({\n                index: entry.index,\n                thickness: entry.thickness,\n                span: {\n                    start: entrySpan.start,\n                    end: barrierSpan.start\n                }\n            }, hiddenEntries);\n        }\n        if (entrySpan.end > barrierSpan.end) {\n            this.insertEntry({\n                index: entry.index,\n                thickness: entry.thickness,\n                span: {\n                    start: barrierSpan.end,\n                    end: entrySpan.end\n                }\n            }, hiddenEntries);\n        }\n    }\n    insertEntryAt(entry, insertion) {\n        let { entriesByLevel, levelCoords } = this;\n        if (insertion.lateral === -1) {\n            // create a new level\n            insertAt(levelCoords, insertion.level, insertion.levelCoord);\n            insertAt(entriesByLevel, insertion.level, [\n                entry\n            ]);\n        } else {\n            // insert into existing level\n            insertAt(entriesByLevel[insertion.level], insertion.lateral, entry);\n        }\n        this.stackCnts[buildEntryKey(entry)] = insertion.stackCnt;\n    }\n    /*\n    does not care about limits\n    */ findInsertion(newEntry) {\n        let { levelCoords, entriesByLevel, strictOrder, stackCnts } = this;\n        let levelCnt = levelCoords.length;\n        let candidateCoord = 0;\n        let touchingLevel = -1;\n        let touchingLateral = -1;\n        let touchingEntry = null;\n        let stackCnt = 0;\n        for(let trackingLevel = 0; trackingLevel < levelCnt; trackingLevel += 1){\n            const trackingCoord = levelCoords[trackingLevel];\n            // if the current level is past the placed entry, we have found a good empty space and can stop.\n            // if strictOrder, keep finding more lateral intersections.\n            if (!strictOrder && trackingCoord >= candidateCoord + this.getEntryThickness(newEntry)) {\n                break;\n            }\n            let trackingEntries = entriesByLevel[trackingLevel];\n            let trackingEntry;\n            let searchRes = binarySearch(trackingEntries, newEntry.span.start, getEntrySpanEnd); // find first entry after newEntry's end\n            let lateralIndex = searchRes[0] + searchRes[1]; // if exact match (which doesn't collide), go to next one\n            while((trackingEntry = trackingEntries[lateralIndex]) && // but not past the whole entry list\n            trackingEntry.span.start < newEntry.span.end // and not entirely past newEntry\n            ){\n                let trackingEntryBottom = trackingCoord + this.getEntryThickness(trackingEntry);\n                // intersects into the top of the candidate?\n                if (trackingEntryBottom > candidateCoord) {\n                    candidateCoord = trackingEntryBottom;\n                    touchingEntry = trackingEntry;\n                    touchingLevel = trackingLevel;\n                    touchingLateral = lateralIndex;\n                }\n                // butts up against top of candidate? (will happen if just intersected as well)\n                if (trackingEntryBottom === candidateCoord) {\n                    // accumulate the highest possible stackCnt of the trackingEntries that butt up\n                    stackCnt = Math.max(stackCnt, stackCnts[buildEntryKey(trackingEntry)] + 1);\n                }\n                lateralIndex += 1;\n            }\n        }\n        // the destination level will be after touchingEntry's level. find it\n        let destLevel = 0;\n        if (touchingEntry) {\n            destLevel = touchingLevel + 1;\n            while(destLevel < levelCnt && levelCoords[destLevel] < candidateCoord){\n                destLevel += 1;\n            }\n        }\n        // if adding to an existing level, find where to insert\n        let destLateral = -1;\n        if (destLevel < levelCnt && levelCoords[destLevel] === candidateCoord) {\n            destLateral = binarySearch(entriesByLevel[destLevel], newEntry.span.end, getEntrySpanEnd)[0];\n        }\n        return {\n            touchingLevel,\n            touchingLateral,\n            touchingEntry,\n            stackCnt,\n            levelCoord: candidateCoord,\n            level: destLevel,\n            lateral: destLateral\n        };\n    }\n    // sorted by levelCoord (lowest to highest)\n    toRects() {\n        let { entriesByLevel, levelCoords } = this;\n        let levelCnt = entriesByLevel.length;\n        let rects = [];\n        for(let level = 0; level < levelCnt; level += 1){\n            let entries = entriesByLevel[level];\n            let levelCoord = levelCoords[level];\n            for (let entry of entries){\n                rects.push(Object.assign(Object.assign({}, entry), {\n                    thickness: this.getEntryThickness(entry),\n                    levelCoord\n                }));\n            }\n        }\n        return rects;\n    }\n}\nfunction getEntrySpanEnd(entry) {\n    return entry.span.end;\n}\nfunction buildEntryKey(entry) {\n    return entry.index + \":\" + entry.span.start;\n}\n// returns groups with entries sorted by input order\nfunction groupIntersectingEntries(entries) {\n    let merges = [];\n    for (let entry of entries){\n        let filteredMerges = [];\n        let hungryMerge = {\n            span: entry.span,\n            entries: [\n                entry\n            ]\n        };\n        for (let merge of merges){\n            if (intersectSpans(merge.span, hungryMerge.span)) {\n                hungryMerge = {\n                    entries: merge.entries.concat(hungryMerge.entries),\n                    span: joinSpans(merge.span, hungryMerge.span)\n                };\n            } else {\n                filteredMerges.push(merge);\n            }\n        }\n        filteredMerges.push(hungryMerge);\n        merges = filteredMerges;\n    }\n    return merges;\n}\nfunction joinSpans(span0, span1) {\n    return {\n        start: Math.min(span0.start, span1.start),\n        end: Math.max(span0.end, span1.end)\n    };\n}\nfunction intersectSpans(span0, span1) {\n    let start = Math.max(span0.start, span1.start);\n    let end = Math.min(span0.end, span1.end);\n    if (start < end) {\n        return {\n            start,\n            end\n        };\n    }\n    return null;\n}\n// general util\n// ---------------------------------------------------------------------------------------------------------------------\nfunction insertAt(arr, index, item) {\n    arr.splice(index, 0, item);\n}\nfunction binarySearch(a, searchVal, getItemVal) {\n    let startIndex = 0;\n    let endIndex = a.length; // exclusive\n    if (!endIndex || searchVal < getItemVal(a[startIndex])) {\n        return [\n            0,\n            0\n        ];\n    }\n    if (searchVal > getItemVal(a[endIndex - 1])) {\n        return [\n            endIndex,\n            0\n        ];\n    }\n    while(startIndex < endIndex){\n        let middleIndex = Math.floor(startIndex + (endIndex - startIndex) / 2);\n        let middleVal = getItemVal(a[middleIndex]);\n        if (searchVal < middleVal) {\n            endIndex = middleIndex;\n        } else if (searchVal > middleVal) {\n            startIndex = middleIndex + 1;\n        } else {\n            return [\n                middleIndex,\n                1\n            ];\n        }\n    }\n    return [\n        startIndex,\n        0\n    ];\n}\n/*\nAn abstraction for a dragging interaction originating on an event.\nDoes higher-level things than PointerDragger, such as possibly:\n- a \"mirror\" that moves with the pointer\n- a minimum number of pixels or other criteria for a true drag to begin\n\nsubclasses must emit:\n- pointerdown\n- dragstart\n- dragmove\n- pointerup\n- dragend\n*/ class ElementDragging {\n    constructor(el, selector){\n        this.emitter = new Emitter();\n    }\n    destroy() {}\n    setMirrorIsVisible(bool) {\n    // optional if subclass doesn't want to support a mirror\n    }\n    setMirrorNeedsRevert(bool) {\n    // optional if subclass doesn't want to support a mirror\n    }\n    setAutoScrollEnabled(bool) {\n    // optional\n    }\n}\n// TODO: get rid of this in favor of options system,\n// tho it's really easy to access this globally rather than pass thru options.\nconst config = {};\n/*\nInformation about what will happen when an external element is dragged-and-dropped\nonto a calendar. Contains information for creating an event.\n*/ const DRAG_META_REFINERS = {\n    startTime: createDuration,\n    duration: createDuration,\n    create: Boolean,\n    sourceId: String\n};\nfunction parseDragMeta(raw) {\n    let { refined, extra } = refineProps(raw, DRAG_META_REFINERS);\n    return {\n        startTime: refined.startTime || null,\n        duration: refined.duration || null,\n        create: refined.create != null ? refined.create : true,\n        sourceId: refined.sourceId,\n        leftoverProps: extra\n    };\n}\n// Computes a default column header formatting string if `colFormat` is not explicitly defined\nfunction computeFallbackHeaderFormat(datesRepDistinctDays, dayCnt) {\n    // if more than one week row, or if there are a lot of columns with not much space,\n    // put just the day numbers will be in each cell\n    if (!datesRepDistinctDays || dayCnt > 10) {\n        return createFormatter({\n            weekday: \"short\"\n        }); // \"Sat\"\n    }\n    if (dayCnt > 1) {\n        return createFormatter({\n            weekday: \"short\",\n            month: \"numeric\",\n            day: \"numeric\",\n            omitCommas: true\n        }); // \"Sat 11/12\"\n    }\n    return createFormatter({\n        weekday: \"long\"\n    }); // \"Saturday\"\n}\nconst CLASS_NAME = \"fc-col-header-cell\"; // do the cushion too? no\nfunction renderInner$1(renderProps) {\n    return renderProps.text;\n}\n// BAD name for this class now. used in the Header\nclass TableDateCell extends BaseComponent {\n    render() {\n        let { dateEnv, options, theme, viewApi } = this.context;\n        let { props } = this;\n        let { date, dateProfile } = props;\n        let dayMeta = getDateMeta(date, props.todayRange, null, dateProfile);\n        let classNames = [\n            CLASS_NAME\n        ].concat(getDayClassNames(dayMeta, theme));\n        let text = dateEnv.format(date, props.dayHeaderFormat);\n        // if colCnt is 1, we are already in a day-view and don't need a navlink\n        let navLinkAttrs = !dayMeta.isDisabled && props.colCnt > 1 ? buildNavLinkAttrs(this.context, date) : {};\n        let renderProps = Object.assign(Object.assign(Object.assign({\n            date: dateEnv.toDate(date),\n            view: viewApi\n        }, props.extraRenderProps), {\n            text\n        }), dayMeta);\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentContainer, {\n            elTag: \"th\",\n            elClasses: classNames,\n            elAttrs: Object.assign({\n                role: \"columnheader\",\n                colSpan: props.colSpan,\n                \"data-date\": !dayMeta.isDisabled ? formatDayString(date) : undefined\n            }, props.extraDataAttrs),\n            renderProps: renderProps,\n            generatorName: \"dayHeaderContent\",\n            customGenerator: options.dayHeaderContent,\n            defaultGenerator: renderInner$1,\n            classNameGenerator: options.dayHeaderClassNames,\n            didMount: options.dayHeaderDidMount,\n            willUnmount: options.dayHeaderWillUnmount\n        }, (InnerContainer)=>(0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n                className: \"fc-scrollgrid-sync-inner\"\n            }, !dayMeta.isDisabled && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(InnerContainer, {\n                elTag: \"a\",\n                elAttrs: navLinkAttrs,\n                elClasses: [\n                    \"fc-col-header-cell-cushion\",\n                    props.isSticky && \"fc-sticky\"\n                ]\n            })));\n    }\n}\nconst WEEKDAY_FORMAT = createFormatter({\n    weekday: \"long\"\n});\nclass TableDowCell extends BaseComponent {\n    render() {\n        let { props } = this;\n        let { dateEnv, theme, viewApi, options } = this.context;\n        let date = addDays(new Date(259200000), props.dow); // start with Sun, 04 Jan 1970 00:00:00 GMT\n        let dateMeta = {\n            dow: props.dow,\n            isDisabled: false,\n            isFuture: false,\n            isPast: false,\n            isToday: false,\n            isOther: false\n        };\n        let text = dateEnv.format(date, props.dayHeaderFormat);\n        let renderProps = Object.assign(Object.assign(Object.assign(Object.assign({\n            date\n        }, dateMeta), {\n            view: viewApi\n        }), props.extraRenderProps), {\n            text\n        });\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentContainer, {\n            elTag: \"th\",\n            elClasses: [\n                CLASS_NAME,\n                ...getDayClassNames(dateMeta, theme),\n                ...props.extraClassNames || []\n            ],\n            elAttrs: Object.assign({\n                role: \"columnheader\",\n                colSpan: props.colSpan\n            }, props.extraDataAttrs),\n            renderProps: renderProps,\n            generatorName: \"dayHeaderContent\",\n            customGenerator: options.dayHeaderContent,\n            defaultGenerator: renderInner$1,\n            classNameGenerator: options.dayHeaderClassNames,\n            didMount: options.dayHeaderDidMount,\n            willUnmount: options.dayHeaderWillUnmount\n        }, (InnerContent)=>(0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n                className: \"fc-scrollgrid-sync-inner\"\n            }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(InnerContent, {\n                elTag: \"a\",\n                elClasses: [\n                    \"fc-col-header-cell-cushion\",\n                    props.isSticky && \"fc-sticky\"\n                ],\n                elAttrs: {\n                    \"aria-label\": dateEnv.format(date, WEEKDAY_FORMAT)\n                }\n            })));\n    }\n}\nclass NowTimer extends preact__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(props, context){\n        super(props, context);\n        this.initialNowDate = getNow(context.options.now, context.dateEnv);\n        this.initialNowQueriedMs = new Date().valueOf();\n        this.state = this.computeTiming().currentState;\n    }\n    render() {\n        let { props, state } = this;\n        return props.children(state.nowDate, state.todayRange);\n    }\n    componentDidMount() {\n        this.setTimeout();\n    }\n    componentDidUpdate(prevProps) {\n        if (prevProps.unit !== this.props.unit) {\n            this.clearTimeout();\n            this.setTimeout();\n        }\n    }\n    componentWillUnmount() {\n        this.clearTimeout();\n    }\n    computeTiming() {\n        let { props, context } = this;\n        let unroundedNow = addMs(this.initialNowDate, new Date().valueOf() - this.initialNowQueriedMs);\n        let currentUnitStart = context.dateEnv.startOf(unroundedNow, props.unit);\n        let nextUnitStart = context.dateEnv.add(currentUnitStart, createDuration(1, props.unit));\n        let waitMs = nextUnitStart.valueOf() - unroundedNow.valueOf();\n        // there is a max setTimeout ms value (https://stackoverflow.com/a/3468650/96342)\n        // ensure no longer than a day\n        waitMs = Math.min(1000 * 60 * 60 * 24, waitMs);\n        return {\n            currentState: {\n                nowDate: currentUnitStart,\n                todayRange: buildDayRange(currentUnitStart)\n            },\n            nextState: {\n                nowDate: nextUnitStart,\n                todayRange: buildDayRange(nextUnitStart)\n            },\n            waitMs\n        };\n    }\n    setTimeout() {\n        let { nextState, waitMs } = this.computeTiming();\n        this.timeoutId = setTimeout(()=>{\n            this.setState(nextState, ()=>{\n                this.setTimeout();\n            });\n        }, waitMs);\n    }\n    clearTimeout() {\n        if (this.timeoutId) {\n            clearTimeout(this.timeoutId);\n        }\n    }\n}\nNowTimer.contextType = ViewContextType;\nfunction buildDayRange(date) {\n    let start = startOfDay(date);\n    let end = addDays(start, 1);\n    return {\n        start,\n        end\n    };\n}\nclass DayHeader extends BaseComponent {\n    constructor(){\n        super(...arguments);\n        this.createDayHeaderFormatter = memoize(createDayHeaderFormatter);\n    }\n    render() {\n        let { context } = this;\n        let { dates, dateProfile, datesRepDistinctDays, renderIntro } = this.props;\n        let dayHeaderFormat = this.createDayHeaderFormatter(context.options.dayHeaderFormat, datesRepDistinctDays, dates.length);\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(NowTimer, {\n            unit: \"day\"\n        }, (nowDate, todayRange)=>(0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"tr\", {\n                role: \"row\"\n            }, renderIntro && renderIntro(\"day\"), dates.map((date)=>datesRepDistinctDays ? (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(TableDateCell, {\n                    key: date.toISOString(),\n                    date: date,\n                    dateProfile: dateProfile,\n                    todayRange: todayRange,\n                    colCnt: dates.length,\n                    dayHeaderFormat: dayHeaderFormat\n                }) : (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(TableDowCell, {\n                    key: date.getUTCDay(),\n                    dow: date.getUTCDay(),\n                    dayHeaderFormat: dayHeaderFormat\n                }))));\n    }\n}\nfunction createDayHeaderFormatter(explicitFormat, datesRepDistinctDays, dateCnt) {\n    return explicitFormat || computeFallbackHeaderFormat(datesRepDistinctDays, dateCnt);\n}\nclass DaySeriesModel {\n    constructor(range, dateProfileGenerator){\n        let date = range.start;\n        let { end } = range;\n        let indices = [];\n        let dates = [];\n        let dayIndex = -1;\n        while(date < end){\n            if (dateProfileGenerator.isHiddenDay(date)) {\n                indices.push(dayIndex + 0.5); // mark that it's between indices\n            } else {\n                dayIndex += 1;\n                indices.push(dayIndex);\n                dates.push(date);\n            }\n            date = addDays(date, 1);\n        }\n        this.dates = dates;\n        this.indices = indices;\n        this.cnt = dates.length;\n    }\n    sliceRange(range) {\n        let firstIndex = this.getDateDayIndex(range.start); // inclusive first index\n        let lastIndex = this.getDateDayIndex(addDays(range.end, -1)); // inclusive last index\n        let clippedFirstIndex = Math.max(0, firstIndex);\n        let clippedLastIndex = Math.min(this.cnt - 1, lastIndex);\n        // deal with in-between indices\n        clippedFirstIndex = Math.ceil(clippedFirstIndex); // in-between starts round to next cell\n        clippedLastIndex = Math.floor(clippedLastIndex); // in-between ends round to prev cell\n        if (clippedFirstIndex <= clippedLastIndex) {\n            return {\n                firstIndex: clippedFirstIndex,\n                lastIndex: clippedLastIndex,\n                isStart: firstIndex === clippedFirstIndex,\n                isEnd: lastIndex === clippedLastIndex\n            };\n        }\n        return null;\n    }\n    // Given a date, returns its chronolocial cell-index from the first cell of the grid.\n    // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.\n    // If before the first offset, returns a negative number.\n    // If after the last offset, returns an offset past the last cell offset.\n    // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.\n    getDateDayIndex(date) {\n        let { indices } = this;\n        let dayOffset = Math.floor(diffDays(this.dates[0], date));\n        if (dayOffset < 0) {\n            return indices[0] - 1;\n        }\n        if (dayOffset >= indices.length) {\n            return indices[indices.length - 1] + 1;\n        }\n        return indices[dayOffset];\n    }\n}\nclass DayTableModel {\n    constructor(daySeries, breakOnWeeks){\n        let { dates } = daySeries;\n        let daysPerRow;\n        let firstDay;\n        let rowCnt;\n        if (breakOnWeeks) {\n            // count columns until the day-of-week repeats\n            firstDay = dates[0].getUTCDay();\n            for(daysPerRow = 1; daysPerRow < dates.length; daysPerRow += 1){\n                if (dates[daysPerRow].getUTCDay() === firstDay) {\n                    break;\n                }\n            }\n            rowCnt = Math.ceil(dates.length / daysPerRow);\n        } else {\n            rowCnt = 1;\n            daysPerRow = dates.length;\n        }\n        this.rowCnt = rowCnt;\n        this.colCnt = daysPerRow;\n        this.daySeries = daySeries;\n        this.cells = this.buildCells();\n        this.headerDates = this.buildHeaderDates();\n    }\n    buildCells() {\n        let rows = [];\n        for(let row = 0; row < this.rowCnt; row += 1){\n            let cells = [];\n            for(let col = 0; col < this.colCnt; col += 1){\n                cells.push(this.buildCell(row, col));\n            }\n            rows.push(cells);\n        }\n        return rows;\n    }\n    buildCell(row, col) {\n        let date = this.daySeries.dates[row * this.colCnt + col];\n        return {\n            key: date.toISOString(),\n            date\n        };\n    }\n    buildHeaderDates() {\n        let dates = [];\n        for(let col = 0; col < this.colCnt; col += 1){\n            dates.push(this.cells[0][col].date);\n        }\n        return dates;\n    }\n    sliceRange(range) {\n        let { colCnt } = this;\n        let seriesSeg = this.daySeries.sliceRange(range);\n        let segs = [];\n        if (seriesSeg) {\n            let { firstIndex, lastIndex } = seriesSeg;\n            let index = firstIndex;\n            while(index <= lastIndex){\n                let row = Math.floor(index / colCnt);\n                let nextIndex = Math.min((row + 1) * colCnt, lastIndex + 1);\n                segs.push({\n                    row,\n                    firstCol: index % colCnt,\n                    lastCol: (nextIndex - 1) % colCnt,\n                    isStart: seriesSeg.isStart && index === firstIndex,\n                    isEnd: seriesSeg.isEnd && nextIndex - 1 === lastIndex\n                });\n                index = nextIndex;\n            }\n        }\n        return segs;\n    }\n}\nclass Slicer {\n    constructor(){\n        this.sliceBusinessHours = memoize(this._sliceBusinessHours);\n        this.sliceDateSelection = memoize(this._sliceDateSpan);\n        this.sliceEventStore = memoize(this._sliceEventStore);\n        this.sliceEventDrag = memoize(this._sliceInteraction);\n        this.sliceEventResize = memoize(this._sliceInteraction);\n        this.forceDayIfListItem = false; // hack\n    }\n    sliceProps(props, dateProfile, nextDayThreshold, context, ...extraArgs) {\n        let { eventUiBases } = props;\n        let eventSegs = this.sliceEventStore(props.eventStore, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs);\n        return {\n            dateSelectionSegs: this.sliceDateSelection(props.dateSelection, dateProfile, nextDayThreshold, eventUiBases, context, ...extraArgs),\n            businessHourSegs: this.sliceBusinessHours(props.businessHours, dateProfile, nextDayThreshold, context, ...extraArgs),\n            fgEventSegs: eventSegs.fg,\n            bgEventSegs: eventSegs.bg,\n            eventDrag: this.sliceEventDrag(props.eventDrag, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs),\n            eventResize: this.sliceEventResize(props.eventResize, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs),\n            eventSelection: props.eventSelection\n        }; // TODO: give interactionSegs?\n    }\n    sliceNowDate(date, dateProfile, nextDayThreshold, context, ...extraArgs) {\n        return this._sliceDateSpan({\n            range: {\n                start: date,\n                end: addMs(date, 1)\n            },\n            allDay: false\n        }, dateProfile, nextDayThreshold, {}, context, ...extraArgs);\n    }\n    _sliceBusinessHours(businessHours, dateProfile, nextDayThreshold, context, ...extraArgs) {\n        if (!businessHours) {\n            return [];\n        }\n        return this._sliceEventStore(expandRecurring(businessHours, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), context), {}, dateProfile, nextDayThreshold, ...extraArgs).bg;\n    }\n    _sliceEventStore(eventStore, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs) {\n        if (eventStore) {\n            let rangeRes = sliceEventStore(eventStore, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);\n            return {\n                bg: this.sliceEventRanges(rangeRes.bg, extraArgs),\n                fg: this.sliceEventRanges(rangeRes.fg, extraArgs)\n            };\n        }\n        return {\n            bg: [],\n            fg: []\n        };\n    }\n    _sliceInteraction(interaction, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs) {\n        if (!interaction) {\n            return null;\n        }\n        let rangeRes = sliceEventStore(interaction.mutatedEvents, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);\n        return {\n            segs: this.sliceEventRanges(rangeRes.fg, extraArgs),\n            affectedInstances: interaction.affectedEvents.instances,\n            isEvent: interaction.isEvent\n        };\n    }\n    _sliceDateSpan(dateSpan, dateProfile, nextDayThreshold, eventUiBases, context, ...extraArgs) {\n        if (!dateSpan) {\n            return [];\n        }\n        let activeRange = computeActiveRange(dateProfile, Boolean(nextDayThreshold));\n        let activeDateSpanRange = intersectRanges(dateSpan.range, activeRange);\n        if (activeDateSpanRange) {\n            dateSpan = Object.assign(Object.assign({}, dateSpan), {\n                range: activeDateSpanRange\n            });\n            let eventRange = fabricateEventRange(dateSpan, eventUiBases, context);\n            let segs = this.sliceRange(dateSpan.range, ...extraArgs);\n            for (let seg of segs){\n                seg.eventRange = eventRange;\n            }\n            return segs;\n        }\n        return [];\n    }\n    /*\n    \"complete\" seg means it has component and eventRange\n    */ sliceEventRanges(eventRanges, extraArgs) {\n        let segs = [];\n        for (let eventRange of eventRanges){\n            segs.push(...this.sliceEventRange(eventRange, extraArgs));\n        }\n        return segs;\n    }\n    /*\n    \"complete\" seg means it has component and eventRange\n    */ sliceEventRange(eventRange, extraArgs) {\n        let dateRange = eventRange.range;\n        // hack to make multi-day events that are being force-displayed as list-items to take up only one day\n        if (this.forceDayIfListItem && eventRange.ui.display === \"list-item\") {\n            dateRange = {\n                start: dateRange.start,\n                end: addDays(dateRange.start, 1)\n            };\n        }\n        let segs = this.sliceRange(dateRange, ...extraArgs);\n        for (let seg of segs){\n            seg.eventRange = eventRange;\n            seg.isStart = eventRange.isStart && seg.isStart;\n            seg.isEnd = eventRange.isEnd && seg.isEnd;\n        }\n        return segs;\n    }\n}\n/*\nfor incorporating slotMinTime/slotMaxTime if appropriate\nTODO: should be part of DateProfile!\nTimelineDateProfile already does this btw\n*/ function computeActiveRange(dateProfile, isComponentAllDay) {\n    let range = dateProfile.activeRange;\n    if (isComponentAllDay) {\n        return range;\n    }\n    return {\n        start: addMs(range.start, dateProfile.slotMinTime.milliseconds),\n        end: addMs(range.end, dateProfile.slotMaxTime.milliseconds - 864e5)\n    };\n}\n// high-level segmenting-aware tester functions\n// ------------------------------------------------------------------------------------------------------------------------\nfunction isInteractionValid(interaction, dateProfile, context) {\n    let { instances } = interaction.mutatedEvents;\n    for(let instanceId in instances){\n        if (!rangeContainsRange(dateProfile.validRange, instances[instanceId].range)) {\n            return false;\n        }\n    }\n    return isNewPropsValid({\n        eventDrag: interaction\n    }, context); // HACK: the eventDrag props is used for ALL interactions\n}\nfunction isDateSelectionValid(dateSelection, dateProfile, context) {\n    if (!rangeContainsRange(dateProfile.validRange, dateSelection.range)) {\n        return false;\n    }\n    return isNewPropsValid({\n        dateSelection\n    }, context);\n}\nfunction isNewPropsValid(newProps, context) {\n    let calendarState = context.getCurrentData();\n    let props = Object.assign({\n        businessHours: calendarState.businessHours,\n        dateSelection: \"\",\n        eventStore: calendarState.eventStore,\n        eventUiBases: calendarState.eventUiBases,\n        eventSelection: \"\",\n        eventDrag: null,\n        eventResize: null\n    }, newProps);\n    return (context.pluginHooks.isPropsValid || isPropsValid)(props, context);\n}\nfunction isPropsValid(state, context, dateSpanMeta = {}, filterConfig) {\n    if (state.eventDrag && !isInteractionPropsValid(state, context, dateSpanMeta, filterConfig)) {\n        return false;\n    }\n    if (state.dateSelection && !isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig)) {\n        return false;\n    }\n    return true;\n}\n// Moving Event Validation\n// ------------------------------------------------------------------------------------------------------------------------\nfunction isInteractionPropsValid(state, context, dateSpanMeta, filterConfig) {\n    let currentState = context.getCurrentData();\n    let interaction = state.eventDrag; // HACK: the eventDrag props is used for ALL interactions\n    let subjectEventStore = interaction.mutatedEvents;\n    let subjectDefs = subjectEventStore.defs;\n    let subjectInstances = subjectEventStore.instances;\n    let subjectConfigs = compileEventUis(subjectDefs, interaction.isEvent ? state.eventUiBases : {\n        \"\": currentState.selectionConfig\n    });\n    if (filterConfig) {\n        subjectConfigs = mapHash(subjectConfigs, filterConfig);\n    }\n    // exclude the subject events. TODO: exclude defs too?\n    let otherEventStore = excludeInstances(state.eventStore, interaction.affectedEvents.instances);\n    let otherDefs = otherEventStore.defs;\n    let otherInstances = otherEventStore.instances;\n    let otherConfigs = compileEventUis(otherDefs, state.eventUiBases);\n    for(let subjectInstanceId in subjectInstances){\n        let subjectInstance = subjectInstances[subjectInstanceId];\n        let subjectRange = subjectInstance.range;\n        let subjectConfig = subjectConfigs[subjectInstance.defId];\n        let subjectDef = subjectDefs[subjectInstance.defId];\n        // constraint\n        if (!allConstraintsPass(subjectConfig.constraints, subjectRange, otherEventStore, state.businessHours, context)) {\n            return false;\n        }\n        // overlap\n        let { eventOverlap } = context.options;\n        let eventOverlapFunc = typeof eventOverlap === \"function\" ? eventOverlap : null;\n        for(let otherInstanceId in otherInstances){\n            let otherInstance = otherInstances[otherInstanceId];\n            // intersect! evaluate\n            if (rangesIntersect(subjectRange, otherInstance.range)) {\n                let otherOverlap = otherConfigs[otherInstance.defId].overlap;\n                // consider the other event's overlap. only do this if the subject event is a \"real\" event\n                if (otherOverlap === false && interaction.isEvent) {\n                    return false;\n                }\n                if (subjectConfig.overlap === false) {\n                    return false;\n                }\n                if (eventOverlapFunc && !eventOverlapFunc(new EventImpl(context, otherDefs[otherInstance.defId], otherInstance), new EventImpl(context, subjectDef, subjectInstance))) {\n                    return false;\n                }\n            }\n        }\n        // allow (a function)\n        let calendarEventStore = currentState.eventStore; // need global-to-calendar, not local to component (splittable)state\n        for (let subjectAllow of subjectConfig.allows){\n            let subjectDateSpan = Object.assign(Object.assign({}, dateSpanMeta), {\n                range: subjectInstance.range,\n                allDay: subjectDef.allDay\n            });\n            let origDef = calendarEventStore.defs[subjectDef.defId];\n            let origInstance = calendarEventStore.instances[subjectInstanceId];\n            let eventApi;\n            if (origDef) {\n                eventApi = new EventImpl(context, origDef, origInstance);\n            } else {\n                eventApi = new EventImpl(context, subjectDef); // no instance, because had no dates\n            }\n            if (!subjectAllow(buildDateSpanApiWithContext(subjectDateSpan, context), eventApi)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n// Date Selection Validation\n// ------------------------------------------------------------------------------------------------------------------------\nfunction isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig) {\n    let relevantEventStore = state.eventStore;\n    let relevantDefs = relevantEventStore.defs;\n    let relevantInstances = relevantEventStore.instances;\n    let selection = state.dateSelection;\n    let selectionRange = selection.range;\n    let { selectionConfig } = context.getCurrentData();\n    if (filterConfig) {\n        selectionConfig = filterConfig(selectionConfig);\n    }\n    // constraint\n    if (!allConstraintsPass(selectionConfig.constraints, selectionRange, relevantEventStore, state.businessHours, context)) {\n        return false;\n    }\n    // overlap\n    let { selectOverlap } = context.options;\n    let selectOverlapFunc = typeof selectOverlap === \"function\" ? selectOverlap : null;\n    for(let relevantInstanceId in relevantInstances){\n        let relevantInstance = relevantInstances[relevantInstanceId];\n        // intersect! evaluate\n        if (rangesIntersect(selectionRange, relevantInstance.range)) {\n            if (selectionConfig.overlap === false) {\n                return false;\n            }\n            if (selectOverlapFunc && !selectOverlapFunc(new EventImpl(context, relevantDefs[relevantInstance.defId], relevantInstance), null)) {\n                return false;\n            }\n        }\n    }\n    // allow (a function)\n    for (let selectionAllow of selectionConfig.allows){\n        let fullDateSpan = Object.assign(Object.assign({}, dateSpanMeta), selection);\n        if (!selectionAllow(buildDateSpanApiWithContext(fullDateSpan, context), null)) {\n            return false;\n        }\n    }\n    return true;\n}\n// Constraint Utils\n// ------------------------------------------------------------------------------------------------------------------------\nfunction allConstraintsPass(constraints, subjectRange, otherEventStore, businessHoursUnexpanded, context) {\n    for (let constraint of constraints){\n        if (!anyRangesContainRange(constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context), subjectRange)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context) {\n    if (constraint === \"businessHours\") {\n        return eventStoreToRanges(expandRecurring(businessHoursUnexpanded, subjectRange, context));\n    }\n    if (typeof constraint === \"string\") {\n        return eventStoreToRanges(filterEventStoreDefs(otherEventStore, (eventDef)=>eventDef.groupId === constraint));\n    }\n    if (typeof constraint === \"object\" && constraint) {\n        return eventStoreToRanges(expandRecurring(constraint, subjectRange, context));\n    }\n    return []; // if it's false\n}\n// TODO: move to event-store file?\nfunction eventStoreToRanges(eventStore) {\n    let { instances } = eventStore;\n    let ranges = [];\n    for(let instanceId in instances){\n        ranges.push(instances[instanceId].range);\n    }\n    return ranges;\n}\n// TODO: move to geom file?\nfunction anyRangesContainRange(outerRanges, innerRange) {\n    for (let outerRange of outerRanges){\n        if (rangeContainsRange(outerRange, innerRange)) {\n            return true;\n        }\n    }\n    return false;\n}\nconst VISIBLE_HIDDEN_RE = /^(visible|hidden)$/;\nclass Scroller extends BaseComponent {\n    constructor(){\n        super(...arguments);\n        this.handleEl = (el)=>{\n            this.el = el;\n            setRef(this.props.elRef, el);\n        };\n    }\n    render() {\n        let { props } = this;\n        let { liquid, liquidIsAbsolute } = props;\n        let isAbsolute = liquid && liquidIsAbsolute;\n        let className = [\n            \"fc-scroller\"\n        ];\n        if (liquid) {\n            if (liquidIsAbsolute) {\n                className.push(\"fc-scroller-liquid-absolute\");\n            } else {\n                className.push(\"fc-scroller-liquid\");\n            }\n        }\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n            ref: this.handleEl,\n            className: className.join(\" \"),\n            style: {\n                overflowX: props.overflowX,\n                overflowY: props.overflowY,\n                left: isAbsolute && -(props.overcomeLeft || 0) || \"\",\n                right: isAbsolute && -(props.overcomeRight || 0) || \"\",\n                bottom: isAbsolute && -(props.overcomeBottom || 0) || \"\",\n                marginLeft: !isAbsolute && -(props.overcomeLeft || 0) || \"\",\n                marginRight: !isAbsolute && -(props.overcomeRight || 0) || \"\",\n                marginBottom: !isAbsolute && -(props.overcomeBottom || 0) || \"\",\n                maxHeight: props.maxHeight || \"\"\n            }\n        }, props.children);\n    }\n    needsXScrolling() {\n        if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {\n            return false;\n        }\n        // testing scrollWidth>clientWidth is unreliable cross-browser when pixel heights aren't integers.\n        // much more reliable to see if children are taller than the scroller, even tho doesn't account for\n        // inner-child margins and absolute positioning\n        let { el } = this;\n        let realClientWidth = this.el.getBoundingClientRect().width - this.getYScrollbarWidth();\n        let { children } = el;\n        for(let i = 0; i < children.length; i += 1){\n            let childEl = children[i];\n            if (childEl.getBoundingClientRect().width > realClientWidth) {\n                return true;\n            }\n        }\n        return false;\n    }\n    needsYScrolling() {\n        if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {\n            return false;\n        }\n        // testing scrollHeight>clientHeight is unreliable cross-browser when pixel heights aren't integers.\n        // much more reliable to see if children are taller than the scroller, even tho doesn't account for\n        // inner-child margins and absolute positioning\n        let { el } = this;\n        let realClientHeight = this.el.getBoundingClientRect().height - this.getXScrollbarWidth();\n        let { children } = el;\n        for(let i = 0; i < children.length; i += 1){\n            let childEl = children[i];\n            if (childEl.getBoundingClientRect().height > realClientHeight) {\n                return true;\n            }\n        }\n        return false;\n    }\n    getXScrollbarWidth() {\n        if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {\n            return 0;\n        }\n        return this.el.offsetHeight - this.el.clientHeight; // only works because we guarantee no borders. TODO: add to CSS with important?\n    }\n    getYScrollbarWidth() {\n        if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {\n            return 0;\n        }\n        return this.el.offsetWidth - this.el.clientWidth; // only works because we guarantee no borders. TODO: add to CSS with important?\n    }\n}\n/*\nTODO: somehow infer OtherArgs from masterCallback?\nTODO: infer RefType from masterCallback if provided\n*/ class RefMap {\n    constructor(masterCallback){\n        this.masterCallback = masterCallback;\n        this.currentMap = {};\n        this.depths = {};\n        this.callbackMap = {};\n        this.handleValue = (val, key)=>{\n            let { depths, currentMap } = this;\n            let removed = false;\n            let added = false;\n            if (val !== null) {\n                // for bug... ACTUALLY: can probably do away with this now that callers don't share numeric indices anymore\n                removed = key in currentMap;\n                currentMap[key] = val;\n                depths[key] = (depths[key] || 0) + 1;\n                added = true;\n            } else {\n                depths[key] -= 1;\n                if (!depths[key]) {\n                    delete currentMap[key];\n                    delete this.callbackMap[key];\n                    removed = true;\n                }\n            }\n            if (this.masterCallback) {\n                if (removed) {\n                    this.masterCallback(null, String(key));\n                }\n                if (added) {\n                    this.masterCallback(val, String(key));\n                }\n            }\n        };\n    }\n    createRef(key) {\n        let refCallback = this.callbackMap[key];\n        if (!refCallback) {\n            refCallback = this.callbackMap[key] = (val)=>{\n                this.handleValue(val, String(key));\n            };\n        }\n        return refCallback;\n    }\n    // TODO: check callers that don't care about order. should use getAll instead\n    // NOTE: this method has become less valuable now that we are encouraged to map order by some other index\n    // TODO: provide ONE array-export function, buildArray, which fails on non-numeric indexes. caller can manipulate and \"collect\"\n    collect(startIndex, endIndex, step) {\n        return collectFromHash(this.currentMap, startIndex, endIndex, step);\n    }\n    getAll() {\n        return hashValuesToArray(this.currentMap);\n    }\n}\nfunction computeShrinkWidth(chunkEls) {\n    let shrinkCells = findElements(chunkEls, \".fc-scrollgrid-shrink\");\n    let largestWidth = 0;\n    for (let shrinkCell of shrinkCells){\n        largestWidth = Math.max(largestWidth, computeSmallestCellWidth(shrinkCell));\n    }\n    return Math.ceil(largestWidth); // <table> elements work best with integers. round up to ensure contents fits\n}\nfunction getSectionHasLiquidHeight(props, sectionConfig) {\n    return props.liquid && sectionConfig.liquid; // does the section do liquid-height? (need to have whole scrollgrid liquid-height as well)\n}\nfunction getAllowYScrolling(props, sectionConfig) {\n    return sectionConfig.maxHeight != null || // if its possible for the height to max out, we might need scrollbars\n    getSectionHasLiquidHeight(props, sectionConfig); // if the section is liquid height, it might condense enough to require scrollbars\n}\n// TODO: ONLY use `arg`. force out internal function to use same API\nfunction renderChunkContent(sectionConfig, chunkConfig, arg, isHeader) {\n    let { expandRows } = arg;\n    let content = typeof chunkConfig.content === \"function\" ? chunkConfig.content(arg) : (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"table\", {\n        role: \"presentation\",\n        className: [\n            chunkConfig.tableClassName,\n            sectionConfig.syncRowHeights ? \"fc-scrollgrid-sync-table\" : \"\"\n        ].join(\" \"),\n        style: {\n            minWidth: arg.tableMinWidth,\n            width: arg.clientWidth,\n            height: expandRows ? arg.clientHeight : \"\"\n        }\n    }, arg.tableColGroupNode, (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(isHeader ? \"thead\" : \"tbody\", {\n        role: \"presentation\"\n    }, typeof chunkConfig.rowContent === \"function\" ? chunkConfig.rowContent(arg) : chunkConfig.rowContent));\n    return content;\n}\nfunction isColPropsEqual(cols0, cols1) {\n    return isArraysEqual(cols0, cols1, isPropsEqual);\n}\nfunction renderMicroColGroup(cols, shrinkWidth) {\n    let colNodes = [];\n    /*\n    for ColProps with spans, it would have been great to make a single <col span=\"\">\n    HOWEVER, Chrome was getting messing up distributing the width to <td>/<th> elements with colspans.\n    SOLUTION: making individual <col> elements makes Chrome behave.\n    */ for (let colProps of cols){\n        let span = colProps.span || 1;\n        for(let i = 0; i < span; i += 1){\n            colNodes.push((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"col\", {\n                style: {\n                    width: colProps.width === \"shrink\" ? sanitizeShrinkWidth(shrinkWidth) : colProps.width || \"\",\n                    minWidth: colProps.minWidth || \"\"\n                }\n            }));\n        }\n    }\n    return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"colgroup\", {}, ...colNodes);\n}\nfunction sanitizeShrinkWidth(shrinkWidth) {\n    /* why 4? if we do 0, it will kill any border, which are needed for computeSmallestCellWidth\n    4 accounts for 2 2-pixel borders. TODO: better solution? */ return shrinkWidth == null ? 4 : shrinkWidth;\n}\nfunction hasShrinkWidth(cols) {\n    for (let col of cols){\n        if (col.width === \"shrink\") {\n            return true;\n        }\n    }\n    return false;\n}\nfunction getScrollGridClassNames(liquid, context) {\n    let classNames = [\n        \"fc-scrollgrid\",\n        context.theme.getClass(\"table\")\n    ];\n    if (liquid) {\n        classNames.push(\"fc-scrollgrid-liquid\");\n    }\n    return classNames;\n}\nfunction getSectionClassNames(sectionConfig, wholeTableVGrow) {\n    let classNames = [\n        \"fc-scrollgrid-section\",\n        `fc-scrollgrid-section-${sectionConfig.type}`,\n        sectionConfig.className\n    ];\n    if (wholeTableVGrow && sectionConfig.liquid && sectionConfig.maxHeight == null) {\n        classNames.push(\"fc-scrollgrid-section-liquid\");\n    }\n    if (sectionConfig.isSticky) {\n        classNames.push(\"fc-scrollgrid-section-sticky\");\n    }\n    return classNames;\n}\nfunction renderScrollShim(arg) {\n    return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-scrollgrid-sticky-shim\",\n        style: {\n            width: arg.clientWidth,\n            minWidth: arg.tableMinWidth\n        }\n    });\n}\nfunction getStickyHeaderDates(options) {\n    let { stickyHeaderDates } = options;\n    if (stickyHeaderDates == null || stickyHeaderDates === \"auto\") {\n        stickyHeaderDates = options.height === \"auto\" || options.viewHeight === \"auto\";\n    }\n    return stickyHeaderDates;\n}\nfunction getStickyFooterScrollbar(options) {\n    let { stickyFooterScrollbar } = options;\n    if (stickyFooterScrollbar == null || stickyFooterScrollbar === \"auto\") {\n        stickyFooterScrollbar = options.height === \"auto\" || options.viewHeight === \"auto\";\n    }\n    return stickyFooterScrollbar;\n}\nclass SimpleScrollGrid extends BaseComponent {\n    constructor(){\n        super(...arguments);\n        this.processCols = memoize((a)=>a, isColPropsEqual); // so we get same `cols` props every time\n        // yucky to memoize VNodes, but much more efficient for consumers\n        this.renderMicroColGroup = memoize(renderMicroColGroup);\n        this.scrollerRefs = new RefMap();\n        this.scrollerElRefs = new RefMap(this._handleScrollerEl.bind(this));\n        this.state = {\n            shrinkWidth: null,\n            forceYScrollbars: false,\n            scrollerClientWidths: {},\n            scrollerClientHeights: {}\n        };\n        // TODO: can do a really simple print-view. dont need to join rows\n        this.handleSizing = ()=>{\n            this.safeSetState(Object.assign({\n                shrinkWidth: this.computeShrinkWidth()\n            }, this.computeScrollerDims()));\n        };\n    }\n    render() {\n        let { props, state, context } = this;\n        let sectionConfigs = props.sections || [];\n        let cols = this.processCols(props.cols);\n        let microColGroupNode = this.renderMicroColGroup(cols, state.shrinkWidth);\n        let classNames = getScrollGridClassNames(props.liquid, context);\n        if (props.collapsibleWidth) {\n            classNames.push(\"fc-scrollgrid-collapsible\");\n        }\n        // TODO: make DRY\n        let configCnt = sectionConfigs.length;\n        let configI = 0;\n        let currentConfig;\n        let headSectionNodes = [];\n        let bodySectionNodes = [];\n        let footSectionNodes = [];\n        while(configI < configCnt && (currentConfig = sectionConfigs[configI]).type === \"header\"){\n            headSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));\n            configI += 1;\n        }\n        while(configI < configCnt && (currentConfig = sectionConfigs[configI]).type === \"body\"){\n            bodySectionNodes.push(this.renderSection(currentConfig, microColGroupNode, false));\n            configI += 1;\n        }\n        while(configI < configCnt && (currentConfig = sectionConfigs[configI]).type === \"footer\"){\n            footSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));\n            configI += 1;\n        }\n        // firefox bug: when setting height on table and there is a thead or tfoot,\n        // the necessary height:100% on the liquid-height body section forces the *whole* table to be taller. (bug #5524)\n        // use getCanVGrowWithinCell as a way to detect table-stupid firefox.\n        // if so, use a simpler dom structure, jam everything into a lone tbody.\n        let isBuggy = !getCanVGrowWithinCell();\n        const roleAttrs = {\n            role: \"rowgroup\"\n        };\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"table\", {\n            role: \"grid\",\n            className: classNames.join(\" \"),\n            style: {\n                height: props.height\n            }\n        }, Boolean(!isBuggy && headSectionNodes.length) && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"thead\", roleAttrs, ...headSectionNodes), Boolean(!isBuggy && bodySectionNodes.length) && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"tbody\", roleAttrs, ...bodySectionNodes), Boolean(!isBuggy && footSectionNodes.length) && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"tfoot\", roleAttrs, ...footSectionNodes), isBuggy && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"tbody\", roleAttrs, ...headSectionNodes, ...bodySectionNodes, ...footSectionNodes));\n    }\n    renderSection(sectionConfig, microColGroupNode, isHeader) {\n        if (\"outerContent\" in sectionConfig) {\n            return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                key: sectionConfig.key\n            }, sectionConfig.outerContent);\n        }\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"tr\", {\n            key: sectionConfig.key,\n            role: \"presentation\",\n            className: getSectionClassNames(sectionConfig, this.props.liquid).join(\" \")\n        }, this.renderChunkTd(sectionConfig, microColGroupNode, sectionConfig.chunk, isHeader));\n    }\n    renderChunkTd(sectionConfig, microColGroupNode, chunkConfig, isHeader) {\n        if (\"outerContent\" in chunkConfig) {\n            return chunkConfig.outerContent;\n        }\n        let { props } = this;\n        let { forceYScrollbars, scrollerClientWidths, scrollerClientHeights } = this.state;\n        let needsYScrolling = getAllowYScrolling(props, sectionConfig); // TODO: do lazily. do in section config?\n        let isLiquid = getSectionHasLiquidHeight(props, sectionConfig);\n        // for `!props.liquid` - is WHOLE scrollgrid natural height?\n        // TODO: do same thing in advanced scrollgrid? prolly not b/c always has horizontal scrollbars\n        let overflowY = !props.liquid ? \"visible\" : forceYScrollbars ? \"scroll\" : !needsYScrolling ? \"hidden\" : \"auto\";\n        let sectionKey = sectionConfig.key;\n        let content = renderChunkContent(sectionConfig, chunkConfig, {\n            tableColGroupNode: microColGroupNode,\n            tableMinWidth: \"\",\n            clientWidth: !props.collapsibleWidth && scrollerClientWidths[sectionKey] !== undefined ? scrollerClientWidths[sectionKey] : null,\n            clientHeight: scrollerClientHeights[sectionKey] !== undefined ? scrollerClientHeights[sectionKey] : null,\n            expandRows: sectionConfig.expandRows,\n            syncRowHeights: false,\n            rowSyncHeights: [],\n            reportRowHeightChange: ()=>{}\n        }, isHeader);\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(isHeader ? \"th\" : \"td\", {\n            ref: chunkConfig.elRef,\n            role: \"presentation\"\n        }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n            className: `fc-scroller-harness${isLiquid ? \" fc-scroller-harness-liquid\" : \"\"}`\n        }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(Scroller, {\n            ref: this.scrollerRefs.createRef(sectionKey),\n            elRef: this.scrollerElRefs.createRef(sectionKey),\n            overflowY: overflowY,\n            overflowX: !props.liquid ? \"visible\" : \"hidden\" /* natural height? */ ,\n            maxHeight: sectionConfig.maxHeight,\n            liquid: isLiquid,\n            liquidIsAbsolute: true\n        }, content)));\n    }\n    _handleScrollerEl(scrollerEl, key) {\n        let section = getSectionByKey(this.props.sections, key);\n        if (section) {\n            setRef(section.chunk.scrollerElRef, scrollerEl);\n        }\n    }\n    componentDidMount() {\n        this.handleSizing();\n        this.context.addResizeHandler(this.handleSizing);\n    }\n    componentDidUpdate() {\n        // TODO: need better solution when state contains non-sizing things\n        this.handleSizing();\n    }\n    componentWillUnmount() {\n        this.context.removeResizeHandler(this.handleSizing);\n    }\n    computeShrinkWidth() {\n        return hasShrinkWidth(this.props.cols) ? computeShrinkWidth(this.scrollerElRefs.getAll()) : 0;\n    }\n    computeScrollerDims() {\n        let scrollbarWidth = getScrollbarWidths();\n        let { scrollerRefs, scrollerElRefs } = this;\n        let forceYScrollbars = false;\n        let scrollerClientWidths = {};\n        let scrollerClientHeights = {};\n        for(let sectionKey in scrollerRefs.currentMap){\n            let scroller = scrollerRefs.currentMap[sectionKey];\n            if (scroller && scroller.needsYScrolling()) {\n                forceYScrollbars = true;\n                break;\n            }\n        }\n        for (let section of this.props.sections){\n            let sectionKey = section.key;\n            let scrollerEl = scrollerElRefs.currentMap[sectionKey];\n            if (scrollerEl) {\n                let harnessEl = scrollerEl.parentNode; // TODO: weird way to get this. need harness b/c doesn't include table borders\n                scrollerClientWidths[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().width - (forceYScrollbars ? scrollbarWidth.y // use global because scroller might not have scrollbars yet but will need them in future\n                 : 0));\n                scrollerClientHeights[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().height);\n            }\n        }\n        return {\n            forceYScrollbars,\n            scrollerClientWidths,\n            scrollerClientHeights\n        };\n    }\n}\nSimpleScrollGrid.addStateEquality({\n    scrollerClientWidths: isPropsEqual,\n    scrollerClientHeights: isPropsEqual\n});\nfunction getSectionByKey(sections, key) {\n    for (let section of sections){\n        if (section.key === key) {\n            return section;\n        }\n    }\n    return null;\n}\nclass EventContainer extends BaseComponent {\n    constructor(){\n        super(...arguments);\n        this.handleEl = (el)=>{\n            this.el = el;\n            if (el) {\n                setElSeg(el, this.props.seg);\n            }\n        };\n    }\n    render() {\n        const { props, context } = this;\n        const { options } = context;\n        const { seg } = props;\n        const { eventRange } = seg;\n        const { ui } = eventRange;\n        const renderProps = {\n            event: new EventImpl(context, eventRange.def, eventRange.instance),\n            view: context.viewApi,\n            timeText: props.timeText,\n            textColor: ui.textColor,\n            backgroundColor: ui.backgroundColor,\n            borderColor: ui.borderColor,\n            isDraggable: !props.disableDragging && computeSegDraggable(seg, context),\n            isStartResizable: !props.disableResizing && computeSegStartResizable(seg, context),\n            isEndResizable: !props.disableResizing && computeSegEndResizable(seg),\n            isMirror: Boolean(props.isDragging || props.isResizing || props.isDateSelecting),\n            isStart: Boolean(seg.isStart),\n            isEnd: Boolean(seg.isEnd),\n            isPast: Boolean(props.isPast),\n            isFuture: Boolean(props.isFuture),\n            isToday: Boolean(props.isToday),\n            isSelected: Boolean(props.isSelected),\n            isDragging: Boolean(props.isDragging),\n            isResizing: Boolean(props.isResizing)\n        };\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentContainer, Object.assign({}, props /* contains children */ , {\n            elRef: this.handleEl,\n            elClasses: [\n                ...getEventClassNames(renderProps),\n                ...seg.eventRange.ui.classNames,\n                ...props.elClasses || []\n            ],\n            renderProps: renderProps,\n            generatorName: \"eventContent\",\n            customGenerator: options.eventContent,\n            defaultGenerator: props.defaultGenerator,\n            classNameGenerator: options.eventClassNames,\n            didMount: options.eventDidMount,\n            willUnmount: options.eventWillUnmount\n        }));\n    }\n    componentDidUpdate(prevProps) {\n        if (this.el && this.props.seg !== prevProps.seg) {\n            setElSeg(this.el, this.props.seg);\n        }\n    }\n}\n// should not be a purecomponent\nclass StandardEvent extends BaseComponent {\n    render() {\n        let { props, context } = this;\n        let { options } = context;\n        let { seg } = props;\n        let { ui } = seg.eventRange;\n        let timeFormat = options.eventTimeFormat || props.defaultTimeFormat;\n        let timeText = buildSegTimeText(seg, timeFormat, context, props.defaultDisplayEventTime, props.defaultDisplayEventEnd);\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(EventContainer, Object.assign({}, props /* includes elRef */ , {\n            elTag: \"a\",\n            elStyle: {\n                borderColor: ui.borderColor,\n                backgroundColor: ui.backgroundColor\n            },\n            elAttrs: getSegAnchorAttrs(seg, context),\n            defaultGenerator: renderInnerContent$1,\n            timeText: timeText\n        }), (InnerContent, eventContentArg)=>(0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(InnerContent, {\n                elTag: \"div\",\n                elClasses: [\n                    \"fc-event-main\"\n                ],\n                elStyle: {\n                    color: eventContentArg.textColor\n                }\n            }), Boolean(eventContentArg.isStartResizable) && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n                className: \"fc-event-resizer fc-event-resizer-start\"\n            }), Boolean(eventContentArg.isEndResizable) && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n                className: \"fc-event-resizer fc-event-resizer-end\"\n            })));\n    }\n}\nfunction renderInnerContent$1(innerProps) {\n    return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-event-main-frame\"\n    }, innerProps.timeText && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-event-time\"\n    }, innerProps.timeText), (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-event-title-container\"\n    }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-event-title fc-sticky\"\n    }, innerProps.event.title || (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, \"\\xa0\"))));\n}\nconst NowIndicatorContainer = (props)=>(0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ViewContextType.Consumer, null, (context)=>{\n        let { options } = context;\n        let renderProps = {\n            isAxis: props.isAxis,\n            date: context.dateEnv.toDate(props.date),\n            view: context.viewApi\n        };\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentContainer, Object.assign({}, props /* includes children */ , {\n            elTag: props.elTag || \"div\",\n            renderProps: renderProps,\n            generatorName: \"nowIndicatorContent\",\n            customGenerator: options.nowIndicatorContent,\n            classNameGenerator: options.nowIndicatorClassNames,\n            didMount: options.nowIndicatorDidMount,\n            willUnmount: options.nowIndicatorWillUnmount\n        }));\n    });\nconst DAY_NUM_FORMAT = createFormatter({\n    day: \"numeric\"\n});\nclass DayCellContainer extends BaseComponent {\n    constructor(){\n        super(...arguments);\n        this.refineRenderProps = memoizeObjArg(refineRenderProps);\n    }\n    render() {\n        let { props, context } = this;\n        let { options } = context;\n        let renderProps = this.refineRenderProps({\n            date: props.date,\n            dateProfile: props.dateProfile,\n            todayRange: props.todayRange,\n            isMonthStart: props.isMonthStart || false,\n            showDayNumber: props.showDayNumber,\n            extraRenderProps: props.extraRenderProps,\n            viewApi: context.viewApi,\n            dateEnv: context.dateEnv,\n            monthStartFormat: options.monthStartFormat\n        });\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentContainer, Object.assign({}, props /* includes children */ , {\n            elClasses: [\n                ...getDayClassNames(renderProps, context.theme),\n                ...props.elClasses || []\n            ],\n            elAttrs: Object.assign(Object.assign({}, props.elAttrs), renderProps.isDisabled ? {} : {\n                \"data-date\": formatDayString(props.date)\n            }),\n            renderProps: renderProps,\n            generatorName: \"dayCellContent\",\n            customGenerator: options.dayCellContent,\n            defaultGenerator: props.defaultGenerator,\n            classNameGenerator: // don't use custom classNames if disabled\n            renderProps.isDisabled ? undefined : options.dayCellClassNames,\n            didMount: options.dayCellDidMount,\n            willUnmount: options.dayCellWillUnmount\n        }));\n    }\n}\nfunction hasCustomDayCellContent(options) {\n    return Boolean(options.dayCellContent || hasCustomRenderingHandler(\"dayCellContent\", options));\n}\nfunction refineRenderProps(raw) {\n    let { date, dateEnv, dateProfile, isMonthStart } = raw;\n    let dayMeta = getDateMeta(date, raw.todayRange, null, dateProfile);\n    let dayNumberText = raw.showDayNumber ? dateEnv.format(date, isMonthStart ? raw.monthStartFormat : DAY_NUM_FORMAT) : \"\";\n    return Object.assign(Object.assign(Object.assign({\n        date: dateEnv.toDate(date),\n        view: raw.viewApi\n    }, dayMeta), {\n        isMonthStart,\n        dayNumberText\n    }), raw.extraRenderProps);\n}\nclass BgEvent extends BaseComponent {\n    render() {\n        let { props } = this;\n        let { seg } = props;\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(EventContainer, {\n            elTag: \"div\",\n            elClasses: [\n                \"fc-bg-event\"\n            ],\n            elStyle: {\n                backgroundColor: seg.eventRange.ui.backgroundColor\n            },\n            defaultGenerator: renderInnerContent,\n            seg: seg,\n            timeText: \"\",\n            isDragging: false,\n            isResizing: false,\n            isDateSelecting: false,\n            isSelected: false,\n            isPast: props.isPast,\n            isFuture: props.isFuture,\n            isToday: props.isToday,\n            disableDragging: true,\n            disableResizing: true\n        });\n    }\n}\nfunction renderInnerContent(props) {\n    let { title } = props.event;\n    return title && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-event-title\"\n    }, props.event.title);\n}\nfunction renderFill(fillType) {\n    return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: `fc-${fillType}`\n    });\n}\nconst WeekNumberContainer = (props)=>(0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ViewContextType.Consumer, null, (context)=>{\n        let { dateEnv, options } = context;\n        let { date } = props;\n        let format = options.weekNumberFormat || props.defaultFormat;\n        let num = dateEnv.computeWeekNumber(date); // TODO: somehow use for formatting as well?\n        let text = dateEnv.format(date, format);\n        let renderProps = {\n            num,\n            text,\n            date\n        };\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentContainer // why isn't WeekNumberContentArg being auto-detected?\n        , Object.assign({}, props /* includes children */ , {\n            renderProps: renderProps,\n            generatorName: \"weekNumberContent\",\n            customGenerator: options.weekNumberContent,\n            defaultGenerator: renderInner,\n            classNameGenerator: options.weekNumberClassNames,\n            didMount: options.weekNumberDidMount,\n            willUnmount: options.weekNumberWillUnmount\n        }));\n    });\nfunction renderInner(innerProps) {\n    return innerProps.text;\n}\nconst PADDING_FROM_VIEWPORT = 10;\nclass Popover extends BaseComponent {\n    constructor(){\n        super(...arguments);\n        this.state = {\n            titleId: getUniqueDomId()\n        };\n        this.handleRootEl = (el)=>{\n            this.rootEl = el;\n            if (this.props.elRef) {\n                setRef(this.props.elRef, el);\n            }\n        };\n        // Triggered when the user clicks *anywhere* in the document, for the autoHide feature\n        this.handleDocumentMouseDown = (ev)=>{\n            // only hide the popover if the click happened outside the popover\n            const target = getEventTargetViaRoot(ev);\n            if (!this.rootEl.contains(target)) {\n                this.handleCloseClick();\n            }\n        };\n        this.handleDocumentKeyDown = (ev)=>{\n            if (ev.key === \"Escape\") {\n                this.handleCloseClick();\n            }\n        };\n        this.handleCloseClick = ()=>{\n            let { onClose } = this.props;\n            if (onClose) {\n                onClose();\n            }\n        };\n    }\n    render() {\n        let { theme, options } = this.context;\n        let { props, state } = this;\n        let classNames = [\n            \"fc-popover\",\n            theme.getClass(\"popover\")\n        ].concat(props.extraClassNames || []);\n        return (0,preact_compat__WEBPACK_IMPORTED_MODULE_1__.createPortal)((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", Object.assign({}, props.extraAttrs, {\n            id: props.id,\n            className: classNames.join(\" \"),\n            \"aria-labelledby\": state.titleId,\n            ref: this.handleRootEl\n        }), (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n            className: \"fc-popover-header \" + theme.getClass(\"popoverHeader\")\n        }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"span\", {\n            className: \"fc-popover-title\",\n            id: state.titleId\n        }, props.title), (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"span\", {\n            className: \"fc-popover-close \" + theme.getIconClass(\"close\"),\n            title: options.closeHint,\n            onClick: this.handleCloseClick\n        })), (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n            className: \"fc-popover-body \" + theme.getClass(\"popoverContent\")\n        }, props.children)), props.parentEl);\n    }\n    componentDidMount() {\n        document.addEventListener(\"mousedown\", this.handleDocumentMouseDown);\n        document.addEventListener(\"keydown\", this.handleDocumentKeyDown);\n        this.updateSize();\n    }\n    componentWillUnmount() {\n        document.removeEventListener(\"mousedown\", this.handleDocumentMouseDown);\n        document.removeEventListener(\"keydown\", this.handleDocumentKeyDown);\n    }\n    updateSize() {\n        let { isRtl } = this.context;\n        let { alignmentEl, alignGridTop } = this.props;\n        let { rootEl } = this;\n        let alignmentRect = computeClippedClientRect(alignmentEl);\n        if (alignmentRect) {\n            let popoverDims = rootEl.getBoundingClientRect();\n            // position relative to viewport\n            let popoverTop = alignGridTop ? elementClosest(alignmentEl, \".fc-scrollgrid\").getBoundingClientRect().top : alignmentRect.top;\n            let popoverLeft = isRtl ? alignmentRect.right - popoverDims.width : alignmentRect.left;\n            // constrain\n            popoverTop = Math.max(popoverTop, PADDING_FROM_VIEWPORT);\n            popoverLeft = Math.min(popoverLeft, document.documentElement.clientWidth - PADDING_FROM_VIEWPORT - popoverDims.width);\n            popoverLeft = Math.max(popoverLeft, PADDING_FROM_VIEWPORT);\n            let origin = rootEl.offsetParent.getBoundingClientRect();\n            applyStyle(rootEl, {\n                top: popoverTop - origin.top,\n                left: popoverLeft - origin.left\n            });\n        }\n    }\n}\nclass MorePopover extends DateComponent {\n    constructor(){\n        super(...arguments);\n        this.handleRootEl = (rootEl)=>{\n            this.rootEl = rootEl;\n            if (rootEl) {\n                this.context.registerInteractiveComponent(this, {\n                    el: rootEl,\n                    useEventCenter: false\n                });\n            } else {\n                this.context.unregisterInteractiveComponent(this);\n            }\n        };\n    }\n    render() {\n        let { options, dateEnv } = this.context;\n        let { props } = this;\n        let { startDate, todayRange, dateProfile } = props;\n        let title = dateEnv.format(startDate, options.dayPopoverFormat);\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(DayCellContainer, {\n            elRef: this.handleRootEl,\n            date: startDate,\n            dateProfile: dateProfile,\n            todayRange: todayRange\n        }, (InnerContent, renderProps, elAttrs)=>(0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(Popover, {\n                elRef: elAttrs.ref,\n                id: props.id,\n                title: title,\n                extraClassNames: [\n                    \"fc-more-popover\"\n                ].concat(elAttrs.className || []),\n                extraAttrs: elAttrs /* TODO: make these time-based when not whole-day? */ ,\n                parentEl: props.parentEl,\n                alignmentEl: props.alignmentEl,\n                alignGridTop: props.alignGridTop,\n                onClose: props.onClose\n            }, hasCustomDayCellContent(options) && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(InnerContent, {\n                elTag: \"div\",\n                elClasses: [\n                    \"fc-more-popover-misc\"\n                ]\n            }), props.children));\n    }\n    queryHit(positionLeft, positionTop, elWidth, elHeight) {\n        let { rootEl, props } = this;\n        if (positionLeft >= 0 && positionLeft < elWidth && positionTop >= 0 && positionTop < elHeight) {\n            return {\n                dateProfile: props.dateProfile,\n                dateSpan: Object.assign({\n                    allDay: !props.forceTimed,\n                    range: {\n                        start: props.startDate,\n                        end: props.endDate\n                    }\n                }, props.extraDateSpan),\n                dayEl: rootEl,\n                rect: {\n                    left: 0,\n                    top: 0,\n                    right: elWidth,\n                    bottom: elHeight\n                },\n                layer: 1\n            };\n        }\n        return null;\n    }\n}\nclass MoreLinkContainer extends BaseComponent {\n    constructor(){\n        super(...arguments);\n        this.state = {\n            isPopoverOpen: false,\n            popoverId: getUniqueDomId()\n        };\n        this.handleLinkEl = (linkEl)=>{\n            this.linkEl = linkEl;\n            if (this.props.elRef) {\n                setRef(this.props.elRef, linkEl);\n            }\n        };\n        this.handleClick = (ev)=>{\n            let { props, context } = this;\n            let { moreLinkClick } = context.options;\n            let date = computeRange(props).start;\n            function buildPublicSeg(seg) {\n                let { def, instance, range } = seg.eventRange;\n                return {\n                    event: new EventImpl(context, def, instance),\n                    start: context.dateEnv.toDate(range.start),\n                    end: context.dateEnv.toDate(range.end),\n                    isStart: seg.isStart,\n                    isEnd: seg.isEnd\n                };\n            }\n            if (typeof moreLinkClick === \"function\") {\n                moreLinkClick = moreLinkClick({\n                    date,\n                    allDay: Boolean(props.allDayDate),\n                    allSegs: props.allSegs.map(buildPublicSeg),\n                    hiddenSegs: props.hiddenSegs.map(buildPublicSeg),\n                    jsEvent: ev,\n                    view: context.viewApi\n                });\n            }\n            if (!moreLinkClick || moreLinkClick === \"popover\") {\n                this.setState({\n                    isPopoverOpen: true\n                });\n            } else if (typeof moreLinkClick === \"string\") {\n                context.calendarApi.zoomTo(date, moreLinkClick);\n            }\n        };\n        this.handlePopoverClose = ()=>{\n            this.setState({\n                isPopoverOpen: false\n            });\n        };\n    }\n    render() {\n        let { props, state } = this;\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ViewContextType.Consumer, null, (context)=>{\n            let { viewApi, options, calendarApi } = context;\n            let { moreLinkText } = options;\n            let { moreCnt } = props;\n            let range = computeRange(props);\n            let text = typeof moreLinkText === \"function\" // TODO: eventually use formatWithOrdinals\n             ? moreLinkText.call(calendarApi, moreCnt) : `+${moreCnt} ${moreLinkText}`;\n            let hint = formatWithOrdinals(options.moreLinkHint, [\n                moreCnt\n            ], text);\n            let renderProps = {\n                num: moreCnt,\n                shortText: `+${moreCnt}`,\n                text,\n                view: viewApi\n            };\n            return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, Boolean(props.moreCnt) && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentContainer, {\n                elTag: props.elTag || \"a\",\n                elRef: this.handleLinkEl,\n                elClasses: [\n                    ...props.elClasses || [],\n                    \"fc-more-link\"\n                ],\n                elStyle: props.elStyle,\n                elAttrs: Object.assign(Object.assign(Object.assign({}, props.elAttrs), createAriaClickAttrs(this.handleClick)), {\n                    title: hint,\n                    \"aria-expanded\": state.isPopoverOpen,\n                    \"aria-controls\": state.isPopoverOpen ? state.popoverId : \"\"\n                }),\n                renderProps: renderProps,\n                generatorName: \"moreLinkContent\",\n                customGenerator: options.moreLinkContent,\n                defaultGenerator: props.defaultGenerator || renderMoreLinkInner,\n                classNameGenerator: options.moreLinkClassNames,\n                didMount: options.moreLinkDidMount,\n                willUnmount: options.moreLinkWillUnmount\n            }, props.children), state.isPopoverOpen && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(MorePopover, {\n                id: state.popoverId,\n                startDate: range.start,\n                endDate: range.end,\n                dateProfile: props.dateProfile,\n                todayRange: props.todayRange,\n                extraDateSpan: props.extraDateSpan,\n                parentEl: this.parentEl,\n                alignmentEl: props.alignmentElRef ? props.alignmentElRef.current : this.linkEl,\n                alignGridTop: props.alignGridTop,\n                forceTimed: props.forceTimed,\n                onClose: this.handlePopoverClose\n            }, props.popoverContent()));\n        });\n    }\n    componentDidMount() {\n        this.updateParentEl();\n    }\n    componentDidUpdate() {\n        this.updateParentEl();\n    }\n    updateParentEl() {\n        if (this.linkEl) {\n            this.parentEl = elementClosest(this.linkEl, \".fc-view-harness\");\n        }\n    }\n}\nfunction renderMoreLinkInner(props) {\n    return props.text;\n}\nfunction computeRange(props) {\n    if (props.allDayDate) {\n        return {\n            start: props.allDayDate,\n            end: addDays(props.allDayDate, 1)\n        };\n    }\n    let { hiddenSegs } = props;\n    return {\n        start: computeEarliestSegStart(hiddenSegs),\n        end: computeLatestSegEnd(hiddenSegs)\n    };\n}\nfunction computeEarliestSegStart(segs) {\n    return segs.reduce(pickEarliestStart).eventRange.range.start;\n}\nfunction pickEarliestStart(seg0, seg1) {\n    return seg0.eventRange.range.start < seg1.eventRange.range.start ? seg0 : seg1;\n}\nfunction computeLatestSegEnd(segs) {\n    return segs.reduce(pickLatestEnd).eventRange.range.end;\n}\nfunction pickLatestEnd(seg0, seg1) {\n    return seg0.eventRange.range.end > seg1.eventRange.range.end ? seg0 : seg1;\n}\nclass Store {\n    constructor(){\n        this.handlers = [];\n    }\n    set(value) {\n        this.currentValue = value;\n        for (let handler of this.handlers){\n            handler(value);\n        }\n    }\n    subscribe(handler) {\n        this.handlers.push(handler);\n        if (this.currentValue !== undefined) {\n            handler(this.currentValue);\n        }\n    }\n}\n/*\nSubscribers will get a LIST of CustomRenderings\n*/ class CustomRenderingStore extends Store {\n    constructor(){\n        super(...arguments);\n        this.map = new Map();\n    }\n    // for consistent order\n    handle(customRendering) {\n        const { map } = this;\n        let updated = false;\n        if (customRendering.isActive) {\n            map.set(customRendering.id, customRendering);\n            updated = true;\n        } else if (map.has(customRendering.id)) {\n            map.delete(customRendering.id);\n            updated = true;\n        }\n        if (updated) {\n            this.set(map);\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL2ludGVybmFsLWNvbW1vbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUM7QUFDMkM7QUFDL0I7QUFFN0MsTUFBTU0sYUFBYSxFQUFFO0FBQ3JCLE1BQU1DLFdBQVcsSUFBSUM7QUFDckIsU0FBU0MsYUFBYUMsU0FBUztJQUMzQkosV0FBV0ssSUFBSSxDQUFDRDtJQUNoQkgsU0FBU0ssT0FBTyxDQUFDLENBQUNDO1FBQ2RDLGVBQWVELFNBQVNIO0lBQzVCO0FBQ0o7QUFDQSxTQUFTSyxrQkFBa0JDLEVBQUU7SUFDekIsSUFBSUEsR0FBR0MsV0FBVyxJQUFJLDZDQUE2QztJQUMvREQsR0FBR0UsV0FBVyxDQUFDLGtEQUFrRDtNQUNuRTtRQUNFQyxtQkFBbUJILEdBQUdFLFdBQVc7SUFDckM7QUFDSjtBQUNBLFNBQVNDLG1CQUFtQkMsUUFBUTtJQUNoQyxJQUFJUCxVQUFVTixTQUFTYyxHQUFHLENBQUNEO0lBQzNCLElBQUksQ0FBQ1AsV0FBVyxDQUFDQSxRQUFRSSxXQUFXLEVBQUU7UUFDbENKLFVBQVVPLFNBQVNFLGFBQWEsQ0FBQztRQUNqQyxJQUFJLENBQUNULFNBQVM7WUFDVkEsVUFBVVUsU0FBU3JCLGFBQWEsQ0FBQztZQUNqQ1csUUFBUVcsWUFBWSxDQUFDLHFCQUFxQjtZQUMxQyxNQUFNQyxRQUFRQztZQUNkLElBQUlELE9BQU87Z0JBQ1BaLFFBQVFZLEtBQUssR0FBR0E7WUFDcEI7WUFDQSxNQUFN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QUN2Qis3RCxPQUFPQyxlQUFlLEVBQUU7UUFDcEIsTUFBTSxFQUFFejhCLEdBQUcsRUFBRSxHQUFHLElBQUk7UUFDcEIsSUFBSTA4QixVQUFVO1FBQ2QsSUFBSUQsZ0JBQWdCOWtDLFFBQVEsRUFBRTtZQUMxQnFJLElBQUloK0IsR0FBRyxDQUFDeTZELGdCQUFnQnptQyxFQUFFLEVBQUV5bUM7WUFDNUJDLFVBQVU7UUFDZCxPQUNLLElBQUkxOEIsSUFBSTI4QixHQUFHLENBQUNGLGdCQUFnQnptQyxFQUFFLEdBQUc7WUFDbENnSyxJQUFJNDhCLE1BQU0sQ0FBQ0gsZ0JBQWdCem1DLEVBQUU7WUFDN0IwbUMsVUFBVTtRQUNkO1FBQ0EsSUFBSUEsU0FBUztZQUNULElBQUksQ0FBQzE2RCxHQUFHLENBQUNnK0I7UUFDYjtJQUNKO0FBQ0o7QUFFZ3pKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVoYXNwb3J0LW1hbmFnZW1lbnQvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL2ludGVybmFsLWNvbW1vbi5qcz81NTlmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHByZWFjdCBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50LCBpc1ZhbGlkRWxlbWVudCwgRnJhZ21lbnQgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsIH0gZnJvbSAncHJlYWN0L2NvbXBhdCc7XG5cbmNvbnN0IHN0eWxlVGV4dHMgPSBbXTtcbmNvbnN0IHN0eWxlRWxzID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gaW5qZWN0U3R5bGVzKHN0eWxlVGV4dCkge1xuICAgIHN0eWxlVGV4dHMucHVzaChzdHlsZVRleHQpO1xuICAgIHN0eWxlRWxzLmZvckVhY2goKHN0eWxlRWwpID0+IHtcbiAgICAgICAgYXBwZW5kU3R5bGVzVG8oc3R5bGVFbCwgc3R5bGVUZXh0KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUVsSGFzU3R5bGVzKGVsKSB7XG4gICAgaWYgKGVsLmlzQ29ubmVjdGVkICYmIC8vIHNvbWV0aW1lcyB0cnVlIGlmIFNTUiBzeXN0ZW0gc2ltdWxhdGVzIERPTVxuICAgICAgICBlbC5nZXRSb290Tm9kZSAvLyBzb21ldGltZXMgdW5kZWZpbmVkIGlmIFNTUiBzeXN0ZW0gc2ltdWxhdGVzIERPTVxuICAgICkge1xuICAgICAgICByZWdpc3RlclN0eWxlc1Jvb3QoZWwuZ2V0Um9vdE5vZGUoKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVnaXN0ZXJTdHlsZXNSb290KHJvb3ROb2RlKSB7XG4gICAgbGV0IHN0eWxlRWwgPSBzdHlsZUVscy5nZXQocm9vdE5vZGUpO1xuICAgIGlmICghc3R5bGVFbCB8fCAhc3R5bGVFbC5pc0Nvbm5lY3RlZCkge1xuICAgICAgICBzdHlsZUVsID0gcm9vdE5vZGUucXVlcnlTZWxlY3Rvcignc3R5bGVbZGF0YS1mdWxsY2FsZW5kYXJdJyk7XG4gICAgICAgIGlmICghc3R5bGVFbCkge1xuICAgICAgICAgICAgc3R5bGVFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgICAgICBzdHlsZUVsLnNldEF0dHJpYnV0ZSgnZGF0YS1mdWxsY2FsZW5kYXInLCAnJyk7XG4gICAgICAgICAgICBjb25zdCBub25jZSA9IGdldE5vbmNlVmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChub25jZSkge1xuICAgICAgICAgICAgICAgIHN0eWxlRWwubm9uY2UgPSBub25jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEVsID0gcm9vdE5vZGUgPT09IGRvY3VtZW50ID8gZG9jdW1lbnQuaGVhZCA6IHJvb3ROb2RlO1xuICAgICAgICAgICAgY29uc3QgaW5zZXJ0QmVmb3JlID0gcm9vdE5vZGUgPT09IGRvY3VtZW50XG4gICAgICAgICAgICAgICAgPyBwYXJlbnRFbC5xdWVyeVNlbGVjdG9yKCdzY3JpcHQsbGlua1tyZWw9c3R5bGVzaGVldF0sbGlua1thcz1zdHlsZV0sc3R5bGUnKVxuICAgICAgICAgICAgICAgIDogcGFyZW50RWwuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHBhcmVudEVsLmluc2VydEJlZm9yZShzdHlsZUVsLCBpbnNlcnRCZWZvcmUpO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlRWxzLnNldChyb290Tm9kZSwgc3R5bGVFbCk7XG4gICAgICAgIGh5ZHJhdGVTdHlsZXNSb290KHN0eWxlRWwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGh5ZHJhdGVTdHlsZXNSb290KHN0eWxlRWwpIHtcbiAgICBmb3IgKGNvbnN0IHN0eWxlVGV4dCBvZiBzdHlsZVRleHRzKSB7XG4gICAgICAgIGFwcGVuZFN0eWxlc1RvKHN0eWxlRWwsIHN0eWxlVGV4dCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwZW5kU3R5bGVzVG8oc3R5bGVFbCwgc3R5bGVUZXh0KSB7XG4gICAgY29uc3QgeyBzaGVldCB9ID0gc3R5bGVFbDtcbiAgICBjb25zdCBydWxlQ250ID0gc2hlZXQuY3NzUnVsZXMubGVuZ3RoO1xuICAgIHN0eWxlVGV4dC5zcGxpdCgnfScpLmZvckVhY2goKHN0eWxlU3RyLCBpKSA9PiB7XG4gICAgICAgIHN0eWxlU3RyID0gc3R5bGVTdHIudHJpbSgpO1xuICAgICAgICBpZiAoc3R5bGVTdHIpIHtcbiAgICAgICAgICAgIHNoZWV0Lmluc2VydFJ1bGUoc3R5bGVTdHIgKyAnfScsIHJ1bGVDbnQgKyBpKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLy8gbm9uY2Vcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmxldCBxdWVyaWVkTm9uY2VWYWx1ZTtcbmZ1bmN0aW9uIGdldE5vbmNlVmFsdWUoKSB7XG4gICAgaWYgKHF1ZXJpZWROb25jZVZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcXVlcmllZE5vbmNlVmFsdWUgPSBxdWVyeU5vbmNlVmFsdWUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJpZWROb25jZVZhbHVlO1xufVxuLypcblRPRE86IGRpc2NvdXJhZ2UgbWV0YSB0YWcgYW5kIGluc3RlYWQgcHV0IG5vbmNlIGF0dHJpYnV0ZSBvbiBwbGFjZWhvbGRlciA8c3R5bGU+IHRhZ1xuKi9cbmZ1bmN0aW9uIHF1ZXJ5Tm9uY2VWYWx1ZSgpIHtcbiAgICBjb25zdCBtZXRhV2l0aE5vbmNlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPVwiY3NwLW5vbmNlXCJdJyk7XG4gICAgaWYgKG1ldGFXaXRoTm9uY2UgJiYgbWV0YVdpdGhOb25jZS5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnQnKSkge1xuICAgICAgICByZXR1cm4gbWV0YVdpdGhOb25jZS5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnKTtcbiAgICB9XG4gICAgY29uc3QgZWxXaXRoTm9uY2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzY3JpcHRbbm9uY2VdJyk7XG4gICAgaWYgKGVsV2l0aE5vbmNlKSB7XG4gICAgICAgIHJldHVybiBlbFdpdGhOb25jZS5ub25jZSB8fCAnJztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuLy8gbWFpblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZWdpc3RlclN0eWxlc1Jvb3QoZG9jdW1lbnQpO1xufVxuXG52YXIgY3NzXzI0OHogPSBcIjpyb290ey0tZmMtc21hbGwtZm9udC1zaXplOi44NWVtOy0tZmMtcGFnZS1iZy1jb2xvcjojZmZmOy0tZmMtbmV1dHJhbC1iZy1jb2xvcjpoc2xhKDAsMCUsODIlLC4zKTstLWZjLW5ldXRyYWwtdGV4dC1jb2xvcjpncmV5Oy0tZmMtYm9yZGVyLWNvbG9yOiNkZGQ7LS1mYy1idXR0b24tdGV4dC1jb2xvcjojZmZmOy0tZmMtYnV0dG9uLWJnLWNvbG9yOiMyYzNlNTA7LS1mYy1idXR0b24tYm9yZGVyLWNvbG9yOiMyYzNlNTA7LS1mYy1idXR0b24taG92ZXItYmctY29sb3I6IzFlMmIzNzstLWZjLWJ1dHRvbi1ob3Zlci1ib3JkZXItY29sb3I6IzFhMjUyZjstLWZjLWJ1dHRvbi1hY3RpdmUtYmctY29sb3I6IzFhMjUyZjstLWZjLWJ1dHRvbi1hY3RpdmUtYm9yZGVyLWNvbG9yOiMxNTFlMjc7LS1mYy1ldmVudC1iZy1jb2xvcjojMzc4OGQ4Oy0tZmMtZXZlbnQtYm9yZGVyLWNvbG9yOiMzNzg4ZDg7LS1mYy1ldmVudC10ZXh0LWNvbG9yOiNmZmY7LS1mYy1ldmVudC1zZWxlY3RlZC1vdmVybGF5LWNvbG9yOnJnYmEoMCwwLDAsLjI1KTstLWZjLW1vcmUtbGluay1iZy1jb2xvcjojZDBkMGQwOy0tZmMtbW9yZS1saW5rLXRleHQtY29sb3I6aW5oZXJpdDstLWZjLWV2ZW50LXJlc2l6ZXItdGhpY2tuZXNzOjhweDstLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoOjhweDstLWZjLWV2ZW50LXJlc2l6ZXItZG90LWJvcmRlci13aWR0aDoxcHg7LS1mYy1ub24tYnVzaW5lc3MtY29sb3I6aHNsYSgwLDAlLDg0JSwuMyk7LS1mYy1iZy1ldmVudC1jb2xvcjojOGZkZjgyOy0tZmMtYmctZXZlbnQtb3BhY2l0eTowLjM7LS1mYy1oaWdobGlnaHQtY29sb3I6cmdiYSgxODgsMjMyLDI0MSwuMyk7LS1mYy10b2RheS1iZy1jb2xvcjpyZ2JhKDI1NSwyMjAsNDAsLjE1KTstLWZjLW5vdy1pbmRpY2F0b3ItY29sb3I6cmVkfS5mYy1ub3QtYWxsb3dlZCwuZmMtbm90LWFsbG93ZWQgLmZjLWV2ZW50e2N1cnNvcjpub3QtYWxsb3dlZH0uZmN7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmb250LXNpemU6MWVtfS5mYywuZmMgKiwuZmMgOmFmdGVyLC5mYyA6YmVmb3Jle2JveC1zaXppbmc6Ym9yZGVyLWJveH0uZmMgdGFibGV7Ym9yZGVyLWNvbGxhcHNlOmNvbGxhcHNlO2JvcmRlci1zcGFjaW5nOjA7Zm9udC1zaXplOjFlbX0uZmMgdGh7dGV4dC1hbGlnbjpjZW50ZXJ9LmZjIHRkLC5mYyB0aHtwYWRkaW5nOjA7dmVydGljYWwtYWxpZ246dG9wfS5mYyBhW2RhdGEtbmF2bGlua117Y3Vyc29yOnBvaW50ZXJ9LmZjIGFbZGF0YS1uYXZsaW5rXTpob3Zlcnt0ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lfS5mYy1kaXJlY3Rpb24tbHRye2RpcmVjdGlvbjpsdHI7dGV4dC1hbGlnbjpsZWZ0fS5mYy1kaXJlY3Rpb24tcnRse2RpcmVjdGlvbjpydGw7dGV4dC1hbGlnbjpyaWdodH0uZmMtdGhlbWUtc3RhbmRhcmQgdGQsLmZjLXRoZW1lLXN0YW5kYXJkIHRoe2JvcmRlcjoxcHggc29saWQgdmFyKC0tZmMtYm9yZGVyLWNvbG9yKX0uZmMtbGlxdWlkLWhhY2sgdGQsLmZjLWxpcXVpZC1oYWNrIHRoe3Bvc2l0aW9uOnJlbGF0aXZlfUBmb250LWZhY2V7Zm9udC1mYW1pbHk6ZmNpY29ucztmb250LXN0eWxlOm5vcm1hbDtmb250LXdlaWdodDo0MDA7c3JjOnVybChcXFwiZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtdHRmO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LEFBRUFBQUFMQUlBQUF3QXdUMU12TWc4U0JmQUFBQUM4QUFBQVlHTnRZWEFYVnRLTkFBQUJIQUFBQUZSbllYTndBQUFBRUFBQUFYQUFBQUFJWjJ4NVpnWXlkeElBQUFGNEFBQUZOR2hsWVdRVUo3Y0lBQUFHckFBQUFEWm9hR1ZoQjIwRHpBQUFCdVFBQUFBa2FHMTBlQ0lBQmhRQUFBY0lBQUFBTEd4dlkyRUQ0QVU2QUFBSE5BQUFBQmh0WVhod0FBOEFqQUFBQjB3QUFBQWdibUZ0WlhzcjY5MEFBQWRzQUFBQmhuQnZjM1FBQXdBQUFBQUk5QUFBQUNBQUF3UEFBWkFBQlFBQUFwa0N6QUFBQUk4Q21RTE1BQUFCNndBekFRa0FBQUFBQUFBQUFBQUFBQUFBQUFBQkVBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUFBRHBCZ1BBLzhBQVFBUEFBRUFBQUFBQkFBQUFBQUFBQUFBQUFBQWdBQUFBQUFBREFBQUFBd0FBQUJ3QUFRQURBQUFBSEFBREFBRUFBQUFjQUFRQU9BQUFBQW9BQ0FBQ0FBSUFBUUFnNlFiLy9mLy9BQUFBQUFBZzZRRC8vZi8vQUFILzR4Y0VBQU1BQVFBQUFBQUFBQUFBQUFBQUFRQUIvLzhBRHdBQkFBQUFBQUFBQUFBQUFnQUFOemtCQUFBQUFBRUFBQUFBQUFBQUFBQUNBQUEzT1FFQUFBQUFBUUFBQUFBQUFBQUFBQUlBQURjNUFRQUFBQUFCQVdJQWpRS2VBc2tBRXdBQUpTYzNOalFuSmlJSEFRWVVGd0VXTWpjMk5DY0NudUxpRFEwTUpBei9BQTBOQVFBTUpBd05EY25pNGd3akRRd00vd0FOSXd6L0FBME5EQ01OQUFBQUFRRmlBSTBDbmdMSkFCTUFBQ1VCTmpRbkFTWWlCd1lVSHdFSEJoUVhGakkzQVo0QkFBME4vd0FNSkF3TkRlTGlEUTBNSkF5TkFRQU1JdzBCQUF3TURTTU00dUlOSXd3TkRRQUFBQUlBNGdDM0F4NENuZ0FUQUNjQUFDVW5OelkwSnlZaUR3RUdGQjhCRmpJM05qUW5JU2MzTmpRbkppSVBBUVlVSHdFV01qYzJOQ2NCODdlM0RRME1JdzNWRFEzVkRTTU1EUTBCSzdlM0RRME1KQXpWRFEzVkRDUU1EUTN6dUxjTUpBd05EZFVOSXd6V0RBd05Jd3k0dHd3a0RBME4xUTBqRE5ZTURBMGpEQUFBQWdEaUFMY0RIZ0tlQUJNQUp3QUFKVGMyTkM4QkppSUhCaFFmQVFjR0ZCY1dNamNoTnpZMEx3RW1JZ2NHRkI4QkJ3WVVGeFl5TndKSjFRME4xUTBqREEwTnQ3Y05EUXdqRGY3VjFRME4xUXdrREEwTnQ3Y05EUXdrRExmV0RDTU4xUTBORENRTXQ3Z01JdzBNRE5ZTUl3M1ZEUTBNSkF5M3VBd2pEUXdNQUFBREFGVUFBQU9yQTFVQU13Qm9BSGNBQUJNaUJnY09BUWNPQVFjT0FSVVJGQllYSGdFWEhnRVhIZ0V6SVRJMk56NEJOejRCTno0Qk5SRTBKaWN1QVNjdUFTY3VBU01GSVRJV0Z4NEJGeDRCRng0QkZSRVVCZ2NPQVFjT0FRY09BU01oSWlZbkxnRW5MZ0VuTGdFMUVUUTJOejRCTno0Qk56NEJNeE1oTWpZMU5DWWpJU0lHRlJRV005VU5HQXdMRlFrSkRnVUZCUVVGQlE0SkNSVUxEQmdOQWxZTkdBd0xGUWtKRGdVRkJRVUZCUTRKQ1JVTERCZ04vYW9DVmdRSUJBUUhBd01GQVFJQkFRSUJCUU1EQndRRUNBVDlxZ1FJQkFRSEF3TUZBUUlCQVFJQkJRTURCd1FFQ0FTQUFWWVJHUmtSL3FvUkdSa1JBMVVGQkFVT0NRa1ZEQXNaRGYyckRSa0xEQlVKQ0E0RkJRVUZCUVVPQ1FnVkRBc1pEUUpWRFJrTERCVUpDUTRGQkFWVkFnRUNCUU1DQndRRUNBWDlxd1FKQXdRSEF3TUZBUUlDQWdJQkJRTURCd1FEQ1FRQ1ZRVUlCQVFIQWdNRkFnRUMvb0FaRWhFWkdSRVNHUUFBQUFBREFGVUFBQU9yQTFVQU13Qm9BSWtBQUJNaUJnY09BUWNPQVFjT0FSVVJGQllYSGdFWEhnRVhIZ0V6SVRJMk56NEJOejRCTno0Qk5SRTBKaWN1QVNjdUFTY3VBU01GSVRJV0Z4NEJGeDRCRng0QkZSRVVCZ2NPQVFjT0FRY09BU01oSWlZbkxnRW5MZ0VuTGdFMUVUUTJOejRCTno0Qk56NEJNeE16RlJRV016STJQUUV6TWpZMU5DWXJBVFUwSmlNaUJoMEJJeUlHRlJRV005VU5HQXdMRlFrSkRnVUZCUVVGQlE0SkNSVUxEQmdOQWxZTkdBd0xGUWtKRGdVRkJRVUZCUTRKQ1JVTERCZ04vYW9DVmdRSUJBUUhBd01GQVFJQkFRSUJCUU1EQndRRUNBVDlxZ1FJQkFRSEF3TUZBUUlCQVFJQkJRTURCd1FFQ0FTQWdCa1NFaG1BRVJrWkVZQVpFaElaZ0JFWkdSRURWUVVFQlE0SkNSVU1DeGtOL2FzTkdRc01GUWtJRGdVRkJRVUZCUTRKQ0JVTUN4a05BbFVOR1FzTUZRa0pEZ1VFQlZVQ0FRSUZBd0lIQkFRSUJmMnJCQWtEQkFjREF3VUJBZ0lDQWdFRkF3TUhCQU1KQkFKVkJRZ0VCQWNDQXdVQ0FRTCtnSUFTR1JrU2dCa1NFUm1BRWhrWkVvQVpFUklaQUFBQkFPSUFqUU1lQXNrQUlBQUFFeGNIQmhRWEZqSS9BUmNXTWpjMk5DOEJOelkwSnlZaUR3RW5KaUlIQmhRWDR1TGlEUTBNSkF6aTRnd2tEQTBONHVJTkRRd2tET0xpRENRTURRMENqZUxpRFNNTURRM2g0UTBORENNTjR1SU1JdzBNRE9MaURBd05Jd3dBQUFBQkFBQUFBUUFBYTVuMHkxOFBQUFVBQ3dRQUFBQUFBTml2T1ZzQUFBQUEySzg1V3dBQUFBQURxd05WQUFBQUNBQUNBQUFBQUFBQUFBRUFBQVBBLzhBQUFBUUFBQUFBQUFPckFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBTEJBQUFBQUFBQUFBQUFBQUFBZ0FBQUFRQUFXSUVBQUZpQkFBQTRnUUFBT0lFQUFCVkJBQUFWUVFBQU9JQUFBQUFBQW9BRkFBZUFFUUFhZ0NxQU9vQm5nSmtBcG9BQVFBQUFBc0FpZ0FEQUFBQUFBQUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTRBcmdBQkFBQUFBQUFCQUFjQUFBQUJBQUFBQUFBQ0FBY0FZQUFCQUFBQUFBQURBQWNBTmdBQkFBQUFBQUFFQUFjQWRRQUJBQUFBQUFBRkFBc0FGUUFCQUFBQUFBQUdBQWNBU3dBQkFBQUFBQUFLQUJvQWlnQURBQUVFQ1FBQkFBNEFCd0FEQUFFRUNRQUNBQTRBWndBREFBRUVDUUFEQUE0QVBRQURBQUVFQ1FBRUFBNEFmQUFEQUFFRUNRQUZBQllBSUFBREFBRUVDUUFHQUE0QVVnQURBQUVFQ1FBS0FEUUFwR1pqYVdOdmJuTUFaZ0JqQUdrQVl3QnZBRzRBYzFabGNuTnBiMjRnTVM0d0FGWUFaUUJ5QUhNQWFRQnZBRzRBSUFBeEFDNEFNR1pqYVdOdmJuTUFaZ0JqQUdrQVl3QnZBRzRBYzJaamFXTnZibk1BWmdCakFHa0FZd0J2QUc0QWMxSmxaM1ZzWVhJQVVnQmxBR2NBZFFCc0FHRUFjbVpqYVdOdmJuTUFaZ0JqQUdrQVl3QnZBRzRBYzBadmJuUWdaMlZ1WlhKaGRHVmtJR0o1SUVsamIwMXZiMjR1QUVZQWJ3QnVBSFFBSUFCbkFHVUFiZ0JsQUhJQVlRQjBBR1VBWkFBZ0FHSUFlUUFnQUVrQVl3QnZBRTBBYndCdkFHNEFMZ0FBQUFNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQT1cXFwiKSBmb3JtYXQoXFxcInRydWV0eXBlXFxcIil9LmZjLWljb257c3BlYWs6bm9uZTstd2Via2l0LWZvbnQtc21vb3RoaW5nOmFudGlhbGlhc2VkOy1tb3otb3N4LWZvbnQtc21vb3RoaW5nOmdyYXlzY2FsZTtkaXNwbGF5OmlubGluZS1ibG9jaztmb250LWZhbWlseTpmY2ljb25zIWltcG9ydGFudDtmb250LXN0eWxlOm5vcm1hbDtmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0OjQwMDtoZWlnaHQ6MWVtO2xpbmUtaGVpZ2h0OjE7dGV4dC1hbGlnbjpjZW50ZXI7dGV4dC10cmFuc2Zvcm06bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTt3aWR0aDoxZW19LmZjLWljb24tY2hldnJvbi1sZWZ0OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTkwMFxcXCJ9LmZjLWljb24tY2hldnJvbi1yaWdodDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU5MDFcXFwifS5mYy1pY29uLWNoZXZyb25zLWxlZnQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlOTAyXFxcIn0uZmMtaWNvbi1jaGV2cm9ucy1yaWdodDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU5MDNcXFwifS5mYy1pY29uLW1pbnVzLXNxdWFyZTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU5MDRcXFwifS5mYy1pY29uLXBsdXMtc3F1YXJlOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTkwNVxcXCJ9LmZjLWljb24teDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU5MDZcXFwifS5mYyAuZmMtYnV0dG9ue2JvcmRlci1yYWRpdXM6MDtmb250LWZhbWlseTppbmhlcml0O2ZvbnQtc2l6ZTppbmhlcml0O2xpbmUtaGVpZ2h0OmluaGVyaXQ7bWFyZ2luOjA7b3ZlcmZsb3c6dmlzaWJsZTt0ZXh0LXRyYW5zZm9ybTpub25lfS5mYyAuZmMtYnV0dG9uOmZvY3Vze291dGxpbmU6MXB4IGRvdHRlZDtvdXRsaW5lOjVweCBhdXRvIC13ZWJraXQtZm9jdXMtcmluZy1jb2xvcn0uZmMgLmZjLWJ1dHRvbnstd2Via2l0LWFwcGVhcmFuY2U6YnV0dG9ufS5mYyAuZmMtYnV0dG9uOm5vdCg6ZGlzYWJsZWQpe2N1cnNvcjpwb2ludGVyfS5mYyAuZmMtYnV0dG9ue2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyOjFweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItcmFkaXVzOi4yNWVtO2Rpc3BsYXk6aW5saW5lLWJsb2NrO2ZvbnQtc2l6ZToxZW07Zm9udC13ZWlnaHQ6NDAwO2xpbmUtaGVpZ2h0OjEuNTtwYWRkaW5nOi40ZW0gLjY1ZW07dGV4dC1hbGlnbjpjZW50ZXI7LW1vei11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7dmVydGljYWwtYWxpZ246bWlkZGxlfS5mYyAuZmMtYnV0dG9uOmhvdmVye3RleHQtZGVjb3JhdGlvbjpub25lfS5mYyAuZmMtYnV0dG9uOmZvY3Vze2JveC1zaGFkb3c6MCAwIDAgLjJyZW0gcmdiYSg0NCw2Miw4MCwuMjUpO291dGxpbmU6MH0uZmMgLmZjLWJ1dHRvbjpkaXNhYmxlZHtvcGFjaXR5Oi42NX0uZmMgLmZjLWJ1dHRvbi1wcmltYXJ5e2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtYnV0dG9uLWJnLWNvbG9yKTtib3JkZXItY29sb3I6dmFyKC0tZmMtYnV0dG9uLWJvcmRlci1jb2xvcik7Y29sb3I6dmFyKC0tZmMtYnV0dG9uLXRleHQtY29sb3IpfS5mYyAuZmMtYnV0dG9uLXByaW1hcnk6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mYy1idXR0b24taG92ZXItYmctY29sb3IpO2JvcmRlci1jb2xvcjp2YXIoLS1mYy1idXR0b24taG92ZXItYm9yZGVyLWNvbG9yKTtjb2xvcjp2YXIoLS1mYy1idXR0b24tdGV4dC1jb2xvcil9LmZjIC5mYy1idXR0b24tcHJpbWFyeTpkaXNhYmxlZHtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZjLWJ1dHRvbi1iZy1jb2xvcik7Ym9yZGVyLWNvbG9yOnZhcigtLWZjLWJ1dHRvbi1ib3JkZXItY29sb3IpO2NvbG9yOnZhcigtLWZjLWJ1dHRvbi10ZXh0LWNvbG9yKX0uZmMgLmZjLWJ1dHRvbi1wcmltYXJ5OmZvY3Vze2JveC1zaGFkb3c6MCAwIDAgLjJyZW0gcmdiYSg3Niw5MSwxMDYsLjUpfS5mYyAuZmMtYnV0dG9uLXByaW1hcnk6bm90KDpkaXNhYmxlZCkuZmMtYnV0dG9uLWFjdGl2ZSwuZmMgLmZjLWJ1dHRvbi1wcmltYXJ5Om5vdCg6ZGlzYWJsZWQpOmFjdGl2ZXtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZjLWJ1dHRvbi1hY3RpdmUtYmctY29sb3IpO2JvcmRlci1jb2xvcjp2YXIoLS1mYy1idXR0b24tYWN0aXZlLWJvcmRlci1jb2xvcik7Y29sb3I6dmFyKC0tZmMtYnV0dG9uLXRleHQtY29sb3IpfS5mYyAuZmMtYnV0dG9uLXByaW1hcnk6bm90KDpkaXNhYmxlZCkuZmMtYnV0dG9uLWFjdGl2ZTpmb2N1cywuZmMgLmZjLWJ1dHRvbi1wcmltYXJ5Om5vdCg6ZGlzYWJsZWQpOmFjdGl2ZTpmb2N1c3tib3gtc2hhZG93OjAgMCAwIC4ycmVtIHJnYmEoNzYsOTEsMTA2LC41KX0uZmMgLmZjLWJ1dHRvbiAuZmMtaWNvbntmb250LXNpemU6MS41ZW07dmVydGljYWwtYWxpZ246bWlkZGxlfS5mYyAuZmMtYnV0dG9uLWdyb3Vwe2Rpc3BsYXk6aW5saW5lLWZsZXg7cG9zaXRpb246cmVsYXRpdmU7dmVydGljYWwtYWxpZ246bWlkZGxlfS5mYyAuZmMtYnV0dG9uLWdyb3VwPi5mYy1idXR0b257ZmxleDoxIDEgYXV0bztwb3NpdGlvbjpyZWxhdGl2ZX0uZmMgLmZjLWJ1dHRvbi1ncm91cD4uZmMtYnV0dG9uLmZjLWJ1dHRvbi1hY3RpdmUsLmZjIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbjphY3RpdmUsLmZjIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbjpmb2N1cywuZmMgLmZjLWJ1dHRvbi1ncm91cD4uZmMtYnV0dG9uOmhvdmVye3otaW5kZXg6MX0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtYnV0dG9uLWdyb3VwPi5mYy1idXR0b246bm90KDpmaXJzdC1jaGlsZCl7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czowO2JvcmRlci10b3AtbGVmdC1yYWRpdXM6MDttYXJnaW4tbGVmdDotMXB4fS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbjpub3QoOmxhc3QtY2hpbGQpe2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOjA7Ym9yZGVyLXRvcC1yaWdodC1yYWRpdXM6MH0uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtYnV0dG9uLWdyb3VwPi5mYy1idXR0b246bm90KDpmaXJzdC1jaGlsZCl7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MDtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czowO21hcmdpbi1yaWdodDotMXB4fS5mYy1kaXJlY3Rpb24tcnRsIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbjpub3QoOmxhc3QtY2hpbGQpe2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6MDtib3JkZXItdG9wLWxlZnQtcmFkaXVzOjB9LmZjIC5mYy10b29sYmFye2FsaWduLWl0ZW1zOmNlbnRlcjtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW59LmZjIC5mYy10b29sYmFyLmZjLWhlYWRlci10b29sYmFye21hcmdpbi1ib3R0b206MS41ZW19LmZjIC5mYy10b29sYmFyLmZjLWZvb3Rlci10b29sYmFye21hcmdpbi10b3A6MS41ZW19LmZjIC5mYy10b29sYmFyLXRpdGxle2ZvbnQtc2l6ZToxLjc1ZW07bWFyZ2luOjB9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLXRvb2xiYXI+Kj46bm90KDpmaXJzdC1jaGlsZCl7bWFyZ2luLWxlZnQ6Ljc1ZW19LmZjLWRpcmVjdGlvbi1ydGwgLmZjLXRvb2xiYXI+Kj46bm90KDpmaXJzdC1jaGlsZCl7bWFyZ2luLXJpZ2h0Oi43NWVtfS5mYy1kaXJlY3Rpb24tcnRsIC5mYy10b29sYmFyLWx0cntmbGV4LWRpcmVjdGlvbjpyb3ctcmV2ZXJzZX0uZmMgLmZjLXNjcm9sbGVyey13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOnRvdWNoO3Bvc2l0aW9uOnJlbGF0aXZlfS5mYyAuZmMtc2Nyb2xsZXItbGlxdWlke2hlaWdodDoxMDAlfS5mYyAuZmMtc2Nyb2xsZXItbGlxdWlkLWFic29sdXRle2JvdHRvbTowO2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowfS5mYyAuZmMtc2Nyb2xsZXItaGFybmVzc3tkaXJlY3Rpb246bHRyO292ZXJmbG93OmhpZGRlbjtwb3NpdGlvbjpyZWxhdGl2ZX0uZmMgLmZjLXNjcm9sbGVyLWhhcm5lc3MtbGlxdWlke2hlaWdodDoxMDAlfS5mYy1kaXJlY3Rpb24tcnRsIC5mYy1zY3JvbGxlci1oYXJuZXNzPi5mYy1zY3JvbGxlcntkaXJlY3Rpb246cnRsfS5mYy10aGVtZS1zdGFuZGFyZCAuZmMtc2Nyb2xsZ3JpZHtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWZjLWJvcmRlci1jb2xvcil9LmZjIC5mYy1zY3JvbGxncmlkLC5mYyAuZmMtc2Nyb2xsZ3JpZCB0YWJsZXt0YWJsZS1sYXlvdXQ6Zml4ZWQ7d2lkdGg6MTAwJX0uZmMgLmZjLXNjcm9sbGdyaWQgdGFibGV7Ym9yZGVyLWxlZnQtc3R5bGU6aGlkZGVuO2JvcmRlci1yaWdodC1zdHlsZTpoaWRkZW47Ym9yZGVyLXRvcC1zdHlsZTpoaWRkZW59LmZjIC5mYy1zY3JvbGxncmlke2JvcmRlci1ib3R0b20td2lkdGg6MDtib3JkZXItY29sbGFwc2U6c2VwYXJhdGU7Ym9yZGVyLXJpZ2h0LXdpZHRoOjB9LmZjIC5mYy1zY3JvbGxncmlkLWxpcXVpZHtoZWlnaHQ6MTAwJX0uZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbiwuZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbiB0YWJsZSwuZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbj50ZHtoZWlnaHQ6MXB4fS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWxpcXVpZD50ZHtoZWlnaHQ6MTAwJX0uZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbj4qe2JvcmRlci1sZWZ0LXdpZHRoOjA7Ym9yZGVyLXRvcC13aWR0aDowfS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWZvb3Rlcj4qLC5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWhlYWRlcj4qe2JvcmRlci1ib3R0b20td2lkdGg6MH0uZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbi1ib2R5IHRhYmxlLC5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWZvb3RlciB0YWJsZXtib3JkZXItYm90dG9tLXN0eWxlOmhpZGRlbn0uZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbi1zdGlja3k+KntiYWNrZ3JvdW5kOnZhcigtLWZjLXBhZ2UtYmctY29sb3IpO3Bvc2l0aW9uOnN0aWNreTt6LWluZGV4OjN9LmZjIC5mYy1zY3JvbGxncmlkLXNlY3Rpb24taGVhZGVyLmZjLXNjcm9sbGdyaWQtc2VjdGlvbi1zdGlja3k+Knt0b3A6MH0uZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbi1mb290ZXIuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLXN0aWNreT4qe2JvdHRvbTowfS5mYyAuZmMtc2Nyb2xsZ3JpZC1zdGlja3ktc2hpbXtoZWlnaHQ6MXB4O21hcmdpbi1ib3R0b206LTFweH0uZmMtc3RpY2t5e3Bvc2l0aW9uOnN0aWNreX0uZmMgLmZjLXZpZXctaGFybmVzc3tmbGV4LWdyb3c6MTtwb3NpdGlvbjpyZWxhdGl2ZX0uZmMgLmZjLXZpZXctaGFybmVzcy1hY3RpdmU+LmZjLXZpZXd7Ym90dG9tOjA7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmZjIC5mYy1jb2wtaGVhZGVyLWNlbGwtY3VzaGlvbntkaXNwbGF5OmlubGluZS1ibG9jaztwYWRkaW5nOjJweCA0cHh9LmZjIC5mYy1iZy1ldmVudCwuZmMgLmZjLWhpZ2hsaWdodCwuZmMgLmZjLW5vbi1idXNpbmVzc3tib3R0b206MDtsZWZ0OjA7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDt0b3A6MH0uZmMgLmZjLW5vbi1idXNpbmVzc3tiYWNrZ3JvdW5kOnZhcigtLWZjLW5vbi1idXNpbmVzcy1jb2xvcil9LmZjIC5mYy1iZy1ldmVudHtiYWNrZ3JvdW5kOnZhcigtLWZjLWJnLWV2ZW50LWNvbG9yKTtvcGFjaXR5OnZhcigtLWZjLWJnLWV2ZW50LW9wYWNpdHkpfS5mYyAuZmMtYmctZXZlbnQgLmZjLWV2ZW50LXRpdGxle2ZvbnQtc2l6ZTp2YXIoLS1mYy1zbWFsbC1mb250LXNpemUpO2ZvbnQtc3R5bGU6aXRhbGljO21hcmdpbjouNWVtfS5mYyAuZmMtaGlnaGxpZ2h0e2JhY2tncm91bmQ6dmFyKC0tZmMtaGlnaGxpZ2h0LWNvbG9yKX0uZmMgLmZjLWNlbGwtc2hhZGVkLC5mYyAuZmMtZGF5LWRpc2FibGVke2JhY2tncm91bmQ6dmFyKC0tZmMtbmV1dHJhbC1iZy1jb2xvcil9YS5mYy1ldmVudCxhLmZjLWV2ZW50OmhvdmVye3RleHQtZGVjb3JhdGlvbjpub25lfS5mYy1ldmVudC5mYy1ldmVudC1kcmFnZ2FibGUsLmZjLWV2ZW50W2hyZWZde2N1cnNvcjpwb2ludGVyfS5mYy1ldmVudCAuZmMtZXZlbnQtbWFpbntwb3NpdGlvbjpyZWxhdGl2ZTt6LWluZGV4OjJ9LmZjLWV2ZW50LWRyYWdnaW5nOm5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpe29wYWNpdHk6Ljc1fS5mYy1ldmVudC1kcmFnZ2luZy5mYy1ldmVudC1zZWxlY3RlZHtib3gtc2hhZG93OjAgMnB4IDdweCByZ2JhKDAsMCwwLC4zKX0uZmMtZXZlbnQgLmZjLWV2ZW50LXJlc2l6ZXJ7ZGlzcGxheTpub25lO3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6NH0uZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXIsLmZjLWV2ZW50OmhvdmVyIC5mYy1ldmVudC1yZXNpemVye2Rpc3BsYXk6YmxvY2t9LmZjLWV2ZW50LXNlbGVjdGVkIC5mYy1ldmVudC1yZXNpemVye2JhY2tncm91bmQ6dmFyKC0tZmMtcGFnZS1iZy1jb2xvcik7Ym9yZGVyLWNvbG9yOmluaGVyaXQ7Ym9yZGVyLXJhZGl1czpjYWxjKHZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoKS8yKTtib3JkZXItc3R5bGU6c29saWQ7Ym9yZGVyLXdpZHRoOnZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LWJvcmRlci13aWR0aCk7aGVpZ2h0OnZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoKTt3aWR0aDp2YXIoLS1mYy1ldmVudC1yZXNpemVyLWRvdC10b3RhbC13aWR0aCl9LmZjLWV2ZW50LXNlbGVjdGVkIC5mYy1ldmVudC1yZXNpemVyOmJlZm9yZXtib3R0b206LTIwcHg7Y29udGVudDpcXFwiXFxcIjtsZWZ0Oi0yMHB4O3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0Oi0yMHB4O3RvcDotMjBweH0uZmMtZXZlbnQtc2VsZWN0ZWQsLmZjLWV2ZW50OmZvY3Vze2JveC1zaGFkb3c6MCAycHggNXB4IHJnYmEoMCwwLDAsLjIpfS5mYy1ldmVudC1zZWxlY3RlZDpiZWZvcmUsLmZjLWV2ZW50OmZvY3VzOmJlZm9yZXtib3R0b206MDtjb250ZW50OlxcXCJcXFwiO2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowO3otaW5kZXg6M30uZmMtZXZlbnQtc2VsZWN0ZWQ6YWZ0ZXIsLmZjLWV2ZW50OmZvY3VzOmFmdGVye2JhY2tncm91bmQ6dmFyKC0tZmMtZXZlbnQtc2VsZWN0ZWQtb3ZlcmxheS1jb2xvcik7Ym90dG9tOi0xcHg7Y29udGVudDpcXFwiXFxcIjtsZWZ0Oi0xcHg7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6LTFweDt0b3A6LTFweDt6LWluZGV4OjF9LmZjLWgtZXZlbnR7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mYy1ldmVudC1iZy1jb2xvcik7Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1mYy1ldmVudC1ib3JkZXItY29sb3IpO2Rpc3BsYXk6YmxvY2t9LmZjLWgtZXZlbnQgLmZjLWV2ZW50LW1haW57Y29sb3I6dmFyKC0tZmMtZXZlbnQtdGV4dC1jb2xvcil9LmZjLWgtZXZlbnQgLmZjLWV2ZW50LW1haW4tZnJhbWV7ZGlzcGxheTpmbGV4fS5mYy1oLWV2ZW50IC5mYy1ldmVudC10aW1le21heC13aWR0aDoxMDAlO292ZXJmbG93OmhpZGRlbn0uZmMtaC1ldmVudCAuZmMtZXZlbnQtdGl0bGUtY29udGFpbmVye2ZsZXgtZ3JvdzoxO2ZsZXgtc2hyaW5rOjE7bWluLXdpZHRoOjB9LmZjLWgtZXZlbnQgLmZjLWV2ZW50LXRpdGxle2Rpc3BsYXk6aW5saW5lLWJsb2NrO2xlZnQ6MDttYXgtd2lkdGg6MTAwJTtvdmVyZmxvdzpoaWRkZW47cmlnaHQ6MDt2ZXJ0aWNhbC1hbGlnbjp0b3B9LmZjLWgtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQ6YmVmb3Jle2JvdHRvbTotMTBweDt0b3A6LTEwcHh9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWRheWdyaWQtYmxvY2stZXZlbnQ6bm90KC5mYy1ldmVudC1zdGFydCksLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWRheWdyaWQtYmxvY2stZXZlbnQ6bm90KC5mYy1ldmVudC1lbmQpe2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6MDtib3JkZXItbGVmdC13aWR0aDowO2JvcmRlci10b3AtbGVmdC1yYWRpdXM6MH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtZGF5Z3JpZC1ibG9jay1ldmVudDpub3QoLmZjLWV2ZW50LWVuZCksLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWRheWdyaWQtYmxvY2stZXZlbnQ6bm90KC5mYy1ldmVudC1zdGFydCl7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MDtib3JkZXItcmlnaHQtd2lkdGg6MDtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czowfS5mYy1oLWV2ZW50Om5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpIC5mYy1ldmVudC1yZXNpemVye2JvdHRvbTowO3RvcDowO3dpZHRoOnZhcigtLWZjLWV2ZW50LXJlc2l6ZXItdGhpY2tuZXNzKX0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtaC1ldmVudDpub3QoLmZjLWV2ZW50LXNlbGVjdGVkKSAuZmMtZXZlbnQtcmVzaXplci1zdGFydCwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtaC1ldmVudDpub3QoLmZjLWV2ZW50LXNlbGVjdGVkKSAuZmMtZXZlbnQtcmVzaXplci1lbmR7Y3Vyc29yOnctcmVzaXplO2xlZnQ6Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLXRoaWNrbmVzcykqLS41KX0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtaC1ldmVudDpub3QoLmZjLWV2ZW50LXNlbGVjdGVkKSAuZmMtZXZlbnQtcmVzaXplci1lbmQsLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWgtZXZlbnQ6bm90KC5mYy1ldmVudC1zZWxlY3RlZCkgLmZjLWV2ZW50LXJlc2l6ZXItc3RhcnR7Y3Vyc29yOmUtcmVzaXplO3JpZ2h0OmNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci10aGlja25lc3MpKi0uNSl9LmZjLWgtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXJ7bWFyZ2luLXRvcDpjYWxjKHZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoKSotLjUpO3RvcDo1MCV9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWgtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXItc3RhcnQsLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWgtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXItZW5ke2xlZnQ6Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLWRvdC10b3RhbC13aWR0aCkqLS41KX0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtaC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplci1lbmQsLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWgtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXItc3RhcnR7cmlnaHQ6Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLWRvdC10b3RhbC13aWR0aCkqLS41KX0uZmMgLmZjLXBvcG92ZXJ7Ym94LXNoYWRvdzowIDJweCA2cHggcmdiYSgwLDAsMCwuMTUpO3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6OTk5OX0uZmMgLmZjLXBvcG92ZXItaGVhZGVye2FsaWduLWl0ZW1zOmNlbnRlcjtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246cm93O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuO3BhZGRpbmc6M3B4IDRweH0uZmMgLmZjLXBvcG92ZXItdGl0bGV7bWFyZ2luOjAgMnB4fS5mYyAuZmMtcG9wb3Zlci1jbG9zZXtjdXJzb3I6cG9pbnRlcjtmb250LXNpemU6MS4xZW07b3BhY2l0eTouNjV9LmZjLXRoZW1lLXN0YW5kYXJkIC5mYy1wb3BvdmVye2JhY2tncm91bmQ6dmFyKC0tZmMtcGFnZS1iZy1jb2xvcik7Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1mYy1ib3JkZXItY29sb3IpfS5mYy10aGVtZS1zdGFuZGFyZCAuZmMtcG9wb3Zlci1oZWFkZXJ7YmFja2dyb3VuZDp2YXIoLS1mYy1uZXV0cmFsLWJnLWNvbG9yKX1cIjtcbmluamVjdFN0eWxlcyhjc3NfMjQ4eik7XG5cbmNsYXNzIERlbGF5ZWRSdW5uZXIge1xuICAgIGNvbnN0cnVjdG9yKGRyYWluZWRPcHRpb24pIHtcbiAgICAgICAgdGhpcy5kcmFpbmVkT3B0aW9uID0gZHJhaW5lZE9wdGlvbjtcbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGF1c2VEZXB0aHMgPSB7fTtcbiAgICAgICAgdGhpcy50aW1lb3V0SWQgPSAwO1xuICAgIH1cbiAgICByZXF1ZXN0KGRlbGF5KSB7XG4gICAgICAgIHRoaXMuaXNEaXJ0eSA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy5pc1BhdXNlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICAgICAgICAgICAgaWYgKGRlbGF5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyeURyYWluKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoLy8gTk9UIE9QVElNQUwhIFRPRE86IGxvb2sgYXQgZGVib3VuY2VcbiAgICAgICAgICAgICAgICB0aGlzLnRyeURyYWluLmJpbmQodGhpcyksIGRlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXVzZShzY29wZSA9ICcnKSB7XG4gICAgICAgIGxldCB7IHBhdXNlRGVwdGhzIH0gPSB0aGlzO1xuICAgICAgICBwYXVzZURlcHRoc1tzY29wZV0gPSAocGF1c2VEZXB0aHNbc2NvcGVdIHx8IDApICsgMTtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICB9XG4gICAgcmVzdW1lKHNjb3BlID0gJycsIGZvcmNlKSB7XG4gICAgICAgIGxldCB7IHBhdXNlRGVwdGhzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoc2NvcGUgaW4gcGF1c2VEZXB0aHMpIHtcbiAgICAgICAgICAgIGlmIChmb3JjZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXVzZURlcHRoc1tzY29wZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXVzZURlcHRoc1tzY29wZV0gLT0gMTtcbiAgICAgICAgICAgICAgICBsZXQgZGVwdGggPSBwYXVzZURlcHRoc1tzY29wZV07XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhdXNlRGVwdGhzW3Njb3BlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyeURyYWluKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNQYXVzZWQoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnBhdXNlRGVwdGhzKS5sZW5ndGg7XG4gICAgfVxuICAgIHRyeURyYWluKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNSdW5uaW5nICYmICF0aGlzLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmlzRGlydHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWluZWQoKTsgLy8gbWlnaHQgc2V0IGlzRGlydHkgdG8gdHJ1ZSBhZ2FpblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGF1c2VEZXB0aHMgPSB7fTtcbiAgICB9XG4gICAgY2xlYXJUaW1lb3V0KCkge1xuICAgICAgICBpZiAodGhpcy50aW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZHJhaW5lZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhaW5lZE9wdGlvbikge1xuICAgICAgICAgICAgdGhpcy5kcmFpbmVkT3B0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoZWwpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSkge1xuICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICB9XG59XG4vLyBRdWVyeWluZ1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gZWxlbWVudENsb3Nlc3QoZWwsIHNlbGVjdG9yKSB7XG4gICAgaWYgKGVsLmNsb3Nlc3QpIHtcbiAgICAgICAgcmV0dXJuIGVsLmNsb3Nlc3Qoc2VsZWN0b3IpO1xuICAgICAgICAvLyByZWFsbHkgYmFkIGZhbGxiYWNrIGZvciBJRVxuICAgICAgICAvLyBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2Nsb3Nlc3RcbiAgICB9XG4gICAgaWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMoZWwpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBkbyB7XG4gICAgICAgIGlmIChlbGVtZW50TWF0Y2hlcyhlbCwgc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH1cbiAgICAgICAgZWwgPSAoZWwucGFyZW50RWxlbWVudCB8fCBlbC5wYXJlbnROb2RlKTtcbiAgICB9IHdoaWxlIChlbCAhPT0gbnVsbCAmJiBlbC5ub2RlVHlwZSA9PT0gMSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlcyhlbCwgc2VsZWN0b3IpIHtcbiAgICBsZXQgbWV0aG9kID0gZWwubWF0Y2hlcyB8fCBlbC5tYXRjaGVzU2VsZWN0b3IgfHwgZWwubXNNYXRjaGVzU2VsZWN0b3I7XG4gICAgcmV0dXJuIG1ldGhvZC5jYWxsKGVsLCBzZWxlY3Rvcik7XG59XG4vLyBhY2NlcHRzIG11bHRpcGxlIHN1YmplY3QgZWxzXG4vLyByZXR1cm5zIGEgcmVhbCBhcnJheS4gZ29vZCBmb3IgbWV0aG9kcyBsaWtlIGZvckVhY2hcbi8vIFRPRE86IGFjY2VwdCB0aGUgZG9jdW1lbnRcbmZ1bmN0aW9uIGZpbmRFbGVtZW50cyhjb250YWluZXIsIHNlbGVjdG9yKSB7XG4gICAgbGV0IGNvbnRhaW5lcnMgPSBjb250YWluZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA/IFtjb250YWluZXJdIDogY29udGFpbmVyO1xuICAgIGxldCBhbGxNYXRjaGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250YWluZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCBtYXRjaGVzID0gY29udGFpbmVyc1tpXS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXRjaGVzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICBhbGxNYXRjaGVzLnB1c2gobWF0Y2hlc1tqXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFsbE1hdGNoZXM7XG59XG4vLyBhY2NlcHRzIG11bHRpcGxlIHN1YmplY3QgZWxzXG4vLyBvbmx5IHF1ZXJpZXMgZGlyZWN0IGNoaWxkIGVsZW1lbnRzIC8vIFRPRE86IHJlbmFtZSB0byBmaW5kRGlyZWN0Q2hpbGRyZW4hXG5mdW5jdGlvbiBmaW5kRGlyZWN0Q2hpbGRyZW4ocGFyZW50LCBzZWxlY3Rvcikge1xuICAgIGxldCBwYXJlbnRzID0gcGFyZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgPyBbcGFyZW50XSA6IHBhcmVudDtcbiAgICBsZXQgYWxsTWF0Y2hlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBsZXQgY2hpbGROb2RlcyA9IHBhcmVudHNbaV0uY2hpbGRyZW47IC8vIG9ubHkgZXZlciBlbGVtZW50c1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoaWxkTm9kZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGxldCBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW2pdO1xuICAgICAgICAgICAgaWYgKCFzZWxlY3RvciB8fCBlbGVtZW50TWF0Y2hlcyhjaGlsZE5vZGUsIHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgIGFsbE1hdGNoZXMucHVzaChjaGlsZE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhbGxNYXRjaGVzO1xufVxuLy8gU3R5bGVcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmNvbnN0IFBJWEVMX1BST1BfUkUgPSAvKHRvcHxsZWZ0fHJpZ2h0fGJvdHRvbXx3aWR0aHxoZWlnaHQpJC9pO1xuZnVuY3Rpb24gYXBwbHlTdHlsZShlbCwgcHJvcHMpIHtcbiAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBwcm9wcykge1xuICAgICAgICBhcHBseVN0eWxlUHJvcChlbCwgcHJvcE5hbWUsIHByb3BzW3Byb3BOYW1lXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwbHlTdHlsZVByb3AoZWwsIG5hbWUsIHZhbCkge1xuICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICBlbC5zdHlsZVtuYW1lXSA9ICcnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiBQSVhFTF9QUk9QX1JFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgZWwuc3R5bGVbbmFtZV0gPSBgJHt2YWx9cHhgO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZWwuc3R5bGVbbmFtZV0gPSB2YWw7XG4gICAgfVxufVxuLy8gRXZlbnQgSGFuZGxpbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGlmIGludGVyY2VwdGluZyBidWJibGVkIGV2ZW50cyBhdCB0aGUgZG9jdW1lbnQvd2luZG93L2JvZHkgbGV2ZWwsXG4vLyBhbmQgd2FudCB0byBzZWUgb3JpZ2luYXRpbmcgZWxlbWVudCAodGhlICd0YXJnZXQnKSwgdXNlIHRoaXMgdXRpbCBpbnN0ZWFkXG4vLyBvZiBgZXYudGFyZ2V0YCBiZWNhdXNlIGl0IGdvZXMgd2l0aGluIHdlYi1jb21wb25lbnQgYm91bmRhcmllcy5cbmZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0VmlhUm9vdChldikge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IGV2LmNvbXBvc2VkUGF0aCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoZXYpWzBdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBldi50YXJnZXQ7XG59XG4vLyBVbmlxdWUgSUQgZm9yIERPTSBhdHRyaWJ1dGVcbmxldCBndWlkJDEgPSAwO1xuZnVuY3Rpb24gZ2V0VW5pcXVlRG9tSWQoKSB7XG4gICAgZ3VpZCQxICs9IDE7XG4gICAgcmV0dXJuICdmYy1kb20tJyArIGd1aWQkMTtcbn1cblxuLy8gU3RvcHMgYSBtb3VzZS90b3VjaCBldmVudCBmcm9tIGRvaW5nIGl0J3MgbmF0aXZlIGJyb3dzZXIgYWN0aW9uXG5mdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldikge1xuICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG59XG4vLyBFdmVudCBEZWxlZ2F0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBidWlsZERlbGVnYXRpb25IYW5kbGVyKHNlbGVjdG9yLCBoYW5kbGVyKSB7XG4gICAgcmV0dXJuIChldikgPT4ge1xuICAgICAgICBsZXQgbWF0Y2hlZENoaWxkID0gZWxlbWVudENsb3Nlc3QoZXYudGFyZ2V0LCBzZWxlY3Rvcik7XG4gICAgICAgIGlmIChtYXRjaGVkQ2hpbGQpIHtcbiAgICAgICAgICAgIGhhbmRsZXIuY2FsbChtYXRjaGVkQ2hpbGQsIGV2LCBtYXRjaGVkQ2hpbGQpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGxpc3RlbkJ5U2VsZWN0b3IoY29udGFpbmVyLCBldmVudFR5cGUsIHNlbGVjdG9yLCBoYW5kbGVyKSB7XG4gICAgbGV0IGF0dGFjaGVkSGFuZGxlciA9IGJ1aWxkRGVsZWdhdGlvbkhhbmRsZXIoc2VsZWN0b3IsIGhhbmRsZXIpO1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgYXR0YWNoZWRIYW5kbGVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGF0dGFjaGVkSGFuZGxlcik7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGxpc3RlblRvSG92ZXJCeVNlbGVjdG9yKGNvbnRhaW5lciwgc2VsZWN0b3IsIG9uTW91c2VFbnRlciwgb25Nb3VzZUxlYXZlKSB7XG4gICAgbGV0IGN1cnJlbnRNYXRjaGVkQ2hpbGQ7XG4gICAgcmV0dXJuIGxpc3RlbkJ5U2VsZWN0b3IoY29udGFpbmVyLCAnbW91c2VvdmVyJywgc2VsZWN0b3IsIChtb3VzZU92ZXJFdiwgbWF0Y2hlZENoaWxkKSA9PiB7XG4gICAgICAgIGlmIChtYXRjaGVkQ2hpbGQgIT09IGN1cnJlbnRNYXRjaGVkQ2hpbGQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRNYXRjaGVkQ2hpbGQgPSBtYXRjaGVkQ2hpbGQ7XG4gICAgICAgICAgICBvbk1vdXNlRW50ZXIobW91c2VPdmVyRXYsIG1hdGNoZWRDaGlsZCk7XG4gICAgICAgICAgICBsZXQgcmVhbE9uTW91c2VMZWF2ZSA9IChtb3VzZUxlYXZlRXYpID0+IHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TWF0Y2hlZENoaWxkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBvbk1vdXNlTGVhdmUobW91c2VMZWF2ZUV2LCBtYXRjaGVkQ2hpbGQpO1xuICAgICAgICAgICAgICAgIG1hdGNoZWRDaGlsZC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgcmVhbE9uTW91c2VMZWF2ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gbGlzdGVuIHRvIHRoZSBuZXh0IG1vdXNlbGVhdmUsIGFuZCB0aGVuIHVuYXR0YWNoXG4gICAgICAgICAgICBtYXRjaGVkQ2hpbGQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHJlYWxPbk1vdXNlTGVhdmUpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vLyBBbmltYXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmNvbnN0IHRyYW5zaXRpb25FdmVudE5hbWVzID0gW1xuICAgICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgICAnb3RyYW5zaXRpb25lbmQnLFxuICAgICdvVHJhbnNpdGlvbkVuZCcsXG4gICAgJ21zVHJhbnNpdGlvbkVuZCcsXG4gICAgJ3RyYW5zaXRpb25lbmQnLFxuXTtcbi8vIHRyaWdnZXJlZCBvbmx5IHdoZW4gdGhlIG5leHQgc2luZ2xlIHN1YnNlcXVlbnQgdHJhbnNpdGlvbiBmaW5pc2hlc1xuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25Eb25lKGVsLCBjYWxsYmFjaykge1xuICAgIGxldCByZWFsQ2FsbGJhY2sgPSAoZXYpID0+IHtcbiAgICAgICAgY2FsbGJhY2soZXYpO1xuICAgICAgICB0cmFuc2l0aW9uRXZlbnROYW1lcy5mb3JFYWNoKChldmVudE5hbWUpID0+IHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCByZWFsQ2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHRyYW5zaXRpb25FdmVudE5hbWVzLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgcmVhbENhbGxiYWNrKTsgLy8gY3Jvc3MtYnJvd3NlciB3YXkgdG8gZGV0ZXJtaW5lIHdoZW4gdGhlIHRyYW5zaXRpb24gZmluaXNoZXNcbiAgICB9KTtcbn1cbi8vIEFSSUEgd29ya2Fyb3VuZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGNyZWF0ZUFyaWFDbGlja0F0dHJzKGhhbmRsZXIpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IG9uQ2xpY2s6IGhhbmRsZXIgfSwgY3JlYXRlQXJpYUtleWJvYXJkQXR0cnMoaGFuZGxlcikpO1xufVxuZnVuY3Rpb24gY3JlYXRlQXJpYUtleWJvYXJkQXR0cnMoaGFuZGxlcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRhYkluZGV4OiAwLFxuICAgICAgICBvbktleURvd24oZXYpIHtcbiAgICAgICAgICAgIGlmIChldi5rZXkgPT09ICdFbnRlcicgfHwgZXYua2V5ID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyKGV2KTtcbiAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpOyAvLyBpZiBzcGFjZSwgZG9uJ3Qgc2Nyb2xsIGRvd24gcGFnZVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG59XG5cbmxldCBndWlkTnVtYmVyID0gMDtcbmZ1bmN0aW9uIGd1aWQoKSB7XG4gICAgZ3VpZE51bWJlciArPSAxO1xuICAgIHJldHVybiBTdHJpbmcoZ3VpZE51bWJlcik7XG59XG4vKiBGdWxsQ2FsZW5kYXItc3BlY2lmaWMgRE9NIFV0aWxpdGllc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vLyBNYWtlIHRoZSBtb3VzZSBjdXJzb3IgZXhwcmVzcyB0aGF0IGFuIGV2ZW50IGlzIG5vdCBhbGxvd2VkIGluIHRoZSBjdXJyZW50IGFyZWFcbmZ1bmN0aW9uIGRpc2FibGVDdXJzb3IoKSB7XG4gICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdmYy1ub3QtYWxsb3dlZCcpO1xufVxuLy8gUmV0dXJucyB0aGUgbW91c2UgY3Vyc29yIHRvIGl0cyBvcmlnaW5hbCBsb29rXG5mdW5jdGlvbiBlbmFibGVDdXJzb3IoKSB7XG4gICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCdmYy1ub3QtYWxsb3dlZCcpO1xufVxuLyogU2VsZWN0aW9uXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmZ1bmN0aW9uIHByZXZlbnRTZWxlY3Rpb24oZWwpIHtcbiAgICBlbC5zdHlsZS51c2VyU2VsZWN0ID0gJ25vbmUnO1xuICAgIGVsLnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XG59XG5mdW5jdGlvbiBhbGxvd1NlbGVjdGlvbihlbCkge1xuICAgIGVsLnN0eWxlLnVzZXJTZWxlY3QgPSAnJztcbiAgICBlbC5zdHlsZS53ZWJraXRVc2VyU2VsZWN0ID0gJyc7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XG59XG4vKiBDb250ZXh0IE1lbnVcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gcHJldmVudENvbnRleHRNZW51KGVsKSB7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBwcmV2ZW50RGVmYXVsdCk7XG59XG5mdW5jdGlvbiBhbGxvd0NvbnRleHRNZW51KGVsKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBwcmV2ZW50RGVmYXVsdCk7XG59XG5mdW5jdGlvbiBwYXJzZUZpZWxkU3BlY3MoaW5wdXQpIHtcbiAgICBsZXQgc3BlY3MgPSBbXTtcbiAgICBsZXQgdG9rZW5zID0gW107XG4gICAgbGV0IGk7XG4gICAgbGV0IHRva2VuO1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRva2VucyA9IGlucHV0LnNwbGl0KC9cXHMqLFxccyovKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRva2VucyA9IFtpbnB1dF07XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIHRva2VucyA9IGlucHV0O1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc3BlY3MucHVzaCh0b2tlbi5jaGFyQXQoMCkgPT09ICctJyA/XG4gICAgICAgICAgICAgICAgeyBmaWVsZDogdG9rZW4uc3Vic3RyaW5nKDEpLCBvcmRlcjogLTEgfSA6XG4gICAgICAgICAgICAgICAgeyBmaWVsZDogdG9rZW4sIG9yZGVyOiAxIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc3BlY3MucHVzaCh7IGZ1bmM6IHRva2VuIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzcGVjcztcbn1cbmZ1bmN0aW9uIGNvbXBhcmVCeUZpZWxkU3BlY3Mob2JqMCwgb2JqMSwgZmllbGRTcGVjcykge1xuICAgIGxldCBpO1xuICAgIGxldCBjbXA7XG4gICAgZm9yIChpID0gMDsgaSA8IGZpZWxkU3BlY3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY21wID0gY29tcGFyZUJ5RmllbGRTcGVjKG9iajAsIG9iajEsIGZpZWxkU3BlY3NbaV0pO1xuICAgICAgICBpZiAoY21wKSB7XG4gICAgICAgICAgICByZXR1cm4gY21wO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gY29tcGFyZUJ5RmllbGRTcGVjKG9iajAsIG9iajEsIGZpZWxkU3BlYykge1xuICAgIGlmIChmaWVsZFNwZWMuZnVuYykge1xuICAgICAgICByZXR1cm4gZmllbGRTcGVjLmZ1bmMob2JqMCwgb2JqMSk7XG4gICAgfVxuICAgIHJldHVybiBmbGV4aWJsZUNvbXBhcmUob2JqMFtmaWVsZFNwZWMuZmllbGRdLCBvYmoxW2ZpZWxkU3BlYy5maWVsZF0pXG4gICAgICAgICogKGZpZWxkU3BlYy5vcmRlciB8fCAxKTtcbn1cbmZ1bmN0aW9uIGZsZXhpYmxlQ29tcGFyZShhLCBiKSB7XG4gICAgaWYgKCFhICYmICFiKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAoYiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKGEgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgYiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhhKS5sb2NhbGVDb21wYXJlKFN0cmluZyhiKSk7XG4gICAgfVxuICAgIHJldHVybiBhIC0gYjtcbn1cbi8qIFN0cmluZyBVdGlsaXRpZXNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gcGFkU3RhcnQodmFsLCBsZW4pIHtcbiAgICBsZXQgcyA9IFN0cmluZyh2YWwpO1xuICAgIHJldHVybiAnMDAwJy5zdWJzdHIoMCwgbGVuIC0gcy5sZW5ndGgpICsgcztcbn1cbmZ1bmN0aW9uIGZvcm1hdFdpdGhPcmRpbmFscyhmb3JtYXR0ZXIsIGFyZ3MsIGZhbGxiYWNrVGV4dCkge1xuICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZXIoLi4uYXJncyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnc3RyaW5nJykgeyAvLyBub24tYmxhbmsgc3RyaW5nXG4gICAgICAgIHJldHVybiBhcmdzLnJlZHVjZSgoc3RyLCBhcmcsIGluZGV4KSA9PiAoc3RyLnJlcGxhY2UoJyQnICsgaW5kZXgsIGFyZyB8fCAnJykpLCBmb3JtYXR0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsbGJhY2tUZXh0O1xufVxuLyogTnVtYmVyIFV0aWxpdGllc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5mdW5jdGlvbiBjb21wYXJlTnVtYmVycyhhLCBiKSB7XG4gICAgcmV0dXJuIGEgLSBiO1xufVxuZnVuY3Rpb24gaXNJbnQobikge1xuICAgIHJldHVybiBuICUgMSA9PT0gMDtcbn1cbi8qIEZDLXNwZWNpZmljIERPTSBkaW1lbnNpb24gc3R1ZmZcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gY29tcHV0ZVNtYWxsZXN0Q2VsbFdpZHRoKGNlbGxFbCkge1xuICAgIGxldCBhbGxXaWR0aEVsID0gY2VsbEVsLnF1ZXJ5U2VsZWN0b3IoJy5mYy1zY3JvbGxncmlkLXNocmluay1mcmFtZScpO1xuICAgIGxldCBjb250ZW50V2lkdGhFbCA9IGNlbGxFbC5xdWVyeVNlbGVjdG9yKCcuZmMtc2Nyb2xsZ3JpZC1zaHJpbmstY3VzaGlvbicpO1xuICAgIGlmICghYWxsV2lkdGhFbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25lZWRzIGZjLXNjcm9sbGdyaWQtc2hyaW5rLWZyYW1lIGNsYXNzTmFtZScpOyAvLyBUT0RPOiB1c2UgY29uc3RcbiAgICB9XG4gICAgaWYgKCFjb250ZW50V2lkdGhFbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25lZWRzIGZjLXNjcm9sbGdyaWQtc2hyaW5rLWN1c2hpb24gY2xhc3NOYW1lJyk7XG4gICAgfVxuICAgIHJldHVybiBjZWxsRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLSBhbGxXaWR0aEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICsgLy8gdGhlIGNlbGwgcGFkZGluZytib3JkZXJcbiAgICAgICAgY29udGVudFdpZHRoRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG59XG5cbmNvbnN0IElOVEVSTkFMX1VOSVRTID0gWyd5ZWFycycsICdtb250aHMnLCAnZGF5cycsICdtaWxsaXNlY29uZHMnXTtcbmNvbnN0IFBBUlNFX1JFID0gL14oLT8pKD86KFxcZCspXFwuKT8oXFxkKyk6KFxcZFxcZCkoPzo6KFxcZFxcZCkoPzpcXC4oXFxkXFxkXFxkKSk/KT8vO1xuLy8gUGFyc2luZyBhbmQgQ3JlYXRpb25cbmZ1bmN0aW9uIGNyZWF0ZUR1cmF0aW9uKGlucHV0LCB1bml0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlU3RyaW5nKGlucHV0KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiYgaW5wdXQpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICAgIHJldHVybiBwYXJzZU9iamVjdChpbnB1dCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBwYXJzZU9iamVjdCh7IFt1bml0IHx8ICdtaWxsaXNlY29uZHMnXTogaW5wdXQgfSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcGFyc2VTdHJpbmcocykge1xuICAgIGxldCBtID0gUEFSU0VfUkUuZXhlYyhzKTtcbiAgICBpZiAobSkge1xuICAgICAgICBsZXQgc2lnbiA9IG1bMV0gPyAtMSA6IDE7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyczogMCxcbiAgICAgICAgICAgIG1vbnRoczogMCxcbiAgICAgICAgICAgIGRheXM6IHNpZ24gKiAobVsyXSA/IHBhcnNlSW50KG1bMl0sIDEwKSA6IDApLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBzaWduICogKChtWzNdID8gcGFyc2VJbnQobVszXSwgMTApIDogMCkgKiA2MCAqIDYwICogMTAwMCArIC8vIGhvdXJzXG4gICAgICAgICAgICAgICAgKG1bNF0gPyBwYXJzZUludChtWzRdLCAxMCkgOiAwKSAqIDYwICogMTAwMCArIC8vIG1pbnV0ZXNcbiAgICAgICAgICAgICAgICAobVs1XSA/IHBhcnNlSW50KG1bNV0sIDEwKSA6IDApICogMTAwMCArIC8vIHNlY29uZHNcbiAgICAgICAgICAgICAgICAobVs2XSA/IHBhcnNlSW50KG1bNl0sIDEwKSA6IDApIC8vIG1zXG4gICAgICAgICAgICApLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHBhcnNlT2JqZWN0KG9iaikge1xuICAgIGxldCBkdXJhdGlvbiA9IHtcbiAgICAgICAgeWVhcnM6IG9iai55ZWFycyB8fCBvYmoueWVhciB8fCAwLFxuICAgICAgICBtb250aHM6IG9iai5tb250aHMgfHwgb2JqLm1vbnRoIHx8IDAsXG4gICAgICAgIGRheXM6IG9iai5kYXlzIHx8IG9iai5kYXkgfHwgMCxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiAob2JqLmhvdXJzIHx8IG9iai5ob3VyIHx8IDApICogNjAgKiA2MCAqIDEwMDAgKyAvLyBob3Vyc1xuICAgICAgICAgICAgKG9iai5taW51dGVzIHx8IG9iai5taW51dGUgfHwgMCkgKiA2MCAqIDEwMDAgKyAvLyBtaW51dGVzXG4gICAgICAgICAgICAob2JqLnNlY29uZHMgfHwgb2JqLnNlY29uZCB8fCAwKSAqIDEwMDAgKyAvLyBzZWNvbmRzXG4gICAgICAgICAgICAob2JqLm1pbGxpc2Vjb25kcyB8fCBvYmoubWlsbGlzZWNvbmQgfHwgb2JqLm1zIHx8IDApLCAvLyBtc1xuICAgIH07XG4gICAgbGV0IHdlZWtzID0gb2JqLndlZWtzIHx8IG9iai53ZWVrO1xuICAgIGlmICh3ZWVrcykge1xuICAgICAgICBkdXJhdGlvbi5kYXlzICs9IHdlZWtzICogNztcbiAgICAgICAgZHVyYXRpb24uc3BlY2lmaWVkV2Vla3MgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZHVyYXRpb247XG59XG4vLyBFcXVhbGl0eVxuZnVuY3Rpb24gZHVyYXRpb25zRXF1YWwoZDAsIGQxKSB7XG4gICAgcmV0dXJuIGQwLnllYXJzID09PSBkMS55ZWFycyAmJlxuICAgICAgICBkMC5tb250aHMgPT09IGQxLm1vbnRocyAmJlxuICAgICAgICBkMC5kYXlzID09PSBkMS5kYXlzICYmXG4gICAgICAgIGQwLm1pbGxpc2Vjb25kcyA9PT0gZDEubWlsbGlzZWNvbmRzO1xufVxuZnVuY3Rpb24gYXNDbGVhbkRheXMoZHVyKSB7XG4gICAgaWYgKCFkdXIueWVhcnMgJiYgIWR1ci5tb250aHMgJiYgIWR1ci5taWxsaXNlY29uZHMpIHtcbiAgICAgICAgcmV0dXJuIGR1ci5kYXlzO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbi8vIFNpbXBsZSBNYXRoXG5mdW5jdGlvbiBhZGREdXJhdGlvbnMoZDAsIGQxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcnM6IGQwLnllYXJzICsgZDEueWVhcnMsXG4gICAgICAgIG1vbnRoczogZDAubW9udGhzICsgZDEubW9udGhzLFxuICAgICAgICBkYXlzOiBkMC5kYXlzICsgZDEuZGF5cyxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiBkMC5taWxsaXNlY29uZHMgKyBkMS5taWxsaXNlY29uZHMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHN1YnRyYWN0RHVyYXRpb25zKGQxLCBkMCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHllYXJzOiBkMS55ZWFycyAtIGQwLnllYXJzLFxuICAgICAgICBtb250aHM6IGQxLm1vbnRocyAtIGQwLm1vbnRocyxcbiAgICAgICAgZGF5czogZDEuZGF5cyAtIGQwLmRheXMsXG4gICAgICAgIG1pbGxpc2Vjb25kczogZDEubWlsbGlzZWNvbmRzIC0gZDAubWlsbGlzZWNvbmRzLFxuICAgIH07XG59XG5mdW5jdGlvbiBtdWx0aXBseUR1cmF0aW9uKGQsIG4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyczogZC55ZWFycyAqIG4sXG4gICAgICAgIG1vbnRoczogZC5tb250aHMgKiBuLFxuICAgICAgICBkYXlzOiBkLmRheXMgKiBuLFxuICAgICAgICBtaWxsaXNlY29uZHM6IGQubWlsbGlzZWNvbmRzICogbixcbiAgICB9O1xufVxuLy8gQ29udmVyc2lvbnNcbi8vIFwiUm91Z2hcIiBiZWNhdXNlIHRoZXkgYXJlIGJhc2VkIG9uIGF2ZXJhZ2UtY2FzZSBHcmVnb3JpYW4gbW9udGhzL3llYXJzXG5mdW5jdGlvbiBhc1JvdWdoWWVhcnMoZHVyKSB7XG4gICAgcmV0dXJuIGFzUm91Z2hEYXlzKGR1cikgLyAzNjU7XG59XG5mdW5jdGlvbiBhc1JvdWdoTW9udGhzKGR1cikge1xuICAgIHJldHVybiBhc1JvdWdoRGF5cyhkdXIpIC8gMzA7XG59XG5mdW5jdGlvbiBhc1JvdWdoRGF5cyhkdXIpIHtcbiAgICByZXR1cm4gYXNSb3VnaE1zKGR1cikgLyA4NjRlNTtcbn1cbmZ1bmN0aW9uIGFzUm91Z2hNaW51dGVzKGR1cikge1xuICAgIHJldHVybiBhc1JvdWdoTXMoZHVyKSAvICgxMDAwICogNjApO1xufVxuZnVuY3Rpb24gYXNSb3VnaFNlY29uZHMoZHVyKSB7XG4gICAgcmV0dXJuIGFzUm91Z2hNcyhkdXIpIC8gMTAwMDtcbn1cbmZ1bmN0aW9uIGFzUm91Z2hNcyhkdXIpIHtcbiAgICByZXR1cm4gZHVyLnllYXJzICogKDM2NSAqIDg2NGU1KSArXG4gICAgICAgIGR1ci5tb250aHMgKiAoMzAgKiA4NjRlNSkgK1xuICAgICAgICBkdXIuZGF5cyAqIDg2NGU1ICtcbiAgICAgICAgZHVyLm1pbGxpc2Vjb25kcztcbn1cbi8vIEFkdmFuY2VkIE1hdGhcbmZ1bmN0aW9uIHdob2xlRGl2aWRlRHVyYXRpb25zKG51bWVyYXRvciwgZGVub21pbmF0b3IpIHtcbiAgICBsZXQgcmVzID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IElOVEVSTkFMX1VOSVRTLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCB1bml0ID0gSU5URVJOQUxfVU5JVFNbaV07XG4gICAgICAgIGlmIChkZW5vbWluYXRvclt1bml0XSkge1xuICAgICAgICAgICAgbGV0IGxvY2FsUmVzID0gbnVtZXJhdG9yW3VuaXRdIC8gZGVub21pbmF0b3JbdW5pdF07XG4gICAgICAgICAgICBpZiAoIWlzSW50KGxvY2FsUmVzKSB8fCAocmVzICE9PSBudWxsICYmIHJlcyAhPT0gbG9jYWxSZXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMgPSBsb2NhbFJlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChudW1lcmF0b3JbdW5pdF0pIHtcbiAgICAgICAgICAgIC8vIG5lZWRzIHRvIGRpdmlkZSBieSBzb21ldGhpbmcgYnV0IGNhbid0IVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXIpIHtcbiAgICBsZXQgbXMgPSBkdXIubWlsbGlzZWNvbmRzO1xuICAgIGlmIChtcykge1xuICAgICAgICBpZiAobXMgJSAxMDAwICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbWlsbGlzZWNvbmQnLCB2YWx1ZTogbXMgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXMgJSAoMTAwMCAqIDYwKSAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3NlY29uZCcsIHZhbHVlOiBtcyAvIDEwMDAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXMgJSAoMTAwMCAqIDYwICogNjApICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbWludXRlJywgdmFsdWU6IG1zIC8gKDEwMDAgKiA2MCkgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXMpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdob3VyJywgdmFsdWU6IG1zIC8gKDEwMDAgKiA2MCAqIDYwKSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkdXIuZGF5cykge1xuICAgICAgICBpZiAoZHVyLnNwZWNpZmllZFdlZWtzICYmIGR1ci5kYXlzICUgNyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3dlZWsnLCB2YWx1ZTogZHVyLmRheXMgLyA3IH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdW5pdDogJ2RheScsIHZhbHVlOiBkdXIuZGF5cyB9O1xuICAgIH1cbiAgICBpZiAoZHVyLm1vbnRocykge1xuICAgICAgICByZXR1cm4geyB1bml0OiAnbW9udGgnLCB2YWx1ZTogZHVyLm1vbnRocyB9O1xuICAgIH1cbiAgICBpZiAoZHVyLnllYXJzKSB7XG4gICAgICAgIHJldHVybiB7IHVuaXQ6ICd5ZWFyJywgdmFsdWU6IGR1ci55ZWFycyB9O1xuICAgIH1cbiAgICByZXR1cm4geyB1bml0OiAnbWlsbGlzZWNvbmQnLCB2YWx1ZTogMCB9O1xufVxuXG4vLyBUT0RPOiBuZXcgdXRpbCBhcnJheWlmeT9cbmZ1bmN0aW9uIHJlbW92ZUV4YWN0KGFycmF5LCBleGFjdFZhbCkge1xuICAgIGxldCByZW1vdmVDbnQgPSAwO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFycmF5Lmxlbmd0aCkge1xuICAgICAgICBpZiAoYXJyYXlbaV0gPT09IGV4YWN0VmFsKSB7XG4gICAgICAgICAgICBhcnJheS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICByZW1vdmVDbnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVtb3ZlQ250O1xufVxuZnVuY3Rpb24gaXNBcnJheXNFcXVhbChhMCwgYTEsIGVxdWFsaXR5RnVuYykge1xuICAgIGlmIChhMCA9PT0gYTEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBsZW4gPSBhMC5sZW5ndGg7XG4gICAgbGV0IGk7XG4gICAgaWYgKGxlbiAhPT0gYTEubGVuZ3RoKSB7IC8vIG5vdCBhcnJheT8gb3Igbm90IHNhbWUgbGVuZ3RoP1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAoIShlcXVhbGl0eUZ1bmMgPyBlcXVhbGl0eUZ1bmMoYTBbaV0sIGExW2ldKSA6IGEwW2ldID09PSBhMVtpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuY29uc3QgREFZX0lEUyA9IFsnc3VuJywgJ21vbicsICd0dWUnLCAnd2VkJywgJ3RodScsICdmcmknLCAnc2F0J107XG4vLyBBZGRpbmdcbmZ1bmN0aW9uIGFkZFdlZWtzKG0sIG4pIHtcbiAgICBsZXQgYSA9IGRhdGVUb1V0Y0FycmF5KG0pO1xuICAgIGFbMl0gKz0gbiAqIDc7XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGEpO1xufVxuZnVuY3Rpb24gYWRkRGF5cyhtLCBuKSB7XG4gICAgbGV0IGEgPSBkYXRlVG9VdGNBcnJheShtKTtcbiAgICBhWzJdICs9IG47XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGEpO1xufVxuZnVuY3Rpb24gYWRkTXMobSwgbikge1xuICAgIGxldCBhID0gZGF0ZVRvVXRjQXJyYXkobSk7XG4gICAgYVs2XSArPSBuO1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShhKTtcbn1cbi8vIERpZmZpbmcgKGFsbCByZXR1cm4gZmxvYXRzKVxuLy8gVE9ETzogd2h5IG5vdCB1c2UgcmFuZ2VzP1xuZnVuY3Rpb24gZGlmZldlZWtzKG0wLCBtMSkge1xuICAgIHJldHVybiBkaWZmRGF5cyhtMCwgbTEpIC8gNztcbn1cbmZ1bmN0aW9uIGRpZmZEYXlzKG0wLCBtMSkge1xuICAgIHJldHVybiAobTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpKSAvICgxMDAwICogNjAgKiA2MCAqIDI0KTtcbn1cbmZ1bmN0aW9uIGRpZmZIb3VycyhtMCwgbTEpIHtcbiAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyAoMTAwMCAqIDYwICogNjApO1xufVxuZnVuY3Rpb24gZGlmZk1pbnV0ZXMobTAsIG0xKSB7XG4gICAgcmV0dXJuIChtMS52YWx1ZU9mKCkgLSBtMC52YWx1ZU9mKCkpIC8gKDEwMDAgKiA2MCk7XG59XG5mdW5jdGlvbiBkaWZmU2Vjb25kcyhtMCwgbTEpIHtcbiAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyAxMDAwO1xufVxuZnVuY3Rpb24gZGlmZkRheUFuZFRpbWUobTAsIG0xKSB7XG4gICAgbGV0IG0wZGF5ID0gc3RhcnRPZkRheShtMCk7XG4gICAgbGV0IG0xZGF5ID0gc3RhcnRPZkRheShtMSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcnM6IDAsXG4gICAgICAgIG1vbnRoczogMCxcbiAgICAgICAgZGF5czogTWF0aC5yb3VuZChkaWZmRGF5cyhtMGRheSwgbTFkYXkpKSxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiAobTEudmFsdWVPZigpIC0gbTFkYXkudmFsdWVPZigpKSAtIChtMC52YWx1ZU9mKCkgLSBtMGRheS52YWx1ZU9mKCkpLFxuICAgIH07XG59XG4vLyBEaWZmaW5nIFdob2xlIFVuaXRzXG5mdW5jdGlvbiBkaWZmV2hvbGVXZWVrcyhtMCwgbTEpIHtcbiAgICBsZXQgZCA9IGRpZmZXaG9sZURheXMobTAsIG0xKTtcbiAgICBpZiAoZCAhPT0gbnVsbCAmJiBkICUgNyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZCAvIDc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZGlmZldob2xlRGF5cyhtMCwgbTEpIHtcbiAgICBpZiAodGltZUFzTXMobTApID09PSB0aW1lQXNNcyhtMSkpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoZGlmZkRheXMobTAsIG0xKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLy8gU3RhcnQtT2ZcbmZ1bmN0aW9uIHN0YXJ0T2ZEYXkobSkge1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgbS5nZXRVVENNb250aCgpLFxuICAgICAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0T2ZIb3VyKG0pIHtcbiAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoW1xuICAgICAgICBtLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgICAgIG0uZ2V0VVRDTW9udGgoKSxcbiAgICAgICAgbS5nZXRVVENEYXRlKCksXG4gICAgICAgIG0uZ2V0VVRDSG91cnMoKSxcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0T2ZNaW51dGUobSkge1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgbS5nZXRVVENNb250aCgpLFxuICAgICAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgbS5nZXRVVENIb3VycygpLFxuICAgICAgICBtLmdldFVUQ01pbnV0ZXMoKSxcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0T2ZTZWNvbmQobSkge1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgbS5nZXRVVENNb250aCgpLFxuICAgICAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgbS5nZXRVVENIb3VycygpLFxuICAgICAgICBtLmdldFVUQ01pbnV0ZXMoKSxcbiAgICAgICAgbS5nZXRVVENTZWNvbmRzKCksXG4gICAgXSk7XG59XG4vLyBXZWVrIENvbXB1dGF0aW9uXG5mdW5jdGlvbiB3ZWVrT2ZZZWFyKG1hcmtlciwgZG93LCBkb3kpIHtcbiAgICBsZXQgeSA9IG1hcmtlci5nZXRVVENGdWxsWWVhcigpO1xuICAgIGxldCB3ID0gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeSwgZG93LCBkb3kpO1xuICAgIGlmICh3IDwgMSkge1xuICAgICAgICByZXR1cm4gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeSAtIDEsIGRvdywgZG95KTtcbiAgICB9XG4gICAgbGV0IG5leHRXID0gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeSArIDEsIGRvdywgZG95KTtcbiAgICBpZiAobmV4dFcgPj0gMSkge1xuICAgICAgICByZXR1cm4gTWF0aC5taW4odywgbmV4dFcpO1xuICAgIH1cbiAgICByZXR1cm4gdztcbn1cbmZ1bmN0aW9uIHdlZWtPZkdpdmVuWWVhcihtYXJrZXIsIHllYXIsIGRvdywgZG95KSB7XG4gICAgbGV0IGZpcnN0V2Vla1N0YXJ0ID0gYXJyYXlUb1V0Y0RhdGUoW3llYXIsIDAsIDEgKyBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpXSk7XG4gICAgbGV0IGRheVN0YXJ0ID0gc3RhcnRPZkRheShtYXJrZXIpO1xuICAgIGxldCBkYXlzID0gTWF0aC5yb3VuZChkaWZmRGF5cyhmaXJzdFdlZWtTdGFydCwgZGF5U3RhcnQpKTtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihkYXlzIC8gNykgKyAxOyAvLyB6ZXJvLWluZGV4ZWRcbn1cbi8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXG5mdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpIHtcbiAgICAvLyBmaXJzdC13ZWVrIGRheSAtLSB3aGljaCBqYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayAoNCBmb3IgaXNvLCAxIGZvciBvdGhlcilcbiAgICBsZXQgZndkID0gNyArIGRvdyAtIGRveTtcbiAgICAvLyBmaXJzdC13ZWVrIGRheSBsb2NhbCB3ZWVrZGF5IC0tIHdoaWNoIGxvY2FsIHdlZWtkYXkgaXMgZndkXG4gICAgbGV0IGZ3ZGx3ID0gKDcgKyBhcnJheVRvVXRjRGF0ZShbeWVhciwgMCwgZndkXSkuZ2V0VVRDRGF5KCkgLSBkb3cpICUgNztcbiAgICByZXR1cm4gLWZ3ZGx3ICsgZndkIC0gMTtcbn1cbi8vIEFycmF5IENvbnZlcnNpb25cbmZ1bmN0aW9uIGRhdGVUb0xvY2FsQXJyYXkoZGF0ZSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGRhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgZGF0ZS5nZXRNb250aCgpLFxuICAgICAgICBkYXRlLmdldERhdGUoKSxcbiAgICAgICAgZGF0ZS5nZXRIb3VycygpLFxuICAgICAgICBkYXRlLmdldE1pbnV0ZXMoKSxcbiAgICAgICAgZGF0ZS5nZXRTZWNvbmRzKCksXG4gICAgICAgIGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCksXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGFycmF5VG9Mb2NhbERhdGUoYSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShhWzBdLCBhWzFdIHx8IDAsIGFbMl0gPT0gbnVsbCA/IDEgOiBhWzJdLCAvLyBkYXkgb2YgbW9udGhcbiAgICBhWzNdIHx8IDAsIGFbNF0gfHwgMCwgYVs1XSB8fCAwKTtcbn1cbmZ1bmN0aW9uIGRhdGVUb1V0Y0FycmF5KGRhdGUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBkYXRlLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgICAgIGRhdGUuZ2V0VVRDTW9udGgoKSxcbiAgICAgICAgZGF0ZS5nZXRVVENEYXRlKCksXG4gICAgICAgIGRhdGUuZ2V0VVRDSG91cnMoKSxcbiAgICAgICAgZGF0ZS5nZXRVVENNaW51dGVzKCksXG4gICAgICAgIGRhdGUuZ2V0VVRDU2Vjb25kcygpLFxuICAgICAgICBkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpLFxuICAgIF07XG59XG5mdW5jdGlvbiBhcnJheVRvVXRjRGF0ZShhKSB7XG4gICAgLy8gYWNjb3JkaW5nIHRvIHdlYiBzdGFuZGFyZHMgKGFuZCBTYWZhcmkpLCBhIG1vbnRoIGluZGV4IGlzIHJlcXVpcmVkLlxuICAgIC8vIG1hc3NhZ2UgaWYgb25seSBnaXZlbiBhIHllYXIuXG4gICAgaWYgKGEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGEgPSBhLmNvbmNhdChbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoLi4uYSkpO1xufVxuLy8gT3RoZXIgVXRpbHNcbmZ1bmN0aW9uIGlzVmFsaWREYXRlKG0pIHtcbiAgICByZXR1cm4gIWlzTmFOKG0udmFsdWVPZigpKTtcbn1cbmZ1bmN0aW9uIHRpbWVBc01zKG0pIHtcbiAgICByZXR1cm4gbS5nZXRVVENIb3VycygpICogMTAwMCAqIDYwICogNjAgK1xuICAgICAgICBtLmdldFVUQ01pbnV0ZXMoKSAqIDEwMDAgKiA2MCArXG4gICAgICAgIG0uZ2V0VVRDU2Vjb25kcygpICogMTAwMCArXG4gICAgICAgIG0uZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG59XG5cbi8vIHRpbWVab25lT2Zmc2V0IGlzIGluIG1pbnV0ZXNcbmZ1bmN0aW9uIGJ1aWxkSXNvU3RyaW5nKG1hcmtlciwgdGltZVpvbmVPZmZzZXQsIHN0cmlwWmVyb1RpbWUgPSBmYWxzZSkge1xuICAgIGxldCBzID0gbWFya2VyLnRvSVNPU3RyaW5nKCk7XG4gICAgcyA9IHMucmVwbGFjZSgnLjAwMCcsICcnKTtcbiAgICBpZiAoc3RyaXBaZXJvVGltZSkge1xuICAgICAgICBzID0gcy5yZXBsYWNlKCdUMDA6MDA6MDBaJywgJycpO1xuICAgIH1cbiAgICBpZiAocy5sZW5ndGggPiAxMCkgeyAvLyB0aW1lIHBhcnQgd2Fzbid0IHN0cmlwcGVkLCBjYW4gYWRkIHRpbWV6b25lIGluZm9cbiAgICAgICAgaWYgKHRpbWVab25lT2Zmc2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJ1onLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGltZVpvbmVPZmZzZXQgIT09IDApIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJ1onLCBmb3JtYXRUaW1lWm9uZU9mZnNldCh0aW1lWm9uZU9mZnNldCwgdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG90aGVyd2lzZSwgaXRzIFVUQy0wIGFuZCB3ZSB3YW50IHRvIGtlZXAgdGhlIFpcbiAgICB9XG4gICAgcmV0dXJuIHM7XG59XG4vLyBmb3JtYXRzIHRoZSBkYXRlLCBidXQgd2l0aCBubyB0aW1lIHBhcnRcbi8vIFRPRE86IHNvbWVob3cgbWVyZ2Ugd2l0aCBidWlsZElzb1N0cmluZyBhbmQgc3RyaXBaZXJvVGltZVxuLy8gVE9ETzogcmVuYW1lLiBvbWl0IFwic3RyaW5nXCJcbmZ1bmN0aW9uIGZvcm1hdERheVN0cmluZyhtYXJrZXIpIHtcbiAgICByZXR1cm4gbWFya2VyLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvVC4qJC8sICcnKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdElzb01vbnRoU3RyKG1hcmtlcikge1xuICAgIHJldHVybiBtYXJrZXIudG9JU09TdHJpbmcoKS5tYXRjaCgvXlxcZHs0fS1cXGR7Mn0vKVswXTtcbn1cbi8vIFRPRE86IHVzZSBEYXRlOjp0b0lTT1N0cmluZyBhbmQgdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIFQ/XG5mdW5jdGlvbiBmb3JtYXRJc29UaW1lU3RyaW5nKG1hcmtlcikge1xuICAgIHJldHVybiBwYWRTdGFydChtYXJrZXIuZ2V0VVRDSG91cnMoKSwgMikgKyAnOicgK1xuICAgICAgICBwYWRTdGFydChtYXJrZXIuZ2V0VVRDTWludXRlcygpLCAyKSArICc6JyArXG4gICAgICAgIHBhZFN0YXJ0KG1hcmtlci5nZXRVVENTZWNvbmRzKCksIDIpO1xufVxuZnVuY3Rpb24gZm9ybWF0VGltZVpvbmVPZmZzZXQobWludXRlcywgZG9Jc28gPSBmYWxzZSkge1xuICAgIGxldCBzaWduID0gbWludXRlcyA8IDAgPyAnLScgOiAnKyc7XG4gICAgbGV0IGFicyA9IE1hdGguYWJzKG1pbnV0ZXMpO1xuICAgIGxldCBob3VycyA9IE1hdGguZmxvb3IoYWJzIC8gNjApO1xuICAgIGxldCBtaW5zID0gTWF0aC5yb3VuZChhYnMgJSA2MCk7XG4gICAgaWYgKGRvSXNvKSB7XG4gICAgICAgIHJldHVybiBgJHtzaWduICsgcGFkU3RhcnQoaG91cnMsIDIpfToke3BhZFN0YXJ0KG1pbnMsIDIpfWA7XG4gICAgfVxuICAgIHJldHVybiBgR01UJHtzaWdufSR7aG91cnN9JHttaW5zID8gYDoke3BhZFN0YXJ0KG1pbnMsIDIpfWAgOiAnJ31gO1xufVxuXG5mdW5jdGlvbiBtZW1vaXplKHdvcmtlckZ1bmMsIHJlc0VxdWFsaXR5LCB0ZWFyZG93bkZ1bmMpIHtcbiAgICBsZXQgY3VycmVudEFyZ3M7XG4gICAgbGV0IGN1cnJlbnRSZXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5uZXdBcmdzKSB7XG4gICAgICAgIGlmICghY3VycmVudEFyZ3MpIHtcbiAgICAgICAgICAgIGN1cnJlbnRSZXMgPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpc0FycmF5c0VxdWFsKGN1cnJlbnRBcmdzLCBuZXdBcmdzKSkge1xuICAgICAgICAgICAgaWYgKHRlYXJkb3duRnVuYykge1xuICAgICAgICAgICAgICAgIHRlYXJkb3duRnVuYyhjdXJyZW50UmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXMgPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ3MpO1xuICAgICAgICAgICAgaWYgKCFyZXNFcXVhbGl0eSB8fCAhcmVzRXF1YWxpdHkocmVzLCBjdXJyZW50UmVzKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRSZXMgPSByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEFyZ3MgPSBuZXdBcmdzO1xuICAgICAgICByZXR1cm4gY3VycmVudFJlcztcbiAgICB9O1xufVxuZnVuY3Rpb24gbWVtb2l6ZU9iakFyZyh3b3JrZXJGdW5jLCByZXNFcXVhbGl0eSwgdGVhcmRvd25GdW5jKSB7XG4gICAgbGV0IGN1cnJlbnRBcmc7XG4gICAgbGV0IGN1cnJlbnRSZXM7XG4gICAgcmV0dXJuIChuZXdBcmcpID0+IHtcbiAgICAgICAgaWYgKCFjdXJyZW50QXJnKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVzID0gd29ya2VyRnVuYy5jYWxsKHRoaXMsIG5ld0FyZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzUHJvcHNFcXVhbChjdXJyZW50QXJnLCBuZXdBcmcpKSB7XG4gICAgICAgICAgICBpZiAodGVhcmRvd25GdW5jKSB7XG4gICAgICAgICAgICAgICAgdGVhcmRvd25GdW5jKGN1cnJlbnRSZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlcyA9IHdvcmtlckZ1bmMuY2FsbCh0aGlzLCBuZXdBcmcpO1xuICAgICAgICAgICAgaWYgKCFyZXNFcXVhbGl0eSB8fCAhcmVzRXF1YWxpdHkocmVzLCBjdXJyZW50UmVzKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRSZXMgPSByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEFyZyA9IG5ld0FyZztcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXM7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1lbW9pemVBcnJheWxpa2UoLy8gdXNlZCBhdCBhbGw/XG53b3JrZXJGdW5jLCByZXNFcXVhbGl0eSwgdGVhcmRvd25GdW5jKSB7XG4gICAgbGV0IGN1cnJlbnRBcmdTZXRzID0gW107XG4gICAgbGV0IGN1cnJlbnRSZXN1bHRzID0gW107XG4gICAgcmV0dXJuIChuZXdBcmdTZXRzKSA9PiB7XG4gICAgICAgIGxldCBjdXJyZW50TGVuID0gY3VycmVudEFyZ1NldHMubGVuZ3RoO1xuICAgICAgICBsZXQgbmV3TGVuID0gbmV3QXJnU2V0cy5sZW5ndGg7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yICg7IGkgPCBjdXJyZW50TGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmICghbmV3QXJnU2V0c1tpXSkgeyAvLyBvbmUgb2YgdGhlIG9sZCBzZXRzIG5vIGxvbmdlciBleGlzdHNcbiAgICAgICAgICAgICAgICBpZiAodGVhcmRvd25GdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlYXJkb3duRnVuYyhjdXJyZW50UmVzdWx0c1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzQXJyYXlzRXF1YWwoY3VycmVudEFyZ1NldHNbaV0sIG5ld0FyZ1NldHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRlYXJkb3duRnVuYykge1xuICAgICAgICAgICAgICAgICAgICB0ZWFyZG93bkZ1bmMoY3VycmVudFJlc3VsdHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmVzID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdTZXRzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc0VxdWFsaXR5IHx8ICFyZXNFcXVhbGl0eShyZXMsIGN1cnJlbnRSZXN1bHRzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVzdWx0c1tpXSA9IHJlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGkgPCBuZXdMZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgY3VycmVudFJlc3VsdHNbaV0gPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ1NldHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRBcmdTZXRzID0gbmV3QXJnU2V0cztcbiAgICAgICAgY3VycmVudFJlc3VsdHMuc3BsaWNlKG5ld0xlbik7IC8vIHJlbW92ZSBleGNlc3NcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXN1bHRzO1xuICAgIH07XG59XG5mdW5jdGlvbiBtZW1vaXplSGFzaGxpa2Uod29ya2VyRnVuYywgcmVzRXF1YWxpdHksIHRlYXJkb3duRnVuYykge1xuICAgIGxldCBjdXJyZW50QXJnSGFzaCA9IHt9O1xuICAgIGxldCBjdXJyZW50UmVzSGFzaCA9IHt9O1xuICAgIHJldHVybiAobmV3QXJnSGFzaCkgPT4ge1xuICAgICAgICBsZXQgbmV3UmVzSGFzaCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gbmV3QXJnSGFzaCkge1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50UmVzSGFzaFtrZXldKSB7XG4gICAgICAgICAgICAgICAgbmV3UmVzSGFzaFtrZXldID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdIYXNoW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzQXJyYXlzRXF1YWwoY3VycmVudEFyZ0hhc2hba2V5XSwgbmV3QXJnSGFzaFtrZXldKSkge1xuICAgICAgICAgICAgICAgIGlmICh0ZWFyZG93bkZ1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVhcmRvd25GdW5jKGN1cnJlbnRSZXNIYXNoW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmVzID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdIYXNoW2tleV0pO1xuICAgICAgICAgICAgICAgIG5ld1Jlc0hhc2hba2V5XSA9IChyZXNFcXVhbGl0eSAmJiByZXNFcXVhbGl0eShyZXMsIGN1cnJlbnRSZXNIYXNoW2tleV0pKVxuICAgICAgICAgICAgICAgICAgICA/IGN1cnJlbnRSZXNIYXNoW2tleV1cbiAgICAgICAgICAgICAgICAgICAgOiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdSZXNIYXNoW2tleV0gPSBjdXJyZW50UmVzSGFzaFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRBcmdIYXNoID0gbmV3QXJnSGFzaDtcbiAgICAgICAgY3VycmVudFJlc0hhc2ggPSBuZXdSZXNIYXNoO1xuICAgICAgICByZXR1cm4gbmV3UmVzSGFzaDtcbiAgICB9O1xufVxuXG5jb25zdCBFWFRFTkRFRF9TRVRUSU5HU19BTkRfU0VWRVJJVElFUyA9IHtcbiAgICB3ZWVrOiAzLFxuICAgIHNlcGFyYXRvcjogMCxcbiAgICBvbWl0WmVyb01pbnV0ZTogMCxcbiAgICBtZXJpZGllbTogMCxcbiAgICBvbWl0Q29tbWFzOiAwLFxufTtcbmNvbnN0IFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTID0ge1xuICAgIHRpbWVab25lTmFtZTogNyxcbiAgICBlcmE6IDYsXG4gICAgeWVhcjogNSxcbiAgICBtb250aDogNCxcbiAgICBkYXk6IDIsXG4gICAgd2Vla2RheTogMixcbiAgICBob3VyOiAxLFxuICAgIG1pbnV0ZTogMSxcbiAgICBzZWNvbmQ6IDEsXG59O1xuY29uc3QgTUVSSURJRU1fUkUgPSAvXFxzKihbYXBdKVxcLj9tXFwuPy9pOyAvLyBlYXRzIHVwIGxlYWRpbmcgc3BhY2VzIHRvb1xuY29uc3QgQ09NTUFfUkUgPSAvLC9nOyAvLyB3ZSBuZWVkIHJlIGZvciBnbG9iYWxuZXNzXG5jb25zdCBNVUxUSV9TUEFDRV9SRSA9IC9cXHMrL2c7XG5jb25zdCBMVFJfUkUgPSAvXFx1MjAwZS9nOyAvLyBjb250cm9sIGNoYXJhY3RlclxuY29uc3QgVVRDX1JFID0gL1VUQ3xHTVQvO1xuY2xhc3MgTmF0aXZlRm9ybWF0dGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihmb3JtYXRTZXR0aW5ncykge1xuICAgICAgICBsZXQgc3RhbmRhcmREYXRlUHJvcHMgPSB7fTtcbiAgICAgICAgbGV0IGV4dGVuZGVkU2V0dGluZ3MgPSB7fTtcbiAgICAgICAgbGV0IHNldmVyaXR5ID0gMDtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBmb3JtYXRTZXR0aW5ncykge1xuICAgICAgICAgICAgaWYgKG5hbWUgaW4gRVhURU5ERURfU0VUVElOR1NfQU5EX1NFVkVSSVRJRVMpIHtcbiAgICAgICAgICAgICAgICBleHRlbmRlZFNldHRpbmdzW25hbWVdID0gZm9ybWF0U2V0dGluZ3NbbmFtZV07XG4gICAgICAgICAgICAgICAgc2V2ZXJpdHkgPSBNYXRoLm1heChFWFRFTkRFRF9TRVRUSU5HU19BTkRfU0VWRVJJVElFU1tuYW1lXSwgc2V2ZXJpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhbmRhcmREYXRlUHJvcHNbbmFtZV0gPSBmb3JtYXRTZXR0aW5nc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSBpbiBTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFUykgeyAvLyBUT0RPOiB3aGF0IGFib3V0IGhvdXIxMj8gbm8gc2V2ZXJpdHlcbiAgICAgICAgICAgICAgICAgICAgc2V2ZXJpdHkgPSBNYXRoLm1heChTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFU1tuYW1lXSwgc2V2ZXJpdHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YW5kYXJkRGF0ZVByb3BzID0gc3RhbmRhcmREYXRlUHJvcHM7XG4gICAgICAgIHRoaXMuZXh0ZW5kZWRTZXR0aW5ncyA9IGV4dGVuZGVkU2V0dGluZ3M7XG4gICAgICAgIHRoaXMuc2V2ZXJpdHkgPSBzZXZlcml0eTtcbiAgICAgICAgdGhpcy5idWlsZEZvcm1hdHRpbmdGdW5jID0gbWVtb2l6ZShidWlsZEZvcm1hdHRpbmdGdW5jKTtcbiAgICB9XG4gICAgZm9ybWF0KGRhdGUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRGb3JtYXR0aW5nRnVuYyh0aGlzLnN0YW5kYXJkRGF0ZVByb3BzLCB0aGlzLmV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpKGRhdGUpO1xuICAgIH1cbiAgICBmb3JtYXRSYW5nZShzdGFydCwgZW5kLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSB7XG4gICAgICAgIGxldCB7IHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgZGlmZlNldmVyaXR5ID0gY29tcHV0ZU1hcmtlckRpZmZTZXZlcml0eShzdGFydC5tYXJrZXIsIGVuZC5tYXJrZXIsIGNvbnRleHQuY2FsZW5kYXJTeXN0ZW0pO1xuICAgICAgICBpZiAoIWRpZmZTZXZlcml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KHN0YXJ0LCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsID0gZGlmZlNldmVyaXR5O1xuICAgICAgICBpZiAoYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsID4gMSAmJiAvLyB0aGUgdHdvIGRhdGVzIGFyZSBkaWZmZXJlbnQgaW4gYSB3YXkgdGhhdCdzIGxhcmdlciBzY2FsZSB0aGFuIHRpbWVcbiAgICAgICAgICAgIChzdGFuZGFyZERhdGVQcm9wcy55ZWFyID09PSAnbnVtZXJpYycgfHwgc3RhbmRhcmREYXRlUHJvcHMueWVhciA9PT0gJzItZGlnaXQnKSAmJlxuICAgICAgICAgICAgKHN0YW5kYXJkRGF0ZVByb3BzLm1vbnRoID09PSAnbnVtZXJpYycgfHwgc3RhbmRhcmREYXRlUHJvcHMubW9udGggPT09ICcyLWRpZ2l0JykgJiZcbiAgICAgICAgICAgIChzdGFuZGFyZERhdGVQcm9wcy5kYXkgPT09ICdudW1lcmljJyB8fCBzdGFuZGFyZERhdGVQcm9wcy5kYXkgPT09ICcyLWRpZ2l0JykpIHtcbiAgICAgICAgICAgIGJpZ2dlc3RVbml0Rm9yUGFydGlhbCA9IDE7IC8vIG1ha2UgaXQgbG9vayBsaWtlIHRoZSBkYXRlcyBhcmUgb25seSBkaWZmZXJlbnQgaW4gdGVybXMgb2YgdGltZVxuICAgICAgICB9XG4gICAgICAgIGxldCBmdWxsMCA9IHRoaXMuZm9ybWF0KHN0YXJ0LCBjb250ZXh0KTtcbiAgICAgICAgbGV0IGZ1bGwxID0gdGhpcy5mb3JtYXQoZW5kLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGZ1bGwwID09PSBmdWxsMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bGwwO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJ0aWFsRGF0ZVByb3BzID0gY29tcHV0ZVBhcnRpYWxGb3JtYXR0aW5nT3B0aW9ucyhzdGFuZGFyZERhdGVQcm9wcywgYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsKTtcbiAgICAgICAgbGV0IHBhcnRpYWxGb3JtYXR0aW5nRnVuYyA9IGJ1aWxkRm9ybWF0dGluZ0Z1bmMocGFydGlhbERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCk7XG4gICAgICAgIGxldCBwYXJ0aWFsMCA9IHBhcnRpYWxGb3JtYXR0aW5nRnVuYyhzdGFydCk7XG4gICAgICAgIGxldCBwYXJ0aWFsMSA9IHBhcnRpYWxGb3JtYXR0aW5nRnVuYyhlbmQpO1xuICAgICAgICBsZXQgaW5zZXJ0aW9uID0gZmluZENvbW1vbkluc2VydGlvbihmdWxsMCwgcGFydGlhbDAsIGZ1bGwxLCBwYXJ0aWFsMSk7XG4gICAgICAgIGxldCBzZXBhcmF0b3IgPSBleHRlbmRlZFNldHRpbmdzLnNlcGFyYXRvciB8fCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yIHx8IGNvbnRleHQuZGVmYXVsdFNlcGFyYXRvciB8fCAnJztcbiAgICAgICAgaWYgKGluc2VydGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGluc2VydGlvbi5iZWZvcmUgKyBwYXJ0aWFsMCArIHNlcGFyYXRvciArIHBhcnRpYWwxICsgaW5zZXJ0aW9uLmFmdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdWxsMCArIHNlcGFyYXRvciArIGZ1bGwxO1xuICAgIH1cbiAgICBnZXRMYXJnZXN0VW5pdCgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnNldmVyaXR5KSB7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICd5ZWFyJztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ21vbnRoJztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3dlZWsnO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiAnZGF5JztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICd0aW1lJzsgLy8gcmVhbGx5P1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGRGb3JtYXR0aW5nRnVuYyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCkge1xuICAgIGxldCBzdGFuZGFyZERhdGVQcm9wQ250ID0gT2JqZWN0LmtleXMoc3RhbmRhcmREYXRlUHJvcHMpLmxlbmd0aDtcbiAgICBpZiAoc3RhbmRhcmREYXRlUHJvcENudCA9PT0gMSAmJiBzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUgPT09ICdzaG9ydCcpIHtcbiAgICAgICAgcmV0dXJuIChkYXRlKSA9PiAoZm9ybWF0VGltZVpvbmVPZmZzZXQoZGF0ZS50aW1lWm9uZU9mZnNldCkpO1xuICAgIH1cbiAgICBpZiAoc3RhbmRhcmREYXRlUHJvcENudCA9PT0gMCAmJiBleHRlbmRlZFNldHRpbmdzLndlZWspIHtcbiAgICAgICAgcmV0dXJuIChkYXRlKSA9PiAoZm9ybWF0V2Vla051bWJlcihjb250ZXh0LmNvbXB1dGVXZWVrTnVtYmVyKGRhdGUubWFya2VyKSwgY29udGV4dC53ZWVrVGV4dCwgY29udGV4dC53ZWVrVGV4dExvbmcsIGNvbnRleHQubG9jYWxlLCBleHRlbmRlZFNldHRpbmdzLndlZWspKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1aWxkTmF0aXZlRm9ybWF0dGluZ0Z1bmMoc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gYnVpbGROYXRpdmVGb3JtYXR0aW5nRnVuYyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCkge1xuICAgIHN0YW5kYXJkRGF0ZVByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhbmRhcmREYXRlUHJvcHMpOyAvLyBjb3B5XG4gICAgZXh0ZW5kZWRTZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIGV4dGVuZGVkU2V0dGluZ3MpOyAvLyBjb3B5XG4gICAgc2FuaXRpemVTZXR0aW5ncyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncyk7XG4gICAgc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmUgPSAnVVRDJzsgLy8gd2UgbGV2ZXJhZ2UgdGhlIG9ubHkgZ3VhcmFudGVlZCB0aW1lWm9uZSBmb3Igb3VyIFVUQyBtYXJrZXJzXG4gICAgbGV0IG5vcm1hbEZvcm1hdCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGNvbnRleHQubG9jYWxlLmNvZGVzLCBzdGFuZGFyZERhdGVQcm9wcyk7XG4gICAgbGV0IHplcm9Gb3JtYXQ7IC8vIG5lZWRlZD9cbiAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5vbWl0WmVyb01pbnV0ZSkge1xuICAgICAgICBsZXQgemVyb1Byb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhbmRhcmREYXRlUHJvcHMpO1xuICAgICAgICBkZWxldGUgemVyb1Byb3BzLm1pbnV0ZTsgLy8gc2Vjb25kcyBhbmQgbXMgd2VyZSBhbHJlYWR5IGNvbnNpZGVyZWQgaW4gc2FuaXRpemVTZXR0aW5nc1xuICAgICAgICB6ZXJvRm9ybWF0ID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoY29udGV4dC5sb2NhbGUuY29kZXMsIHplcm9Qcm9wcyk7XG4gICAgfVxuICAgIHJldHVybiAoZGF0ZSkgPT4ge1xuICAgICAgICBsZXQgeyBtYXJrZXIgfSA9IGRhdGU7XG4gICAgICAgIGxldCBmb3JtYXQ7XG4gICAgICAgIGlmICh6ZXJvRm9ybWF0ICYmICFtYXJrZXIuZ2V0VVRDTWludXRlcygpKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSB6ZXJvRm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0ID0gbm9ybWFsRm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIGxldCBzID0gZm9ybWF0LmZvcm1hdChtYXJrZXIpO1xuICAgICAgICByZXR1cm4gcG9zdFByb2Nlc3MocywgZGF0ZSwgc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBzYW5pdGl6ZVNldHRpbmdzKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzKSB7XG4gICAgLy8gZGVhbCB3aXRoIGEgYnJvd3NlciBpbmNvbnNpc3RlbmN5IHdoZXJlIGZvcm1hdHRpbmcgdGhlIHRpbWV6b25lXG4gICAgLy8gcmVxdWlyZXMgdGhhdCB0aGUgaG91ci9taW51dGUgYmUgcHJlc2VudC5cbiAgICBpZiAoc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmVOYW1lKSB7XG4gICAgICAgIGlmICghc3RhbmRhcmREYXRlUHJvcHMuaG91cikge1xuICAgICAgICAgICAgc3RhbmRhcmREYXRlUHJvcHMuaG91ciA9ICcyLWRpZ2l0JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0YW5kYXJkRGF0ZVByb3BzLm1pbnV0ZSkge1xuICAgICAgICAgICAgc3RhbmRhcmREYXRlUHJvcHMubWludXRlID0gJzItZGlnaXQnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG9ubHkgc3VwcG9ydCBzaG9ydCB0aW1lem9uZSBuYW1lc1xuICAgIGlmIChzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUgPT09ICdsb25nJykge1xuICAgICAgICBzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUgPSAnc2hvcnQnO1xuICAgIH1cbiAgICAvLyBpZiByZXF1ZXN0aW5nIHRvIGRpc3BsYXkgc2Vjb25kcywgTVVTVCBkaXNwbGF5IG1pbnV0ZXNcbiAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5vbWl0WmVyb01pbnV0ZSAmJiAoc3RhbmRhcmREYXRlUHJvcHMuc2Vjb25kIHx8IHN0YW5kYXJkRGF0ZVByb3BzLm1pbGxpc2Vjb25kKSkge1xuICAgICAgICBkZWxldGUgZXh0ZW5kZWRTZXR0aW5ncy5vbWl0WmVyb01pbnV0ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBwb3N0UHJvY2VzcyhzLCBkYXRlLCBzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCkge1xuICAgIHMgPSBzLnJlcGxhY2UoTFRSX1JFLCAnJyk7IC8vIHJlbW92ZSBsZWZ0LXRvLXJpZ2h0IGNvbnRyb2wgY2hhcnMuIGRvIGZpcnN0LiBnb29kIGZvciBvdGhlciByZWdleGVzXG4gICAgaWYgKHN0YW5kYXJkRGF0ZVByb3BzLnRpbWVab25lTmFtZSA9PT0gJ3Nob3J0Jykge1xuICAgICAgICBzID0gaW5qZWN0VHpvU3RyKHMsIChjb250ZXh0LnRpbWVab25lID09PSAnVVRDJyB8fCBkYXRlLnRpbWVab25lT2Zmc2V0ID09IG51bGwpID9cbiAgICAgICAgICAgICdVVEMnIDogLy8gaW1wb3J0YW50IHRvIG5vcm1hbGl6ZSBmb3IgSUUsIHdoaWNoIGRvZXMgXCJHTVRcIlxuICAgICAgICAgICAgZm9ybWF0VGltZVpvbmVPZmZzZXQoZGF0ZS50aW1lWm9uZU9mZnNldCkpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5vbWl0Q29tbWFzKSB7XG4gICAgICAgIHMgPSBzLnJlcGxhY2UoQ09NTUFfUkUsICcnKS50cmltKCk7XG4gICAgfVxuICAgIGlmIChleHRlbmRlZFNldHRpbmdzLm9taXRaZXJvTWludXRlKSB7XG4gICAgICAgIHMgPSBzLnJlcGxhY2UoJzowMCcsICcnKTsgLy8gemVyb0Zvcm1hdCBkb2Vzbid0IGFsd2F5cyBhY2hpZXZlIHRoaXNcbiAgICB9XG4gICAgLy8gXiBkbyBhbnl0aGluZyB0aGF0IG1pZ2h0IGNyZWF0ZSBhZGphY2VudCBzcGFjZXMgYmVmb3JlIHRoaXMgcG9pbnQsXG4gICAgLy8gYmVjYXVzZSBNRVJJRElFTV9SRSBsaWtlcyB0byBlYXQgdXAgbG9hZGluZyBzcGFjZXNcbiAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5tZXJpZGllbSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcyA9IHMucmVwbGFjZShNRVJJRElFTV9SRSwgJycpLnRyaW0oKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5tZXJpZGllbSA9PT0gJ25hcnJvdycpIHsgLy8gYS9wXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsIChtMCwgbTEpID0+IG0xLnRvTG9jYWxlTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHRlbmRlZFNldHRpbmdzLm1lcmlkaWVtID09PSAnc2hvcnQnKSB7IC8vIGFtL3BtXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsIChtMCwgbTEpID0+IGAke20xLnRvTG9jYWxlTG93ZXJDYXNlKCl9bWApO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHRlbmRlZFNldHRpbmdzLm1lcmlkaWVtID09PSAnbG93ZXJjYXNlJykgeyAvLyBvdGhlciBtZXJpZGllbSB0cmFuc2Zvcm1lcnMgYWxyZWFkeSBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsIChtMCkgPT4gbTAudG9Mb2NhbGVMb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIHMgPSBzLnJlcGxhY2UoTVVMVElfU1BBQ0VfUkUsICcgJyk7XG4gICAgcyA9IHMudHJpbSgpO1xuICAgIHJldHVybiBzO1xufVxuZnVuY3Rpb24gaW5qZWN0VHpvU3RyKHMsIHR6b1N0cikge1xuICAgIGxldCByZXBsYWNlZCA9IGZhbHNlO1xuICAgIHMgPSBzLnJlcGxhY2UoVVRDX1JFLCAoKSA9PiB7XG4gICAgICAgIHJlcGxhY2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHR6b1N0cjtcbiAgICB9KTtcbiAgICAvLyBJRTExIGRvZXNuJ3QgaW5jbHVkZSBVVEMvR01UIGluIHRoZSBvcmlnaW5hbCBzdHJpbmcsIHNvIGFwcGVuZCB0byBlbmRcbiAgICBpZiAoIXJlcGxhY2VkKSB7XG4gICAgICAgIHMgKz0gYCAke3R6b1N0cn1gO1xuICAgIH1cbiAgICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIGZvcm1hdFdlZWtOdW1iZXIobnVtLCB3ZWVrVGV4dCwgd2Vla1RleHRMb25nLCBsb2NhbGUsIGRpc3BsYXkpIHtcbiAgICBsZXQgcGFydHMgPSBbXTtcbiAgICBpZiAoZGlzcGxheSA9PT0gJ2xvbmcnKSB7XG4gICAgICAgIHBhcnRzLnB1c2god2Vla1RleHRMb25nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGlzcGxheSA9PT0gJ3Nob3J0JyB8fCBkaXNwbGF5ID09PSAnbmFycm93Jykge1xuICAgICAgICBwYXJ0cy5wdXNoKHdlZWtUZXh0KTtcbiAgICB9XG4gICAgaWYgKGRpc3BsYXkgPT09ICdsb25nJyB8fCBkaXNwbGF5ID09PSAnc2hvcnQnKSB7XG4gICAgICAgIHBhcnRzLnB1c2goJyAnKTtcbiAgICB9XG4gICAgcGFydHMucHVzaChsb2NhbGUuc2ltcGxlTnVtYmVyRm9ybWF0LmZvcm1hdChudW0pKTtcbiAgICBpZiAobG9jYWxlLm9wdGlvbnMuZGlyZWN0aW9uID09PSAncnRsJykgeyAvLyBUT0RPOiB1c2UgY29udHJvbCBjaGFyYWN0ZXJzIGluc3RlYWQ/XG4gICAgICAgIHBhcnRzLnJldmVyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJycpO1xufVxuLy8gUmFuZ2UgRm9ybWF0dGluZyBVdGlsc1xuLy8gMCA9IGV4YWN0bHkgdGhlIHNhbWVcbi8vIDEgPSBkaWZmZXJlbnQgYnkgdGltZVxuLy8gYW5kIGJpZ2dlclxuZnVuY3Rpb24gY29tcHV0ZU1hcmtlckRpZmZTZXZlcml0eShkMCwgZDEsIGNhKSB7XG4gICAgaWYgKGNhLmdldE1hcmtlclllYXIoZDApICE9PSBjYS5nZXRNYXJrZXJZZWFyKGQxKSkge1xuICAgICAgICByZXR1cm4gNTtcbiAgICB9XG4gICAgaWYgKGNhLmdldE1hcmtlck1vbnRoKGQwKSAhPT0gY2EuZ2V0TWFya2VyTW9udGgoZDEpKSB7XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cbiAgICBpZiAoY2EuZ2V0TWFya2VyRGF5KGQwKSAhPT0gY2EuZ2V0TWFya2VyRGF5KGQxKSkge1xuICAgICAgICByZXR1cm4gMjtcbiAgICB9XG4gICAgaWYgKHRpbWVBc01zKGQwKSAhPT0gdGltZUFzTXMoZDEpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVQYXJ0aWFsRm9ybWF0dGluZ09wdGlvbnMob3B0aW9ucywgYmlnZ2VzdFVuaXQpIHtcbiAgICBsZXQgcGFydGlhbE9wdGlvbnMgPSB7fTtcbiAgICBmb3IgKGxldCBuYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCEobmFtZSBpbiBTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFUykgfHwgLy8gbm90IGEgZGF0ZSBwYXJ0IHByb3AgKGxpa2UgdGltZVpvbmUpXG4gICAgICAgICAgICBTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFU1tuYW1lXSA8PSBiaWdnZXN0VW5pdCkge1xuICAgICAgICAgICAgcGFydGlhbE9wdGlvbnNbbmFtZV0gPSBvcHRpb25zW25hbWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJ0aWFsT3B0aW9ucztcbn1cbmZ1bmN0aW9uIGZpbmRDb21tb25JbnNlcnRpb24oZnVsbDAsIHBhcnRpYWwwLCBmdWxsMSwgcGFydGlhbDEpIHtcbiAgICBsZXQgaTAgPSAwO1xuICAgIHdoaWxlIChpMCA8IGZ1bGwwLmxlbmd0aCkge1xuICAgICAgICBsZXQgZm91bmQwID0gZnVsbDAuaW5kZXhPZihwYXJ0aWFsMCwgaTApO1xuICAgICAgICBpZiAoZm91bmQwID09PSAtMSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJlZm9yZTAgPSBmdWxsMC5zdWJzdHIoMCwgZm91bmQwKTtcbiAgICAgICAgaTAgPSBmb3VuZDAgKyBwYXJ0aWFsMC5sZW5ndGg7XG4gICAgICAgIGxldCBhZnRlcjAgPSBmdWxsMC5zdWJzdHIoaTApO1xuICAgICAgICBsZXQgaTEgPSAwO1xuICAgICAgICB3aGlsZSAoaTEgPCBmdWxsMS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBmb3VuZDEgPSBmdWxsMS5pbmRleE9mKHBhcnRpYWwxLCBpMSk7XG4gICAgICAgICAgICBpZiAoZm91bmQxID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGJlZm9yZTEgPSBmdWxsMS5zdWJzdHIoMCwgZm91bmQxKTtcbiAgICAgICAgICAgIGkxID0gZm91bmQxICsgcGFydGlhbDEubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGFmdGVyMSA9IGZ1bGwxLnN1YnN0cihpMSk7XG4gICAgICAgICAgICBpZiAoYmVmb3JlMCA9PT0gYmVmb3JlMSAmJiBhZnRlcjAgPT09IGFmdGVyMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZTogYmVmb3JlMCxcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXI6IGFmdGVyMCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBleHBhbmRab25lZE1hcmtlcihkYXRlSW5mbywgY2FsZW5kYXJTeXN0ZW0pIHtcbiAgICBsZXQgYSA9IGNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkoZGF0ZUluZm8ubWFya2VyKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBtYXJrZXI6IGRhdGVJbmZvLm1hcmtlcixcbiAgICAgICAgdGltZVpvbmVPZmZzZXQ6IGRhdGVJbmZvLnRpbWVab25lT2Zmc2V0LFxuICAgICAgICBhcnJheTogYSxcbiAgICAgICAgeWVhcjogYVswXSxcbiAgICAgICAgbW9udGg6IGFbMV0sXG4gICAgICAgIGRheTogYVsyXSxcbiAgICAgICAgaG91cjogYVszXSxcbiAgICAgICAgbWludXRlOiBhWzRdLFxuICAgICAgICBzZWNvbmQ6IGFbNV0sXG4gICAgICAgIG1pbGxpc2Vjb25kOiBhWzZdLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICBsZXQgc3RhcnRJbmZvID0gZXhwYW5kWm9uZWRNYXJrZXIoc3RhcnQsIGNvbnRleHQuY2FsZW5kYXJTeXN0ZW0pO1xuICAgIGxldCBlbmRJbmZvID0gZW5kID8gZXhwYW5kWm9uZWRNYXJrZXIoZW5kLCBjb250ZXh0LmNhbGVuZGFyU3lzdGVtKSA6IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0ZTogc3RhcnRJbmZvLFxuICAgICAgICBzdGFydDogc3RhcnRJbmZvLFxuICAgICAgICBlbmQ6IGVuZEluZm8sXG4gICAgICAgIHRpbWVab25lOiBjb250ZXh0LnRpbWVab25lLFxuICAgICAgICBsb2NhbGVDb2RlczogY29udGV4dC5sb2NhbGUuY29kZXMsXG4gICAgICAgIGRlZmF1bHRTZXBhcmF0b3I6IGJldHRlckRlZmF1bHRTZXBhcmF0b3IgfHwgY29udGV4dC5kZWZhdWx0U2VwYXJhdG9yLFxuICAgIH07XG59XG5cbi8qXG5UT0RPOiBmaXggdGhlIHRlcm1pbm9sb2d5IG9mIFwiZm9ybWF0dGVyXCIgdnMgXCJmb3JtYXR0aW5nIGZ1bmNcIlxuKi9cbi8qXG5BdCB0aGUgdGltZSBvZiBpbnN0YW50aWF0aW9uLCB0aGlzIG9iamVjdCBkb2VzIG5vdCBrbm93IHdoaWNoIGNtZC1mb3JtYXR0aW5nIHN5c3RlbSBpdCB3aWxsIHVzZS5cbkl0IHJlY2VpdmVzIHRoaXMgYXQgdGhlIHRpbWUgb2YgZm9ybWF0dGluZywgYXMgYSBzZXR0aW5nLlxuKi9cbmNsYXNzIENtZEZvcm1hdHRlciB7XG4gICAgY29uc3RydWN0b3IoY21kU3RyKSB7XG4gICAgICAgIHRoaXMuY21kU3RyID0gY21kU3RyO1xuICAgIH1cbiAgICBmb3JtYXQoZGF0ZSwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gY29udGV4dC5jbWRGb3JtYXR0ZXIodGhpcy5jbWRTdHIsIGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKGRhdGUsIG51bGwsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpKTtcbiAgICB9XG4gICAgZm9ybWF0UmFuZ2Uoc3RhcnQsIGVuZCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gY29udGV4dC5jbWRGb3JtYXR0ZXIodGhpcy5jbWRTdHIsIGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpKTtcbiAgICB9XG59XG5cbmNsYXNzIEZ1bmNGb3JtYXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGZ1bmMpIHtcbiAgICAgICAgdGhpcy5mdW5jID0gZnVuYztcbiAgICB9XG4gICAgZm9ybWF0KGRhdGUsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuYyhjcmVhdGVWZXJib3NlRm9ybWF0dGluZ0FyZyhkYXRlLCBudWxsLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSk7XG4gICAgfVxuICAgIGZvcm1hdFJhbmdlKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuYyhjcmVhdGVWZXJib3NlRm9ybWF0dGluZ0FyZyhzdGFydCwgZW5kLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGb3JtYXR0ZXIoaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVGb3JtYXR0ZXIoaW5wdXQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbmV3IENtZEZvcm1hdHRlcihpbnB1dCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jRm9ybWF0dGVyKGlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8vIGJhc2Ugb3B0aW9uc1xuLy8gLS0tLS0tLS0tLS0tXG5jb25zdCBCQVNFX09QVElPTl9SRUZJTkVSUyA9IHtcbiAgICBuYXZMaW5rRGF5Q2xpY2s6IGlkZW50aXR5LFxuICAgIG5hdkxpbmtXZWVrQ2xpY2s6IGlkZW50aXR5LFxuICAgIGR1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBib290c3RyYXBGb250QXdlc29tZTogaWRlbnRpdHksXG4gICAgYnV0dG9uSWNvbnM6IGlkZW50aXR5LFxuICAgIGN1c3RvbUJ1dHRvbnM6IGlkZW50aXR5LFxuICAgIGRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBkZWZhdWx0VGltZWRFdmVudER1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBuZXh0RGF5VGhyZXNob2xkOiBjcmVhdGVEdXJhdGlvbixcbiAgICBzY3JvbGxUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgICBzY3JvbGxUaW1lUmVzZXQ6IEJvb2xlYW4sXG4gICAgc2xvdE1pblRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIHNsb3RNYXhUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgICBkYXlQb3BvdmVyRm9ybWF0OiBjcmVhdGVGb3JtYXR0ZXIsXG4gICAgc2xvdER1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBzbmFwRHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGhlYWRlclRvb2xiYXI6IGlkZW50aXR5LFxuICAgIGZvb3RlclRvb2xiYXI6IGlkZW50aXR5LFxuICAgIGRlZmF1bHRSYW5nZVNlcGFyYXRvcjogU3RyaW5nLFxuICAgIHRpdGxlUmFuZ2VTZXBhcmF0b3I6IFN0cmluZyxcbiAgICBmb3JjZUV2ZW50RHVyYXRpb246IEJvb2xlYW4sXG4gICAgZGF5SGVhZGVyczogQm9vbGVhbixcbiAgICBkYXlIZWFkZXJGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcbiAgICBkYXlIZWFkZXJDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBkYXlIZWFkZXJDb250ZW50OiBpZGVudGl0eSxcbiAgICBkYXlIZWFkZXJEaWRNb3VudDogaWRlbnRpdHksXG4gICAgZGF5SGVhZGVyV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIGRheUNlbGxDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBkYXlDZWxsQ29udGVudDogaWRlbnRpdHksXG4gICAgZGF5Q2VsbERpZE1vdW50OiBpZGVudGl0eSxcbiAgICBkYXlDZWxsV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIGluaXRpYWxWaWV3OiBTdHJpbmcsXG4gICAgYXNwZWN0UmF0aW86IE51bWJlcixcbiAgICB3ZWVrZW5kczogQm9vbGVhbixcbiAgICB3ZWVrTnVtYmVyQ2FsY3VsYXRpb246IGlkZW50aXR5LFxuICAgIHdlZWtOdW1iZXJzOiBCb29sZWFuLFxuICAgIHdlZWtOdW1iZXJDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICB3ZWVrTnVtYmVyQ29udGVudDogaWRlbnRpdHksXG4gICAgd2Vla051bWJlckRpZE1vdW50OiBpZGVudGl0eSxcbiAgICB3ZWVrTnVtYmVyV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIGVkaXRhYmxlOiBCb29sZWFuLFxuICAgIHZpZXdDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICB2aWV3RGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIHZpZXdXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgbm93SW5kaWNhdG9yOiBCb29sZWFuLFxuICAgIG5vd0luZGljYXRvckNsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIG5vd0luZGljYXRvckNvbnRlbnQ6IGlkZW50aXR5LFxuICAgIG5vd0luZGljYXRvckRpZE1vdW50OiBpZGVudGl0eSxcbiAgICBub3dJbmRpY2F0b3JXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgc2hvd05vbkN1cnJlbnREYXRlczogQm9vbGVhbixcbiAgICBsYXp5RmV0Y2hpbmc6IEJvb2xlYW4sXG4gICAgc3RhcnRQYXJhbTogU3RyaW5nLFxuICAgIGVuZFBhcmFtOiBTdHJpbmcsXG4gICAgdGltZVpvbmVQYXJhbTogU3RyaW5nLFxuICAgIHRpbWVab25lOiBTdHJpbmcsXG4gICAgbG9jYWxlczogaWRlbnRpdHksXG4gICAgbG9jYWxlOiBpZGVudGl0eSxcbiAgICB0aGVtZVN5c3RlbTogU3RyaW5nLFxuICAgIGRyYWdSZXZlcnREdXJhdGlvbjogTnVtYmVyLFxuICAgIGRyYWdTY3JvbGw6IEJvb2xlYW4sXG4gICAgYWxsRGF5TWFpbnRhaW5EdXJhdGlvbjogQm9vbGVhbixcbiAgICB1bnNlbGVjdEF1dG86IEJvb2xlYW4sXG4gICAgZHJvcEFjY2VwdDogaWRlbnRpdHksXG4gICAgZXZlbnRPcmRlcjogcGFyc2VGaWVsZFNwZWNzLFxuICAgIGV2ZW50T3JkZXJTdHJpY3Q6IEJvb2xlYW4sXG4gICAgaGFuZGxlV2luZG93UmVzaXplOiBCb29sZWFuLFxuICAgIHdpbmRvd1Jlc2l6ZURlbGF5OiBOdW1iZXIsXG4gICAgbG9uZ1ByZXNzRGVsYXk6IE51bWJlcixcbiAgICBldmVudERyYWdNaW5EaXN0YW5jZTogTnVtYmVyLFxuICAgIGV4cGFuZFJvd3M6IEJvb2xlYW4sXG4gICAgaGVpZ2h0OiBpZGVudGl0eSxcbiAgICBjb250ZW50SGVpZ2h0OiBpZGVudGl0eSxcbiAgICBkaXJlY3Rpb246IFN0cmluZyxcbiAgICB3ZWVrTnVtYmVyRm9ybWF0OiBjcmVhdGVGb3JtYXR0ZXIsXG4gICAgZXZlbnRSZXNpemFibGVGcm9tU3RhcnQ6IEJvb2xlYW4sXG4gICAgZGlzcGxheUV2ZW50VGltZTogQm9vbGVhbixcbiAgICBkaXNwbGF5RXZlbnRFbmQ6IEJvb2xlYW4sXG4gICAgd2Vla1RleHQ6IFN0cmluZyxcbiAgICB3ZWVrVGV4dExvbmc6IFN0cmluZyxcbiAgICBwcm9ncmVzc2l2ZUV2ZW50UmVuZGVyaW5nOiBCb29sZWFuLFxuICAgIGJ1c2luZXNzSG91cnM6IGlkZW50aXR5LFxuICAgIGluaXRpYWxEYXRlOiBpZGVudGl0eSxcbiAgICBub3c6IGlkZW50aXR5LFxuICAgIGV2ZW50RGF0YVRyYW5zZm9ybTogaWRlbnRpdHksXG4gICAgc3RpY2t5SGVhZGVyRGF0ZXM6IGlkZW50aXR5LFxuICAgIHN0aWNreUZvb3RlclNjcm9sbGJhcjogaWRlbnRpdHksXG4gICAgdmlld0hlaWdodDogaWRlbnRpdHksXG4gICAgZGVmYXVsdEFsbERheTogQm9vbGVhbixcbiAgICBldmVudFNvdXJjZUZhaWx1cmU6IGlkZW50aXR5LFxuICAgIGV2ZW50U291cmNlU3VjY2VzczogaWRlbnRpdHksXG4gICAgZXZlbnREaXNwbGF5OiBTdHJpbmcsXG4gICAgZXZlbnRTdGFydEVkaXRhYmxlOiBCb29sZWFuLFxuICAgIGV2ZW50RHVyYXRpb25FZGl0YWJsZTogQm9vbGVhbixcbiAgICBldmVudE92ZXJsYXA6IGlkZW50aXR5LFxuICAgIGV2ZW50Q29uc3RyYWludDogaWRlbnRpdHksXG4gICAgZXZlbnRBbGxvdzogaWRlbnRpdHksXG4gICAgZXZlbnRCYWNrZ3JvdW5kQ29sb3I6IFN0cmluZyxcbiAgICBldmVudEJvcmRlckNvbG9yOiBTdHJpbmcsXG4gICAgZXZlbnRUZXh0Q29sb3I6IFN0cmluZyxcbiAgICBldmVudENvbG9yOiBTdHJpbmcsXG4gICAgZXZlbnRDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBldmVudENvbnRlbnQ6IGlkZW50aXR5LFxuICAgIGV2ZW50RGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIGV2ZW50V2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIHNlbGVjdENvbnN0cmFpbnQ6IGlkZW50aXR5LFxuICAgIHNlbGVjdE92ZXJsYXA6IGlkZW50aXR5LFxuICAgIHNlbGVjdEFsbG93OiBpZGVudGl0eSxcbiAgICBkcm9wcGFibGU6IEJvb2xlYW4sXG4gICAgdW5zZWxlY3RDYW5jZWw6IFN0cmluZyxcbiAgICBzbG90TGFiZWxGb3JtYXQ6IGlkZW50aXR5LFxuICAgIHNsb3RMYW5lQ2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgc2xvdExhbmVDb250ZW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFuZURpZE1vdW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFuZVdpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFiZWxDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBzbG90TGFiZWxDb250ZW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFiZWxEaWRNb3VudDogaWRlbnRpdHksXG4gICAgc2xvdExhYmVsV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIGRheU1heEV2ZW50czogaWRlbnRpdHksXG4gICAgZGF5TWF4RXZlbnRSb3dzOiBpZGVudGl0eSxcbiAgICBkYXlNaW5XaWR0aDogTnVtYmVyLFxuICAgIHNsb3RMYWJlbEludGVydmFsOiBjcmVhdGVEdXJhdGlvbixcbiAgICBhbGxEYXlUZXh0OiBTdHJpbmcsXG4gICAgYWxsRGF5Q2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgYWxsRGF5Q29udGVudDogaWRlbnRpdHksXG4gICAgYWxsRGF5RGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIGFsbERheVdpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBzbG90TWluV2lkdGg6IE51bWJlcixcbiAgICBuYXZMaW5rczogQm9vbGVhbixcbiAgICBldmVudFRpbWVGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcbiAgICByZXJlbmRlckRlbGF5OiBOdW1iZXIsXG4gICAgbW9yZUxpbmtUZXh0OiBpZGVudGl0eSxcbiAgICBtb3JlTGlua0hpbnQ6IGlkZW50aXR5LFxuICAgIHNlbGVjdE1pbkRpc3RhbmNlOiBOdW1iZXIsXG4gICAgc2VsZWN0YWJsZTogQm9vbGVhbixcbiAgICBzZWxlY3RMb25nUHJlc3NEZWxheTogTnVtYmVyLFxuICAgIGV2ZW50TG9uZ1ByZXNzRGVsYXk6IE51bWJlcixcbiAgICBzZWxlY3RNaXJyb3I6IEJvb2xlYW4sXG4gICAgZXZlbnRNYXhTdGFjazogTnVtYmVyLFxuICAgIGV2ZW50TWluSGVpZ2h0OiBOdW1iZXIsXG4gICAgZXZlbnRNaW5XaWR0aDogTnVtYmVyLFxuICAgIGV2ZW50U2hvcnRIZWlnaHQ6IE51bWJlcixcbiAgICBzbG90RXZlbnRPdmVybGFwOiBCb29sZWFuLFxuICAgIHBsdWdpbnM6IGlkZW50aXR5LFxuICAgIGZpcnN0RGF5OiBOdW1iZXIsXG4gICAgZGF5Q291bnQ6IE51bWJlcixcbiAgICBkYXRlQWxpZ25tZW50OiBTdHJpbmcsXG4gICAgZGF0ZUluY3JlbWVudDogY3JlYXRlRHVyYXRpb24sXG4gICAgaGlkZGVuRGF5czogaWRlbnRpdHksXG4gICAgZml4ZWRXZWVrQ291bnQ6IEJvb2xlYW4sXG4gICAgdmFsaWRSYW5nZTogaWRlbnRpdHksXG4gICAgdmlzaWJsZVJhbmdlOiBpZGVudGl0eSxcbiAgICB0aXRsZUZvcm1hdDogaWRlbnRpdHksXG4gICAgZXZlbnRJbnRlcmFjdGl2ZTogQm9vbGVhbixcbiAgICAvLyBvbmx5IHVzZWQgYnkgbGlzdC12aWV3LCBidXQgbGFuZ3VhZ2VzIGRlZmluZSB0aGUgdmFsdWUsIHNvIHdlIG5lZWQgaXQgaW4gYmFzZSBvcHRpb25zXG4gICAgbm9FdmVudHNUZXh0OiBTdHJpbmcsXG4gICAgdmlld0hpbnQ6IGlkZW50aXR5LFxuICAgIG5hdkxpbmtIaW50OiBpZGVudGl0eSxcbiAgICBjbG9zZUhpbnQ6IFN0cmluZyxcbiAgICB0aW1lSGludDogU3RyaW5nLFxuICAgIGV2ZW50SGludDogU3RyaW5nLFxuICAgIG1vcmVMaW5rQ2xpY2s6IGlkZW50aXR5LFxuICAgIG1vcmVMaW5rQ2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgbW9yZUxpbmtDb250ZW50OiBpZGVudGl0eSxcbiAgICBtb3JlTGlua0RpZE1vdW50OiBpZGVudGl0eSxcbiAgICBtb3JlTGlua1dpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBtb250aFN0YXJ0Rm9ybWF0OiBjcmVhdGVGb3JtYXR0ZXIsXG4gICAgLy8gZm9yIGNvbm5lY3RvcnNcbiAgICAvLyAoY2FuJ3QgYmUgcGFydCBvZiBwbHVnaW4gc3lzdGVtIGIvYyBtdXN0IGJlIHByb3ZpZGVkIGF0IHJ1bnRpbWUpXG4gICAgaGFuZGxlQ3VzdG9tUmVuZGVyaW5nOiBpZGVudGl0eSxcbiAgICBjdXN0b21SZW5kZXJpbmdNZXRhTWFwOiBpZGVudGl0eSxcbiAgICBjdXN0b21SZW5kZXJpbmdSZXBsYWNlczogQm9vbGVhbixcbn07XG4vLyBkbyBOT1QgZ2l2ZSBhIHR5cGUgaGVyZS4gbmVlZCBgdHlwZW9mIEJBU0VfT1BUSU9OX0RFRkFVTFRTYCB0byBnaXZlIHJlYWwgcmVzdWx0cy5cbi8vIHJhdyB2YWx1ZXMuXG5jb25zdCBCQVNFX09QVElPTl9ERUZBVUxUUyA9IHtcbiAgICBldmVudERpc3BsYXk6ICdhdXRvJyxcbiAgICBkZWZhdWx0UmFuZ2VTZXBhcmF0b3I6ICcgLSAnLFxuICAgIHRpdGxlUmFuZ2VTZXBhcmF0b3I6ICcgXFx1MjAxMyAnLFxuICAgIGRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb246ICcwMTowMDowMCcsXG4gICAgZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb246IHsgZGF5OiAxIH0sXG4gICAgZm9yY2VFdmVudER1cmF0aW9uOiBmYWxzZSxcbiAgICBuZXh0RGF5VGhyZXNob2xkOiAnMDA6MDA6MDAnLFxuICAgIGRheUhlYWRlcnM6IHRydWUsXG4gICAgaW5pdGlhbFZpZXc6ICcnLFxuICAgIGFzcGVjdFJhdGlvOiAxLjM1LFxuICAgIGhlYWRlclRvb2xiYXI6IHtcbiAgICAgICAgc3RhcnQ6ICd0aXRsZScsXG4gICAgICAgIGNlbnRlcjogJycsXG4gICAgICAgIGVuZDogJ3RvZGF5IHByZXYsbmV4dCcsXG4gICAgfSxcbiAgICB3ZWVrZW5kczogdHJ1ZSxcbiAgICB3ZWVrTnVtYmVyczogZmFsc2UsXG4gICAgd2Vla051bWJlckNhbGN1bGF0aW9uOiAnbG9jYWwnLFxuICAgIGVkaXRhYmxlOiBmYWxzZSxcbiAgICBub3dJbmRpY2F0b3I6IGZhbHNlLFxuICAgIHNjcm9sbFRpbWU6ICcwNjowMDowMCcsXG4gICAgc2Nyb2xsVGltZVJlc2V0OiB0cnVlLFxuICAgIHNsb3RNaW5UaW1lOiAnMDA6MDA6MDAnLFxuICAgIHNsb3RNYXhUaW1lOiAnMjQ6MDA6MDAnLFxuICAgIHNob3dOb25DdXJyZW50RGF0ZXM6IHRydWUsXG4gICAgbGF6eUZldGNoaW5nOiB0cnVlLFxuICAgIHN0YXJ0UGFyYW06ICdzdGFydCcsXG4gICAgZW5kUGFyYW06ICdlbmQnLFxuICAgIHRpbWVab25lUGFyYW06ICd0aW1lWm9uZScsXG4gICAgdGltZVpvbmU6ICdsb2NhbCcsXG4gICAgbG9jYWxlczogW10sXG4gICAgbG9jYWxlOiAnJyxcbiAgICB0aGVtZVN5c3RlbTogJ3N0YW5kYXJkJyxcbiAgICBkcmFnUmV2ZXJ0RHVyYXRpb246IDUwMCxcbiAgICBkcmFnU2Nyb2xsOiB0cnVlLFxuICAgIGFsbERheU1haW50YWluRHVyYXRpb246IGZhbHNlLFxuICAgIHVuc2VsZWN0QXV0bzogdHJ1ZSxcbiAgICBkcm9wQWNjZXB0OiAnKicsXG4gICAgZXZlbnRPcmRlcjogJ3N0YXJ0LC1kdXJhdGlvbixhbGxEYXksdGl0bGUnLFxuICAgIGRheVBvcG92ZXJGb3JtYXQ6IHsgbW9udGg6ICdsb25nJywgZGF5OiAnbnVtZXJpYycsIHllYXI6ICdudW1lcmljJyB9LFxuICAgIGhhbmRsZVdpbmRvd1Jlc2l6ZTogdHJ1ZSxcbiAgICB3aW5kb3dSZXNpemVEZWxheTogMTAwLFxuICAgIGxvbmdQcmVzc0RlbGF5OiAxMDAwLFxuICAgIGV2ZW50RHJhZ01pbkRpc3RhbmNlOiA1LFxuICAgIGV4cGFuZFJvd3M6IGZhbHNlLFxuICAgIG5hdkxpbmtzOiBmYWxzZSxcbiAgICBzZWxlY3RhYmxlOiBmYWxzZSxcbiAgICBldmVudE1pbkhlaWdodDogMTUsXG4gICAgZXZlbnRNaW5XaWR0aDogMzAsXG4gICAgZXZlbnRTaG9ydEhlaWdodDogMzAsXG4gICAgbW9udGhTdGFydEZvcm1hdDogeyBtb250aDogJ2xvbmcnLCBkYXk6ICdudW1lcmljJyB9LFxufTtcbi8vIGNhbGVuZGFyIGxpc3RlbmVyc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5jb25zdCBDQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUyA9IHtcbiAgICBkYXRlc1NldDogaWRlbnRpdHksXG4gICAgZXZlbnRzU2V0OiBpZGVudGl0eSxcbiAgICBldmVudEFkZDogaWRlbnRpdHksXG4gICAgZXZlbnRDaGFuZ2U6IGlkZW50aXR5LFxuICAgIGV2ZW50UmVtb3ZlOiBpZGVudGl0eSxcbiAgICB3aW5kb3dSZXNpemU6IGlkZW50aXR5LFxuICAgIGV2ZW50Q2xpY2s6IGlkZW50aXR5LFxuICAgIGV2ZW50TW91c2VFbnRlcjogaWRlbnRpdHksXG4gICAgZXZlbnRNb3VzZUxlYXZlOiBpZGVudGl0eSxcbiAgICBzZWxlY3Q6IGlkZW50aXR5LFxuICAgIHVuc2VsZWN0OiBpZGVudGl0eSxcbiAgICBsb2FkaW5nOiBpZGVudGl0eSxcbiAgICAvLyBpbnRlcm5hbFxuICAgIF91bm1vdW50OiBpZGVudGl0eSxcbiAgICBfYmVmb3JlcHJpbnQ6IGlkZW50aXR5LFxuICAgIF9hZnRlcnByaW50OiBpZGVudGl0eSxcbiAgICBfbm9FdmVudERyb3A6IGlkZW50aXR5LFxuICAgIF9ub0V2ZW50UmVzaXplOiBpZGVudGl0eSxcbiAgICBfcmVzaXplOiBpZGVudGl0eSxcbiAgICBfc2Nyb2xsUmVxdWVzdDogaWRlbnRpdHksXG59O1xuLy8gY2FsZW5kYXItc3BlY2lmaWMgb3B0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY29uc3QgQ0FMRU5EQVJfT1BUSU9OX1JFRklORVJTID0ge1xuICAgIGJ1dHRvblRleHQ6IGlkZW50aXR5LFxuICAgIGJ1dHRvbkhpbnRzOiBpZGVudGl0eSxcbiAgICB2aWV3czogaWRlbnRpdHksXG4gICAgcGx1Z2luczogaWRlbnRpdHksXG4gICAgaW5pdGlhbEV2ZW50czogaWRlbnRpdHksXG4gICAgZXZlbnRzOiBpZGVudGl0eSxcbiAgICBldmVudFNvdXJjZXM6IGlkZW50aXR5LFxufTtcbmNvbnN0IENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTID0ge1xuICAgIGhlYWRlclRvb2xiYXI6IGlzTWF5YmVPYmplY3RzRXF1YWwsXG4gICAgZm9vdGVyVG9vbGJhcjogaXNNYXliZU9iamVjdHNFcXVhbCxcbiAgICBidXR0b25UZXh0OiBpc01heWJlT2JqZWN0c0VxdWFsLFxuICAgIGJ1dHRvbkhpbnRzOiBpc01heWJlT2JqZWN0c0VxdWFsLFxuICAgIGJ1dHRvbkljb25zOiBpc01heWJlT2JqZWN0c0VxdWFsLFxuICAgIGRhdGVJbmNyZW1lbnQ6IGlzTWF5YmVPYmplY3RzRXF1YWwsXG4gICAgcGx1Z2luczogaXNNYXliZUFycmF5c0VxdWFsLFxuICAgIGV2ZW50czogaXNNYXliZUFycmF5c0VxdWFsLFxuICAgIGV2ZW50U291cmNlczogaXNNYXliZUFycmF5c0VxdWFsLFxuICAgIFsncmVzb3VyY2VzJ106IGlzTWF5YmVBcnJheXNFcXVhbCxcbn07XG5mdW5jdGlvbiBpc01heWJlT2JqZWN0c0VxdWFsKGEsIGIpIHtcbiAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBiID09PSAnb2JqZWN0JyAmJiBhICYmIGIpIHsgLy8gYm90aCBub24tbnVsbCBvYmplY3RzXG4gICAgICAgIHJldHVybiBpc1Byb3BzRXF1YWwoYSwgYik7XG4gICAgfVxuICAgIHJldHVybiBhID09PSBiO1xufVxuZnVuY3Rpb24gaXNNYXliZUFycmF5c0VxdWFsKGEsIGIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSAmJiBBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5c0VxdWFsKGEsIGIpO1xuICAgIH1cbiAgICByZXR1cm4gYSA9PT0gYjtcbn1cbi8vIHZpZXctc3BlY2lmaWMgb3B0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5jb25zdCBWSUVXX09QVElPTl9SRUZJTkVSUyA9IHtcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgY29tcG9uZW50OiBpZGVudGl0eSxcbiAgICBidXR0b25UZXh0OiBTdHJpbmcsXG4gICAgYnV0dG9uVGV4dEtleTogU3RyaW5nLFxuICAgIGRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3M6IGlkZW50aXR5LFxuICAgIHVzZXNNaW5NYXhUaW1lOiBCb29sZWFuLFxuICAgIGNsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIGNvbnRlbnQ6IGlkZW50aXR5LFxuICAgIGRpZE1vdW50OiBpZGVudGl0eSxcbiAgICB3aWxsVW5tb3VudDogaWRlbnRpdHksXG59O1xuLy8gdXRpbCBmdW5jc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gbWVyZ2VSYXdPcHRpb25zKG9wdGlvblNldHMpIHtcbiAgICByZXR1cm4gbWVyZ2VQcm9wcyhvcHRpb25TZXRzLCBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SUyk7XG59XG5mdW5jdGlvbiByZWZpbmVQcm9wcyhpbnB1dCwgcmVmaW5lcnMpIHtcbiAgICBsZXQgcmVmaW5lZCA9IHt9O1xuICAgIGxldCBleHRyYSA9IHt9O1xuICAgIGZvciAobGV0IHByb3BOYW1lIGluIHJlZmluZXJzKSB7XG4gICAgICAgIGlmIChwcm9wTmFtZSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgcmVmaW5lZFtwcm9wTmFtZV0gPSByZWZpbmVyc1twcm9wTmFtZV0oaW5wdXRbcHJvcE5hbWVdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBpbnB1dCkge1xuICAgICAgICBpZiAoIShwcm9wTmFtZSBpbiByZWZpbmVycykpIHtcbiAgICAgICAgICAgIGV4dHJhW3Byb3BOYW1lXSA9IGlucHV0W3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyByZWZpbmVkLCBleHRyYSB9O1xufVxuZnVuY3Rpb24gaWRlbnRpdHkocmF3KSB7XG4gICAgcmV0dXJuIHJhdztcbn1cblxuY29uc3QgeyBoYXNPd25Qcm9wZXJ0eSB9ID0gT2JqZWN0LnByb3RvdHlwZTtcbi8vIE1lcmdlcyBhbiBhcnJheSBvZiBvYmplY3RzIGludG8gYSBzaW5nbGUgb2JqZWN0LlxuLy8gVGhlIHNlY29uZCBhcmd1bWVudCBhbGxvd3MgZm9yIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIHdobydzIG9iamVjdCB2YWx1ZXMgd2lsbCBiZSBtZXJnZWQgdG9nZXRoZXIuXG5mdW5jdGlvbiBtZXJnZVByb3BzKHByb3BPYmpzLCBjb21wbGV4UHJvcHNNYXApIHtcbiAgICBsZXQgZGVzdCA9IHt9O1xuICAgIGlmIChjb21wbGV4UHJvcHNNYXApIHtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBjb21wbGV4UHJvcHNNYXApIHtcbiAgICAgICAgICAgIGlmIChjb21wbGV4UHJvcHNNYXBbbmFtZV0gPT09IGlzTWF5YmVPYmplY3RzRXF1YWwpIHsgLy8gaW1wbGllcyB0aGF0IGl0J3Mgb2JqZWN0LW1lcmdlYWJsZVxuICAgICAgICAgICAgICAgIGxldCBjb21wbGV4T2JqcyA9IFtdO1xuICAgICAgICAgICAgICAgIC8vIGNvbGxlY3QgdGhlIHRyYWlsaW5nIG9iamVjdCB2YWx1ZXMsIHN0b3BwaW5nIHdoZW4gYSBub24tb2JqZWN0IGlzIGRpc2NvdmVyZWRcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gcHJvcE9ianMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IHByb3BPYmpzW2ldW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsKSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxleE9ianMudW5zaGlmdCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0W25hbWVdID0gdmFsOyAvLyBpZiB0aGVyZSB3ZXJlIG5vIG9iamVjdHMsIHRoaXMgdmFsdWUgd2lsbCBiZSB1c2VkXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgdHJhaWxpbmcgdmFsdWVzIHdlcmUgb2JqZWN0cywgdXNlIHRoZSBtZXJnZWQgdmFsdWVcbiAgICAgICAgICAgICAgICBpZiAoY29tcGxleE9ianMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc3RbbmFtZV0gPSBtZXJnZVByb3BzKGNvbXBsZXhPYmpzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gY29weSB2YWx1ZXMgaW50byB0aGUgZGVzdGluYXRpb24sIGdvaW5nIGZyb20gbGFzdCB0byBmaXJzdFxuICAgIGZvciAobGV0IGkgPSBwcm9wT2Jqcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBsZXQgcHJvcHMgPSBwcm9wT2Jqc1tpXTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBwcm9wcykge1xuICAgICAgICAgICAgaWYgKCEobmFtZSBpbiBkZXN0KSkgeyAvLyBpZiBhbHJlYWR5IGFzc2lnbmVkIGJ5IHByZXZpb3VzIHByb3BzIG9yIGNvbXBsZXggcHJvcHMsIGRvbid0IHJlYXNzaWduXG4gICAgICAgICAgICAgICAgZGVzdFtuYW1lXSA9IHByb3BzW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xufVxuZnVuY3Rpb24gZmlsdGVySGFzaChoYXNoLCBmdW5jKSB7XG4gICAgbGV0IGZpbHRlcmVkID0ge307XG4gICAgZm9yIChsZXQga2V5IGluIGhhc2gpIHtcbiAgICAgICAgaWYgKGZ1bmMoaGFzaFtrZXldLCBrZXkpKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZFtrZXldID0gaGFzaFtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXJlZDtcbn1cbmZ1bmN0aW9uIG1hcEhhc2goaGFzaCwgZnVuYykge1xuICAgIGxldCBuZXdIYXNoID0ge307XG4gICAgZm9yIChsZXQga2V5IGluIGhhc2gpIHtcbiAgICAgICAgbmV3SGFzaFtrZXldID0gZnVuYyhoYXNoW2tleV0sIGtleSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdIYXNoO1xufVxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYSkge1xuICAgIGxldCBoYXNoID0ge307XG4gICAgZm9yIChsZXQgaXRlbSBvZiBhKSB7XG4gICAgICAgIGhhc2hbaXRlbV0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaDtcbn1cbi8vIFRPRE86IHJlYXNzZXNzIGJyb3dzZXIgc3VwcG9ydFxuLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8/c2VhcmNoPW9iamVjdC52YWx1ZXNcbmZ1bmN0aW9uIGhhc2hWYWx1ZXNUb0FycmF5KG9iaikge1xuICAgIGxldCBhID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG9iaikge1xuICAgICAgICBhLnB1c2gob2JqW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn1cbmZ1bmN0aW9uIGlzUHJvcHNFcXVhbChvYmowLCBvYmoxKSB7XG4gICAgaWYgKG9iajAgPT09IG9iajEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvciAobGV0IGtleSBpbiBvYmowKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iajAsIGtleSkpIHtcbiAgICAgICAgICAgIGlmICghKGtleSBpbiBvYmoxKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBrZXkgaW4gb2JqMSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmoxLCBrZXkpKSB7XG4gICAgICAgICAgICBpZiAob2JqMFtrZXldICE9PSBvYmoxW2tleV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBIQU5ETEVSX1JFID0gL15vbltBLVpdLztcbmZ1bmN0aW9uIGlzTm9uSGFuZGxlclByb3BzRXF1YWwob2JqMCwgb2JqMSkge1xuICAgIGNvbnN0IGtleXMgPSBnZXRVbmVxdWFsUHJvcHMob2JqMCwgb2JqMSk7XG4gICAgZm9yIChsZXQga2V5IG9mIGtleXMpIHtcbiAgICAgICAgaWYgKCFIQU5ETEVSX1JFLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0VW5lcXVhbFByb3BzKG9iajAsIG9iajEpIHtcbiAgICBsZXQga2V5cyA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvYmowKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iajAsIGtleSkpIHtcbiAgICAgICAgICAgIGlmICghKGtleSBpbiBvYmoxKSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGtleSBpbiBvYmoxKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iajEsIGtleSkpIHtcbiAgICAgICAgICAgIGlmIChvYmowW2tleV0gIT09IG9iajFba2V5XSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gY29tcGFyZU9ianMob2xkUHJvcHMsIG5ld1Byb3BzLCBlcXVhbGl0eUZ1bmNzID0ge30pIHtcbiAgICBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmb3IgKGxldCBrZXkgaW4gbmV3UHJvcHMpIHtcbiAgICAgICAgaWYgKGtleSBpbiBvbGRQcm9wcyAmJiBpc09ialZhbHNFcXVhbChvbGRQcm9wc1trZXldLCBuZXdQcm9wc1trZXldLCBlcXVhbGl0eUZ1bmNzW2tleV0pKSA7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGNoZWNrIGZvciBwcm9wcyB0aGF0IHdlcmUgb21pdHRlZCBpbiB0aGUgbmV3XG4gICAgZm9yIChsZXQga2V5IGluIG9sZFByb3BzKSB7XG4gICAgICAgIGlmICghKGtleSBpbiBuZXdQcm9wcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qXG5hc3N1bWVkIFwidHJ1ZVwiIGVxdWFsaXR5IGZvciBoYW5kbGVyIG5hbWVzIGxpa2UgXCJvblJlY2VpdmVTb21ldGhpbmdcIlxuKi9cbmZ1bmN0aW9uIGlzT2JqVmFsc0VxdWFsKHZhbDAsIHZhbDEsIGNvbXBhcmF0b3IpIHtcbiAgICBpZiAodmFsMCA9PT0gdmFsMSB8fCBjb21wYXJhdG9yID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gY29tcGFyYXRvcih2YWwwLCB2YWwxKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY29sbGVjdEZyb21IYXNoKGhhc2gsIHN0YXJ0SW5kZXggPSAwLCBlbmRJbmRleCwgc3RlcCA9IDEpIHtcbiAgICBsZXQgcmVzID0gW107XG4gICAgaWYgKGVuZEluZGV4ID09IG51bGwpIHtcbiAgICAgICAgZW5kSW5kZXggPSBPYmplY3Qua2V5cyhoYXNoKS5sZW5ndGg7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkgKz0gc3RlcCkge1xuICAgICAgICBsZXQgdmFsID0gaGFzaFtpXTtcbiAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7IC8vIHdpbGwgZGlzcmVnYXJkIHVuZGVmaW5lZCBmb3Igc3BhcnNlIGFycmF5c1xuICAgICAgICAgICAgcmVzLnB1c2godmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5sZXQgY2FsZW5kYXJTeXN0ZW1DbGFzc01hcCA9IHt9O1xuZnVuY3Rpb24gcmVnaXN0ZXJDYWxlbmRhclN5c3RlbShuYW1lLCB0aGVDbGFzcykge1xuICAgIGNhbGVuZGFyU3lzdGVtQ2xhc3NNYXBbbmFtZV0gPSB0aGVDbGFzcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhbGVuZGFyU3lzdGVtKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IGNhbGVuZGFyU3lzdGVtQ2xhc3NNYXBbbmFtZV0oKTtcbn1cbmNsYXNzIEdyZWdvcmlhbkNhbGVuZGFyU3lzdGVtIHtcbiAgICBnZXRNYXJrZXJZZWFyKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICB9XG4gICAgZ2V0TWFya2VyTW9udGgoZCkge1xuICAgICAgICByZXR1cm4gZC5nZXRVVENNb250aCgpO1xuICAgIH1cbiAgICBnZXRNYXJrZXJEYXkoZCkge1xuICAgICAgICByZXR1cm4gZC5nZXRVVENEYXRlKCk7XG4gICAgfVxuICAgIGFycmF5VG9NYXJrZXIoYXJyKSB7XG4gICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShhcnIpO1xuICAgIH1cbiAgICBtYXJrZXJUb0FycmF5KG1hcmtlcikge1xuICAgICAgICByZXR1cm4gZGF0ZVRvVXRjQXJyYXkobWFya2VyKTtcbiAgICB9XG59XG5yZWdpc3RlckNhbGVuZGFyU3lzdGVtKCdncmVnb3J5JywgR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW0pO1xuXG5jb25zdCBJU09fUkUgPSAvXlxccyooXFxkezR9KSgtPyhcXGR7Mn0pKC0/KFxcZHsyfSkoW1QgXShcXGR7Mn0pOj8oXFxkezJ9KSg6PyhcXGR7Mn0pKFxcLihcXGQrKSk/KT8oWnwoKFstK10pKFxcZHsyfSkoOj8oXFxkezJ9KSk/KSk/KT8pPyk/JC87XG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgICBsZXQgbSA9IElTT19SRS5leGVjKHN0cik7XG4gICAgaWYgKG0pIHtcbiAgICAgICAgbGV0IG1hcmtlciA9IG5ldyBEYXRlKERhdGUuVVRDKE51bWJlcihtWzFdKSwgbVszXSA/IE51bWJlcihtWzNdKSAtIDEgOiAwLCBOdW1iZXIobVs1XSB8fCAxKSwgTnVtYmVyKG1bN10gfHwgMCksIE51bWJlcihtWzhdIHx8IDApLCBOdW1iZXIobVsxMF0gfHwgMCksIG1bMTJdID8gTnVtYmVyKGAwLiR7bVsxMl19YCkgKiAxMDAwIDogMCkpO1xuICAgICAgICBpZiAoaXNWYWxpZERhdGUobWFya2VyKSkge1xuICAgICAgICAgICAgbGV0IHRpbWVab25lT2Zmc2V0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChtWzEzXSkge1xuICAgICAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0ID0gKG1bMTVdID09PSAnLScgPyAtMSA6IDEpICogKE51bWJlcihtWzE2XSB8fCAwKSAqIDYwICtcbiAgICAgICAgICAgICAgICAgICAgTnVtYmVyKG1bMThdIHx8IDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWFya2VyLFxuICAgICAgICAgICAgICAgIGlzVGltZVVuc3BlY2lmaWVkOiAhbVs2XSxcbiAgICAgICAgICAgICAgICB0aW1lWm9uZU9mZnNldCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmNsYXNzIERhdGVFbnYge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgICAgIGxldCB0aW1lWm9uZSA9IHRoaXMudGltZVpvbmUgPSBzZXR0aW5ncy50aW1lWm9uZTtcbiAgICAgICAgbGV0IGlzTmFtZWRUaW1lWm9uZSA9IHRpbWVab25lICE9PSAnbG9jYWwnICYmIHRpbWVab25lICE9PSAnVVRDJztcbiAgICAgICAgaWYgKHNldHRpbmdzLm5hbWVkVGltZVpvbmVJbXBsICYmIGlzTmFtZWRUaW1lWm9uZSkge1xuICAgICAgICAgICAgdGhpcy5uYW1lZFRpbWVab25lSW1wbCA9IG5ldyBzZXR0aW5ncy5uYW1lZFRpbWVab25lSW1wbCh0aW1lWm9uZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW5Db21wdXRlT2Zmc2V0ID0gQm9vbGVhbighaXNOYW1lZFRpbWVab25lIHx8IHRoaXMubmFtZWRUaW1lWm9uZUltcGwpO1xuICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtID0gY3JlYXRlQ2FsZW5kYXJTeXN0ZW0oc2V0dGluZ3MuY2FsZW5kYXJTeXN0ZW0pO1xuICAgICAgICB0aGlzLmxvY2FsZSA9IHNldHRpbmdzLmxvY2FsZTtcbiAgICAgICAgdGhpcy53ZWVrRG93ID0gc2V0dGluZ3MubG9jYWxlLndlZWsuZG93O1xuICAgICAgICB0aGlzLndlZWtEb3kgPSBzZXR0aW5ncy5sb2NhbGUud2Vlay5kb3k7XG4gICAgICAgIGlmIChzZXR0aW5ncy53ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdJU08nKSB7XG4gICAgICAgICAgICB0aGlzLndlZWtEb3cgPSAxO1xuICAgICAgICAgICAgdGhpcy53ZWVrRG95ID0gNDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLmZpcnN0RGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy53ZWVrRG93ID0gc2V0dGluZ3MuZmlyc3REYXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy53ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMud2Vla051bWJlckZ1bmMgPSBzZXR0aW5ncy53ZWVrTnVtYmVyQ2FsY3VsYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53ZWVrVGV4dCA9IHNldHRpbmdzLndlZWtUZXh0ICE9IG51bGwgPyBzZXR0aW5ncy53ZWVrVGV4dCA6IHNldHRpbmdzLmxvY2FsZS5vcHRpb25zLndlZWtUZXh0O1xuICAgICAgICB0aGlzLndlZWtUZXh0TG9uZyA9IChzZXR0aW5ncy53ZWVrVGV4dExvbmcgIT0gbnVsbCA/IHNldHRpbmdzLndlZWtUZXh0TG9uZyA6IHNldHRpbmdzLmxvY2FsZS5vcHRpb25zLndlZWtUZXh0TG9uZykgfHwgdGhpcy53ZWVrVGV4dDtcbiAgICAgICAgdGhpcy5jbWRGb3JtYXR0ZXIgPSBzZXR0aW5ncy5jbWRGb3JtYXR0ZXI7XG4gICAgICAgIHRoaXMuZGVmYXVsdFNlcGFyYXRvciA9IHNldHRpbmdzLmRlZmF1bHRTZXBhcmF0b3I7XG4gICAgfVxuICAgIC8vIENyZWF0aW5nIC8gUGFyc2luZ1xuICAgIGNyZWF0ZU1hcmtlcihpbnB1dCkge1xuICAgICAgICBsZXQgbWV0YSA9IHRoaXMuY3JlYXRlTWFya2VyTWV0YShpbnB1dCk7XG4gICAgICAgIGlmIChtZXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0YS5tYXJrZXI7XG4gICAgfVxuICAgIGNyZWF0ZU5vd01hcmtlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuQ29tcHV0ZU9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGltZXN0YW1wVG9NYXJrZXIobmV3IERhdGUoKS52YWx1ZU9mKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlIGNhbid0IGNvbXB1dGUgdGhlIGN1cnJlbnQgZGF0ZSB2YWwgZm9yIGEgdGltZXpvbmUsXG4gICAgICAgIC8vIGJldHRlciB0byBnaXZlIHRoZSBjdXJyZW50IGxvY2FsIGRhdGUgdmFscyB0aGFuIFVUQ1xuICAgICAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoZGF0ZVRvTG9jYWxBcnJheShuZXcgRGF0ZSgpKSk7XG4gICAgfVxuICAgIGNyZWF0ZU1hcmtlck1ldGEoaW5wdXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWFya2VyID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIG1hcmtlciA9IHRoaXMudGltZXN0YW1wVG9NYXJrZXIoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIG1hcmtlciA9IHRoaXMudGltZXN0YW1wVG9NYXJrZXIoaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBtYXJrZXIgPSBhcnJheVRvVXRjRGF0ZShpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtlciA9PT0gbnVsbCB8fCAhaXNWYWxpZERhdGUobWFya2VyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbWFya2VyLCBpc1RpbWVVbnNwZWNpZmllZDogZmFsc2UsIGZvcmNlZFR6bzogbnVsbCB9O1xuICAgIH1cbiAgICBwYXJzZShzKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IHBhcnNlKHMpO1xuICAgICAgICBpZiAocGFydHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IG1hcmtlciB9ID0gcGFydHM7XG4gICAgICAgIGxldCBmb3JjZWRUem8gPSBudWxsO1xuICAgICAgICBpZiAocGFydHMudGltZVpvbmVPZmZzZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbkNvbXB1dGVPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIgPSB0aGlzLnRpbWVzdGFtcFRvTWFya2VyKG1hcmtlci52YWx1ZU9mKCkgLSBwYXJ0cy50aW1lWm9uZU9mZnNldCAqIDYwICogMTAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3JjZWRUem8gPSBwYXJ0cy50aW1lWm9uZU9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtYXJrZXIsIGlzVGltZVVuc3BlY2lmaWVkOiBwYXJ0cy5pc1RpbWVVbnNwZWNpZmllZCwgZm9yY2VkVHpvIH07XG4gICAgfVxuICAgIC8vIEFjY2Vzc29yc1xuICAgIGdldFllYXIobWFya2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobWFya2VyKTtcbiAgICB9XG4gICAgZ2V0TW9udGgobWFya2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG1hcmtlcik7XG4gICAgfVxuICAgIGdldERheShtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIEFkZGluZyAvIFN1YnRyYWN0aW5nXG4gICAgYWRkKG1hcmtlciwgZHVyKSB7XG4gICAgICAgIGxldCBhID0gdGhpcy5jYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KG1hcmtlcik7XG4gICAgICAgIGFbMF0gKz0gZHVyLnllYXJzO1xuICAgICAgICBhWzFdICs9IGR1ci5tb250aHM7XG4gICAgICAgIGFbMl0gKz0gZHVyLmRheXM7XG4gICAgICAgIGFbNl0gKz0gZHVyLm1pbGxpc2Vjb25kcztcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihhKTtcbiAgICB9XG4gICAgc3VidHJhY3QobWFya2VyLCBkdXIpIHtcbiAgICAgICAgbGV0IGEgPSB0aGlzLmNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkobWFya2VyKTtcbiAgICAgICAgYVswXSAtPSBkdXIueWVhcnM7XG4gICAgICAgIGFbMV0gLT0gZHVyLm1vbnRocztcbiAgICAgICAgYVsyXSAtPSBkdXIuZGF5cztcbiAgICAgICAgYVs2XSAtPSBkdXIubWlsbGlzZWNvbmRzO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKGEpO1xuICAgIH1cbiAgICBhZGRZZWFycyhtYXJrZXIsIG4pIHtcbiAgICAgICAgbGV0IGEgPSB0aGlzLmNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkobWFya2VyKTtcbiAgICAgICAgYVswXSArPSBuO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKGEpO1xuICAgIH1cbiAgICBhZGRNb250aHMobWFya2VyLCBuKSB7XG4gICAgICAgIGxldCBhID0gdGhpcy5jYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KG1hcmtlcik7XG4gICAgICAgIGFbMV0gKz0gbjtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihhKTtcbiAgICB9XG4gICAgLy8gRGlmZmluZyBXaG9sZSBVbml0c1xuICAgIGRpZmZXaG9sZVllYXJzKG0wLCBtMSkge1xuICAgICAgICBsZXQgeyBjYWxlbmRhclN5c3RlbSB9ID0gdGhpcztcbiAgICAgICAgaWYgKHRpbWVBc01zKG0wKSA9PT0gdGltZUFzTXMobTEpICYmXG4gICAgICAgICAgICBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJEYXkobTApID09PSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJEYXkobTEpICYmXG4gICAgICAgICAgICBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMCkgPT09IGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0xKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobTEpIC0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRpZmZXaG9sZU1vbnRocyhtMCwgbTEpIHtcbiAgICAgICAgbGV0IHsgY2FsZW5kYXJTeXN0ZW0gfSA9IHRoaXM7XG4gICAgICAgIGlmICh0aW1lQXNNcyhtMCkgPT09IHRpbWVBc01zKG0xKSAmJlxuICAgICAgICAgICAgY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG0wKSA9PT0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG0xKSkge1xuICAgICAgICAgICAgcmV0dXJuIChjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMSkgLSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMCkpICtcbiAgICAgICAgICAgICAgICAoY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtMSkgLSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0wKSkgKiAxMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gUmFuZ2UgLyBEdXJhdGlvblxuICAgIGdyZWF0ZXN0V2hvbGVVbml0KG0wLCBtMSkge1xuICAgICAgICBsZXQgbiA9IHRoaXMuZGlmZldob2xlWWVhcnMobTAsIG0xKTtcbiAgICAgICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICd5ZWFyJywgdmFsdWU6IG4gfTtcbiAgICAgICAgfVxuICAgICAgICBuID0gdGhpcy5kaWZmV2hvbGVNb250aHMobTAsIG0xKTtcbiAgICAgICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdtb250aCcsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGRpZmZXaG9sZVdlZWtzKG0wLCBtMSk7XG4gICAgICAgIGlmIChuICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnd2VlaycsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGRpZmZXaG9sZURheXMobTAsIG0xKTtcbiAgICAgICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdkYXknLCB2YWx1ZTogbiB9O1xuICAgICAgICB9XG4gICAgICAgIG4gPSBkaWZmSG91cnMobTAsIG0xKTtcbiAgICAgICAgaWYgKGlzSW50KG4pKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnaG91cicsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGRpZmZNaW51dGVzKG0wLCBtMSk7XG4gICAgICAgIGlmIChpc0ludChuKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ21pbnV0ZScsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGRpZmZTZWNvbmRzKG0wLCBtMSk7XG4gICAgICAgIGlmIChpc0ludChuKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3NlY29uZCcsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdW5pdDogJ21pbGxpc2Vjb25kJywgdmFsdWU6IG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSB9O1xuICAgIH1cbiAgICBjb3VudER1cmF0aW9uc0JldHdlZW4obTAsIG0xLCBkKSB7XG4gICAgICAgIC8vIFRPRE86IGNhbiB1c2UgZ3JlYXRlc3RXaG9sZVVuaXRcbiAgICAgICAgbGV0IGRpZmY7XG4gICAgICAgIGlmIChkLnllYXJzKSB7XG4gICAgICAgICAgICBkaWZmID0gdGhpcy5kaWZmV2hvbGVZZWFycyhtMCwgbTEpO1xuICAgICAgICAgICAgaWYgKGRpZmYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiAvIGFzUm91Z2hZZWFycyhkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZC5tb250aHMpIHtcbiAgICAgICAgICAgIGRpZmYgPSB0aGlzLmRpZmZXaG9sZU1vbnRocyhtMCwgbTEpO1xuICAgICAgICAgICAgaWYgKGRpZmYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiAvIGFzUm91Z2hNb250aHMoZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGQuZGF5cykge1xuICAgICAgICAgICAgZGlmZiA9IGRpZmZXaG9sZURheXMobTAsIG0xKTtcbiAgICAgICAgICAgIGlmIChkaWZmICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpZmYgLyBhc1JvdWdoRGF5cyhkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyBhc1JvdWdoTXMoZCk7XG4gICAgfVxuICAgIC8vIFN0YXJ0LU9mXG4gICAgLy8gdGhlc2UgRE9OJ1QgcmV0dXJuIHpvbmVkLWRhdGVzLiBvbmx5IFVUQyBzdGFydC1vZiBkYXRlc1xuICAgIHN0YXJ0T2YobSwgdW5pdCkge1xuICAgICAgICBpZiAodW5pdCA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydE9mWWVhcihtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5pdCA9PT0gJ21vbnRoJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRPZk1vbnRoKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0ID09PSAnd2VlaycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0T2ZXZWVrKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0ID09PSAnZGF5Jykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZEYXkobSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXQgPT09ICdob3VyJykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZIb3VyKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0ID09PSAnbWludXRlJykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZNaW51dGUobSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXQgPT09ICdzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnRPZlNlY29uZChtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3RhcnRPZlllYXIobSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKFtcbiAgICAgICAgICAgIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtKSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHN0YXJ0T2ZNb250aChtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoW1xuICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0pLFxuICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtKSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHN0YXJ0T2ZXZWVrKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihbXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobSksXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0pLFxuICAgICAgICAgICAgbS5nZXRVVENEYXRlKCkgLSAoKG0uZ2V0VVRDRGF5KCkgLSB0aGlzLndlZWtEb3cgKyA3KSAlIDcpLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLy8gV2VlayBOdW1iZXJcbiAgICBjb21wdXRlV2Vla051bWJlcihtYXJrZXIpIHtcbiAgICAgICAgaWYgKHRoaXMud2Vla051bWJlckZ1bmMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlZWtOdW1iZXJGdW5jKHRoaXMudG9EYXRlKG1hcmtlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKG1hcmtlciwgdGhpcy53ZWVrRG93LCB0aGlzLndlZWtEb3kpO1xuICAgIH1cbiAgICAvLyBUT0RPOiBjaG9rZSBvbiB0aW1lWm9uZU5hbWU6IGxvbmdcbiAgICBmb3JtYXQobWFya2VyLCBmb3JtYXR0ZXIsIGRhdGVPcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQoe1xuICAgICAgICAgICAgbWFya2VyLFxuICAgICAgICAgICAgdGltZVpvbmVPZmZzZXQ6IGRhdGVPcHRpb25zLmZvcmNlZFR6byAhPSBudWxsID9cbiAgICAgICAgICAgICAgICBkYXRlT3B0aW9ucy5mb3JjZWRUem8gOlxuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0Rm9yTWFya2VyKG1hcmtlciksXG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgICBmb3JtYXRSYW5nZShzdGFydCwgZW5kLCBmb3JtYXR0ZXIsIGRhdGVPcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKGRhdGVPcHRpb25zLmlzRW5kRXhjbHVzaXZlKSB7XG4gICAgICAgICAgICBlbmQgPSBhZGRNcyhlbmQsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdFJhbmdlKHtcbiAgICAgICAgICAgIG1hcmtlcjogc3RhcnQsXG4gICAgICAgICAgICB0aW1lWm9uZU9mZnNldDogZGF0ZU9wdGlvbnMuZm9yY2VkU3RhcnRUem8gIT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgZGF0ZU9wdGlvbnMuZm9yY2VkU3RhcnRUem8gOlxuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0Rm9yTWFya2VyKHN0YXJ0KSxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbWFya2VyOiBlbmQsXG4gICAgICAgICAgICB0aW1lWm9uZU9mZnNldDogZGF0ZU9wdGlvbnMuZm9yY2VkRW5kVHpvICE9IG51bGwgP1xuICAgICAgICAgICAgICAgIGRhdGVPcHRpb25zLmZvcmNlZEVuZFR6byA6XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRGb3JNYXJrZXIoZW5kKSxcbiAgICAgICAgfSwgdGhpcywgZGF0ZU9wdGlvbnMuZGVmYXVsdFNlcGFyYXRvcik7XG4gICAgfVxuICAgIC8qXG4gICAgRFVNQjogdGhlIG9taXRUaW1lIGFyZyBpcyBkdW1iLiBpZiB3ZSBvbWl0IHRoZSB0aW1lLCB3ZSB3YW50IHRvIG9taXQgdGhlIHRpbWV6b25lIG9mZnNldC4gYW5kIGlmIHdlIGRvIHRoYXQsXG4gICAgbWlnaHQgYXMgd2VsbCB1c2UgYnVpbGRJc29TdHJpbmcgb3Igc29tZSBvdGhlciB1dGlsIGRpcmVjdGx5XG4gICAgKi9cbiAgICBmb3JtYXRJc28obWFya2VyLCBleHRyYU9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgdGltZVpvbmVPZmZzZXQgPSBudWxsO1xuICAgICAgICBpZiAoIWV4dHJhT3B0aW9ucy5vbWl0VGltZVpvbmVPZmZzZXQpIHtcbiAgICAgICAgICAgIGlmIChleHRyYU9wdGlvbnMuZm9yY2VkVHpvICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aW1lWm9uZU9mZnNldCA9IGV4dHJhT3B0aW9ucy5mb3JjZWRUem87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aW1lWm9uZU9mZnNldCA9IHRoaXMub2Zmc2V0Rm9yTWFya2VyKG1hcmtlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkSXNvU3RyaW5nKG1hcmtlciwgdGltZVpvbmVPZmZzZXQsIGV4dHJhT3B0aW9ucy5vbWl0VGltZSk7XG4gICAgfVxuICAgIC8vIFRpbWVab25lXG4gICAgdGltZXN0YW1wVG9NYXJrZXIobXMpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZVpvbmUgPT09ICdsb2NhbCcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShkYXRlVG9Mb2NhbEFycmF5KG5ldyBEYXRlKG1zKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnVVRDJyB8fCAhdGhpcy5uYW1lZFRpbWVab25lSW1wbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUodGhpcy5uYW1lZFRpbWVab25lSW1wbC50aW1lc3RhbXBUb0FycmF5KG1zKSk7XG4gICAgfVxuICAgIG9mZnNldEZvck1hcmtlcihtKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnbG9jYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gLWFycmF5VG9Mb2NhbERhdGUoZGF0ZVRvVXRjQXJyYXkobSkpLmdldFRpbWV6b25lT2Zmc2V0KCk7IC8vIGNvbnZlcnQgXCJpbnZlcnNlXCIgb2Zmc2V0IHRvIFwibm9ybWFsXCIgb2Zmc2V0XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGltZVpvbmUgPT09ICdVVEMnKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uYW1lZFRpbWVab25lSW1wbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZWRUaW1lWm9uZUltcGwub2Zmc2V0Rm9yQXJyYXkoZGF0ZVRvVXRjQXJyYXkobSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBDb252ZXJzaW9uXG4gICAgdG9EYXRlKG0sIGZvcmNlZFR6bykge1xuICAgICAgICBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ2xvY2FsJykge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5VG9Mb2NhbERhdGUoZGF0ZVRvVXRjQXJyYXkobSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnVVRDJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG0udmFsdWVPZigpKTsgLy8gbWFrZSBzdXJlIGl0J3MgYSBjb3B5XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm5hbWVkVGltZVpvbmVJbXBsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUobS52YWx1ZU9mKCkgLSAoZm9yY2VkVHpvIHx8IDApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERhdGUobS52YWx1ZU9mKCkgLVxuICAgICAgICAgICAgdGhpcy5uYW1lZFRpbWVab25lSW1wbC5vZmZzZXRGb3JBcnJheShkYXRlVG9VdGNBcnJheShtKSkgKiAxMDAwICogNjApO1xuICAgIH1cbn1cblxuY2xhc3MgVGhlbWUge1xuICAgIGNvbnN0cnVjdG9yKGNhbGVuZGFyT3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5pY29uT3ZlcnJpZGVPcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SWNvbk92ZXJyaWRlKGNhbGVuZGFyT3B0aW9uc1t0aGlzLmljb25PdmVycmlkZU9wdGlvbl0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEljb25PdmVycmlkZShpY29uT3ZlcnJpZGVIYXNoKSB7XG4gICAgICAgIGxldCBpY29uQ2xhc3Nlc0NvcHk7XG4gICAgICAgIGxldCBidXR0b25OYW1lO1xuICAgICAgICBpZiAodHlwZW9mIGljb25PdmVycmlkZUhhc2ggPT09ICdvYmplY3QnICYmIGljb25PdmVycmlkZUhhc2gpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICAgICAgICBpY29uQ2xhc3Nlc0NvcHkgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmljb25DbGFzc2VzKTtcbiAgICAgICAgICAgIGZvciAoYnV0dG9uTmFtZSBpbiBpY29uT3ZlcnJpZGVIYXNoKSB7XG4gICAgICAgICAgICAgICAgaWNvbkNsYXNzZXNDb3B5W2J1dHRvbk5hbWVdID0gdGhpcy5hcHBseUljb25PdmVycmlkZVByZWZpeChpY29uT3ZlcnJpZGVIYXNoW2J1dHRvbk5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaWNvbkNsYXNzZXMgPSBpY29uQ2xhc3Nlc0NvcHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaWNvbk92ZXJyaWRlSGFzaCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuaWNvbkNsYXNzZXMgPSB7fTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBseUljb25PdmVycmlkZVByZWZpeChjbGFzc05hbWUpIHtcbiAgICAgICAgbGV0IHByZWZpeCA9IHRoaXMuaWNvbk92ZXJyaWRlUHJlZml4O1xuICAgICAgICBpZiAocHJlZml4ICYmIGNsYXNzTmFtZS5pbmRleE9mKHByZWZpeCkgIT09IDApIHsgLy8gaWYgbm90IGFscmVhZHkgcHJlc2VudFxuICAgICAgICAgICAgY2xhc3NOYW1lID0gcHJlZml4ICsgY2xhc3NOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGFzc05hbWU7XG4gICAgfVxuICAgIGdldENsYXNzKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGFzc2VzW2tleV0gfHwgJyc7XG4gICAgfVxuICAgIGdldEljb25DbGFzcyhidXR0b25OYW1lLCBpc1J0bCkge1xuICAgICAgICBsZXQgY2xhc3NOYW1lO1xuICAgICAgICBpZiAoaXNSdGwgJiYgdGhpcy5ydGxJY29uQ2xhc3Nlcykge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gdGhpcy5ydGxJY29uQ2xhc3Nlc1tidXR0b25OYW1lXSB8fCB0aGlzLmljb25DbGFzc2VzW2J1dHRvbk5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gdGhpcy5pY29uQ2xhc3Nlc1tidXR0b25OYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5iYXNlSWNvbkNsYXNzfSAke2NsYXNzTmFtZX1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgZ2V0Q3VzdG9tQnV0dG9uSWNvbkNsYXNzKGN1c3RvbUJ1dHRvblByb3BzKSB7XG4gICAgICAgIGxldCBjbGFzc05hbWU7XG4gICAgICAgIGlmICh0aGlzLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbikge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gY3VzdG9tQnV0dG9uUHJvcHNbdGhpcy5pY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb25dO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmJhc2VJY29uQ2xhc3N9ICR7dGhpcy5hcHBseUljb25PdmVycmlkZVByZWZpeChjbGFzc05hbWUpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn1cblRoZW1lLnByb3RvdHlwZS5jbGFzc2VzID0ge307XG5UaGVtZS5wcm90b3R5cGUuaWNvbkNsYXNzZXMgPSB7fTtcblRoZW1lLnByb3RvdHlwZS5iYXNlSWNvbkNsYXNzID0gJyc7XG5UaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlUHJlZml4ID0gJyc7XG5cbi8qXG5OT1RFOiB0aGlzIGNhbiBiZSBhIHB1YmxpYyBBUEksIGVzcGVjaWFsbHkgY3JlYXRlRWxlbWVudCBmb3IgaG9va3MuXG5TZWUgZXhhbXBsZXMvdHlwZXNjcmlwdC1zY2hlZHVsZXIvc3JjL2luZGV4LnRzXG4qL1xuZnVuY3Rpb24gZmx1c2hTeW5jKHJ1bkJlZm9yZUZsdXNoKSB7XG4gICAgcnVuQmVmb3JlRmx1c2goKTtcbiAgICBsZXQgb2xkRGVib3VuY2VSZW5kZXJpbmcgPSBwcmVhY3Qub3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZzsgLy8gb3JpZ1xuICAgIGxldCBjYWxsYmFja1EgPSBbXTtcbiAgICBmdW5jdGlvbiBleGVjQ2FsbGJhY2tTeW5jKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrUS5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgcHJlYWN0Lm9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmcgPSBleGVjQ2FsbGJhY2tTeW5jO1xuICAgIHByZWFjdC5yZW5kZXIocHJlYWN0LmNyZWF0ZUVsZW1lbnQoRmFrZUNvbXBvbmVudCwge30pLCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gICAgd2hpbGUgKGNhbGxiYWNrUS5sZW5ndGgpIHtcbiAgICAgICAgY2FsbGJhY2tRLnNoaWZ0KCkoKTtcbiAgICB9XG4gICAgcHJlYWN0Lm9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmcgPSBvbGREZWJvdW5jZVJlbmRlcmluZztcbn1cbmNsYXNzIEZha2VDb21wb25lbnQgZXh0ZW5kcyBwcmVhY3QuQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7IHJldHVybiBwcmVhY3QuY3JlYXRlRWxlbWVudCgnZGl2Jywge30pOyB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7IHRoaXMuc2V0U3RhdGUoe30pOyB9XG59XG4vLyBUT0RPOiB1c2UgcHJlYWN0L2NvbXBhdCBpbnN0ZWFkP1xuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUpIHtcbiAgICBsZXQgQ29udGV4dFR5cGUgPSBwcmVhY3QuY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUpO1xuICAgIGxldCBvcmlnUHJvdmlkZXIgPSBDb250ZXh0VHlwZS5Qcm92aWRlcjtcbiAgICBDb250ZXh0VHlwZS5Qcm92aWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGV0IGlzTmV3ID0gIXRoaXMuZ2V0Q2hpbGRDb250ZXh0O1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBvcmlnUHJvdmlkZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICAgICAgaWYgKGlzTmV3KSB7XG4gICAgICAgICAgICBsZXQgc3VicyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zaG91bGRDb21wb25lbnRVcGRhdGUgPSAoX3Byb3BzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMudmFsdWUgIT09IF9wcm9wcy52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuY29udGV4dCA9IF9wcm9wcy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuc3ViID0gKGMpID0+IHtcbiAgICAgICAgICAgICAgICBzdWJzLnB1c2goYyk7XG4gICAgICAgICAgICAgICAgbGV0IG9sZCA9IGMuY29tcG9uZW50V2lsbFVubW91bnQ7XG4gICAgICAgICAgICAgICAgYy5jb21wb25lbnRXaWxsVW5tb3VudCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3Vicy5zcGxpY2Uoc3Vicy5pbmRleE9mKGMpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgb2xkICYmIG9sZC5jYWxsKGMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9O1xuICAgIHJldHVybiBDb250ZXh0VHlwZTtcbn1cblxuY2xhc3MgU2Nyb2xsUmVzcG9uZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihleGVjRnVuYywgZW1pdHRlciwgc2Nyb2xsVGltZSwgc2Nyb2xsVGltZVJlc2V0KSB7XG4gICAgICAgIHRoaXMuZXhlY0Z1bmMgPSBleGVjRnVuYztcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gZW1pdHRlcjtcbiAgICAgICAgdGhpcy5zY3JvbGxUaW1lID0gc2Nyb2xsVGltZTtcbiAgICAgICAgdGhpcy5zY3JvbGxUaW1lUmVzZXQgPSBzY3JvbGxUaW1lUmVzZXQ7XG4gICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlZFJlcXVlc3QgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnF1ZXVlZFJlcXVlc3QgfHwge30sIHJlcXVlc3QpO1xuICAgICAgICAgICAgdGhpcy5kcmFpbigpO1xuICAgICAgICB9O1xuICAgICAgICBlbWl0dGVyLm9uKCdfc2Nyb2xsUmVxdWVzdCcsIHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCk7XG4gICAgICAgIHRoaXMuZmlyZUluaXRpYWxTY3JvbGwoKTtcbiAgICB9XG4gICAgZGV0YWNoKCkge1xuICAgICAgICB0aGlzLmVtaXR0ZXIub2ZmKCdfc2Nyb2xsUmVxdWVzdCcsIHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCk7XG4gICAgfVxuICAgIHVwZGF0ZShpc0RhdGVzTmV3KSB7XG4gICAgICAgIGlmIChpc0RhdGVzTmV3ICYmIHRoaXMuc2Nyb2xsVGltZVJlc2V0KSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVJbml0aWFsU2Nyb2xsKCk7IC8vIHdpbGwgZHJhaW5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZHJhaW4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaXJlSW5pdGlhbFNjcm9sbCgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGxSZXF1ZXN0KHtcbiAgICAgICAgICAgIHRpbWU6IHRoaXMuc2Nyb2xsVGltZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRyYWluKCkge1xuICAgICAgICBpZiAodGhpcy5xdWV1ZWRSZXF1ZXN0ICYmIHRoaXMuZXhlY0Z1bmModGhpcy5xdWV1ZWRSZXF1ZXN0KSkge1xuICAgICAgICAgICAgdGhpcy5xdWV1ZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgVmlld0NvbnRleHRUeXBlID0gY3JlYXRlQ29udGV4dCh7fSk7IC8vIGZvciBDb21wb25lbnRzXG5mdW5jdGlvbiBidWlsZFZpZXdDb250ZXh0KHZpZXdTcGVjLCB2aWV3QXBpLCB2aWV3T3B0aW9ucywgZGF0ZVByb2ZpbGVHZW5lcmF0b3IsIGRhdGVFbnYsIHRoZW1lLCBwbHVnaW5Ib29rcywgZGlzcGF0Y2gsIGdldEN1cnJlbnREYXRhLCBlbWl0dGVyLCBjYWxlbmRhckFwaSwgcmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCwgdW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0ZUVudixcbiAgICAgICAgb3B0aW9uczogdmlld09wdGlvbnMsXG4gICAgICAgIHBsdWdpbkhvb2tzLFxuICAgICAgICBlbWl0dGVyLFxuICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgZ2V0Q3VycmVudERhdGEsXG4gICAgICAgIGNhbGVuZGFyQXBpLFxuICAgICAgICB2aWV3U3BlYyxcbiAgICAgICAgdmlld0FwaSxcbiAgICAgICAgZGF0ZVByb2ZpbGVHZW5lcmF0b3IsXG4gICAgICAgIHRoZW1lLFxuICAgICAgICBpc1J0bDogdmlld09wdGlvbnMuZGlyZWN0aW9uID09PSAncnRsJyxcbiAgICAgICAgYWRkUmVzaXplSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICAgICAgICBlbWl0dGVyLm9uKCdfcmVzaXplJywgaGFuZGxlcik7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZVJlc2l6ZUhhbmRsZXIoaGFuZGxlcikge1xuICAgICAgICAgICAgZW1pdHRlci5vZmYoJ19yZXNpemUnLCBoYW5kbGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlU2Nyb2xsUmVzcG9uZGVyKGV4ZWNGdW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNjcm9sbFJlc3BvbmRlcihleGVjRnVuYywgZW1pdHRlciwgY3JlYXRlRHVyYXRpb24odmlld09wdGlvbnMuc2Nyb2xsVGltZSksIHZpZXdPcHRpb25zLnNjcm9sbFRpbWVSZXNldCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQsXG4gICAgICAgIHVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCxcbiAgICB9O1xufVxuXG4vKiBlc2xpbnQgbWF4LWNsYXNzZXMtcGVyLWZpbGU6IG9mZiAqL1xuY2xhc3MgUHVyZUNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlKSB7XG4gICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgY29uc29sZS5sb2coZ2V0VW5lcXVhbFByb3BzKG5leHRQcm9wcywgdGhpcy5wcm9wcyksIGdldFVuZXF1YWxQcm9wcyhuZXh0U3RhdGUsIHRoaXMuc3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIWNvbXBhcmVPYmpzKHRoaXMucHJvcHMsIG5leHRQcm9wcywgdGhpcy5wcm9wRXF1YWxpdHkpIHx8XG4gICAgICAgICAgICAhY29tcGFyZU9ianModGhpcy5zdGF0ZSwgbmV4dFN0YXRlLCB0aGlzLnN0YXRlRXF1YWxpdHkpO1xuICAgIH1cbiAgICAvLyBIQUNLIGZvciBmcmVha2luJyBSZWFjdCBTdHJpY3RNb2RlXG4gICAgc2FmZVNldFN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIGlmICghY29tcGFyZU9ianModGhpcy5zdGF0ZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0YXRlKSwgbmV3U3RhdGUpLCB0aGlzLnN0YXRlRXF1YWxpdHkpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblB1cmVDb21wb25lbnQuYWRkUHJvcHNFcXVhbGl0eSA9IGFkZFByb3BzRXF1YWxpdHk7XG5QdXJlQ29tcG9uZW50LmFkZFN0YXRlRXF1YWxpdHkgPSBhZGRTdGF0ZUVxdWFsaXR5O1xuUHVyZUNvbXBvbmVudC5jb250ZXh0VHlwZSA9IFZpZXdDb250ZXh0VHlwZTtcblB1cmVDb21wb25lbnQucHJvdG90eXBlLnByb3BFcXVhbGl0eSA9IHt9O1xuUHVyZUNvbXBvbmVudC5wcm90b3R5cGUuc3RhdGVFcXVhbGl0eSA9IHt9O1xuY2xhc3MgQmFzZUNvbXBvbmVudCBleHRlbmRzIFB1cmVDb21wb25lbnQge1xufVxuQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZSA9IFZpZXdDb250ZXh0VHlwZTtcbmZ1bmN0aW9uIGFkZFByb3BzRXF1YWxpdHkocHJvcEVxdWFsaXR5KSB7XG4gICAgbGV0IGhhc2ggPSBPYmplY3QuY3JlYXRlKHRoaXMucHJvdG90eXBlLnByb3BFcXVhbGl0eSk7XG4gICAgT2JqZWN0LmFzc2lnbihoYXNoLCBwcm9wRXF1YWxpdHkpO1xuICAgIHRoaXMucHJvdG90eXBlLnByb3BFcXVhbGl0eSA9IGhhc2g7XG59XG5mdW5jdGlvbiBhZGRTdGF0ZUVxdWFsaXR5KHN0YXRlRXF1YWxpdHkpIHtcbiAgICBsZXQgaGFzaCA9IE9iamVjdC5jcmVhdGUodGhpcy5wcm90b3R5cGUuc3RhdGVFcXVhbGl0eSk7XG4gICAgT2JqZWN0LmFzc2lnbihoYXNoLCBzdGF0ZUVxdWFsaXR5KTtcbiAgICB0aGlzLnByb3RvdHlwZS5zdGF0ZUVxdWFsaXR5ID0gaGFzaDtcbn1cbi8vIHVzZSBvdGhlciBvbmVcbmZ1bmN0aW9uIHNldFJlZihyZWYsIGN1cnJlbnQpIHtcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZWYoY3VycmVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlZikge1xuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzAyOVxuICAgICAgICByZWYuY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgfVxufVxuXG5jbGFzcyBDb250ZW50SW5qZWN0b3IgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5pZCA9IGd1aWQoKTtcbiAgICAgICAgdGhpcy5xdWV1ZWREb21Ob2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnREb21Ob2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmhhbmRsZUVsID0gKGVsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgICAgIGNvbnN0IHsgZ2VuZXJhdG9yTmFtZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5jdXN0b21SZW5kZXJpbmdSZXBsYWNlcyB8fCAhaGFzQ3VzdG9tUmVuZGVyaW5nSGFuZGxlcihnZW5lcmF0b3JOYW1lLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRWxSZWYoZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZUVsUmVmID0gKGVsKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5lbFJlZikge1xuICAgICAgICAgICAgICAgIHNldFJlZih0aGlzLnByb3BzLmVsUmVmLCBlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgICAgICBjb25zdCB7IGN1c3RvbUdlbmVyYXRvciwgZGVmYXVsdEdlbmVyYXRvciwgcmVuZGVyUHJvcHMgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBhdHRycyA9IGJ1aWxkRWxBdHRycyhwcm9wcywgW10sIHRoaXMuaGFuZGxlRWwpO1xuICAgICAgICBsZXQgdXNlRGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICBsZXQgaW5uZXJDb250ZW50O1xuICAgICAgICBsZXQgcXVldWVkRG9tTm9kZXMgPSBbXTtcbiAgICAgICAgbGV0IGN1cnJlbnRHZW5lcmF0b3JNZXRhO1xuICAgICAgICBpZiAoY3VzdG9tR2VuZXJhdG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1c3RvbUdlbmVyYXRvclJlcyA9IHR5cGVvZiBjdXN0b21HZW5lcmF0b3IgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgICAgIGN1c3RvbUdlbmVyYXRvcihyZW5kZXJQcm9wcywgY3JlYXRlRWxlbWVudCkgOlxuICAgICAgICAgICAgICAgIGN1c3RvbUdlbmVyYXRvcjtcbiAgICAgICAgICAgIGlmIChjdXN0b21HZW5lcmF0b3JSZXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB1c2VEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzT2JqZWN0ID0gY3VzdG9tR2VuZXJhdG9yUmVzICYmIHR5cGVvZiBjdXN0b21HZW5lcmF0b3JSZXMgPT09ICdvYmplY3QnOyAvLyBub24tbnVsbFxuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdCAmJiAoJ2h0bWwnIGluIGN1c3RvbUdlbmVyYXRvclJlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPSB7IF9faHRtbDogY3VzdG9tR2VuZXJhdG9yUmVzLmh0bWwgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QgJiYgKCdkb21Ob2RlcycgaW4gY3VzdG9tR2VuZXJhdG9yUmVzKSkge1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZWREb21Ob2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGN1c3RvbUdlbmVyYXRvclJlcy5kb21Ob2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0XG4gICAgICAgICAgICAgICAgICAgID8gaXNWYWxpZEVsZW1lbnQoY3VzdG9tR2VuZXJhdG9yUmVzKSAvLyB2ZG9tIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2YgY3VzdG9tR2VuZXJhdG9yUmVzICE9PSAnZnVuY3Rpb24nIC8vIHByaW1pdGl2ZSB2YWx1ZSAobGlrZSBzdHJpbmcgb3IgbnVtYmVyKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvLyB1c2UgaW4gdmRvbVxuICAgICAgICAgICAgICAgICAgICBpbm5lckNvbnRlbnQgPSBjdXN0b21HZW5lcmF0b3JSZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBhbiBleG90aWMgb2JqZWN0IGZvciBoYW5kbGVDdXN0b21SZW5kZXJpbmdcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEdlbmVyYXRvck1ldGEgPSBjdXN0b21HZW5lcmF0b3JSZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXNlRGVmYXVsdCA9ICFoYXNDdXN0b21SZW5kZXJpbmdIYW5kbGVyKHByb3BzLmdlbmVyYXRvck5hbWUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VEZWZhdWx0ICYmIGRlZmF1bHRHZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIGlubmVyQ29udGVudCA9IGRlZmF1bHRHZW5lcmF0b3IocmVuZGVyUHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucXVldWVkRG9tTm9kZXMgPSBxdWV1ZWREb21Ob2RlcztcbiAgICAgICAgdGhpcy5jdXJyZW50R2VuZXJhdG9yTWV0YSA9IGN1cnJlbnRHZW5lcmF0b3JNZXRhO1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChwcm9wcy5lbFRhZywgYXR0cnMsIGlubmVyQ29udGVudCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLmFwcGx5UXVldWV1ZERvbU5vZGVzKCk7XG4gICAgICAgIHRoaXMudHJpZ2dlckN1c3RvbVJlbmRlcmluZyh0cnVlKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICB0aGlzLmFwcGx5UXVldWV1ZERvbU5vZGVzKCk7XG4gICAgICAgIHRoaXMudHJpZ2dlckN1c3RvbVJlbmRlcmluZyh0cnVlKTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlckN1c3RvbVJlbmRlcmluZyhmYWxzZSk7IC8vIFRPRE86IGRpZmZlcmVudCBBUEkgZm9yIHJlbW92YWw/XG4gICAgfVxuICAgIHRyaWdnZXJDdXN0b21SZW5kZXJpbmcoaXNBY3RpdmUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGhhbmRsZUN1c3RvbVJlbmRlcmluZywgY3VzdG9tUmVuZGVyaW5nTWV0YU1hcCB9ID0gY29udGV4dC5vcHRpb25zO1xuICAgICAgICBpZiAoaGFuZGxlQ3VzdG9tUmVuZGVyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBnZW5lcmF0b3JNZXRhID0gKF9hID0gdGhpcy5jdXJyZW50R2VuZXJhdG9yTWV0YSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY3VzdG9tUmVuZGVyaW5nTWV0YU1hcCA9PT0gbnVsbCB8fCBjdXN0b21SZW5kZXJpbmdNZXRhTWFwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXN0b21SZW5kZXJpbmdNZXRhTWFwW3Byb3BzLmdlbmVyYXRvck5hbWVdO1xuICAgICAgICAgICAgaWYgKGdlbmVyYXRvck1ldGEpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVDdXN0b21SZW5kZXJpbmcoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgaWQ6IHRoaXMuaWQsIGlzQWN0aXZlLCBjb250YWluZXJFbDogdGhpcy5iYXNlLCByZXBvcnROZXdDb250YWluZXJFbDogdGhpcy51cGRhdGVFbFJlZiwgLy8gZnJvbnQtZW5kIGZyYW1ld29yayB0ZWxscyB1cyBhYm91dCBuZXcgY29udGFpbmVyIGVsc1xuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0b3JNZXRhIH0sIHByb3BzKSwgeyBlbENsYXNzZXM6IChwcm9wcy5lbENsYXNzZXMgfHwgW10pLmZpbHRlcihpc1RydXRoeSkgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFwcGx5UXVldWV1ZERvbU5vZGVzKCkge1xuICAgICAgICBjb25zdCB7IHF1ZXVlZERvbU5vZGVzLCBjdXJyZW50RG9tTm9kZXMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpcy5iYXNlO1xuICAgICAgICBpZiAoIWlzQXJyYXlzRXF1YWwocXVldWVkRG9tTm9kZXMsIGN1cnJlbnREb21Ob2RlcykpIHtcbiAgICAgICAgICAgIGN1cnJlbnREb21Ob2Rlcy5mb3JFYWNoKHJlbW92ZUVsZW1lbnQpO1xuICAgICAgICAgICAgZm9yIChsZXQgbmV3Tm9kZSBvZiBxdWV1ZWREb21Ob2Rlcykge1xuICAgICAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKG5ld05vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50RG9tTm9kZXMgPSBxdWV1ZWREb21Ob2RlcztcbiAgICAgICAgfVxuICAgIH1cbn1cbkNvbnRlbnRJbmplY3Rvci5hZGRQcm9wc0VxdWFsaXR5KHtcbiAgICBlbENsYXNzZXM6IGlzQXJyYXlzRXF1YWwsXG4gICAgZWxTdHlsZTogaXNQcm9wc0VxdWFsLFxuICAgIGVsQXR0cnM6IGlzTm9uSGFuZGxlclByb3BzRXF1YWwsXG4gICAgcmVuZGVyUHJvcHM6IGlzUHJvcHNFcXVhbCxcbn0pO1xuLy8gVXRpbFxuLypcbkRvZXMgVUktZnJhbWV3b3JrIHByb3ZpZGUgY3VzdG9tIHdheSBvZiByZW5kZXJpbmcgdGhhdCBkb2VzIG5vdCB1c2UgUHJlYWN0IFZET01cbkFORCBkb2VzIHRoZSBjYWxlbmRhcidzIG9wdGlvbnMgZGVmaW5lIGN1c3RvbSByZW5kZXJpbmc/XG5BS0EuIFNob3VsZCB3ZSBOT1QgcmVuZGVyIHRoZSBkZWZhdWx0IGNvbnRlbnQ/XG4qL1xuZnVuY3Rpb24gaGFzQ3VzdG9tUmVuZGVyaW5nSGFuZGxlcihnZW5lcmF0b3JOYW1lLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBCb29sZWFuKG9wdGlvbnMuaGFuZGxlQ3VzdG9tUmVuZGVyaW5nICYmXG4gICAgICAgIGdlbmVyYXRvck5hbWUgJiZcbiAgICAgICAgKChfYSA9IG9wdGlvbnMuY3VzdG9tUmVuZGVyaW5nTWV0YU1hcCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2dlbmVyYXRvck5hbWVdKSk7XG59XG5mdW5jdGlvbiBidWlsZEVsQXR0cnMocHJvcHMsIGV4dHJhQ2xhc3NOYW1lcywgZWxSZWYpIHtcbiAgICBjb25zdCBhdHRycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMuZWxBdHRycyksIHsgcmVmOiBlbFJlZiB9KTtcbiAgICBpZiAocHJvcHMuZWxDbGFzc2VzIHx8IGV4dHJhQ2xhc3NOYW1lcykge1xuICAgICAgICBhdHRycy5jbGFzc05hbWUgPSAocHJvcHMuZWxDbGFzc2VzIHx8IFtdKVxuICAgICAgICAgICAgLmNvbmNhdChleHRyYUNsYXNzTmFtZXMgfHwgW10pXG4gICAgICAgICAgICAuY29uY2F0KGF0dHJzLmNsYXNzTmFtZSB8fCBbXSlcbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgICAgIC5qb2luKCcgJyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5lbFN0eWxlKSB7XG4gICAgICAgIGF0dHJzLnN0eWxlID0gcHJvcHMuZWxTdHlsZTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJzO1xufVxuZnVuY3Rpb24gaXNUcnV0aHkodmFsKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odmFsKTtcbn1cblxuY29uc3QgUmVuZGVySWQgPSBjcmVhdGVDb250ZXh0KDApO1xuXG5jbGFzcyBDb250ZW50Q29udGFpbmVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5Jbm5lckNvbnRlbnQgPSBJbm5lckNvbnRlbnRJbmplY3Rvci5iaW5kKHVuZGVmaW5lZCwgdGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlRWwgPSAoZWwpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmVsUmVmKSB7XG4gICAgICAgICAgICAgICAgc2V0UmVmKHRoaXMucHJvcHMuZWxSZWYsIGVsKTtcbiAgICAgICAgICAgICAgICBpZiAoZWwgJiYgdGhpcy5kaWRNb3VudE1pc2ZpcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBnZW5lcmF0ZWRDbGFzc05hbWVzID0gZ2VuZXJhdGVDbGFzc05hbWVzKHByb3BzLmNsYXNzTmFtZUdlbmVyYXRvciwgcHJvcHMucmVuZGVyUHJvcHMpO1xuICAgICAgICBpZiAocHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGVsQXR0cnMgPSBidWlsZEVsQXR0cnMocHJvcHMsIGdlbmVyYXRlZENsYXNzTmFtZXMsIHRoaXMuaGFuZGxlRWwpO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbih0aGlzLklubmVyQ29udGVudCwgcHJvcHMucmVuZGVyUHJvcHMsIGVsQXR0cnMpO1xuICAgICAgICAgICAgaWYgKHByb3BzLmVsVGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQocHJvcHMuZWxUYWcsIGVsQXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KChDb250ZW50SW5qZWN0b3IpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSwgeyBlbFJlZjogdGhpcy5oYW5kbGVFbCwgZWxUYWc6IHByb3BzLmVsVGFnIHx8ICdkaXYnLCBlbENsYXNzZXM6IChwcm9wcy5lbENsYXNzZXMgfHwgW10pLmNvbmNhdChnZW5lcmF0ZWRDbGFzc05hbWVzKSwgcmVuZGVySWQ6IHRoaXMuY29udGV4dCB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLmVsKSB7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLnByb3BzKS5kaWRNb3VudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcy5yZW5kZXJQcm9wcyksIHsgZWw6IHRoaXMuZWwgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kaWRNb3VudE1pc2ZpcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLnByb3BzKS53aWxsVW5tb3VudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcy5yZW5kZXJQcm9wcyksIHsgZWw6IHRoaXMuZWwgfSkpO1xuICAgIH1cbn1cbkNvbnRlbnRDb250YWluZXIuY29udGV4dFR5cGUgPSBSZW5kZXJJZDtcbmZ1bmN0aW9uIElubmVyQ29udGVudEluamVjdG9yKGNvbnRhaW5lckNvbXBvbmVudCwgcHJvcHMpIHtcbiAgICBjb25zdCBwYXJlbnRQcm9wcyA9IGNvbnRhaW5lckNvbXBvbmVudC5wcm9wcztcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgoQ29udGVudEluamVjdG9yKSwgT2JqZWN0LmFzc2lnbih7IHJlbmRlclByb3BzOiBwYXJlbnRQcm9wcy5yZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogcGFyZW50UHJvcHMuZ2VuZXJhdG9yTmFtZSwgY3VzdG9tR2VuZXJhdG9yOiBwYXJlbnRQcm9wcy5jdXN0b21HZW5lcmF0b3IsIGRlZmF1bHRHZW5lcmF0b3I6IHBhcmVudFByb3BzLmRlZmF1bHRHZW5lcmF0b3IsIHJlbmRlcklkOiBjb250YWluZXJDb21wb25lbnQuY29udGV4dCB9LCBwcm9wcykpO1xufVxuLy8gVXRpbHNcbmZ1bmN0aW9uIGdlbmVyYXRlQ2xhc3NOYW1lcyhjbGFzc05hbWVHZW5lcmF0b3IsIHJlbmRlclByb3BzKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IHR5cGVvZiBjbGFzc05hbWVHZW5lcmF0b3IgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICBjbGFzc05hbWVHZW5lcmF0b3IocmVuZGVyUHJvcHMpIDpcbiAgICAgICAgY2xhc3NOYW1lR2VuZXJhdG9yIHx8IFtdO1xuICAgIHJldHVybiB0eXBlb2YgY2xhc3NOYW1lcyA9PT0gJ3N0cmluZycgPyBbY2xhc3NOYW1lc10gOiBjbGFzc05hbWVzO1xufVxuXG5jbGFzcyBWaWV3Q29udGFpbmVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICAgICAgbGV0IHJlbmRlclByb3BzID0geyB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7IGVsVGFnOiBwcm9wcy5lbFRhZyB8fCAnZGl2JywgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgLi4uYnVpbGRWaWV3Q2xhc3NOYW1lcyhwcm9wcy52aWV3U3BlYyksXG4gICAgICAgICAgICAgICAgLi4uKHByb3BzLmVsQ2xhc3NlcyB8fCBbXSksXG4gICAgICAgICAgICBdLCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy52aWV3Q2xhc3NOYW1lcywgZ2VuZXJhdG9yTmFtZTogdW5kZWZpbmVkLCBkaWRNb3VudDogb3B0aW9ucy52aWV3RGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLnZpZXdXaWxsVW5tb3VudCB9KSwgKCkgPT4gcHJvcHMuY2hpbGRyZW4pKTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZFZpZXdDbGFzc05hbWVzKHZpZXdTcGVjKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgYGZjLSR7dmlld1NwZWMudHlwZX0tdmlld2AsXG4gICAgICAgICdmYy12aWV3JyxcbiAgICBdO1xufVxuXG5mdW5jdGlvbiBwYXJzZVJhbmdlKGlucHV0LCBkYXRlRW52KSB7XG4gICAgbGV0IHN0YXJ0ID0gbnVsbDtcbiAgICBsZXQgZW5kID0gbnVsbDtcbiAgICBpZiAoaW5wdXQuc3RhcnQpIHtcbiAgICAgICAgc3RhcnQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihpbnB1dC5zdGFydCk7XG4gICAgfVxuICAgIGlmIChpbnB1dC5lbmQpIHtcbiAgICAgICAgZW5kID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoaW5wdXQuZW5kKTtcbiAgICB9XG4gICAgaWYgKCFzdGFydCAmJiAhZW5kKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgJiYgZW5kICYmIGVuZCA8IHN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG59XG4vLyBTSURFLUVGRkVDVDogd2lsbCBtdXRhdGUgcmFuZ2VzLlxuLy8gV2lsbCByZXR1cm4gYSBuZXcgYXJyYXkgcmVzdWx0LlxuZnVuY3Rpb24gaW52ZXJ0UmFuZ2VzKHJhbmdlcywgY29uc3RyYWludFJhbmdlKSB7XG4gICAgbGV0IGludmVydGVkUmFuZ2VzID0gW107XG4gICAgbGV0IHsgc3RhcnQgfSA9IGNvbnN0cmFpbnRSYW5nZTsgLy8gdGhlIGVuZCBvZiB0aGUgcHJldmlvdXMgcmFuZ2UuIHRoZSBzdGFydCBvZiB0aGUgbmV3IHJhbmdlXG4gICAgbGV0IGk7XG4gICAgbGV0IGRhdGVSYW5nZTtcbiAgICAvLyByYW5nZXMgbmVlZCB0byBiZSBpbiBvcmRlci4gcmVxdWlyZWQgZm9yIG91ciBkYXRlLXdhbGtpbmcgYWxnb3JpdGhtXG4gICAgcmFuZ2VzLnNvcnQoY29tcGFyZVJhbmdlcyk7XG4gICAgZm9yIChpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBkYXRlUmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgIC8vIGFkZCB0aGUgc3BhbiBvZiB0aW1lIGJlZm9yZSB0aGUgZXZlbnQgKGlmIHRoZXJlIGlzIGFueSlcbiAgICAgICAgaWYgKGRhdGVSYW5nZS5zdGFydCA+IHN0YXJ0KSB7IC8vIGNvbXBhcmUgbWlsbGlzZWNvbmQgdGltZSAoc2tpcCBhbnkgYW1iaWcgbG9naWMpXG4gICAgICAgICAgICBpbnZlcnRlZFJhbmdlcy5wdXNoKHsgc3RhcnQsIGVuZDogZGF0ZVJhbmdlLnN0YXJ0IH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRlUmFuZ2UuZW5kID4gc3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gZGF0ZVJhbmdlLmVuZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgdGhlIHNwYW4gb2YgdGltZSBhZnRlciB0aGUgbGFzdCBldmVudCAoaWYgdGhlcmUgaXMgYW55KVxuICAgIGlmIChzdGFydCA8IGNvbnN0cmFpbnRSYW5nZS5lbmQpIHsgLy8gY29tcGFyZSBtaWxsaXNlY29uZCB0aW1lIChza2lwIGFueSBhbWJpZyBsb2dpYylcbiAgICAgICAgaW52ZXJ0ZWRSYW5nZXMucHVzaCh7IHN0YXJ0LCBlbmQ6IGNvbnN0cmFpbnRSYW5nZS5lbmQgfSk7XG4gICAgfVxuICAgIHJldHVybiBpbnZlcnRlZFJhbmdlcztcbn1cbmZ1bmN0aW9uIGNvbXBhcmVSYW5nZXMocmFuZ2UwLCByYW5nZTEpIHtcbiAgICByZXR1cm4gcmFuZ2UwLnN0YXJ0LnZhbHVlT2YoKSAtIHJhbmdlMS5zdGFydC52YWx1ZU9mKCk7IC8vIGVhcmxpZXIgcmFuZ2VzIGdvIGZpcnN0XG59XG5mdW5jdGlvbiBpbnRlcnNlY3RSYW5nZXMocmFuZ2UwLCByYW5nZTEpIHtcbiAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSByYW5nZTA7XG4gICAgbGV0IG5ld1JhbmdlID0gbnVsbDtcbiAgICBpZiAocmFuZ2UxLnN0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhcnQgPSByYW5nZTEuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydCA9IG5ldyBEYXRlKE1hdGgubWF4KHN0YXJ0LnZhbHVlT2YoKSwgcmFuZ2UxLnN0YXJ0LnZhbHVlT2YoKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyYW5nZTEuZW5kICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZW5kID0gcmFuZ2UxLmVuZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuZCA9IG5ldyBEYXRlKE1hdGgubWluKGVuZC52YWx1ZU9mKCksIHJhbmdlMS5lbmQudmFsdWVPZigpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXJ0ID09PSBudWxsIHx8IGVuZCA9PT0gbnVsbCB8fCBzdGFydCA8IGVuZCkge1xuICAgICAgICBuZXdSYW5nZSA9IHsgc3RhcnQsIGVuZCB9O1xuICAgIH1cbiAgICByZXR1cm4gbmV3UmFuZ2U7XG59XG5mdW5jdGlvbiByYW5nZXNFcXVhbChyYW5nZTAsIHJhbmdlMSkge1xuICAgIHJldHVybiAocmFuZ2UwLnN0YXJ0ID09PSBudWxsID8gbnVsbCA6IHJhbmdlMC5zdGFydC52YWx1ZU9mKCkpID09PSAocmFuZ2UxLnN0YXJ0ID09PSBudWxsID8gbnVsbCA6IHJhbmdlMS5zdGFydC52YWx1ZU9mKCkpICYmXG4gICAgICAgIChyYW5nZTAuZW5kID09PSBudWxsID8gbnVsbCA6IHJhbmdlMC5lbmQudmFsdWVPZigpKSA9PT0gKHJhbmdlMS5lbmQgPT09IG51bGwgPyBudWxsIDogcmFuZ2UxLmVuZC52YWx1ZU9mKCkpO1xufVxuZnVuY3Rpb24gcmFuZ2VzSW50ZXJzZWN0KHJhbmdlMCwgcmFuZ2UxKSB7XG4gICAgcmV0dXJuIChyYW5nZTAuZW5kID09PSBudWxsIHx8IHJhbmdlMS5zdGFydCA9PT0gbnVsbCB8fCByYW5nZTAuZW5kID4gcmFuZ2UxLnN0YXJ0KSAmJlxuICAgICAgICAocmFuZ2UwLnN0YXJ0ID09PSBudWxsIHx8IHJhbmdlMS5lbmQgPT09IG51bGwgfHwgcmFuZ2UwLnN0YXJ0IDwgcmFuZ2UxLmVuZCk7XG59XG5mdW5jdGlvbiByYW5nZUNvbnRhaW5zUmFuZ2Uob3V0ZXJSYW5nZSwgaW5uZXJSYW5nZSkge1xuICAgIHJldHVybiAob3V0ZXJSYW5nZS5zdGFydCA9PT0gbnVsbCB8fCAoaW5uZXJSYW5nZS5zdGFydCAhPT0gbnVsbCAmJiBpbm5lclJhbmdlLnN0YXJ0ID49IG91dGVyUmFuZ2Uuc3RhcnQpKSAmJlxuICAgICAgICAob3V0ZXJSYW5nZS5lbmQgPT09IG51bGwgfHwgKGlubmVyUmFuZ2UuZW5kICE9PSBudWxsICYmIGlubmVyUmFuZ2UuZW5kIDw9IG91dGVyUmFuZ2UuZW5kKSk7XG59XG5mdW5jdGlvbiByYW5nZUNvbnRhaW5zTWFya2VyKHJhbmdlLCBkYXRlKSB7XG4gICAgcmV0dXJuIChyYW5nZS5zdGFydCA9PT0gbnVsbCB8fCBkYXRlID49IHJhbmdlLnN0YXJ0KSAmJlxuICAgICAgICAocmFuZ2UuZW5kID09PSBudWxsIHx8IGRhdGUgPCByYW5nZS5lbmQpO1xufVxuLy8gSWYgdGhlIGdpdmVuIGRhdGUgaXMgbm90IHdpdGhpbiB0aGUgZ2l2ZW4gcmFuZ2UsIG1vdmUgaXQgaW5zaWRlLlxuLy8gKElmIGl0J3MgcGFzdCB0aGUgZW5kLCBtYWtlIGl0IG9uZSBtaWxsaXNlY29uZCBiZWZvcmUgdGhlIGVuZCkuXG5mdW5jdGlvbiBjb25zdHJhaW5NYXJrZXJUb1JhbmdlKGRhdGUsIHJhbmdlKSB7XG4gICAgaWYgKHJhbmdlLnN0YXJ0ICE9IG51bGwgJiYgZGF0ZSA8IHJhbmdlLnN0YXJ0KSB7XG4gICAgICAgIHJldHVybiByYW5nZS5zdGFydDtcbiAgICB9XG4gICAgaWYgKHJhbmdlLmVuZCAhPSBudWxsICYmIGRhdGUgPj0gcmFuZ2UuZW5kKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShyYW5nZS5lbmQudmFsdWVPZigpIC0gMSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRlO1xufVxuXG4vKiBEYXRlIHN0dWZmIHRoYXQgZG9lc24ndCBiZWxvbmcgaW4gZGF0ZWxpYiBjb3JlXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8vIGdpdmVuIGEgdGltZWQgcmFuZ2UsIGNvbXB1dGVzIGFuIGFsbC1kYXkgcmFuZ2UgdGhhdCBoYXMgdGhlIHNhbWUgZXhhY3QgZHVyYXRpb24sXG4vLyBidXQgd2hvc2Ugc3RhcnQgdGltZSBpcyBhbGlnbmVkIHdpdGggdGhlIHN0YXJ0IG9mIHRoZSBkYXkuXG5mdW5jdGlvbiBjb21wdXRlQWxpZ25lZERheVJhbmdlKHRpbWVkUmFuZ2UpIHtcbiAgICBsZXQgZGF5Q250ID0gTWF0aC5mbG9vcihkaWZmRGF5cyh0aW1lZFJhbmdlLnN0YXJ0LCB0aW1lZFJhbmdlLmVuZCkpIHx8IDE7XG4gICAgbGV0IHN0YXJ0ID0gc3RhcnRPZkRheSh0aW1lZFJhbmdlLnN0YXJ0KTtcbiAgICBsZXQgZW5kID0gYWRkRGF5cyhzdGFydCwgZGF5Q250KTtcbiAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG59XG4vLyBnaXZlbiBhIHRpbWVkIHJhbmdlLCBjb21wdXRlcyBhbiBhbGwtZGF5IHJhbmdlIGJhc2VkIG9uIGhvdyBmb3IgdGhlIGVuZCBkYXRlIGJsZWVkcyBpbnRvIHRoZSBuZXh0IGRheVxuLy8gVE9ETzogZ2l2ZSBuZXh0RGF5VGhyZXNob2xkIGEgZGVmYXVsdCBhcmdcbmZ1bmN0aW9uIGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UodGltZWRSYW5nZSwgbmV4dERheVRocmVzaG9sZCA9IGNyZWF0ZUR1cmF0aW9uKDApKSB7XG4gICAgbGV0IHN0YXJ0RGF5ID0gbnVsbDtcbiAgICBsZXQgZW5kRGF5ID0gbnVsbDtcbiAgICBpZiAodGltZWRSYW5nZS5lbmQpIHtcbiAgICAgICAgZW5kRGF5ID0gc3RhcnRPZkRheSh0aW1lZFJhbmdlLmVuZCk7XG4gICAgICAgIGxldCBlbmRUaW1lTVMgPSB0aW1lZFJhbmdlLmVuZC52YWx1ZU9mKCkgLSBlbmREYXkudmFsdWVPZigpOyAvLyAjIG9mIG1pbGxpc2Vjb25kcyBpbnRvIGBlbmREYXlgXG4gICAgICAgIC8vIElmIHRoZSBlbmQgdGltZSBpcyBhY3R1YWxseSBpbmNsdXNpdmVseSBwYXJ0IG9mIHRoZSBuZXh0IGRheSBhbmQgaXMgZXF1YWwgdG8gb3JcbiAgICAgICAgLy8gYmV5b25kIHRoZSBuZXh0IGRheSB0aHJlc2hvbGQsIGFkanVzdCB0aGUgZW5kIHRvIGJlIHRoZSBleGNsdXNpdmUgZW5kIG9mIGBlbmREYXlgLlxuICAgICAgICAvLyBPdGhlcndpc2UsIGxlYXZpbmcgaXQgYXMgaW5jbHVzaXZlIHdpbGwgY2F1c2UgaXQgdG8gZXhjbHVkZSBgZW5kRGF5YC5cbiAgICAgICAgaWYgKGVuZFRpbWVNUyAmJiBlbmRUaW1lTVMgPj0gYXNSb3VnaE1zKG5leHREYXlUaHJlc2hvbGQpKSB7XG4gICAgICAgICAgICBlbmREYXkgPSBhZGREYXlzKGVuZERheSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVkUmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgc3RhcnREYXkgPSBzdGFydE9mRGF5KHRpbWVkUmFuZ2Uuc3RhcnQpOyAvLyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkYXkgdGhlIHJhbmdlIHN0YXJ0c1xuICAgICAgICAvLyBJZiBlbmQgaXMgd2l0aGluIGBzdGFydERheWAgYnV0IG5vdCBwYXN0IG5leHREYXlUaHJlc2hvbGQsIGFzc2lnbiB0aGUgZGVmYXVsdCBkdXJhdGlvbiBvZiBvbmUgZGF5LlxuICAgICAgICBpZiAoZW5kRGF5ICYmIGVuZERheSA8PSBzdGFydERheSkge1xuICAgICAgICAgICAgZW5kRGF5ID0gYWRkRGF5cyhzdGFydERheSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0RGF5LCBlbmQ6IGVuZERheSB9O1xufVxuLy8gc3BhbnMgZnJvbSBvbmUgZGF5IGludG8gYW5vdGhlcj9cbmZ1bmN0aW9uIGlzTXVsdGlEYXlSYW5nZShyYW5nZSkge1xuICAgIGxldCB2aXNpYmxlUmFuZ2UgPSBjb21wdXRlVmlzaWJsZURheVJhbmdlKHJhbmdlKTtcbiAgICByZXR1cm4gZGlmZkRheXModmlzaWJsZVJhbmdlLnN0YXJ0LCB2aXNpYmxlUmFuZ2UuZW5kKSA+IDE7XG59XG5mdW5jdGlvbiBkaWZmRGF0ZXMoZGF0ZTAsIGRhdGUxLCBkYXRlRW52LCBsYXJnZVVuaXQpIHtcbiAgICBpZiAobGFyZ2VVbml0ID09PSAneWVhcicpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKGRhdGVFbnYuZGlmZldob2xlWWVhcnMoZGF0ZTAsIGRhdGUxKSwgJ3llYXInKTtcbiAgICB9XG4gICAgaWYgKGxhcmdlVW5pdCA9PT0gJ21vbnRoJykge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oZGF0ZUVudi5kaWZmV2hvbGVNb250aHMoZGF0ZTAsIGRhdGUxKSwgJ21vbnRoJyk7XG4gICAgfVxuICAgIHJldHVybiBkaWZmRGF5QW5kVGltZShkYXRlMCwgZGF0ZTEpOyAvLyByZXR1cm5zIGEgZHVyYXRpb25cbn1cblxuZnVuY3Rpb24gcmVkdWNlQ3VycmVudERhdGUoY3VycmVudERhdGUsIGFjdGlvbikge1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnQ0hBTkdFX0RBVEUnOlxuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5kYXRlTWFya2VyO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnREYXRlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEluaXRpYWxEYXRlKG9wdGlvbnMsIGRhdGVFbnYpIHtcbiAgICBsZXQgaW5pdGlhbERhdGVJbnB1dCA9IG9wdGlvbnMuaW5pdGlhbERhdGU7XG4gICAgLy8gY29tcHV0ZSB0aGUgaW5pdGlhbCBhbWJpZy10aW1lem9uZSBkYXRlXG4gICAgaWYgKGluaXRpYWxEYXRlSW5wdXQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZGF0ZUVudi5jcmVhdGVNYXJrZXIoaW5pdGlhbERhdGVJbnB1dCk7XG4gICAgfVxuICAgIHJldHVybiBnZXROb3cob3B0aW9ucy5ub3csIGRhdGVFbnYpOyAvLyBnZXROb3cgYWxyZWFkeSByZXR1cm5zIHVuem9uZWRcbn1cbmZ1bmN0aW9uIGdldE5vdyhub3dJbnB1dCwgZGF0ZUVudikge1xuICAgIGlmICh0eXBlb2Ygbm93SW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbm93SW5wdXQgPSBub3dJbnB1dCgpO1xuICAgIH1cbiAgICBpZiAobm93SW5wdXQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZGF0ZUVudi5jcmVhdGVOb3dNYXJrZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGVFbnYuY3JlYXRlTWFya2VyKG5vd0lucHV0KTtcbn1cblxuY2xhc3MgRGF0ZVByb2ZpbGVHZW5lcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5ub3dEYXRlID0gZ2V0Tm93KHByb3BzLm5vd0lucHV0LCBwcm9wcy5kYXRlRW52KTtcbiAgICAgICAgdGhpcy5pbml0SGlkZGVuRGF5cygpO1xuICAgIH1cbiAgICAvKiBEYXRlIFJhbmdlIENvbXB1dGF0aW9uXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgd2l0aCBpbmZvIGFib3V0IHdoYXQgdGhlIGRhdGVzL3JhbmdlcyB3aWxsIGJlIGZvciB0aGUgXCJwcmV2XCIgdmlldy5cbiAgICBidWlsZFByZXYoY3VycmVudERhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSwgZm9yY2VUb1ZhbGlkKSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBwcmV2RGF0ZSA9IGRhdGVFbnYuc3VidHJhY3QoZGF0ZUVudi5zdGFydE9mKGN1cnJlbnREYXRlLCBjdXJyZW50RGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCksIC8vIGltcG9ydGFudCBmb3Igc3RhcnQtb2YtbW9udGhcbiAgICAgICAgY3VycmVudERhdGVQcm9maWxlLmRhdGVJbmNyZW1lbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5idWlsZChwcmV2RGF0ZSwgLTEsIGZvcmNlVG9WYWxpZCk7XG4gICAgfVxuICAgIC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSB3aXRoIGluZm8gYWJvdXQgd2hhdCB0aGUgZGF0ZXMvcmFuZ2VzIHdpbGwgYmUgZm9yIHRoZSBcIm5leHRcIiB2aWV3LlxuICAgIGJ1aWxkTmV4dChjdXJyZW50RGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlLCBmb3JjZVRvVmFsaWQpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IG5leHREYXRlID0gZGF0ZUVudi5hZGQoZGF0ZUVudi5zdGFydE9mKGN1cnJlbnREYXRlLCBjdXJyZW50RGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCksIC8vIGltcG9ydGFudCBmb3Igc3RhcnQtb2YtbW9udGhcbiAgICAgICAgY3VycmVudERhdGVQcm9maWxlLmRhdGVJbmNyZW1lbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5idWlsZChuZXh0RGF0ZSwgMSwgZm9yY2VUb1ZhbGlkKTtcbiAgICB9XG4gICAgLy8gQnVpbGRzIGEgc3RydWN0dXJlIGhvbGRpbmcgZGF0ZXMvcmFuZ2VzIGZvciByZW5kZXJpbmcgYXJvdW5kIHRoZSBnaXZlbiBkYXRlLlxuICAgIC8vIE9wdGlvbmFsIGRpcmVjdGlvbiBwYXJhbSBpbmRpY2F0ZXMgd2hldGhlciB0aGUgZGF0ZSBpcyBiZWluZyBpbmNyZW1lbnRlZC9kZWNyZW1lbnRlZFxuICAgIC8vIGZyb20gaXRzIHByZXZpb3VzIHZhbHVlLiBkZWNyZW1lbnRlZCA9IC0xLCBpbmNyZW1lbnRlZCA9IDEgKGRlZmF1bHQpLlxuICAgIGJ1aWxkKGN1cnJlbnREYXRlLCBkaXJlY3Rpb24sIGZvcmNlVG9WYWxpZCA9IHRydWUpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB2YWxpZFJhbmdlO1xuICAgICAgICBsZXQgY3VycmVudEluZm87XG4gICAgICAgIGxldCBpc1JhbmdlQWxsRGF5O1xuICAgICAgICBsZXQgcmVuZGVyUmFuZ2U7XG4gICAgICAgIGxldCBhY3RpdmVSYW5nZTtcbiAgICAgICAgbGV0IGlzVmFsaWQ7XG4gICAgICAgIHZhbGlkUmFuZ2UgPSB0aGlzLmJ1aWxkVmFsaWRSYW5nZSgpO1xuICAgICAgICB2YWxpZFJhbmdlID0gdGhpcy50cmltSGlkZGVuRGF5cyh2YWxpZFJhbmdlKTtcbiAgICAgICAgaWYgKGZvcmNlVG9WYWxpZCkge1xuICAgICAgICAgICAgY3VycmVudERhdGUgPSBjb25zdHJhaW5NYXJrZXJUb1JhbmdlKGN1cnJlbnREYXRlLCB2YWxpZFJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50SW5mbyA9IHRoaXMuYnVpbGRDdXJyZW50UmFuZ2VJbmZvKGN1cnJlbnREYXRlLCBkaXJlY3Rpb24pO1xuICAgICAgICBpc1JhbmdlQWxsRGF5ID0gL14oeWVhcnxtb250aHx3ZWVrfGRheSkkLy50ZXN0KGN1cnJlbnRJbmZvLnVuaXQpO1xuICAgICAgICByZW5kZXJSYW5nZSA9IHRoaXMuYnVpbGRSZW5kZXJSYW5nZSh0aGlzLnRyaW1IaWRkZW5EYXlzKGN1cnJlbnRJbmZvLnJhbmdlKSwgY3VycmVudEluZm8udW5pdCwgaXNSYW5nZUFsbERheSk7XG4gICAgICAgIHJlbmRlclJhbmdlID0gdGhpcy50cmltSGlkZGVuRGF5cyhyZW5kZXJSYW5nZSk7XG4gICAgICAgIGFjdGl2ZVJhbmdlID0gcmVuZGVyUmFuZ2U7XG4gICAgICAgIGlmICghcHJvcHMuc2hvd05vbkN1cnJlbnREYXRlcykge1xuICAgICAgICAgICAgYWN0aXZlUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMoYWN0aXZlUmFuZ2UsIGN1cnJlbnRJbmZvLnJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBhY3RpdmVSYW5nZSA9IHRoaXMuYWRqdXN0QWN0aXZlUmFuZ2UoYWN0aXZlUmFuZ2UpO1xuICAgICAgICBhY3RpdmVSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhhY3RpdmVSYW5nZSwgdmFsaWRSYW5nZSk7IC8vIG1pZ2h0IHJldHVybiBudWxsXG4gICAgICAgIC8vIGl0J3MgaW52YWxpZCBpZiB0aGUgb3JpZ2luYWxseSByZXF1ZXN0ZWQgZGF0ZSBpcyBub3QgY29udGFpbmVkLFxuICAgICAgICAvLyBvciBpZiB0aGUgcmFuZ2UgaXMgY29tcGxldGVseSBvdXRzaWRlIG9mIHRoZSB2YWxpZCByYW5nZS5cbiAgICAgICAgaXNWYWxpZCA9IHJhbmdlc0ludGVyc2VjdChjdXJyZW50SW5mby5yYW5nZSwgdmFsaWRSYW5nZSk7XG4gICAgICAgIC8vIEhBQ0s6IGNvbnN0cmFpbiB0byByZW5kZXItcmFuZ2Ugc28gYGN1cnJlbnREYXRlYCBpcyBtb3JlIHVzZWZ1bCB0byB2aWV3IHJlbmRlcmluZ1xuICAgICAgICBpZiAoIXJhbmdlQ29udGFpbnNNYXJrZXIocmVuZGVyUmFuZ2UsIGN1cnJlbnREYXRlKSkge1xuICAgICAgICAgICAgY3VycmVudERhdGUgPSByZW5kZXJSYW5nZS5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3VycmVudERhdGUsXG4gICAgICAgICAgICAvLyBjb25zdHJhaW50IGZvciB3aGVyZSBwcmV2L25leHQgb3BlcmF0aW9ucyBjYW4gZ28gYW5kIHdoZXJlIGV2ZW50cyBjYW4gYmUgZHJhZ2dlZC9yZXNpemVkIHRvLlxuICAgICAgICAgICAgLy8gYW4gb2JqZWN0IHdpdGggb3B0aW9uYWwgc3RhcnQgYW5kIGVuZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgdmFsaWRSYW5nZSxcbiAgICAgICAgICAgIC8vIHJhbmdlIHRoZSB2aWV3IGlzIGZvcm1hbGx5IHJlc3BvbnNpYmxlIGZvci5cbiAgICAgICAgICAgIC8vIGZvciBleGFtcGxlLCBhIG1vbnRoIHZpZXcgbWlnaHQgaGF2ZSAxc3QtMzFzdCwgZXhjbHVkaW5nIHBhZGRlZCBkYXRlc1xuICAgICAgICAgICAgY3VycmVudFJhbmdlOiBjdXJyZW50SW5mby5yYW5nZSxcbiAgICAgICAgICAgIC8vIG5hbWUgb2YgbGFyZ2VzdCB1bml0IGJlaW5nIGRpc3BsYXllZCwgbGlrZSBcIm1vbnRoXCIgb3IgXCJ3ZWVrXCJcbiAgICAgICAgICAgIGN1cnJlbnRSYW5nZVVuaXQ6IGN1cnJlbnRJbmZvLnVuaXQsXG4gICAgICAgICAgICBpc1JhbmdlQWxsRGF5LFxuICAgICAgICAgICAgLy8gZGF0ZXMgdGhhdCBkaXNwbGF5IGV2ZW50cyBhbmQgYWNjZXB0IGRyYWctbi1kcm9wXG4gICAgICAgICAgICAvLyB3aWxsIGJlIGBudWxsYCBpZiBubyBkYXRlcyBhY2NlcHQgZXZlbnRzXG4gICAgICAgICAgICBhY3RpdmVSYW5nZSxcbiAgICAgICAgICAgIC8vIGRhdGUgcmFuZ2Ugd2l0aCBhIHJlbmRlcmVkIHNrZWxldG9uXG4gICAgICAgICAgICAvLyBpbmNsdWRlcyBub3QtYWN0aXZlIGRheXMgdGhhdCBuZWVkIHNvbWUgc29ydCBvZiBET01cbiAgICAgICAgICAgIHJlbmRlclJhbmdlLFxuICAgICAgICAgICAgLy8gRHVyYXRpb24gb2JqZWN0IHRoYXQgZGVub3RlcyB0aGUgZmlyc3QgdmlzaWJsZSB0aW1lIG9mIGFueSBnaXZlbiBkYXlcbiAgICAgICAgICAgIHNsb3RNaW5UaW1lOiBwcm9wcy5zbG90TWluVGltZSxcbiAgICAgICAgICAgIC8vIER1cmF0aW9uIG9iamVjdCB0aGF0IGRlbm90ZXMgdGhlIGV4Y2x1c2l2ZSB2aXNpYmxlIGVuZCB0aW1lIG9mIGFueSBnaXZlbiBkYXlcbiAgICAgICAgICAgIHNsb3RNYXhUaW1lOiBwcm9wcy5zbG90TWF4VGltZSxcbiAgICAgICAgICAgIGlzVmFsaWQsXG4gICAgICAgICAgICAvLyBob3cgZmFyIHRoZSBjdXJyZW50IGRhdGUgd2lsbCBtb3ZlIGZvciBhIHByZXYvbmV4dCBvcGVyYXRpb25cbiAgICAgICAgICAgIGRhdGVJbmNyZW1lbnQ6IHRoaXMuYnVpbGREYXRlSW5jcmVtZW50KGN1cnJlbnRJbmZvLmR1cmF0aW9uKSxcbiAgICAgICAgICAgIC8vIHBhc3MgYSBmYWxsYmFjayAobWlnaHQgYmUgbnVsbCkgXlxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBCdWlsZHMgYW4gb2JqZWN0IHdpdGggb3B0aW9uYWwgc3RhcnQvZW5kIHByb3BlcnRpZXMuXG4gICAgLy8gSW5kaWNhdGVzIHRoZSBtaW5pbXVtL21heGltdW0gZGF0ZXMgdG8gZGlzcGxheS5cbiAgICAvLyBub3QgcmVzcG9uc2libGUgZm9yIHRyaW1taW5nIGhpZGRlbiBkYXlzLlxuICAgIGJ1aWxkVmFsaWRSYW5nZSgpIHtcbiAgICAgICAgbGV0IGlucHV0ID0gdGhpcy5wcm9wcy52YWxpZFJhbmdlSW5wdXQ7XG4gICAgICAgIGxldCBzaW1wbGVJbnB1dCA9IHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBpbnB1dC5jYWxsKHRoaXMucHJvcHMuY2FsZW5kYXJBcGksIHRoaXMubm93RGF0ZSlcbiAgICAgICAgICAgIDogaW5wdXQ7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZmluZVJhbmdlKHNpbXBsZUlucHV0KSB8fFxuICAgICAgICAgICAgeyBzdGFydDogbnVsbCwgZW5kOiBudWxsIH07IC8vIGNvbXBsZXRlbHkgb3Blbi1lbmRlZFxuICAgIH1cbiAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgd2l0aCBpbmZvIGFib3V0IHRoZSBcImN1cnJlbnRcIiByYW5nZSwgdGhlIHJhbmdlIHRoYXQgaXNcbiAgICAvLyBoaWdobGlnaHRlZCBhcyBiZWluZyB0aGUgY3VycmVudCBtb250aCBmb3IgZXhhbXBsZS5cbiAgICAvLyBTZWUgYnVpbGQoKSBmb3IgYSBkZXNjcmlwdGlvbiBvZiBgZGlyZWN0aW9uYC5cbiAgICAvLyBHdWFyYW50ZWVkIHRvIGhhdmUgYHJhbmdlYCBhbmQgYHVuaXRgIHByb3BlcnRpZXMuIGBkdXJhdGlvbmAgaXMgb3B0aW9uYWwuXG4gICAgYnVpbGRDdXJyZW50UmFuZ2VJbmZvKGRhdGUsIGRpcmVjdGlvbikge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGR1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgbGV0IHVuaXQgPSBudWxsO1xuICAgICAgICBsZXQgcmFuZ2UgPSBudWxsO1xuICAgICAgICBsZXQgZGF5Q291bnQ7XG4gICAgICAgIGlmIChwcm9wcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgZHVyYXRpb24gPSBwcm9wcy5kdXJhdGlvbjtcbiAgICAgICAgICAgIHVuaXQgPSBwcm9wcy5kdXJhdGlvblVuaXQ7XG4gICAgICAgICAgICByYW5nZSA9IHRoaXMuYnVpbGRSYW5nZUZyb21EdXJhdGlvbihkYXRlLCBkaXJlY3Rpb24sIGR1cmF0aW9uLCB1bml0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoZGF5Q291bnQgPSB0aGlzLnByb3BzLmRheUNvdW50KSkge1xuICAgICAgICAgICAgdW5pdCA9ICdkYXknO1xuICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLmJ1aWxkUmFuZ2VGcm9tRGF5Q291bnQoZGF0ZSwgZGlyZWN0aW9uLCBkYXlDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHJhbmdlID0gdGhpcy5idWlsZEN1c3RvbVZpc2libGVSYW5nZShkYXRlKSkpIHtcbiAgICAgICAgICAgIHVuaXQgPSBwcm9wcy5kYXRlRW52LmdyZWF0ZXN0V2hvbGVVbml0KHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpLnVuaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHRoaXMuZ2V0RmFsbGJhY2tEdXJhdGlvbigpO1xuICAgICAgICAgICAgdW5pdCA9IGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXJhdGlvbikudW5pdDtcbiAgICAgICAgICAgIHJhbmdlID0gdGhpcy5idWlsZFJhbmdlRnJvbUR1cmF0aW9uKGRhdGUsIGRpcmVjdGlvbiwgZHVyYXRpb24sIHVuaXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGR1cmF0aW9uLCB1bml0LCByYW5nZSB9O1xuICAgIH1cbiAgICBnZXRGYWxsYmFja0R1cmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oeyBkYXk6IDEgfSk7XG4gICAgfVxuICAgIC8vIFJldHVybnMgYSBuZXcgYWN0aXZlUmFuZ2UgdG8gaGF2ZSB0aW1lIHZhbHVlcyAodW4tYW1iaWd1YXRlKVxuICAgIC8vIHNsb3RNaW5UaW1lIG9yIHNsb3RNYXhUaW1lIGNhdXNlcyB0aGUgcmFuZ2UgdG8gZXhwYW5kLlxuICAgIGFkanVzdEFjdGl2ZVJhbmdlKHJhbmdlKSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYsIHVzZXNNaW5NYXhUaW1lLCBzbG90TWluVGltZSwgc2xvdE1heFRpbWUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCB7IHN0YXJ0LCBlbmQgfSA9IHJhbmdlO1xuICAgICAgICBpZiAodXNlc01pbk1heFRpbWUpIHtcbiAgICAgICAgICAgIC8vIGV4cGFuZCBhY3RpdmUgcmFuZ2UgaWYgc2xvdE1pblRpbWUgaXMgbmVnYXRpdmUgKHdoeSBub3Qgd2hlbiBwb3NpdGl2ZT8pXG4gICAgICAgICAgICBpZiAoYXNSb3VnaERheXMoc2xvdE1pblRpbWUpIDwgMCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnRPZkRheShzdGFydCk7IC8vIG5lY2Vzc2FyeT9cbiAgICAgICAgICAgICAgICBzdGFydCA9IGRhdGVFbnYuYWRkKHN0YXJ0LCBzbG90TWluVGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBleHBhbmQgYWN0aXZlIHJhbmdlIGlmIHNsb3RNYXhUaW1lIGlzIGJleW9uZCBvbmUgZGF5ICh3aHkgbm90IHdoZW4gbmVnYXRpdmU/KVxuICAgICAgICAgICAgaWYgKGFzUm91Z2hEYXlzKHNsb3RNYXhUaW1lKSA+IDEpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBzdGFydE9mRGF5KGVuZCk7IC8vIG5lY2Vzc2FyeT9cbiAgICAgICAgICAgICAgICBlbmQgPSBhZGREYXlzKGVuZCwgLTEpO1xuICAgICAgICAgICAgICAgIGVuZCA9IGRhdGVFbnYuYWRkKGVuZCwgc2xvdE1heFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcbiAgICB9XG4gICAgLy8gQnVpbGRzIHRoZSBcImN1cnJlbnRcIiByYW5nZSB3aGVuIGl0IGlzIHNwZWNpZmllZCBhcyBhbiBleHBsaWNpdCBkdXJhdGlvbi5cbiAgICAvLyBgdW5pdGAgaXMgdGhlIGFscmVhZHktY29tcHV0ZWQgZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yIHVuaXQgb2YgZHVyYXRpb24uXG4gICAgYnVpbGRSYW5nZUZyb21EdXJhdGlvbihkYXRlLCBkaXJlY3Rpb24sIGR1cmF0aW9uLCB1bml0KSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYsIGRhdGVBbGlnbm1lbnQgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBzdGFydDtcbiAgICAgICAgbGV0IGVuZDtcbiAgICAgICAgbGV0IHJlcztcbiAgICAgICAgLy8gY29tcHV0ZSB3aGF0IHRoZSBhbGlnbm1lbnQgc2hvdWxkIGJlXG4gICAgICAgIGlmICghZGF0ZUFsaWdubWVudCkge1xuICAgICAgICAgICAgbGV0IHsgZGF0ZUluY3JlbWVudCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGlmIChkYXRlSW5jcmVtZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBzbWFsbGVyIG9mIHRoZSB0d28gdW5pdHNcbiAgICAgICAgICAgICAgICBpZiAoYXNSb3VnaE1zKGRhdGVJbmNyZW1lbnQpIDwgYXNSb3VnaE1zKGR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRlQWxpZ25tZW50ID0gZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yKGRhdGVJbmNyZW1lbnQpLnVuaXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRlQWxpZ25tZW50ID0gdW5pdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRlQWxpZ25tZW50ID0gdW5pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgdmlldyBkaXNwbGF5cyBhIHNpbmdsZSBkYXkgb3Igc21hbGxlclxuICAgICAgICBpZiAoYXNSb3VnaERheXMoZHVyYXRpb24pIDw9IDEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSGlkZGVuRGF5KHN0YXJ0KSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5za2lwSGlkZGVuRGF5cyhzdGFydCwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHN0YXJ0T2ZEYXkoc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVSZXMoKSB7XG4gICAgICAgICAgICBzdGFydCA9IGRhdGVFbnYuc3RhcnRPZihkYXRlLCBkYXRlQWxpZ25tZW50KTtcbiAgICAgICAgICAgIGVuZCA9IGRhdGVFbnYuYWRkKHN0YXJ0LCBkdXJhdGlvbik7XG4gICAgICAgICAgICByZXMgPSB7IHN0YXJ0LCBlbmQgfTtcbiAgICAgICAgfVxuICAgICAgICBjb21wdXRlUmVzKCk7XG4gICAgICAgIC8vIGlmIHJhbmdlIGlzIGNvbXBsZXRlbHkgZW52ZWxvcGVkIGJ5IGhpZGRlbiBkYXlzLCBnbyBwYXN0IHRoZSBoaWRkZW4gZGF5c1xuICAgICAgICBpZiAoIXRoaXMudHJpbUhpZGRlbkRheXMocmVzKSkge1xuICAgICAgICAgICAgZGF0ZSA9IHRoaXMuc2tpcEhpZGRlbkRheXMoZGF0ZSwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIGNvbXB1dGVSZXMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICAvLyBCdWlsZHMgdGhlIFwiY3VycmVudFwiIHJhbmdlIHdoZW4gYSBkYXlDb3VudCBpcyBzcGVjaWZpZWQuXG4gICAgYnVpbGRSYW5nZUZyb21EYXlDb3VudChkYXRlLCBkaXJlY3Rpb24sIGRheUNvdW50KSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYsIGRhdGVBbGlnbm1lbnQgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBydW5uaW5nQ291bnQgPSAwO1xuICAgICAgICBsZXQgc3RhcnQgPSBkYXRlO1xuICAgICAgICBsZXQgZW5kO1xuICAgICAgICBpZiAoZGF0ZUFsaWdubWVudCkge1xuICAgICAgICAgICAgc3RhcnQgPSBkYXRlRW52LnN0YXJ0T2Yoc3RhcnQsIGRhdGVBbGlnbm1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gc3RhcnRPZkRheShzdGFydCk7XG4gICAgICAgIHN0YXJ0ID0gdGhpcy5za2lwSGlkZGVuRGF5cyhzdGFydCwgZGlyZWN0aW9uKTtcbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGVuZCA9IGFkZERheXMoZW5kLCAxKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0hpZGRlbkRheShlbmQpKSB7XG4gICAgICAgICAgICAgICAgcnVubmluZ0NvdW50ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHJ1bm5pbmdDb3VudCA8IGRheUNvdW50KTtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9O1xuICAgIH1cbiAgICAvLyBCdWlsZHMgYSBub3JtYWxpemVkIHJhbmdlIG9iamVjdCBmb3IgdGhlIFwidmlzaWJsZVwiIHJhbmdlLFxuICAgIC8vIHdoaWNoIGlzIGEgd2F5IHRvIGRlZmluZSB0aGUgY3VycmVudFJhbmdlIGFuZCBhY3RpdmVSYW5nZSBhdCB0aGUgc2FtZSB0aW1lLlxuICAgIGJ1aWxkQ3VzdG9tVmlzaWJsZVJhbmdlKGRhdGUpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBpbnB1dCA9IHByb3BzLnZpc2libGVSYW5nZUlucHV0O1xuICAgICAgICBsZXQgc2ltcGxlSW5wdXQgPSB0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gaW5wdXQuY2FsbChwcm9wcy5jYWxlbmRhckFwaSwgcHJvcHMuZGF0ZUVudi50b0RhdGUoZGF0ZSkpXG4gICAgICAgICAgICA6IGlucHV0O1xuICAgICAgICBsZXQgcmFuZ2UgPSB0aGlzLnJlZmluZVJhbmdlKHNpbXBsZUlucHV0KTtcbiAgICAgICAgaWYgKHJhbmdlICYmIChyYW5nZS5zdGFydCA9PSBudWxsIHx8IHJhbmdlLmVuZCA9PSBudWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cbiAgICAvLyBDb21wdXRlcyB0aGUgcmFuZ2UgdGhhdCB3aWxsIHJlcHJlc2VudCB0aGUgZWxlbWVudC9jZWxscyBmb3IgKnJlbmRlcmluZyosXG4gICAgLy8gYnV0IHdoaWNoIG1heSBoYXZlIHZvaWRlZCBkYXlzL3RpbWVzLlxuICAgIC8vIG5vdCByZXNwb25zaWJsZSBmb3IgdHJpbW1pbmcgaGlkZGVuIGRheXMuXG4gICAgYnVpbGRSZW5kZXJSYW5nZShjdXJyZW50UmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRSYW5nZTtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZSB0aGUgZHVyYXRpb24gdmFsdWUgdGhhdCBzaG91bGQgYmUgYWRkZWQvc3Vic3RyYWN0ZWQgdG8gdGhlIGN1cnJlbnQgZGF0ZVxuICAgIC8vIHdoZW4gYSBwcmV2L25leHQgb3BlcmF0aW9uIGhhcHBlbnMuXG4gICAgYnVpbGREYXRlSW5jcmVtZW50KGZhbGxiYWNrKSB7XG4gICAgICAgIGxldCB7IGRhdGVJbmNyZW1lbnQgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBjdXN0b21BbGlnbm1lbnQ7XG4gICAgICAgIGlmIChkYXRlSW5jcmVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZUluY3JlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGN1c3RvbUFsaWdubWVudCA9IHRoaXMucHJvcHMuZGF0ZUFsaWdubWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbigxLCBjdXN0b21BbGlnbm1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7IGRheXM6IDEgfSk7XG4gICAgfVxuICAgIHJlZmluZVJhbmdlKHJhbmdlSW5wdXQpIHtcbiAgICAgICAgaWYgKHJhbmdlSW5wdXQpIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHBhcnNlUmFuZ2UocmFuZ2VJbnB1dCwgdGhpcy5wcm9wcy5kYXRlRW52KTtcbiAgICAgICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgICAgIHJhbmdlID0gY29tcHV0ZVZpc2libGVEYXlSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qIEhpZGRlbiBEYXlzXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICAvLyBJbml0aWFsaXplcyBpbnRlcm5hbCB2YXJpYWJsZXMgcmVsYXRlZCB0byBjYWxjdWxhdGluZyBoaWRkZW4gZGF5cy1vZi13ZWVrXG4gICAgaW5pdEhpZGRlbkRheXMoKSB7XG4gICAgICAgIGxldCBoaWRkZW5EYXlzID0gdGhpcy5wcm9wcy5oaWRkZW5EYXlzIHx8IFtdOyAvLyBhcnJheSBvZiBkYXktb2Ytd2VlayBpbmRpY2VzIHRoYXQgYXJlIGhpZGRlblxuICAgICAgICBsZXQgaXNIaWRkZW5EYXlIYXNoID0gW107IC8vIGlzIHRoZSBkYXktb2Ytd2VlayBoaWRkZW4/IChoYXNoIHdpdGggZGF5LW9mLXdlZWstaW5kZXggLT4gYm9vbClcbiAgICAgICAgbGV0IGRheUNudCA9IDA7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy53ZWVrZW5kcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGhpZGRlbkRheXMucHVzaCgwLCA2KTsgLy8gMD1zdW5kYXksIDY9c2F0dXJkYXlcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoIShpc0hpZGRlbkRheUhhc2hbaV0gPSBoaWRkZW5EYXlzLmluZGV4T2YoaSkgIT09IC0xKSkge1xuICAgICAgICAgICAgICAgIGRheUNudCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZGF5Q250KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaGlkZGVuRGF5cycpOyAvLyBhbGwgZGF5cyB3ZXJlIGhpZGRlbj8gYmFkLlxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNIaWRkZW5EYXlIYXNoID0gaXNIaWRkZW5EYXlIYXNoO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgZGF5cyBmcm9tIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgcmFuZ2UgdGhhdCBhcmUgY29tcHV0ZWQgYXMgaGlkZGVuLlxuICAgIC8vIElmIHRoZSB3aG9sZSByYW5nZSBpcyB0cmltbWVkIG9mZiwgcmV0dXJucyBudWxsXG4gICAgdHJpbUhpZGRlbkRheXMocmFuZ2UpIHtcbiAgICAgICAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gcmFuZ2U7XG4gICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgICAgc3RhcnQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKHN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kKSB7XG4gICAgICAgICAgICBlbmQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKGVuZCwgLTEsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA9PSBudWxsIHx8IGVuZCA9PSBudWxsIHx8IHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIElzIHRoZSBjdXJyZW50IGRheSBoaWRkZW4/XG4gICAgLy8gYGRheWAgaXMgYSBkYXktb2Ytd2VlayBpbmRleCAoMC02KSwgb3IgYSBEYXRlICh1c2VkIGZvciBVVEMpXG4gICAgaXNIaWRkZW5EYXkoZGF5KSB7XG4gICAgICAgIGlmIChkYXkgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICBkYXkgPSBkYXkuZ2V0VVRDRGF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaXNIaWRkZW5EYXlIYXNoW2RheV07XG4gICAgfVxuICAgIC8vIEluY3JlbWVudGluZyB0aGUgY3VycmVudCBkYXkgdW50aWwgaXQgaXMgbm8gbG9uZ2VyIGEgaGlkZGVuIGRheSwgcmV0dXJuaW5nIGEgY29weS5cbiAgICAvLyBET0VTIE5PVCBDT05TSURFUiB2YWxpZFJhbmdlIVxuICAgIC8vIElmIHRoZSBpbml0aWFsIHZhbHVlIG9mIGBkYXRlYCBpcyBub3QgYSBoaWRkZW4gZGF5LCBkb24ndCBkbyBhbnl0aGluZy5cbiAgICAvLyBQYXNzIGBpc0V4Y2x1c2l2ZWAgYXMgYHRydWVgIGlmIHlvdSBhcmUgZGVhbGluZyB3aXRoIGFuIGVuZCBkYXRlLlxuICAgIC8vIGBpbmNgIGRlZmF1bHRzIHRvIGAxYCAoaW5jcmVtZW50IG9uZSBkYXkgZm9yd2FyZCBlYWNoIHRpbWUpXG4gICAgc2tpcEhpZGRlbkRheXMoZGF0ZSwgaW5jID0gMSwgaXNFeGNsdXNpdmUgPSBmYWxzZSkge1xuICAgICAgICB3aGlsZSAodGhpcy5pc0hpZGRlbkRheUhhc2hbKGRhdGUuZ2V0VVRDRGF5KCkgKyAoaXNFeGNsdXNpdmUgPyBpbmMgOiAwKSArIDcpICUgN10pIHtcbiAgICAgICAgICAgIGRhdGUgPSBhZGREYXlzKGRhdGUsIGluYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFdmVudEluc3RhbmNlKGRlZklkLCByYW5nZSwgZm9yY2VkU3RhcnRUem8sIGZvcmNlZEVuZFR6bykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGluc3RhbmNlSWQ6IGd1aWQoKSxcbiAgICAgICAgZGVmSWQsXG4gICAgICAgIHJhbmdlLFxuICAgICAgICBmb3JjZWRTdGFydFR6bzogZm9yY2VkU3RhcnRUem8gPT0gbnVsbCA/IG51bGwgOiBmb3JjZWRTdGFydFR6byxcbiAgICAgICAgZm9yY2VkRW5kVHpvOiBmb3JjZWRFbmRUem8gPT0gbnVsbCA/IG51bGwgOiBmb3JjZWRFbmRUem8sXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VSZWN1cnJpbmcocmVmaW5lZCwgZGVmYXVsdEFsbERheSwgZGF0ZUVudiwgcmVjdXJyaW5nVHlwZXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3VycmluZ1R5cGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCBwYXJzZWQgPSByZWN1cnJpbmdUeXBlc1tpXS5wYXJzZShyZWZpbmVkLCBkYXRlRW52KTtcbiAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgbGV0IHsgYWxsRGF5IH0gPSByZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGFsbERheSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYWxsRGF5ID0gZGVmYXVsdEFsbERheTtcbiAgICAgICAgICAgICAgICBpZiAoYWxsRGF5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsRGF5ID0gcGFyc2VkLmFsbERheUd1ZXNzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsRGF5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbERheSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhbGxEYXksXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHBhcnNlZC5kdXJhdGlvbixcbiAgICAgICAgICAgICAgICB0eXBlRGF0YTogcGFyc2VkLnR5cGVEYXRhLFxuICAgICAgICAgICAgICAgIHR5cGVJZDogaSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBleHBhbmRSZWN1cnJpbmcoZXZlbnRTdG9yZSwgZnJhbWluZ1JhbmdlLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgZGF0ZUVudiwgcGx1Z2luSG9va3MsIG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgbGV0IHsgZGVmcywgaW5zdGFuY2VzIH0gPSBldmVudFN0b3JlO1xuICAgIC8vIHJlbW92ZSBleGlzdGluZyByZWN1cnJpbmcgaW5zdGFuY2VzXG4gICAgLy8gVE9ETzogYmFkLiBhbHdheXMgZXhwYW5kIGV2ZW50cyBhcyBhIHNlY29uZCBzdGVwXG4gICAgaW5zdGFuY2VzID0gZmlsdGVySGFzaChpbnN0YW5jZXMsIChpbnN0YW5jZSkgPT4gIWRlZnNbaW5zdGFuY2UuZGVmSWRdLnJlY3VycmluZ0RlZik7XG4gICAgZm9yIChsZXQgZGVmSWQgaW4gZGVmcykge1xuICAgICAgICBsZXQgZGVmID0gZGVmc1tkZWZJZF07XG4gICAgICAgIGlmIChkZWYucmVjdXJyaW5nRGVmKSB7XG4gICAgICAgICAgICBsZXQgeyBkdXJhdGlvbiB9ID0gZGVmLnJlY3VycmluZ0RlZjtcbiAgICAgICAgICAgIGlmICghZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IGRlZi5hbGxEYXkgP1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uIDpcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN0YXJ0cyA9IGV4cGFuZFJlY3VycmluZ1JhbmdlcyhkZWYsIGR1cmF0aW9uLCBmcmFtaW5nUmFuZ2UsIGRhdGVFbnYsIHBsdWdpbkhvb2tzLnJlY3VycmluZ1R5cGVzKTtcbiAgICAgICAgICAgIGZvciAobGV0IHN0YXJ0IG9mIHN0YXJ0cykge1xuICAgICAgICAgICAgICAgIGxldCBpbnN0YW5jZSA9IGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmSWQsIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogZGF0ZUVudi5hZGQoc3RhcnQsIGR1cmF0aW9uKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZXNbaW5zdGFuY2UuaW5zdGFuY2VJZF0gPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBkZWZzLCBpbnN0YW5jZXMgfTtcbn1cbi8qXG5FdmVudCBNVVNUIGhhdmUgYSByZWN1cnJpbmdEZWZcbiovXG5mdW5jdGlvbiBleHBhbmRSZWN1cnJpbmdSYW5nZXMoZXZlbnREZWYsIGR1cmF0aW9uLCBmcmFtaW5nUmFuZ2UsIGRhdGVFbnYsIHJlY3VycmluZ1R5cGVzKSB7XG4gICAgbGV0IHR5cGVEZWYgPSByZWN1cnJpbmdUeXBlc1tldmVudERlZi5yZWN1cnJpbmdEZWYudHlwZUlkXTtcbiAgICBsZXQgbWFya2VycyA9IHR5cGVEZWYuZXhwYW5kKGV2ZW50RGVmLnJlY3VycmluZ0RlZi50eXBlRGF0YSwge1xuICAgICAgICBzdGFydDogZGF0ZUVudi5zdWJ0cmFjdChmcmFtaW5nUmFuZ2Uuc3RhcnQsIGR1cmF0aW9uKSxcbiAgICAgICAgZW5kOiBmcmFtaW5nUmFuZ2UuZW5kLFxuICAgIH0sIGRhdGVFbnYpO1xuICAgIC8vIHRoZSByZWN1cnJlbmNlIHBsdWdpbnMgZG9uJ3QgZ3VhcmFudGVlIHRoYXQgYWxsLWRheSBldmVudHMgYXJlIHN0YXJ0LW9mLWRheSwgc28gd2UgaGF2ZSB0b1xuICAgIGlmIChldmVudERlZi5hbGxEYXkpIHtcbiAgICAgICAgbWFya2VycyA9IG1hcmtlcnMubWFwKHN0YXJ0T2ZEYXkpO1xuICAgIH1cbiAgICByZXR1cm4gbWFya2Vycztcbn1cblxuY29uc3QgRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlMgPSB7XG4gICAgaWQ6IFN0cmluZyxcbiAgICBncm91cElkOiBTdHJpbmcsXG4gICAgdGl0bGU6IFN0cmluZyxcbiAgICB1cmw6IFN0cmluZyxcbiAgICBpbnRlcmFjdGl2ZTogQm9vbGVhbixcbn07XG5jb25zdCBFVkVOVF9EQVRFX1JFRklORVJTID0ge1xuICAgIHN0YXJ0OiBpZGVudGl0eSxcbiAgICBlbmQ6IGlkZW50aXR5LFxuICAgIGRhdGU6IGlkZW50aXR5LFxuICAgIGFsbERheTogQm9vbGVhbixcbn07XG5jb25zdCBFVkVOVF9SRUZJTkVSUyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBFVkVOVF9OT05fREFURV9SRUZJTkVSUyksIEVWRU5UX0RBVEVfUkVGSU5FUlMpLCB7IGV4dGVuZGVkUHJvcHM6IGlkZW50aXR5IH0pO1xuZnVuY3Rpb24gcGFyc2VFdmVudChyYXcsIGV2ZW50U291cmNlLCBjb250ZXh0LCBhbGxvd09wZW5SYW5nZSwgcmVmaW5lcnMgPSBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dCksIGRlZklkTWFwLCBpbnN0YW5jZUlkTWFwKSB7XG4gICAgbGV0IHsgcmVmaW5lZCwgZXh0cmEgfSA9IHJlZmluZUV2ZW50RGVmKHJhdywgY29udGV4dCwgcmVmaW5lcnMpO1xuICAgIGxldCBkZWZhdWx0QWxsRGF5ID0gY29tcHV0ZUlzRGVmYXVsdEFsbERheShldmVudFNvdXJjZSwgY29udGV4dCk7XG4gICAgbGV0IHJlY3VycmluZ1JlcyA9IHBhcnNlUmVjdXJyaW5nKHJlZmluZWQsIGRlZmF1bHRBbGxEYXksIGNvbnRleHQuZGF0ZUVudiwgY29udGV4dC5wbHVnaW5Ib29rcy5yZWN1cnJpbmdUeXBlcyk7XG4gICAgaWYgKHJlY3VycmluZ1Jlcykge1xuICAgICAgICBsZXQgZGVmID0gcGFyc2VFdmVudERlZihyZWZpbmVkLCBleHRyYSwgZXZlbnRTb3VyY2UgPyBldmVudFNvdXJjZS5zb3VyY2VJZCA6ICcnLCByZWN1cnJpbmdSZXMuYWxsRGF5LCBCb29sZWFuKHJlY3VycmluZ1Jlcy5kdXJhdGlvbiksIGNvbnRleHQsIGRlZklkTWFwKTtcbiAgICAgICAgZGVmLnJlY3VycmluZ0RlZiA9IHtcbiAgICAgICAgICAgIHR5cGVJZDogcmVjdXJyaW5nUmVzLnR5cGVJZCxcbiAgICAgICAgICAgIHR5cGVEYXRhOiByZWN1cnJpbmdSZXMudHlwZURhdGEsXG4gICAgICAgICAgICBkdXJhdGlvbjogcmVjdXJyaW5nUmVzLmR1cmF0aW9uLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geyBkZWYsIGluc3RhbmNlOiBudWxsIH07XG4gICAgfVxuICAgIGxldCBzaW5nbGVSZXMgPSBwYXJzZVNpbmdsZShyZWZpbmVkLCBkZWZhdWx0QWxsRGF5LCBjb250ZXh0LCBhbGxvd09wZW5SYW5nZSk7XG4gICAgaWYgKHNpbmdsZVJlcykge1xuICAgICAgICBsZXQgZGVmID0gcGFyc2VFdmVudERlZihyZWZpbmVkLCBleHRyYSwgZXZlbnRTb3VyY2UgPyBldmVudFNvdXJjZS5zb3VyY2VJZCA6ICcnLCBzaW5nbGVSZXMuYWxsRGF5LCBzaW5nbGVSZXMuaGFzRW5kLCBjb250ZXh0LCBkZWZJZE1hcCk7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmLmRlZklkLCBzaW5nbGVSZXMucmFuZ2UsIHNpbmdsZVJlcy5mb3JjZWRTdGFydFR6bywgc2luZ2xlUmVzLmZvcmNlZEVuZFR6byk7XG4gICAgICAgIGlmIChpbnN0YW5jZUlkTWFwICYmIGRlZi5wdWJsaWNJZCAmJiBpbnN0YW5jZUlkTWFwW2RlZi5wdWJsaWNJZF0pIHtcbiAgICAgICAgICAgIGluc3RhbmNlLmluc3RhbmNlSWQgPSBpbnN0YW5jZUlkTWFwW2RlZi5wdWJsaWNJZF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZGVmLCBpbnN0YW5jZSB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHJlZmluZUV2ZW50RGVmKHJhdywgY29udGV4dCwgcmVmaW5lcnMgPSBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dCkpIHtcbiAgICByZXR1cm4gcmVmaW5lUHJvcHMocmF3LCByZWZpbmVycyk7XG59XG5mdW5jdGlvbiBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgRVZFTlRfVUlfUkVGSU5FUlMpLCBFVkVOVF9SRUZJTkVSUyksIGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnRSZWZpbmVycyk7XG59XG4vKlxuV2lsbCBOT1QgcG9wdWxhdGUgZXh0ZW5kZWRQcm9wcyB3aXRoIHRoZSBsZWZ0b3ZlciBwcm9wZXJ0aWVzLlxuV2lsbCBOT1QgcG9wdWxhdGUgZGF0ZS1yZWxhdGVkIHByb3BzLlxuKi9cbmZ1bmN0aW9uIHBhcnNlRXZlbnREZWYocmVmaW5lZCwgZXh0cmEsIHNvdXJjZUlkLCBhbGxEYXksIGhhc0VuZCwgY29udGV4dCwgZGVmSWRNYXApIHtcbiAgICBsZXQgZGVmID0ge1xuICAgICAgICB0aXRsZTogcmVmaW5lZC50aXRsZSB8fCAnJyxcbiAgICAgICAgZ3JvdXBJZDogcmVmaW5lZC5ncm91cElkIHx8ICcnLFxuICAgICAgICBwdWJsaWNJZDogcmVmaW5lZC5pZCB8fCAnJyxcbiAgICAgICAgdXJsOiByZWZpbmVkLnVybCB8fCAnJyxcbiAgICAgICAgcmVjdXJyaW5nRGVmOiBudWxsLFxuICAgICAgICBkZWZJZDogKChkZWZJZE1hcCAmJiByZWZpbmVkLmlkKSA/IGRlZklkTWFwW3JlZmluZWQuaWRdIDogJycpIHx8IGd1aWQoKSxcbiAgICAgICAgc291cmNlSWQsXG4gICAgICAgIGFsbERheSxcbiAgICAgICAgaGFzRW5kLFxuICAgICAgICBpbnRlcmFjdGl2ZTogcmVmaW5lZC5pbnRlcmFjdGl2ZSxcbiAgICAgICAgdWk6IGNyZWF0ZUV2ZW50VWkocmVmaW5lZCwgY29udGV4dCksXG4gICAgICAgIGV4dGVuZGVkUHJvcHM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHJlZmluZWQuZXh0ZW5kZWRQcm9wcyB8fCB7fSkpLCBleHRyYSksXG4gICAgfTtcbiAgICBmb3IgKGxldCBtZW1iZXJBZGRlciBvZiBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50RGVmTWVtYmVyQWRkZXJzKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oZGVmLCBtZW1iZXJBZGRlcihyZWZpbmVkKSk7XG4gICAgfVxuICAgIC8vIGhlbHAgb3V0IEV2ZW50SW1wbCBmcm9tIGhhdmluZyB1c2VyIG1vZGlmeSBwcm9wc1xuICAgIE9iamVjdC5mcmVlemUoZGVmLnVpLmNsYXNzTmFtZXMpO1xuICAgIE9iamVjdC5mcmVlemUoZGVmLmV4dGVuZGVkUHJvcHMpO1xuICAgIHJldHVybiBkZWY7XG59XG5mdW5jdGlvbiBwYXJzZVNpbmdsZShyZWZpbmVkLCBkZWZhdWx0QWxsRGF5LCBjb250ZXh0LCBhbGxvd09wZW5SYW5nZSkge1xuICAgIGxldCB7IGFsbERheSB9ID0gcmVmaW5lZDtcbiAgICBsZXQgc3RhcnRNZXRhO1xuICAgIGxldCBzdGFydE1hcmtlciA9IG51bGw7XG4gICAgbGV0IGhhc0VuZCA9IGZhbHNlO1xuICAgIGxldCBlbmRNZXRhO1xuICAgIGxldCBlbmRNYXJrZXIgPSBudWxsO1xuICAgIGxldCBzdGFydElucHV0ID0gcmVmaW5lZC5zdGFydCAhPSBudWxsID8gcmVmaW5lZC5zdGFydCA6IHJlZmluZWQuZGF0ZTtcbiAgICBzdGFydE1ldGEgPSBjb250ZXh0LmRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShzdGFydElucHV0KTtcbiAgICBpZiAoc3RhcnRNZXRhKSB7XG4gICAgICAgIHN0YXJ0TWFya2VyID0gc3RhcnRNZXRhLm1hcmtlcjtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWFsbG93T3BlblJhbmdlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAocmVmaW5lZC5lbmQgIT0gbnVsbCkge1xuICAgICAgICBlbmRNZXRhID0gY29udGV4dC5kYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEocmVmaW5lZC5lbmQpO1xuICAgIH1cbiAgICBpZiAoYWxsRGF5ID09IG51bGwpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRBbGxEYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgYWxsRGF5ID0gZGVmYXVsdEFsbERheTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZhbGwgYmFjayB0byB0aGUgZGF0ZSBwcm9wcyBMQVNUXG4gICAgICAgICAgICBhbGxEYXkgPSAoIXN0YXJ0TWV0YSB8fCBzdGFydE1ldGEuaXNUaW1lVW5zcGVjaWZpZWQpICYmXG4gICAgICAgICAgICAgICAgKCFlbmRNZXRhIHx8IGVuZE1ldGEuaXNUaW1lVW5zcGVjaWZpZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhbGxEYXkgJiYgc3RhcnRNYXJrZXIpIHtcbiAgICAgICAgc3RhcnRNYXJrZXIgPSBzdGFydE9mRGF5KHN0YXJ0TWFya2VyKTtcbiAgICB9XG4gICAgaWYgKGVuZE1ldGEpIHtcbiAgICAgICAgZW5kTWFya2VyID0gZW5kTWV0YS5tYXJrZXI7XG4gICAgICAgIGlmIChhbGxEYXkpIHtcbiAgICAgICAgICAgIGVuZE1hcmtlciA9IHN0YXJ0T2ZEYXkoZW5kTWFya2VyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRNYXJrZXIgJiYgZW5kTWFya2VyIDw9IHN0YXJ0TWFya2VyKSB7XG4gICAgICAgICAgICBlbmRNYXJrZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlbmRNYXJrZXIpIHtcbiAgICAgICAgaGFzRW5kID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWFsbG93T3BlblJhbmdlKSB7XG4gICAgICAgIGhhc0VuZCA9IGNvbnRleHQub3B0aW9ucy5mb3JjZUV2ZW50RHVyYXRpb24gfHwgZmFsc2U7XG4gICAgICAgIGVuZE1hcmtlciA9IGNvbnRleHQuZGF0ZUVudi5hZGQoc3RhcnRNYXJrZXIsIGFsbERheSA/XG4gICAgICAgICAgICBjb250ZXh0Lm9wdGlvbnMuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24gOlxuICAgICAgICAgICAgY29udGV4dC5vcHRpb25zLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBhbGxEYXksXG4gICAgICAgIGhhc0VuZCxcbiAgICAgICAgcmFuZ2U6IHsgc3RhcnQ6IHN0YXJ0TWFya2VyLCBlbmQ6IGVuZE1hcmtlciB9LFxuICAgICAgICBmb3JjZWRTdGFydFR6bzogc3RhcnRNZXRhID8gc3RhcnRNZXRhLmZvcmNlZFR6byA6IG51bGwsXG4gICAgICAgIGZvcmNlZEVuZFR6bzogZW5kTWV0YSA/IGVuZE1ldGEuZm9yY2VkVHpvIDogbnVsbCxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUlzRGVmYXVsdEFsbERheShldmVudFNvdXJjZSwgY29udGV4dCkge1xuICAgIGxldCByZXMgPSBudWxsO1xuICAgIGlmIChldmVudFNvdXJjZSkge1xuICAgICAgICByZXMgPSBldmVudFNvdXJjZS5kZWZhdWx0QWxsRGF5O1xuICAgIH1cbiAgICBpZiAocmVzID09IG51bGwpIHtcbiAgICAgICAgcmVzID0gY29udGV4dC5vcHRpb25zLmRlZmF1bHRBbGxEYXk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRXZlbnRzKHJhd0V2ZW50cywgZXZlbnRTb3VyY2UsIGNvbnRleHQsIGFsbG93T3BlblJhbmdlLCBkZWZJZE1hcCwgaW5zdGFuY2VJZE1hcCkge1xuICAgIGxldCBldmVudFN0b3JlID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XG4gICAgbGV0IGV2ZW50UmVmaW5lcnMgPSBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dCk7XG4gICAgZm9yIChsZXQgcmF3RXZlbnQgb2YgcmF3RXZlbnRzKSB7XG4gICAgICAgIGxldCB0dXBsZSA9IHBhcnNlRXZlbnQocmF3RXZlbnQsIGV2ZW50U291cmNlLCBjb250ZXh0LCBhbGxvd09wZW5SYW5nZSwgZXZlbnRSZWZpbmVycywgZGVmSWRNYXAsIGluc3RhbmNlSWRNYXApO1xuICAgICAgICBpZiAodHVwbGUpIHtcbiAgICAgICAgICAgIGV2ZW50VHVwbGVUb1N0b3JlKHR1cGxlLCBldmVudFN0b3JlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRTdG9yZTtcbn1cbmZ1bmN0aW9uIGV2ZW50VHVwbGVUb1N0b3JlKHR1cGxlLCBldmVudFN0b3JlID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCkpIHtcbiAgICBldmVudFN0b3JlLmRlZnNbdHVwbGUuZGVmLmRlZklkXSA9IHR1cGxlLmRlZjtcbiAgICBpZiAodHVwbGUuaW5zdGFuY2UpIHtcbiAgICAgICAgZXZlbnRTdG9yZS5pbnN0YW5jZXNbdHVwbGUuaW5zdGFuY2UuaW5zdGFuY2VJZF0gPSB0dXBsZS5pbnN0YW5jZTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50U3RvcmU7XG59XG4vLyByZXRyaWV2ZXMgZXZlbnRzIHRoYXQgaGF2ZSB0aGUgc2FtZSBncm91cElkIGFzIHRoZSBpbnN0YW5jZSBzcGVjaWZpZWQgYnkgYGluc3RhbmNlSWRgXG4vLyBvciB0aGV5IGFyZSB0aGUgc2FtZSBhcyB0aGUgaW5zdGFuY2UuXG4vLyB3aHkgbWlnaHQgaW5zdGFuY2VJZCBub3QgYmUgaW4gdGhlIHN0b3JlPyBhbiBldmVudCBmcm9tIGFub3RoZXIgY2FsZW5kYXI/XG5mdW5jdGlvbiBnZXRSZWxldmFudEV2ZW50cyhldmVudFN0b3JlLCBpbnN0YW5jZUlkKSB7XG4gICAgbGV0IGluc3RhbmNlID0gZXZlbnRTdG9yZS5pbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgIGxldCBkZWYgPSBldmVudFN0b3JlLmRlZnNbaW5zdGFuY2UuZGVmSWRdO1xuICAgICAgICAvLyBnZXQgZXZlbnRzL2luc3RhbmNlcyB3aXRoIHNhbWUgZ3JvdXBcbiAgICAgICAgbGV0IG5ld1N0b3JlID0gZmlsdGVyRXZlbnRTdG9yZURlZnMoZXZlbnRTdG9yZSwgKGxvb2tEZWYpID0+IGlzRXZlbnREZWZzR3JvdXBlZChkZWYsIGxvb2tEZWYpKTtcbiAgICAgICAgLy8gYWRkIHRoZSBvcmlnaW5hbFxuICAgICAgICAvLyBUT0RPOiB3aXNoIHdlIGNvdWxkIHVzZSBldmVudFR1cGxlVG9TdG9yZSBvciBzb21ldGhpbmcgbGlrZSBpdFxuICAgICAgICBuZXdTdG9yZS5kZWZzW2RlZi5kZWZJZF0gPSBkZWY7XG4gICAgICAgIG5ld1N0b3JlLmluc3RhbmNlc1tpbnN0YW5jZS5pbnN0YW5jZUlkXSA9IGluc3RhbmNlO1xuICAgICAgICByZXR1cm4gbmV3U3RvcmU7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcbn1cbmZ1bmN0aW9uIGlzRXZlbnREZWZzR3JvdXBlZChkZWYwLCBkZWYxKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oZGVmMC5ncm91cElkICYmIGRlZjAuZ3JvdXBJZCA9PT0gZGVmMS5ncm91cElkKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpIHtcbiAgICByZXR1cm4geyBkZWZzOiB7fSwgaW5zdGFuY2VzOiB7fSB9O1xufVxuZnVuY3Rpb24gbWVyZ2VFdmVudFN0b3JlcyhzdG9yZTAsIHN0b3JlMSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlZnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RvcmUwLmRlZnMpLCBzdG9yZTEuZGVmcyksXG4gICAgICAgIGluc3RhbmNlczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdG9yZTAuaW5zdGFuY2VzKSwgc3RvcmUxLmluc3RhbmNlcyksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZpbHRlckV2ZW50U3RvcmVEZWZzKGV2ZW50U3RvcmUsIGZpbHRlckZ1bmMpIHtcbiAgICBsZXQgZGVmcyA9IGZpbHRlckhhc2goZXZlbnRTdG9yZS5kZWZzLCBmaWx0ZXJGdW5jKTtcbiAgICBsZXQgaW5zdGFuY2VzID0gZmlsdGVySGFzaChldmVudFN0b3JlLmluc3RhbmNlcywgKGluc3RhbmNlKSA9PiAoZGVmc1tpbnN0YW5jZS5kZWZJZF0gLy8gc3RpbGwgZXhpc3RzP1xuICAgICkpO1xuICAgIHJldHVybiB7IGRlZnMsIGluc3RhbmNlcyB9O1xufVxuZnVuY3Rpb24gZXhjbHVkZVN1YkV2ZW50U3RvcmUobWFzdGVyLCBzdWIpIHtcbiAgICBsZXQgeyBkZWZzLCBpbnN0YW5jZXMgfSA9IG1hc3RlcjtcbiAgICBsZXQgZmlsdGVyZWREZWZzID0ge307XG4gICAgbGV0IGZpbHRlcmVkSW5zdGFuY2VzID0ge307XG4gICAgZm9yIChsZXQgZGVmSWQgaW4gZGVmcykge1xuICAgICAgICBpZiAoIXN1Yi5kZWZzW2RlZklkXSkgeyAvLyBub3QgZXhwbGljaXRseSBleGNsdWRlZFxuICAgICAgICAgICAgZmlsdGVyZWREZWZzW2RlZklkXSA9IGRlZnNbZGVmSWRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgIGlmICghc3ViLmluc3RhbmNlc1tpbnN0YW5jZUlkXSAmJiAvLyBub3QgZXhwbGljaXRseSBleGNsdWRlZFxuICAgICAgICAgICAgZmlsdGVyZWREZWZzW2luc3RhbmNlc1tpbnN0YW5jZUlkXS5kZWZJZF0gLy8gZGVmIHdhc24ndCBmaWx0ZXJlZCBhd2F5XG4gICAgICAgICkge1xuICAgICAgICAgICAgZmlsdGVyZWRJbnN0YW5jZXNbaW5zdGFuY2VJZF0gPSBpbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVmczogZmlsdGVyZWREZWZzLFxuICAgICAgICBpbnN0YW5jZXM6IGZpbHRlcmVkSW5zdGFuY2VzLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbnN0cmFpbnQoaW5wdXQsIGNvbnRleHQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRXZlbnRzKGlucHV0LCBudWxsLCBjb250ZXh0LCB0cnVlKTsgLy8gYWxsb3dPcGVuUmFuZ2U9dHJ1ZVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgcmV0dXJuIHBhcnNlRXZlbnRzKFtpbnB1dF0sIG51bGwsIGNvbnRleHQsIHRydWUpOyAvLyBhbGxvd09wZW5SYW5nZT10cnVlXG4gICAgfVxuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoaW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcGFyc2VDbGFzc05hbWVzKHJhdykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJhdykpIHtcbiAgICAgICAgcmV0dXJuIHJhdztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByYXcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiByYXcuc3BsaXQoL1xccysvKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuXG4vLyBUT0RPOiBiZXR0ZXIgY2FsbGVkIFwiRXZlbnRTZXR0aW5nc1wiIG9yIFwiRXZlbnRDb25maWdcIlxuLy8gVE9ETzogbW92ZSB0aGlzIGZpbGUgaW50byBzdHJ1Y3RzXG4vLyBUT0RPOiBzZXBhcmF0ZSBjb25zdHJhaW50L292ZXJsYXAvYWxsb3csIGJlY2F1c2Ugc2VsZWN0aW9uIHVzZXMgb25seSB0aGF0LCBub3Qgb3RoZXIgcHJvcHNcbmNvbnN0IEVWRU5UX1VJX1JFRklORVJTID0ge1xuICAgIGRpc3BsYXk6IFN0cmluZyxcbiAgICBlZGl0YWJsZTogQm9vbGVhbixcbiAgICBzdGFydEVkaXRhYmxlOiBCb29sZWFuLFxuICAgIGR1cmF0aW9uRWRpdGFibGU6IEJvb2xlYW4sXG4gICAgY29uc3RyYWludDogaWRlbnRpdHksXG4gICAgb3ZlcmxhcDogaWRlbnRpdHksXG4gICAgYWxsb3c6IGlkZW50aXR5LFxuICAgIGNsYXNzTmFtZTogcGFyc2VDbGFzc05hbWVzLFxuICAgIGNsYXNzTmFtZXM6IHBhcnNlQ2xhc3NOYW1lcyxcbiAgICBjb2xvcjogU3RyaW5nLFxuICAgIGJhY2tncm91bmRDb2xvcjogU3RyaW5nLFxuICAgIGJvcmRlckNvbG9yOiBTdHJpbmcsXG4gICAgdGV4dENvbG9yOiBTdHJpbmcsXG59O1xuY29uc3QgRU1QVFlfRVZFTlRfVUkgPSB7XG4gICAgZGlzcGxheTogbnVsbCxcbiAgICBzdGFydEVkaXRhYmxlOiBudWxsLFxuICAgIGR1cmF0aW9uRWRpdGFibGU6IG51bGwsXG4gICAgY29uc3RyYWludHM6IFtdLFxuICAgIG92ZXJsYXA6IG51bGwsXG4gICAgYWxsb3dzOiBbXSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICcnLFxuICAgIGJvcmRlckNvbG9yOiAnJyxcbiAgICB0ZXh0Q29sb3I6ICcnLFxuICAgIGNsYXNzTmFtZXM6IFtdLFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50VWkocmVmaW5lZCwgY29udGV4dCkge1xuICAgIGxldCBjb25zdHJhaW50ID0gbm9ybWFsaXplQ29uc3RyYWludChyZWZpbmVkLmNvbnN0cmFpbnQsIGNvbnRleHQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRpc3BsYXk6IHJlZmluZWQuZGlzcGxheSB8fCBudWxsLFxuICAgICAgICBzdGFydEVkaXRhYmxlOiByZWZpbmVkLnN0YXJ0RWRpdGFibGUgIT0gbnVsbCA/IHJlZmluZWQuc3RhcnRFZGl0YWJsZSA6IHJlZmluZWQuZWRpdGFibGUsXG4gICAgICAgIGR1cmF0aW9uRWRpdGFibGU6IHJlZmluZWQuZHVyYXRpb25FZGl0YWJsZSAhPSBudWxsID8gcmVmaW5lZC5kdXJhdGlvbkVkaXRhYmxlIDogcmVmaW5lZC5lZGl0YWJsZSxcbiAgICAgICAgY29uc3RyYWludHM6IGNvbnN0cmFpbnQgIT0gbnVsbCA/IFtjb25zdHJhaW50XSA6IFtdLFxuICAgICAgICBvdmVybGFwOiByZWZpbmVkLm92ZXJsYXAgIT0gbnVsbCA/IHJlZmluZWQub3ZlcmxhcCA6IG51bGwsXG4gICAgICAgIGFsbG93czogcmVmaW5lZC5hbGxvdyAhPSBudWxsID8gW3JlZmluZWQuYWxsb3ddIDogW10sXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogcmVmaW5lZC5iYWNrZ3JvdW5kQ29sb3IgfHwgcmVmaW5lZC5jb2xvciB8fCAnJyxcbiAgICAgICAgYm9yZGVyQ29sb3I6IHJlZmluZWQuYm9yZGVyQ29sb3IgfHwgcmVmaW5lZC5jb2xvciB8fCAnJyxcbiAgICAgICAgdGV4dENvbG9yOiByZWZpbmVkLnRleHRDb2xvciB8fCAnJyxcbiAgICAgICAgY2xhc3NOYW1lczogKHJlZmluZWQuY2xhc3NOYW1lIHx8IFtdKS5jb25jYXQocmVmaW5lZC5jbGFzc05hbWVzIHx8IFtdKSwgLy8gam9pbiBzaW5ndWxhciBhbmQgcGx1cmFsXG4gICAgfTtcbn1cbi8vIFRPRE86IHByZXZlbnQgYWdhaW5zdCBwcm9ibGVtcyB3aXRoIDwyIGFyZ3MhXG5mdW5jdGlvbiBjb21iaW5lRXZlbnRVaXModWlzKSB7XG4gICAgcmV0dXJuIHVpcy5yZWR1Y2UoY29tYmluZVR3b0V2ZW50VWlzLCBFTVBUWV9FVkVOVF9VSSk7XG59XG5mdW5jdGlvbiBjb21iaW5lVHdvRXZlbnRVaXMoaXRlbTAsIGl0ZW0xKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGlzcGxheTogaXRlbTEuZGlzcGxheSAhPSBudWxsID8gaXRlbTEuZGlzcGxheSA6IGl0ZW0wLmRpc3BsYXksXG4gICAgICAgIHN0YXJ0RWRpdGFibGU6IGl0ZW0xLnN0YXJ0RWRpdGFibGUgIT0gbnVsbCA/IGl0ZW0xLnN0YXJ0RWRpdGFibGUgOiBpdGVtMC5zdGFydEVkaXRhYmxlLFxuICAgICAgICBkdXJhdGlvbkVkaXRhYmxlOiBpdGVtMS5kdXJhdGlvbkVkaXRhYmxlICE9IG51bGwgPyBpdGVtMS5kdXJhdGlvbkVkaXRhYmxlIDogaXRlbTAuZHVyYXRpb25FZGl0YWJsZSxcbiAgICAgICAgY29uc3RyYWludHM6IGl0ZW0wLmNvbnN0cmFpbnRzLmNvbmNhdChpdGVtMS5jb25zdHJhaW50cyksXG4gICAgICAgIG92ZXJsYXA6IHR5cGVvZiBpdGVtMS5vdmVybGFwID09PSAnYm9vbGVhbicgPyBpdGVtMS5vdmVybGFwIDogaXRlbTAub3ZlcmxhcCxcbiAgICAgICAgYWxsb3dzOiBpdGVtMC5hbGxvd3MuY29uY2F0KGl0ZW0xLmFsbG93cyksXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogaXRlbTEuYmFja2dyb3VuZENvbG9yIHx8IGl0ZW0wLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgYm9yZGVyQ29sb3I6IGl0ZW0xLmJvcmRlckNvbG9yIHx8IGl0ZW0wLmJvcmRlckNvbG9yLFxuICAgICAgICB0ZXh0Q29sb3I6IGl0ZW0xLnRleHRDb2xvciB8fCBpdGVtMC50ZXh0Q29sb3IsXG4gICAgICAgIGNsYXNzTmFtZXM6IGl0ZW0wLmNsYXNzTmFtZXMuY29uY2F0KGl0ZW0xLmNsYXNzTmFtZXMpLFxuICAgIH07XG59XG5cbmNvbnN0IEVWRU5UX1NPVVJDRV9SRUZJTkVSUyA9IHtcbiAgICBpZDogU3RyaW5nLFxuICAgIGRlZmF1bHRBbGxEYXk6IEJvb2xlYW4sXG4gICAgdXJsOiBTdHJpbmcsXG4gICAgZm9ybWF0OiBTdHJpbmcsXG4gICAgZXZlbnRzOiBpZGVudGl0eSxcbiAgICBldmVudERhdGFUcmFuc2Zvcm06IGlkZW50aXR5LFxuICAgIC8vIGZvciBhbnkgbmV0d29yay1yZWxhdGVkIHNvdXJjZXNcbiAgICBzdWNjZXNzOiBpZGVudGl0eSxcbiAgICBmYWlsdXJlOiBpZGVudGl0eSxcbn07XG5mdW5jdGlvbiBwYXJzZUV2ZW50U291cmNlKHJhdywgY29udGV4dCwgcmVmaW5lcnMgPSBidWlsZEV2ZW50U291cmNlUmVmaW5lcnMoY29udGV4dCkpIHtcbiAgICBsZXQgcmF3T2JqO1xuICAgIGlmICh0eXBlb2YgcmF3ID09PSAnc3RyaW5nJykge1xuICAgICAgICByYXdPYmogPSB7IHVybDogcmF3IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiByYXcgPT09ICdmdW5jdGlvbicgfHwgQXJyYXkuaXNBcnJheShyYXcpKSB7XG4gICAgICAgIHJhd09iaiA9IHsgZXZlbnRzOiByYXcgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHJhdyA9PT0gJ29iamVjdCcgJiYgcmF3KSB7IC8vIG5vdCBudWxsXG4gICAgICAgIHJhd09iaiA9IHJhdztcbiAgICB9XG4gICAgaWYgKHJhd09iaikge1xuICAgICAgICBsZXQgeyByZWZpbmVkLCBleHRyYSB9ID0gcmVmaW5lUHJvcHMocmF3T2JqLCByZWZpbmVycyk7XG4gICAgICAgIGxldCBtZXRhUmVzID0gYnVpbGRFdmVudFNvdXJjZU1ldGEocmVmaW5lZCwgY29udGV4dCk7XG4gICAgICAgIGlmIChtZXRhUmVzKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIF9yYXc6IHJhdyxcbiAgICAgICAgICAgICAgICBpc0ZldGNoaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBsYXRlc3RGZXRjaElkOiAnJyxcbiAgICAgICAgICAgICAgICBmZXRjaFJhbmdlOiBudWxsLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRBbGxEYXk6IHJlZmluZWQuZGVmYXVsdEFsbERheSxcbiAgICAgICAgICAgICAgICBldmVudERhdGFUcmFuc2Zvcm06IHJlZmluZWQuZXZlbnREYXRhVHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHJlZmluZWQuc3VjY2VzcyxcbiAgICAgICAgICAgICAgICBmYWlsdXJlOiByZWZpbmVkLmZhaWx1cmUsXG4gICAgICAgICAgICAgICAgcHVibGljSWQ6IHJlZmluZWQuaWQgfHwgJycsXG4gICAgICAgICAgICAgICAgc291cmNlSWQ6IGd1aWQoKSxcbiAgICAgICAgICAgICAgICBzb3VyY2VEZWZJZDogbWV0YVJlcy5zb3VyY2VEZWZJZCxcbiAgICAgICAgICAgICAgICBtZXRhOiBtZXRhUmVzLm1ldGEsXG4gICAgICAgICAgICAgICAgdWk6IGNyZWF0ZUV2ZW50VWkocmVmaW5lZCwgY29udGV4dCksXG4gICAgICAgICAgICAgICAgZXh0ZW5kZWRQcm9wczogZXh0cmEsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gYnVpbGRFdmVudFNvdXJjZVJlZmluZXJzKGNvbnRleHQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEVWRU5UX1VJX1JFRklORVJTKSwgRVZFTlRfU09VUkNFX1JFRklORVJTKSwgY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudFNvdXJjZVJlZmluZXJzKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRTb3VyY2VNZXRhKHJhdywgY29udGV4dCkge1xuICAgIGxldCBkZWZzID0gY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudFNvdXJjZURlZnM7XG4gICAgZm9yIChsZXQgaSA9IGRlZnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHsgLy8gbGF0ZXItYWRkZWQgcGx1Z2lucyB0YWtlIHByZWNlZGVuY2VcbiAgICAgICAgbGV0IGRlZiA9IGRlZnNbaV07XG4gICAgICAgIGxldCBtZXRhID0gZGVmLnBhcnNlTWV0YShyYXcpO1xuICAgICAgICBpZiAobWV0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc291cmNlRGVmSWQ6IGksIG1ldGEgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVkdWNlRXZlbnRTdG9yZShldmVudFN0b3JlLCBhY3Rpb24sIGV2ZW50U291cmNlcywgZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1JFQ0VJVkVfRVZFTlRTJzogLy8gcmF3XG4gICAgICAgICAgICByZXR1cm4gcmVjZWl2ZVJhd0V2ZW50cyhldmVudFN0b3JlLCBldmVudFNvdXJjZXNbYWN0aW9uLnNvdXJjZUlkXSwgYWN0aW9uLmZldGNoSWQsIGFjdGlvbi5mZXRjaFJhbmdlLCBhY3Rpb24ucmF3RXZlbnRzLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAnUkVTRVRfUkFXX0VWRU5UUyc6XG4gICAgICAgICAgICByZXR1cm4gcmVzZXRSYXdFdmVudHMoZXZlbnRTdG9yZSwgZXZlbnRTb3VyY2VzW2FjdGlvbi5zb3VyY2VJZF0sIGFjdGlvbi5yYXdFdmVudHMsIGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAnQUREX0VWRU5UUyc6IC8vIGFscmVhZHkgcGFyc2VkLCBidXQgbm90IGV4cGFuZGVkXG4gICAgICAgICAgICByZXR1cm4gYWRkRXZlbnQoZXZlbnRTdG9yZSwgYWN0aW9uLmV2ZW50U3RvcmUsIC8vIG5ldyBvbmVzXG4gICAgICAgICAgICBkYXRlUHJvZmlsZSA/IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlIDogbnVsbCwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgJ1JFU0VUX0VWRU5UUyc6XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uLmV2ZW50U3RvcmU7XG4gICAgICAgIGNhc2UgJ01FUkdFX0VWRU5UUyc6IC8vIGFscmVhZHkgcGFyc2VkIGFuZCBleHBhbmRlZFxuICAgICAgICAgICAgcmV0dXJuIG1lcmdlRXZlbnRTdG9yZXMoZXZlbnRTdG9yZSwgYWN0aW9uLmV2ZW50U3RvcmUpO1xuICAgICAgICBjYXNlICdQUkVWJzogLy8gVE9ETzogaG93IGRvIHdlIHRyYWNrIGFsbCBhY3Rpb25zIHRoYXQgYWZmZWN0IGRhdGVQcm9maWxlIDooXG4gICAgICAgIGNhc2UgJ05FWFQnOlxuICAgICAgICBjYXNlICdDSEFOR0VfREFURSc6XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9WSUVXX1RZUEUnOlxuICAgICAgICAgICAgaWYgKGRhdGVQcm9maWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cGFuZFJlY3VycmluZyhldmVudFN0b3JlLCBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRTdG9yZTtcbiAgICAgICAgY2FzZSAnUkVNT1ZFX0VWRU5UUyc6XG4gICAgICAgICAgICByZXR1cm4gZXhjbHVkZVN1YkV2ZW50U3RvcmUoZXZlbnRTdG9yZSwgYWN0aW9uLmV2ZW50U3RvcmUpO1xuICAgICAgICBjYXNlICdSRU1PVkVfRVZFTlRfU09VUkNFJzpcbiAgICAgICAgICAgIHJldHVybiBleGNsdWRlRXZlbnRzQnlTb3VyY2VJZChldmVudFN0b3JlLCBhY3Rpb24uc291cmNlSWQpO1xuICAgICAgICBjYXNlICdSRU1PVkVfQUxMX0VWRU5UX1NPVVJDRVMnOlxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlckV2ZW50U3RvcmVEZWZzKGV2ZW50U3RvcmUsIChldmVudERlZikgPT4gKCFldmVudERlZi5zb3VyY2VJZCAvLyBvbmx5IGtlZXAgZXZlbnRzIHdpdGggbm8gc291cmNlIGlkXG4gICAgICAgICAgICApKTtcbiAgICAgICAgY2FzZSAnUkVNT1ZFX0FMTF9FVkVOVFMnOlxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50U3RvcmU7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVjZWl2ZVJhd0V2ZW50cyhldmVudFN0b3JlLCBldmVudFNvdXJjZSwgZmV0Y2hJZCwgZmV0Y2hSYW5nZSwgcmF3RXZlbnRzLCBjb250ZXh0KSB7XG4gICAgaWYgKGV2ZW50U291cmNlICYmIC8vIG5vdCBhbHJlYWR5IHJlbW92ZWRcbiAgICAgICAgZmV0Y2hJZCA9PT0gZXZlbnRTb3VyY2UubGF0ZXN0RmV0Y2hJZCAvLyBUT0RPOiB3aXNoIHRoaXMgbG9naWMgd2FzIGFsd2F5cyBpbiBldmVudC1zb3VyY2VzXG4gICAgKSB7XG4gICAgICAgIGxldCBzdWJzZXQgPSBwYXJzZUV2ZW50cyh0cmFuc2Zvcm1SYXdFdmVudHMocmF3RXZlbnRzLCBldmVudFNvdXJjZSwgY29udGV4dCksIGV2ZW50U291cmNlLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGZldGNoUmFuZ2UpIHtcbiAgICAgICAgICAgIHN1YnNldCA9IGV4cGFuZFJlY3VycmluZyhzdWJzZXQsIGZldGNoUmFuZ2UsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXJnZUV2ZW50U3RvcmVzKGV4Y2x1ZGVFdmVudHNCeVNvdXJjZUlkKGV2ZW50U3RvcmUsIGV2ZW50U291cmNlLnNvdXJjZUlkKSwgc3Vic2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50U3RvcmU7XG59XG5mdW5jdGlvbiByZXNldFJhd0V2ZW50cyhleGlzdGluZ0V2ZW50U3RvcmUsIGV2ZW50U291cmNlLCByYXdFdmVudHMsIGFjdGl2ZVJhbmdlLCBjb250ZXh0KSB7XG4gICAgY29uc3QgeyBkZWZJZE1hcCwgaW5zdGFuY2VJZE1hcCB9ID0gYnVpbGRQdWJsaWNJZE1hcHMoZXhpc3RpbmdFdmVudFN0b3JlKTtcbiAgICBsZXQgbmV3RXZlbnRTdG9yZSA9IHBhcnNlRXZlbnRzKHRyYW5zZm9ybVJhd0V2ZW50cyhyYXdFdmVudHMsIGV2ZW50U291cmNlLCBjb250ZXh0KSwgZXZlbnRTb3VyY2UsIGNvbnRleHQsIGZhbHNlLCBkZWZJZE1hcCwgaW5zdGFuY2VJZE1hcCk7XG4gICAgcmV0dXJuIGV4cGFuZFJlY3VycmluZyhuZXdFdmVudFN0b3JlLCBhY3RpdmVSYW5nZSwgY29udGV4dCk7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1SYXdFdmVudHMocmF3RXZlbnRzLCBldmVudFNvdXJjZSwgY29udGV4dCkge1xuICAgIGxldCBjYWxFYWNoVHJhbnNmb3JtID0gY29udGV4dC5vcHRpb25zLmV2ZW50RGF0YVRyYW5zZm9ybTtcbiAgICBsZXQgc291cmNlRWFjaFRyYW5zZm9ybSA9IGV2ZW50U291cmNlID8gZXZlbnRTb3VyY2UuZXZlbnREYXRhVHJhbnNmb3JtIDogbnVsbDtcbiAgICBpZiAoc291cmNlRWFjaFRyYW5zZm9ybSkge1xuICAgICAgICByYXdFdmVudHMgPSB0cmFuc2Zvcm1FYWNoUmF3RXZlbnQocmF3RXZlbnRzLCBzb3VyY2VFYWNoVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgaWYgKGNhbEVhY2hUcmFuc2Zvcm0pIHtcbiAgICAgICAgcmF3RXZlbnRzID0gdHJhbnNmb3JtRWFjaFJhd0V2ZW50KHJhd0V2ZW50cywgY2FsRWFjaFRyYW5zZm9ybSk7XG4gICAgfVxuICAgIHJldHVybiByYXdFdmVudHM7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1FYWNoUmF3RXZlbnQocmF3RXZlbnRzLCBmdW5jKSB7XG4gICAgbGV0IHJlZmluZWRFdmVudHM7XG4gICAgaWYgKCFmdW5jKSB7XG4gICAgICAgIHJlZmluZWRFdmVudHMgPSByYXdFdmVudHM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZWZpbmVkRXZlbnRzID0gW107XG4gICAgICAgIGZvciAobGV0IHJhd0V2ZW50IG9mIHJhd0V2ZW50cykge1xuICAgICAgICAgICAgbGV0IHJlZmluZWRFdmVudCA9IGZ1bmMocmF3RXZlbnQpO1xuICAgICAgICAgICAgaWYgKHJlZmluZWRFdmVudCkge1xuICAgICAgICAgICAgICAgIHJlZmluZWRFdmVudHMucHVzaChyZWZpbmVkRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVmaW5lZEV2ZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZWZpbmVkRXZlbnRzLnB1c2gocmF3RXZlbnQpO1xuICAgICAgICAgICAgfSAvLyBpZiBhIGRpZmZlcmVudCBmYWxzeSB2YWx1ZSwgZG8gbm90aGluZ1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZWZpbmVkRXZlbnRzO1xufVxuZnVuY3Rpb24gYWRkRXZlbnQoZXZlbnRTdG9yZSwgc3Vic2V0LCBleHBhbmRSYW5nZSwgY29udGV4dCkge1xuICAgIGlmIChleHBhbmRSYW5nZSkge1xuICAgICAgICBzdWJzZXQgPSBleHBhbmRSZWN1cnJpbmcoc3Vic2V0LCBleHBhbmRSYW5nZSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBtZXJnZUV2ZW50U3RvcmVzKGV2ZW50U3RvcmUsIHN1YnNldCk7XG59XG5mdW5jdGlvbiByZXpvbmVFdmVudFN0b3JlRGF0ZXMoZXZlbnRTdG9yZSwgb2xkRGF0ZUVudiwgbmV3RGF0ZUVudikge1xuICAgIGxldCB7IGRlZnMgfSA9IGV2ZW50U3RvcmU7XG4gICAgbGV0IGluc3RhbmNlcyA9IG1hcEhhc2goZXZlbnRTdG9yZS5pbnN0YW5jZXMsIChpbnN0YW5jZSkgPT4ge1xuICAgICAgICBsZXQgZGVmID0gZGVmc1tpbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIGlmIChkZWYuYWxsRGF5KSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7IC8vIGlzbid0IGRlcGVuZGVudCBvbiB0aW1lem9uZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGluc3RhbmNlKSwgeyByYW5nZToge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBuZXdEYXRlRW52LmNyZWF0ZU1hcmtlcihvbGREYXRlRW52LnRvRGF0ZShpbnN0YW5jZS5yYW5nZS5zdGFydCwgaW5zdGFuY2UuZm9yY2VkU3RhcnRUem8pKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG5ld0RhdGVFbnYuY3JlYXRlTWFya2VyKG9sZERhdGVFbnYudG9EYXRlKGluc3RhbmNlLnJhbmdlLmVuZCwgaW5zdGFuY2UuZm9yY2VkRW5kVHpvKSksXG4gICAgICAgICAgICB9LCBmb3JjZWRTdGFydFR6bzogbmV3RGF0ZUVudi5jYW5Db21wdXRlT2Zmc2V0ID8gbnVsbCA6IGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLCBmb3JjZWRFbmRUem86IG5ld0RhdGVFbnYuY2FuQ29tcHV0ZU9mZnNldCA/IG51bGwgOiBpbnN0YW5jZS5mb3JjZWRFbmRUem8gfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgZGVmcywgaW5zdGFuY2VzIH07XG59XG5mdW5jdGlvbiBleGNsdWRlRXZlbnRzQnlTb3VyY2VJZChldmVudFN0b3JlLCBzb3VyY2VJZCkge1xuICAgIHJldHVybiBmaWx0ZXJFdmVudFN0b3JlRGVmcyhldmVudFN0b3JlLCAoZXZlbnREZWYpID0+IGV2ZW50RGVmLnNvdXJjZUlkICE9PSBzb3VyY2VJZCk7XG59XG4vLyBRVUVTVElPTjogd2h5IG5vdCBqdXN0IHJldHVybiBpbnN0YW5jZXM/IGRvIGEgZ2VuZXJhbCBvYmplY3QtcHJvcGVydHktZXhjbHVzaW9uIHV0aWxcbmZ1bmN0aW9uIGV4Y2x1ZGVJbnN0YW5jZXMoZXZlbnRTdG9yZSwgcmVtb3ZhbHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWZzOiBldmVudFN0b3JlLmRlZnMsXG4gICAgICAgIGluc3RhbmNlczogZmlsdGVySGFzaChldmVudFN0b3JlLmluc3RhbmNlcywgKGluc3RhbmNlKSA9PiAhcmVtb3ZhbHNbaW5zdGFuY2UuaW5zdGFuY2VJZF0pLFxuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZFB1YmxpY0lkTWFwcyhldmVudFN0b3JlKSB7XG4gICAgY29uc3QgeyBkZWZzLCBpbnN0YW5jZXMgfSA9IGV2ZW50U3RvcmU7XG4gICAgY29uc3QgZGVmSWRNYXAgPSB7fTtcbiAgICBjb25zdCBpbnN0YW5jZUlkTWFwID0ge307XG4gICAgZm9yIChsZXQgZGVmSWQgaW4gZGVmcykge1xuICAgICAgICBjb25zdCBkZWYgPSBkZWZzW2RlZklkXTtcbiAgICAgICAgY29uc3QgeyBwdWJsaWNJZCB9ID0gZGVmO1xuICAgICAgICBpZiAocHVibGljSWQpIHtcbiAgICAgICAgICAgIGRlZklkTWFwW3B1YmxpY0lkXSA9IGRlZklkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VzW2luc3RhbmNlSWRdO1xuICAgICAgICBjb25zdCBkZWYgPSBkZWZzW2luc3RhbmNlLmRlZklkXTtcbiAgICAgICAgY29uc3QgeyBwdWJsaWNJZCB9ID0gZGVmO1xuICAgICAgICBpZiAocHVibGljSWQpIHtcbiAgICAgICAgICAgIGluc3RhbmNlSWRNYXBbcHVibGljSWRdID0gaW5zdGFuY2VJZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBkZWZJZE1hcCwgaW5zdGFuY2VJZE1hcCB9O1xufVxuXG5jbGFzcyBFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgICAgICB0aGlzLnRoaXNDb250ZXh0ID0gbnVsbDtcbiAgICB9XG4gICAgc2V0VGhpc0NvbnRleHQodGhpc0NvbnRleHQpIHtcbiAgICAgICAgdGhpcy50aGlzQ29udGV4dCA9IHRoaXNDb250ZXh0O1xuICAgIH1cbiAgICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgb24odHlwZSwgaGFuZGxlcikge1xuICAgICAgICBhZGRUb0hhc2godGhpcy5oYW5kbGVycywgdHlwZSwgaGFuZGxlcik7XG4gICAgfVxuICAgIG9mZih0eXBlLCBoYW5kbGVyKSB7XG4gICAgICAgIHJlbW92ZUZyb21IYXNoKHRoaXMuaGFuZGxlcnMsIHR5cGUsIGhhbmRsZXIpO1xuICAgIH1cbiAgICB0cmlnZ2VyKHR5cGUsIC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IGF0dGFjaGVkSGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW3R5cGVdIHx8IFtdO1xuICAgICAgICBsZXQgb3B0aW9uSGFuZGxlciA9IHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnNbdHlwZV07XG4gICAgICAgIGxldCBoYW5kbGVycyA9IFtdLmNvbmNhdChvcHRpb25IYW5kbGVyIHx8IFtdLCBhdHRhY2hlZEhhbmRsZXJzKTtcbiAgICAgICAgZm9yIChsZXQgaGFuZGxlciBvZiBoYW5kbGVycykge1xuICAgICAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLnRoaXNDb250ZXh0LCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNIYW5kbGVycyh0eXBlKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKCh0aGlzLmhhbmRsZXJzW3R5cGVdICYmIHRoaXMuaGFuZGxlcnNbdHlwZV0ubGVuZ3RoKSB8fFxuICAgICAgICAgICAgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnNbdHlwZV0pKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRUb0hhc2goaGFzaCwgdHlwZSwgaGFuZGxlcikge1xuICAgIChoYXNoW3R5cGVdIHx8IChoYXNoW3R5cGVdID0gW10pKVxuICAgICAgICAucHVzaChoYW5kbGVyKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUZyb21IYXNoKGhhc2gsIHR5cGUsIGhhbmRsZXIpIHtcbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICBpZiAoaGFzaFt0eXBlXSkge1xuICAgICAgICAgICAgaGFzaFt0eXBlXSA9IGhhc2hbdHlwZV0uZmlsdGVyKChmdW5jKSA9PiBmdW5jICE9PSBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGVsZXRlIGhhc2hbdHlwZV07IC8vIHJlbW92ZSBhbGwgaGFuZGxlciBmdW5jcyBmb3IgdGhpcyB0eXBlXG4gICAgfVxufVxuXG5jb25zdCBERUZfREVGQVVMVFMgPSB7XG4gICAgc3RhcnRUaW1lOiAnMDk6MDAnLFxuICAgIGVuZFRpbWU6ICcxNzowMCcsXG4gICAgZGF5c09mV2VlazogWzEsIDIsIDMsIDQsIDVdLFxuICAgIGRpc3BsYXk6ICdpbnZlcnNlLWJhY2tncm91bmQnLFxuICAgIGNsYXNzTmFtZXM6ICdmYy1ub24tYnVzaW5lc3MnLFxuICAgIGdyb3VwSWQ6ICdfYnVzaW5lc3NIb3VycycsIC8vIHNvIG11bHRpcGxlIGRlZnMgZ2V0IGdyb3VwZWRcbn07XG4vKlxuVE9ETzogcGFzcyBhcm91bmQgYXMgRXZlbnREZWZIYXNoISEhXG4qL1xuZnVuY3Rpb24gcGFyc2VCdXNpbmVzc0hvdXJzKGlucHV0LCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHBhcnNlRXZlbnRzKHJlZmluZUlucHV0cyhpbnB1dCksIG51bGwsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gcmVmaW5lSW5wdXRzKGlucHV0KSB7XG4gICAgbGV0IHJhd0RlZnM7XG4gICAgaWYgKGlucHV0ID09PSB0cnVlKSB7XG4gICAgICAgIHJhd0RlZnMgPSBbe31dOyAvLyB3aWxsIGdldCBERUZfREVGQVVMVFMgdmVyYmF0aW1cbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgLy8gaWYgc3BlY2lmeWluZyBhbiBhcnJheSwgZXZlcnkgc3ViLWRlZmluaXRpb24gTkVFRFMgYSBkYXktb2Ytd2Vla1xuICAgICAgICByYXdEZWZzID0gaW5wdXQuZmlsdGVyKChyYXdEZWYpID0+IHJhd0RlZi5kYXlzT2ZXZWVrKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgcmF3RGVmcyA9IFtpbnB1dF07XG4gICAgfVxuICAgIGVsc2UgeyAvLyBpcyBwcm9iYWJseSBmYWxzZVxuICAgICAgICByYXdEZWZzID0gW107XG4gICAgfVxuICAgIHJhd0RlZnMgPSByYXdEZWZzLm1hcCgocmF3RGVmKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZfREVGQVVMVFMpLCByYXdEZWYpKSk7XG4gICAgcmV0dXJuIHJhd0RlZnM7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXJEYXRlU2VsZWN0KHNlbGVjdGlvbiwgcGV2LCBjb250ZXh0KSB7XG4gICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ3NlbGVjdCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYnVpbGREYXRlU3BhbkFwaVdpdGhDb250ZXh0KHNlbGVjdGlvbiwgY29udGV4dCkpLCB7IGpzRXZlbnQ6IHBldiA/IHBldi5vcmlnRXZlbnQgOiBudWxsLCB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfHwgY29udGV4dC5jYWxlbmRhckFwaS52aWV3IH0pKTtcbn1cbmZ1bmN0aW9uIHRyaWdnZXJEYXRlVW5zZWxlY3QocGV2LCBjb250ZXh0KSB7XG4gICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ3Vuc2VsZWN0Jywge1xuICAgICAgICBqc0V2ZW50OiBwZXYgPyBwZXYub3JpZ0V2ZW50IDogbnVsbCxcbiAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpIHx8IGNvbnRleHQuY2FsZW5kYXJBcGkudmlldyxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRGF0ZVNwYW5BcGlXaXRoQ29udGV4dChkYXRlU3BhbiwgY29udGV4dCkge1xuICAgIGxldCBwcm9wcyA9IHt9O1xuICAgIGZvciAobGV0IHRyYW5zZm9ybSBvZiBjb250ZXh0LnBsdWdpbkhvb2tzLmRhdGVTcGFuVHJhbnNmb3Jtcykge1xuICAgICAgICBPYmplY3QuYXNzaWduKHByb3BzLCB0cmFuc2Zvcm0oZGF0ZVNwYW4sIGNvbnRleHQpKTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbihwcm9wcywgYnVpbGREYXRlU3BhbkFwaShkYXRlU3BhbiwgY29udGV4dC5kYXRlRW52KSk7XG4gICAgcmV0dXJuIHByb3BzO1xufVxuLy8gR2l2ZW4gYW4gZXZlbnQncyBhbGxEYXkgc3RhdHVzIGFuZCBzdGFydCBkYXRlLCByZXR1cm4gd2hhdCBpdHMgZmFsbGJhY2sgZW5kIGRhdGUgc2hvdWxkIGJlLlxuLy8gVE9ETzogcmVuYW1lIHRvIGNvbXB1dGVEZWZhdWx0RXZlbnRFbmRcbmZ1bmN0aW9uIGdldERlZmF1bHRFdmVudEVuZChhbGxEYXksIG1hcmtlciwgY29udGV4dCkge1xuICAgIGxldCB7IGRhdGVFbnYsIG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgbGV0IGVuZCA9IG1hcmtlcjtcbiAgICBpZiAoYWxsRGF5KSB7XG4gICAgICAgIGVuZCA9IHN0YXJ0T2ZEYXkoZW5kKTtcbiAgICAgICAgZW5kID0gZGF0ZUVudi5hZGQoZW5kLCBvcHRpb25zLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVuZCA9IGRhdGVFbnYuYWRkKGVuZCwgb3B0aW9ucy5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuZDtcbn1cblxuLy8gYXBwbGllcyB0aGUgbXV0YXRpb24gdG8gQUxMIGRlZnMvaW5zdGFuY2VzIHdpdGhpbiB0aGUgZXZlbnQgc3RvcmVcbmZ1bmN0aW9uIGFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUoZXZlbnRTdG9yZSwgZXZlbnRDb25maWdCYXNlLCBtdXRhdGlvbiwgY29udGV4dCkge1xuICAgIGxldCBldmVudENvbmZpZ3MgPSBjb21waWxlRXZlbnRVaXMoZXZlbnRTdG9yZS5kZWZzLCBldmVudENvbmZpZ0Jhc2UpO1xuICAgIGxldCBkZXN0ID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XG4gICAgZm9yIChsZXQgZGVmSWQgaW4gZXZlbnRTdG9yZS5kZWZzKSB7XG4gICAgICAgIGxldCBkZWYgPSBldmVudFN0b3JlLmRlZnNbZGVmSWRdO1xuICAgICAgICBkZXN0LmRlZnNbZGVmSWRdID0gYXBwbHlNdXRhdGlvblRvRXZlbnREZWYoZGVmLCBldmVudENvbmZpZ3NbZGVmSWRdLCBtdXRhdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIGZvciAobGV0IGluc3RhbmNlSWQgaW4gZXZlbnRTdG9yZS5pbnN0YW5jZXMpIHtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gZXZlbnRTdG9yZS5pbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgICAgIGxldCBkZWYgPSBkZXN0LmRlZnNbaW5zdGFuY2UuZGVmSWRdOyAvLyBpbXBvcnRhbnQgdG8gZ3JhYiB0aGUgbmV3bHkgbW9kaWZpZWQgZGVmXG4gICAgICAgIGRlc3QuaW5zdGFuY2VzW2luc3RhbmNlSWRdID0gYXBwbHlNdXRhdGlvblRvRXZlbnRJbnN0YW5jZShpbnN0YW5jZSwgZGVmLCBldmVudENvbmZpZ3NbaW5zdGFuY2UuZGVmSWRdLCBtdXRhdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xufVxuZnVuY3Rpb24gYXBwbHlNdXRhdGlvblRvRXZlbnREZWYoZXZlbnREZWYsIGV2ZW50Q29uZmlnLCBtdXRhdGlvbiwgY29udGV4dCkge1xuICAgIGxldCBzdGFuZGFyZFByb3BzID0gbXV0YXRpb24uc3RhbmRhcmRQcm9wcyB8fCB7fTtcbiAgICAvLyBpZiBoYXNFbmQgaGFzIG5vdCBiZWVuIHNwZWNpZmllZCwgZ3Vlc3MgYSBnb29kIHZhbHVlIGJhc2VkIG9uIGRlbHRhcy5cbiAgICAvLyBpZiBkdXJhdGlvbiB3aWxsIGNoYW5nZSwgdGhlcmUncyBubyB3YXkgdGhlIGRlZmF1bHQgZHVyYXRpb24gd2lsbCBwZXJzaXN0LFxuICAgIC8vIGFuZCB0aHVzLCB3ZSBuZWVkIHRvIG1hcmsgdGhlIGV2ZW50IGFzIGhhdmluZyBhIHJlYWwgZW5kXG4gICAgaWYgKHN0YW5kYXJkUHJvcHMuaGFzRW5kID09IG51bGwgJiZcbiAgICAgICAgZXZlbnRDb25maWcuZHVyYXRpb25FZGl0YWJsZSAmJlxuICAgICAgICAobXV0YXRpb24uc3RhcnREZWx0YSB8fCBtdXRhdGlvbi5lbmREZWx0YSkpIHtcbiAgICAgICAgc3RhbmRhcmRQcm9wcy5oYXNFbmQgPSB0cnVlOyAvLyBUT0RPOiBpcyB0aGlzIG11dGF0aW9uIG9rYXk/XG4gICAgfVxuICAgIGxldCBjb3B5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50RGVmKSwgc3RhbmRhcmRQcm9wcyksIHsgdWk6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnREZWYudWkpLCBzdGFuZGFyZFByb3BzLnVpKSB9KTtcbiAgICBpZiAobXV0YXRpb24uZXh0ZW5kZWRQcm9wcykge1xuICAgICAgICBjb3B5LmV4dGVuZGVkUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvcHkuZXh0ZW5kZWRQcm9wcyksIG11dGF0aW9uLmV4dGVuZGVkUHJvcHMpO1xuICAgIH1cbiAgICBmb3IgKGxldCBhcHBsaWVyIG9mIGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzKSB7XG4gICAgICAgIGFwcGxpZXIoY29weSwgbXV0YXRpb24sIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAoIWNvcHkuaGFzRW5kICYmIGNvbnRleHQub3B0aW9ucy5mb3JjZUV2ZW50RHVyYXRpb24pIHtcbiAgICAgICAgY29weS5oYXNFbmQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gY29weTtcbn1cbmZ1bmN0aW9uIGFwcGx5TXV0YXRpb25Ub0V2ZW50SW5zdGFuY2UoZXZlbnRJbnN0YW5jZSwgZXZlbnREZWYsIC8vIG11c3QgZmlyc3QgYmUgbW9kaWZpZWQgYnkgYXBwbHlNdXRhdGlvblRvRXZlbnREZWZcbmV2ZW50Q29uZmlnLCBtdXRhdGlvbiwgY29udGV4dCkge1xuICAgIGxldCB7IGRhdGVFbnYgfSA9IGNvbnRleHQ7XG4gICAgbGV0IGZvcmNlQWxsRGF5ID0gbXV0YXRpb24uc3RhbmRhcmRQcm9wcyAmJiBtdXRhdGlvbi5zdGFuZGFyZFByb3BzLmFsbERheSA9PT0gdHJ1ZTtcbiAgICBsZXQgY2xlYXJFbmQgPSBtdXRhdGlvbi5zdGFuZGFyZFByb3BzICYmIG11dGF0aW9uLnN0YW5kYXJkUHJvcHMuaGFzRW5kID09PSBmYWxzZTtcbiAgICBsZXQgY29weSA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50SW5zdGFuY2UpO1xuICAgIGlmIChmb3JjZUFsbERheSkge1xuICAgICAgICBjb3B5LnJhbmdlID0gY29tcHV0ZUFsaWduZWREYXlSYW5nZShjb3B5LnJhbmdlKTtcbiAgICB9XG4gICAgaWYgKG11dGF0aW9uLmRhdGVzRGVsdGEgJiYgZXZlbnRDb25maWcuc3RhcnRFZGl0YWJsZSkge1xuICAgICAgICBjb3B5LnJhbmdlID0ge1xuICAgICAgICAgICAgc3RhcnQ6IGRhdGVFbnYuYWRkKGNvcHkucmFuZ2Uuc3RhcnQsIG11dGF0aW9uLmRhdGVzRGVsdGEpLFxuICAgICAgICAgICAgZW5kOiBkYXRlRW52LmFkZChjb3B5LnJhbmdlLmVuZCwgbXV0YXRpb24uZGF0ZXNEZWx0YSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChtdXRhdGlvbi5zdGFydERlbHRhICYmIGV2ZW50Q29uZmlnLmR1cmF0aW9uRWRpdGFibGUpIHtcbiAgICAgICAgY29weS5yYW5nZSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBkYXRlRW52LmFkZChjb3B5LnJhbmdlLnN0YXJ0LCBtdXRhdGlvbi5zdGFydERlbHRhKSxcbiAgICAgICAgICAgIGVuZDogY29weS5yYW5nZS5lbmQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChtdXRhdGlvbi5lbmREZWx0YSAmJiBldmVudENvbmZpZy5kdXJhdGlvbkVkaXRhYmxlKSB7XG4gICAgICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydDogY29weS5yYW5nZS5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZGF0ZUVudi5hZGQoY29weS5yYW5nZS5lbmQsIG11dGF0aW9uLmVuZERlbHRhKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGNsZWFyRW5kKSB7XG4gICAgICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydDogY29weS5yYW5nZS5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZ2V0RGVmYXVsdEV2ZW50RW5kKGV2ZW50RGVmLmFsbERheSwgY29weS5yYW5nZS5zdGFydCwgY29udGV4dCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGluIGNhc2UgZXZlbnQgd2FzIGFsbC1kYXkgYnV0IHRoZSBzdXBwbGllZCBkZWx0YXMgd2VyZSBub3RcbiAgICAvLyBiZXR0ZXIgdXRpbCBmb3IgdGhpcz9cbiAgICBpZiAoZXZlbnREZWYuYWxsRGF5KSB7XG4gICAgICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydDogc3RhcnRPZkRheShjb3B5LnJhbmdlLnN0YXJ0KSxcbiAgICAgICAgICAgIGVuZDogc3RhcnRPZkRheShjb3B5LnJhbmdlLmVuZCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGhhbmRsZSBpbnZhbGlkIGR1cmF0aW9uc1xuICAgIGlmIChjb3B5LnJhbmdlLmVuZCA8IGNvcHkucmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgY29weS5yYW5nZS5lbmQgPSBnZXREZWZhdWx0RXZlbnRFbmQoZXZlbnREZWYuYWxsRGF5LCBjb3B5LnJhbmdlLnN0YXJ0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG59XG5cbmNsYXNzIEV2ZW50U291cmNlSW1wbCB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgaW50ZXJuYWxFdmVudFNvdXJjZSkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmludGVybmFsRXZlbnRTb3VyY2UgPSBpbnRlcm5hbEV2ZW50U291cmNlO1xuICAgIH1cbiAgICByZW1vdmUoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UX1NPVVJDRScsXG4gICAgICAgICAgICBzb3VyY2VJZDogdGhpcy5pbnRlcm5hbEV2ZW50U291cmNlLnNvdXJjZUlkLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVmZXRjaCgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdGRVRDSF9FVkVOVF9TT1VSQ0VTJyxcbiAgICAgICAgICAgIHNvdXJjZUlkczogW3RoaXMuaW50ZXJuYWxFdmVudFNvdXJjZS5zb3VyY2VJZF0sXG4gICAgICAgICAgICBpc1JlZmV0Y2g6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsRXZlbnRTb3VyY2UucHVibGljSWQ7XG4gICAgfVxuICAgIGdldCB1cmwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsRXZlbnRTb3VyY2UubWV0YS51cmw7XG4gICAgfVxuICAgIGdldCBmb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsRXZlbnRTb3VyY2UubWV0YS5mb3JtYXQ7IC8vIFRPRE86IGJhZC4gbm90IGd1YXJhbnRlZWRcbiAgICB9XG59XG5cbmNsYXNzIEV2ZW50SW1wbCB7XG4gICAgLy8gaW5zdGFuY2Ugd2lsbCBiZSBudWxsIGlmIGV4cHJlc3NpbmcgYSByZWN1cnJpbmcgZXZlbnQgdGhhdCBoYXMgbm8gY3VycmVudCBpbnN0YW5jZXMsXG4gICAgLy8gT1IgaWYgdHJ5aW5nIHRvIHZhbGlkYXRlIGFuIGluY29taW5nIGV4dGVybmFsIGV2ZW50IHRoYXQgaGFzIG5vIGRhdGVzIGFzc2lnbmVkXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgZGVmLCBpbnN0YW5jZSkge1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5fZGVmID0gZGVmO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IGluc3RhbmNlIHx8IG51bGw7XG4gICAgfVxuICAgIC8qXG4gICAgVE9ETzogbWFrZSBldmVudCBzdHJ1Y3QgbW9yZSByZXNwb25zaWJsZSBmb3IgdGhpc1xuICAgICovXG4gICAgc2V0UHJvcChuYW1lLCB2YWwpIHtcbiAgICAgICAgaWYgKG5hbWUgaW4gRVZFTlRfREFURV9SRUZJTkVSUykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3Qgc2V0IGRhdGUtcmVsYXRlZCBwcm9wIFxcJ25hbWVcXCcuIFVzZSBvbmUgb2YgdGhlIGRhdGUtcmVsYXRlZCBtZXRob2RzIGluc3RlYWQuJyk7XG4gICAgICAgICAgICAvLyBUT0RPOiBtYWtlIHByb3BlciBhbGlhc2luZyBzeXN0ZW0/XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ2lkJykge1xuICAgICAgICAgICAgdmFsID0gRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlNbbmFtZV0odmFsKTtcbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHtcbiAgICAgICAgICAgICAgICBzdGFuZGFyZFByb3BzOiB7IHB1YmxpY0lkOiB2YWwgfSwgLy8gaGFyZGNvZGVkIGludGVybmFsIG5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgaW4gRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlMpIHtcbiAgICAgICAgICAgIHZhbCA9IEVWRU5UX05PTl9EQVRFX1JFRklORVJTW25hbWVdKHZhbCk7XG4gICAgICAgICAgICB0aGlzLm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgc3RhbmRhcmRQcm9wczogeyBbbmFtZV06IHZhbCB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSBpbiBFVkVOVF9VSV9SRUZJTkVSUykge1xuICAgICAgICAgICAgbGV0IHVpID0gRVZFTlRfVUlfUkVGSU5FUlNbbmFtZV0odmFsKTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnY29sb3InKSB7XG4gICAgICAgICAgICAgICAgdWkgPSB7IGJhY2tncm91bmRDb2xvcjogdmFsLCBib3JkZXJDb2xvcjogdmFsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnZWRpdGFibGUnKSB7XG4gICAgICAgICAgICAgICAgdWkgPSB7IHN0YXJ0RWRpdGFibGU6IHZhbCwgZHVyYXRpb25FZGl0YWJsZTogdmFsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1aSA9IHsgW25hbWVdOiB2YWwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHtcbiAgICAgICAgICAgICAgICBzdGFuZGFyZFByb3BzOiB7IHVpIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IHNldCBwcm9wICcke25hbWV9Jy4gVXNlIHNldEV4dGVuZGVkUHJvcCBpbnN0ZWFkLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEV4dGVuZGVkUHJvcChuYW1lLCB2YWwpIHtcbiAgICAgICAgdGhpcy5tdXRhdGUoe1xuICAgICAgICAgICAgZXh0ZW5kZWRQcm9wczogeyBbbmFtZV06IHZhbCB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0U3RhcnQoc3RhcnRJbnB1dCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMuX2NvbnRleHQ7XG4gICAgICAgIGxldCBzdGFydCA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKHN0YXJ0SW5wdXQpO1xuICAgICAgICBpZiAoc3RhcnQgJiYgdGhpcy5faW5zdGFuY2UpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICBsZXQgaW5zdGFuY2VSYW5nZSA9IHRoaXMuX2luc3RhbmNlLnJhbmdlO1xuICAgICAgICAgICAgbGV0IHN0YXJ0RGVsdGEgPSBkaWZmRGF0ZXMoaW5zdGFuY2VSYW5nZS5zdGFydCwgc3RhcnQsIGRhdGVFbnYsIG9wdGlvbnMuZ3JhbnVsYXJpdHkpOyAvLyB3aGF0IGlmIHBhcnNlZCBiYWQhP1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubWFpbnRhaW5EdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZGF0ZXNEZWx0YTogc3RhcnREZWx0YSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRFbmQoZW5kSW5wdXQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLl9jb250ZXh0O1xuICAgICAgICBsZXQgZW5kO1xuICAgICAgICBpZiAoZW5kSW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgZW5kID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoZW5kSW5wdXQpO1xuICAgICAgICAgICAgaWYgKCFlbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgICAgICAgIGxldCBlbmREZWx0YSA9IGRpZmZEYXRlcyh0aGlzLl9pbnN0YW5jZS5yYW5nZS5lbmQsIGVuZCwgZGF0ZUVudiwgb3B0aW9ucy5ncmFudWxhcml0eSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBlbmREZWx0YSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhbmRhcmRQcm9wczogeyBoYXNFbmQ6IGZhbHNlIH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0RGF0ZXMoc3RhcnRJbnB1dCwgZW5kSW5wdXQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLl9jb250ZXh0O1xuICAgICAgICBsZXQgc3RhbmRhcmRQcm9wcyA9IHsgYWxsRGF5OiBvcHRpb25zLmFsbERheSB9O1xuICAgICAgICBsZXQgc3RhcnQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihzdGFydElucHV0KTtcbiAgICAgICAgbGV0IGVuZDtcbiAgICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kSW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgZW5kID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoZW5kSW5wdXQpO1xuICAgICAgICAgICAgaWYgKCFlbmQpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgICAgICAgbGV0IGluc3RhbmNlUmFuZ2UgPSB0aGlzLl9pbnN0YW5jZS5yYW5nZTtcbiAgICAgICAgICAgIC8vIHdoZW4gY29tcHV0aW5nIHRoZSBkaWZmIGZvciBhbiBldmVudCBiZWluZyBjb252ZXJ0ZWQgdG8gYWxsLWRheSxcbiAgICAgICAgICAgIC8vIGNvbXB1dGUgZGlmZiBvZmYgb2YgdGhlIGFsbC1kYXkgdmFsdWVzIHRoZSB3YXkgZXZlbnQtbXV0YXRpb24gZG9lcy5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFsbERheSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlUmFuZ2UgPSBjb21wdXRlQWxpZ25lZERheVJhbmdlKGluc3RhbmNlUmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN0YXJ0RGVsdGEgPSBkaWZmRGF0ZXMoaW5zdGFuY2VSYW5nZS5zdGFydCwgc3RhcnQsIGRhdGVFbnYsIG9wdGlvbnMuZ3JhbnVsYXJpdHkpO1xuICAgICAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgICAgICAgIGxldCBlbmREZWx0YSA9IGRpZmZEYXRlcyhpbnN0YW5jZVJhbmdlLmVuZCwgZW5kLCBkYXRlRW52LCBvcHRpb25zLmdyYW51bGFyaXR5KTtcbiAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb25zRXF1YWwoc3RhcnREZWx0YSwgZW5kRGVsdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZGF0ZXNEZWx0YTogc3RhcnREZWx0YSwgc3RhbmRhcmRQcm9wcyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YSwgZW5kRGVsdGEsIHN0YW5kYXJkUHJvcHMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vIG1lYW5zIFwiY2xlYXIgdGhlIGVuZFwiXG4gICAgICAgICAgICAgICAgc3RhbmRhcmRQcm9wcy5oYXNFbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZSh7IGRhdGVzRGVsdGE6IHN0YXJ0RGVsdGEsIHN0YW5kYXJkUHJvcHMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW92ZVN0YXJ0KGRlbHRhSW5wdXQpIHtcbiAgICAgICAgbGV0IGRlbHRhID0gY3JlYXRlRHVyYXRpb24oZGVsdGFJbnB1dCk7XG4gICAgICAgIGlmIChkZWx0YSkgeyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YTogZGVsdGEgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW92ZUVuZChkZWx0YUlucHV0KSB7XG4gICAgICAgIGxldCBkZWx0YSA9IGNyZWF0ZUR1cmF0aW9uKGRlbHRhSW5wdXQpO1xuICAgICAgICBpZiAoZGVsdGEpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICB0aGlzLm11dGF0ZSh7IGVuZERlbHRhOiBkZWx0YSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3ZlRGF0ZXMoZGVsdGFJbnB1dCkge1xuICAgICAgICBsZXQgZGVsdGEgPSBjcmVhdGVEdXJhdGlvbihkZWx0YUlucHV0KTtcbiAgICAgICAgaWYgKGRlbHRhKSB7IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxuICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBkYXRlc0RlbHRhOiBkZWx0YSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRBbGxEYXkoYWxsRGF5LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IHN0YW5kYXJkUHJvcHMgPSB7IGFsbERheSB9O1xuICAgICAgICBsZXQgeyBtYWludGFpbkR1cmF0aW9uIH0gPSBvcHRpb25zO1xuICAgICAgICBpZiAobWFpbnRhaW5EdXJhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICBtYWludGFpbkR1cmF0aW9uID0gdGhpcy5fY29udGV4dC5vcHRpb25zLmFsbERheU1haW50YWluRHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RlZi5hbGxEYXkgIT09IGFsbERheSkge1xuICAgICAgICAgICAgc3RhbmRhcmRQcm9wcy5oYXNFbmQgPSBtYWludGFpbkR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubXV0YXRlKHsgc3RhbmRhcmRQcm9wcyB9KTtcbiAgICB9XG4gICAgZm9ybWF0UmFuZ2UoZm9ybWF0SW5wdXQpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5fY29udGV4dDtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XG4gICAgICAgIGxldCBmb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIoZm9ybWF0SW5wdXQpO1xuICAgICAgICBpZiAodGhpcy5fZGVmLmhhc0VuZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0UmFuZ2UoaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIGluc3RhbmNlLnJhbmdlLmVuZCwgZm9ybWF0dGVyLCB7XG4gICAgICAgICAgICAgICAgZm9yY2VkU3RhcnRUem86IGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLFxuICAgICAgICAgICAgICAgIGZvcmNlZEVuZFR6bzogaW5zdGFuY2UuZm9yY2VkRW5kVHpvLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0KGluc3RhbmNlLnJhbmdlLnN0YXJ0LCBmb3JtYXR0ZXIsIHtcbiAgICAgICAgICAgIGZvcmNlZFR6bzogaW5zdGFuY2UuZm9yY2VkU3RhcnRUem8sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtdXRhdGUobXV0YXRpb24pIHtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgbGV0IGRlZiA9IHRoaXMuX2RlZjtcbiAgICAgICAgICAgIGxldCBjb250ZXh0ID0gdGhpcy5fY29udGV4dDtcbiAgICAgICAgICAgIGxldCB7IGV2ZW50U3RvcmUgfSA9IGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgICAgIGxldCByZWxldmFudEV2ZW50cyA9IGdldFJlbGV2YW50RXZlbnRzKGV2ZW50U3RvcmUsIGluc3RhbmNlLmluc3RhbmNlSWQpO1xuICAgICAgICAgICAgbGV0IGV2ZW50Q29uZmlnQmFzZSA9IHtcbiAgICAgICAgICAgICAgICAnJzoge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnJyxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRFZGl0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb25FZGl0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBvdmVybGFwOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd3M6IFtdLFxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcnLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJycsXG4gICAgICAgICAgICAgICAgICAgIHRleHRDb2xvcjogJycsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXM6IFtdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVsZXZhbnRFdmVudHMgPSBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlKHJlbGV2YW50RXZlbnRzLCBldmVudENvbmZpZ0Jhc2UsIG11dGF0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGxldCBvbGRFdmVudCA9IG5ldyBFdmVudEltcGwoY29udGV4dCwgZGVmLCBpbnN0YW5jZSk7IC8vIHNuYXBzaG90XG4gICAgICAgICAgICB0aGlzLl9kZWYgPSByZWxldmFudEV2ZW50cy5kZWZzW2RlZi5kZWZJZF07XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IHJlbGV2YW50RXZlbnRzLmluc3RhbmNlc1tpbnN0YW5jZS5pbnN0YW5jZUlkXTtcbiAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IHJlbGV2YW50RXZlbnRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRDaGFuZ2UnLCB7XG4gICAgICAgICAgICAgICAgb2xkRXZlbnQsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogYnVpbGRFdmVudEFwaXMocmVsZXZhbnRFdmVudHMsIGNvbnRleHQsIGluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICByZXZlcnQoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1JFU0VUX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlLCAvLyB0aGUgT1JJR0lOQUwgc3RvcmVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZSgpIHtcbiAgICAgICAgbGV0IGNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xuICAgICAgICBsZXQgYXNTdG9yZSA9IGV2ZW50QXBpVG9TdG9yZSh0aGlzKTtcbiAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UUycsXG4gICAgICAgICAgICBldmVudFN0b3JlOiBhc1N0b3JlLFxuICAgICAgICB9KTtcbiAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50UmVtb3ZlJywge1xuICAgICAgICAgICAgZXZlbnQ6IHRoaXMsXG4gICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBbXSxcbiAgICAgICAgICAgIHJldmVydCgpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IGFzU3RvcmUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IHNvdXJjZSgpIHtcbiAgICAgICAgbGV0IHsgc291cmNlSWQgfSA9IHRoaXMuX2RlZjtcbiAgICAgICAgaWYgKHNvdXJjZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50U291cmNlSW1wbCh0aGlzLl9jb250ZXh0LCB0aGlzLl9jb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRTb3VyY2VzW3NvdXJjZUlkXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldCBzdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlID9cbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZGF0ZUVudi50b0RhdGUodGhpcy5faW5zdGFuY2UucmFuZ2Uuc3RhcnQpIDpcbiAgICAgICAgICAgIG51bGw7XG4gICAgfVxuICAgIGdldCBlbmQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5faW5zdGFuY2UgJiYgdGhpcy5fZGVmLmhhc0VuZCkgP1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5kYXRlRW52LnRvRGF0ZSh0aGlzLl9pbnN0YW5jZS5yYW5nZS5lbmQpIDpcbiAgICAgICAgICAgIG51bGw7XG4gICAgfVxuICAgIGdldCBzdGFydFN0cigpIHtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZGF0ZUVudi5mb3JtYXRJc28oaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIHtcbiAgICAgICAgICAgICAgICBvbWl0VGltZTogdGhpcy5fZGVmLmFsbERheSxcbiAgICAgICAgICAgICAgICBmb3JjZWRUem86IGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBnZXQgZW5kU3RyKCkge1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIHRoaXMuX2RlZi5oYXNFbmQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmRhdGVFbnYuZm9ybWF0SXNvKGluc3RhbmNlLnJhbmdlLmVuZCwge1xuICAgICAgICAgICAgICAgIG9taXRUaW1lOiB0aGlzLl9kZWYuYWxsRGF5LFxuICAgICAgICAgICAgICAgIGZvcmNlZFR6bzogaW5zdGFuY2UuZm9yY2VkRW5kVHpvLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICAvLyBjb21wdXRhYmxlIHByb3BzIHRoYXQgYWxsIGFjY2VzcyB0aGUgZGVmXG4gICAgLy8gVE9ETzogZmluZCBhIFR5cGVTY3JpcHQtY29tcGF0aWJsZSB3YXkgdG8gZG8gdGhpcyBhdCBzY2FsZVxuICAgIGdldCBpZCgpIHsgcmV0dXJuIHRoaXMuX2RlZi5wdWJsaWNJZDsgfVxuICAgIGdldCBncm91cElkKCkgeyByZXR1cm4gdGhpcy5fZGVmLmdyb3VwSWQ7IH1cbiAgICBnZXQgYWxsRGF5KCkgeyByZXR1cm4gdGhpcy5fZGVmLmFsbERheTsgfVxuICAgIGdldCB0aXRsZSgpIHsgcmV0dXJuIHRoaXMuX2RlZi50aXRsZTsgfVxuICAgIGdldCB1cmwoKSB7IHJldHVybiB0aGlzLl9kZWYudXJsOyB9XG4gICAgZ2V0IGRpc3BsYXkoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuZGlzcGxheSB8fCAnYXV0byc7IH0gLy8gYmFkLiBqdXN0IG5vcm1hbGl6ZSB0aGUgdHlwZSBlYXJsaWVyXG4gICAgZ2V0IHN0YXJ0RWRpdGFibGUoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuc3RhcnRFZGl0YWJsZTsgfVxuICAgIGdldCBkdXJhdGlvbkVkaXRhYmxlKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmR1cmF0aW9uRWRpdGFibGU7IH1cbiAgICBnZXQgY29uc3RyYWludCgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5jb25zdHJhaW50c1swXSB8fCBudWxsOyB9XG4gICAgZ2V0IG92ZXJsYXAoKSB7IHJldHVybiB0aGlzLl9kZWYudWkub3ZlcmxhcDsgfVxuICAgIGdldCBhbGxvdygpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5hbGxvd3NbMF0gfHwgbnVsbDsgfVxuICAgIGdldCBiYWNrZ3JvdW5kQ29sb3IoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuYmFja2dyb3VuZENvbG9yOyB9XG4gICAgZ2V0IGJvcmRlckNvbG9yKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmJvcmRlckNvbG9yOyB9XG4gICAgZ2V0IHRleHRDb2xvcigpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS50ZXh0Q29sb3I7IH1cbiAgICAvLyBOT1RFOiB1c2VyIGNhbid0IG1vZGlmeSB0aGVzZSBiZWNhdXNlIE9iamVjdC5mcmVlemUgd2FzIGNhbGxlZCBpbiBldmVudC1kZWYgcGFyc2luZ1xuICAgIGdldCBjbGFzc05hbWVzKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmNsYXNzTmFtZXM7IH1cbiAgICBnZXQgZXh0ZW5kZWRQcm9wcygpIHsgcmV0dXJuIHRoaXMuX2RlZi5leHRlbmRlZFByb3BzOyB9XG4gICAgdG9QbGFpbk9iamVjdChzZXR0aW5ncyA9IHt9KSB7XG4gICAgICAgIGxldCBkZWYgPSB0aGlzLl9kZWY7XG4gICAgICAgIGxldCB7IHVpIH0gPSBkZWY7XG4gICAgICAgIGxldCB7IHN0YXJ0U3RyLCBlbmRTdHIgfSA9IHRoaXM7XG4gICAgICAgIGxldCByZXMgPSB7XG4gICAgICAgICAgICBhbGxEYXk6IGRlZi5hbGxEYXksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChkZWYudGl0bGUpIHtcbiAgICAgICAgICAgIHJlcy50aXRsZSA9IGRlZi50aXRsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRTdHIpIHtcbiAgICAgICAgICAgIHJlcy5zdGFydCA9IHN0YXJ0U3RyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRTdHIpIHtcbiAgICAgICAgICAgIHJlcy5lbmQgPSBlbmRTdHI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5wdWJsaWNJZCkge1xuICAgICAgICAgICAgcmVzLmlkID0gZGVmLnB1YmxpY0lkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYuZ3JvdXBJZCkge1xuICAgICAgICAgICAgcmVzLmdyb3VwSWQgPSBkZWYuZ3JvdXBJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLnVybCkge1xuICAgICAgICAgICAgcmVzLnVybCA9IGRlZi51cmw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVpLmRpc3BsYXkgJiYgdWkuZGlzcGxheSAhPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICByZXMuZGlzcGxheSA9IHVpLmRpc3BsYXk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogd2hhdCBhYm91dCByZWN1cnJpbmctZXZlbnQgcHJvcGVydGllcz8/P1xuICAgICAgICAvLyBUT0RPOiBpbmNsdWRlIHN0YXJ0RWRpdGFibGUvZHVyYXRpb25FZGl0YWJsZS9jb25zdHJhaW50L292ZXJsYXAvYWxsb3dcbiAgICAgICAgaWYgKHNldHRpbmdzLmNvbGxhcHNlQ29sb3IgJiYgdWkuYmFja2dyb3VuZENvbG9yICYmIHVpLmJhY2tncm91bmRDb2xvciA9PT0gdWkuYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgICAgIHJlcy5jb2xvciA9IHVpLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh1aS5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgICAgICAgICByZXMuYmFja2dyb3VuZENvbG9yID0gdWkuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVpLmJvcmRlckNvbG9yKSB7XG4gICAgICAgICAgICAgICAgcmVzLmJvcmRlckNvbG9yID0gdWkuYm9yZGVyQ29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVpLnRleHRDb2xvcikge1xuICAgICAgICAgICAgcmVzLnRleHRDb2xvciA9IHVpLnRleHRDb2xvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodWkuY2xhc3NOYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlcy5jbGFzc05hbWVzID0gdWkuY2xhc3NOYW1lcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoZGVmLmV4dGVuZGVkUHJvcHMpLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmNvbGxhcHNlRXh0ZW5kZWRQcm9wcykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzLCBkZWYuZXh0ZW5kZWRQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMuZXh0ZW5kZWRQcm9wcyA9IGRlZi5leHRlbmRlZFByb3BzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9QbGFpbk9iamVjdCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGV2ZW50QXBpVG9TdG9yZShldmVudEFwaSkge1xuICAgIGxldCBkZWYgPSBldmVudEFwaS5fZGVmO1xuICAgIGxldCBpbnN0YW5jZSA9IGV2ZW50QXBpLl9pbnN0YW5jZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWZzOiB7IFtkZWYuZGVmSWRdOiBkZWYgfSxcbiAgICAgICAgaW5zdGFuY2VzOiBpbnN0YW5jZVxuICAgICAgICAgICAgPyB7IFtpbnN0YW5jZS5pbnN0YW5jZUlkXTogaW5zdGFuY2UgfVxuICAgICAgICAgICAgOiB7fSxcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGRFdmVudEFwaXMoZXZlbnRTdG9yZSwgY29udGV4dCwgZXhjbHVkZUluc3RhbmNlKSB7XG4gICAgbGV0IHsgZGVmcywgaW5zdGFuY2VzIH0gPSBldmVudFN0b3JlO1xuICAgIGxldCBldmVudEFwaXMgPSBbXTtcbiAgICBsZXQgZXhjbHVkZUluc3RhbmNlSWQgPSBleGNsdWRlSW5zdGFuY2UgPyBleGNsdWRlSW5zdGFuY2UuaW5zdGFuY2VJZCA6ICcnO1xuICAgIGZvciAobGV0IGlkIGluIGluc3RhbmNlcykge1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaWRdO1xuICAgICAgICBsZXQgZGVmID0gZGVmc1tpbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIGlmIChpbnN0YW5jZS5pbnN0YW5jZUlkICE9PSBleGNsdWRlSW5zdGFuY2VJZCkge1xuICAgICAgICAgICAgZXZlbnRBcGlzLnB1c2gobmV3IEV2ZW50SW1wbChjb250ZXh0LCBkZWYsIGluc3RhbmNlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50QXBpcztcbn1cblxuLypcblNwZWNpZnlpbmcgbmV4dERheVRocmVzaG9sZCBzaWduYWxzIHRoYXQgYWxsLWRheSByYW5nZXMgc2hvdWxkIGJlIHNsaWNlZC5cbiovXG5mdW5jdGlvbiBzbGljZUV2ZW50U3RvcmUoZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzLCBmcmFtaW5nUmFuZ2UsIG5leHREYXlUaHJlc2hvbGQpIHtcbiAgICBsZXQgaW52ZXJzZUJnQnlHcm91cElkID0ge307XG4gICAgbGV0IGludmVyc2VCZ0J5RGVmSWQgPSB7fTtcbiAgICBsZXQgZGVmQnlHcm91cElkID0ge307XG4gICAgbGV0IGJnUmFuZ2VzID0gW107XG4gICAgbGV0IGZnUmFuZ2VzID0gW107XG4gICAgbGV0IGV2ZW50VWlzID0gY29tcGlsZUV2ZW50VWlzKGV2ZW50U3RvcmUuZGVmcywgZXZlbnRVaUJhc2VzKTtcbiAgICBmb3IgKGxldCBkZWZJZCBpbiBldmVudFN0b3JlLmRlZnMpIHtcbiAgICAgICAgbGV0IGRlZiA9IGV2ZW50U3RvcmUuZGVmc1tkZWZJZF07XG4gICAgICAgIGxldCB1aSA9IGV2ZW50VWlzW2RlZi5kZWZJZF07XG4gICAgICAgIGlmICh1aS5kaXNwbGF5ID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJykge1xuICAgICAgICAgICAgaWYgKGRlZi5ncm91cElkKSB7XG4gICAgICAgICAgICAgICAgaW52ZXJzZUJnQnlHcm91cElkW2RlZi5ncm91cElkXSA9IFtdO1xuICAgICAgICAgICAgICAgIGlmICghZGVmQnlHcm91cElkW2RlZi5ncm91cElkXSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZCeUdyb3VwSWRbZGVmLmdyb3VwSWRdID0gZGVmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGludmVyc2VCZ0J5RGVmSWRbZGVmSWRdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaW5zdGFuY2VJZCBpbiBldmVudFN0b3JlLmluc3RhbmNlcykge1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSBldmVudFN0b3JlLmluc3RhbmNlc1tpbnN0YW5jZUlkXTtcbiAgICAgICAgbGV0IGRlZiA9IGV2ZW50U3RvcmUuZGVmc1tpbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIGxldCB1aSA9IGV2ZW50VWlzW2RlZi5kZWZJZF07XG4gICAgICAgIGxldCBvcmlnUmFuZ2UgPSBpbnN0YW5jZS5yYW5nZTtcbiAgICAgICAgbGV0IG5vcm1hbFJhbmdlID0gKCFkZWYuYWxsRGF5ICYmIG5leHREYXlUaHJlc2hvbGQpID9cbiAgICAgICAgICAgIGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2Uob3JpZ1JhbmdlLCBuZXh0RGF5VGhyZXNob2xkKSA6XG4gICAgICAgICAgICBvcmlnUmFuZ2U7XG4gICAgICAgIGxldCBzbGljZWRSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhub3JtYWxSYW5nZSwgZnJhbWluZ1JhbmdlKTtcbiAgICAgICAgaWYgKHNsaWNlZFJhbmdlKSB7XG4gICAgICAgICAgICBpZiAodWkuZGlzcGxheSA9PT0gJ2ludmVyc2UtYmFja2dyb3VuZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVmLmdyb3VwSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52ZXJzZUJnQnlHcm91cElkW2RlZi5ncm91cElkXS5wdXNoKHNsaWNlZFJhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGludmVyc2VCZ0J5RGVmSWRbaW5zdGFuY2UuZGVmSWRdLnB1c2goc2xpY2VkUmFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVpLmRpc3BsYXkgIT09ICdub25lJykge1xuICAgICAgICAgICAgICAgICh1aS5kaXNwbGF5ID09PSAnYmFja2dyb3VuZCcgPyBiZ1JhbmdlcyA6IGZnUmFuZ2VzKS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZGVmLFxuICAgICAgICAgICAgICAgICAgICB1aSxcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBzbGljZWRSYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogbm9ybWFsUmFuZ2Uuc3RhcnQgJiYgbm9ybWFsUmFuZ2Uuc3RhcnQudmFsdWVPZigpID09PSBzbGljZWRSYW5nZS5zdGFydC52YWx1ZU9mKCksXG4gICAgICAgICAgICAgICAgICAgIGlzRW5kOiBub3JtYWxSYW5nZS5lbmQgJiYgbm9ybWFsUmFuZ2UuZW5kLnZhbHVlT2YoKSA9PT0gc2xpY2VkUmFuZ2UuZW5kLnZhbHVlT2YoKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBncm91cElkIGluIGludmVyc2VCZ0J5R3JvdXBJZCkgeyAvLyBCWSBHUk9VUFxuICAgICAgICBsZXQgcmFuZ2VzID0gaW52ZXJzZUJnQnlHcm91cElkW2dyb3VwSWRdO1xuICAgICAgICBsZXQgaW52ZXJ0ZWRSYW5nZXMgPSBpbnZlcnRSYW5nZXMocmFuZ2VzLCBmcmFtaW5nUmFuZ2UpO1xuICAgICAgICBmb3IgKGxldCBpbnZlcnRlZFJhbmdlIG9mIGludmVydGVkUmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgZGVmID0gZGVmQnlHcm91cElkW2dyb3VwSWRdO1xuICAgICAgICAgICAgbGV0IHVpID0gZXZlbnRVaXNbZGVmLmRlZklkXTtcbiAgICAgICAgICAgIGJnUmFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIGRlZixcbiAgICAgICAgICAgICAgICB1aSxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgICAgICAgICByYW5nZTogaW52ZXJ0ZWRSYW5nZSxcbiAgICAgICAgICAgICAgICBpc1N0YXJ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0VuZDogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBkZWZJZCBpbiBpbnZlcnNlQmdCeURlZklkKSB7XG4gICAgICAgIGxldCByYW5nZXMgPSBpbnZlcnNlQmdCeURlZklkW2RlZklkXTtcbiAgICAgICAgbGV0IGludmVydGVkUmFuZ2VzID0gaW52ZXJ0UmFuZ2VzKHJhbmdlcywgZnJhbWluZ1JhbmdlKTtcbiAgICAgICAgZm9yIChsZXQgaW52ZXJ0ZWRSYW5nZSBvZiBpbnZlcnRlZFJhbmdlcykge1xuICAgICAgICAgICAgYmdSYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZGVmOiBldmVudFN0b3JlLmRlZnNbZGVmSWRdLFxuICAgICAgICAgICAgICAgIHVpOiBldmVudFVpc1tkZWZJZF0sXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IG51bGwsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IGludmVydGVkUmFuZ2UsXG4gICAgICAgICAgICAgICAgaXNTdGFydDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNFbmQ6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgYmc6IGJnUmFuZ2VzLCBmZzogZmdSYW5nZXMgfTtcbn1cbmZ1bmN0aW9uIGhhc0JnUmVuZGVyaW5nKGRlZikge1xuICAgIHJldHVybiBkZWYudWkuZGlzcGxheSA9PT0gJ2JhY2tncm91bmQnIHx8IGRlZi51aS5kaXNwbGF5ID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJztcbn1cbmZ1bmN0aW9uIHNldEVsU2VnKGVsLCBzZWcpIHtcbiAgICBlbC5mY1NlZyA9IHNlZztcbn1cbmZ1bmN0aW9uIGdldEVsU2VnKGVsKSB7XG4gICAgcmV0dXJuIGVsLmZjU2VnIHx8XG4gICAgICAgIGVsLnBhcmVudE5vZGUuZmNTZWcgfHwgLy8gZm9yIHRoZSBoYXJuZXNzXG4gICAgICAgIG51bGw7XG59XG4vLyBldmVudCB1aSBjb21wdXRhdGlvblxuZnVuY3Rpb24gY29tcGlsZUV2ZW50VWlzKGV2ZW50RGVmcywgZXZlbnRVaUJhc2VzKSB7XG4gICAgcmV0dXJuIG1hcEhhc2goZXZlbnREZWZzLCAoZXZlbnREZWYpID0+IGNvbXBpbGVFdmVudFVpKGV2ZW50RGVmLCBldmVudFVpQmFzZXMpKTtcbn1cbmZ1bmN0aW9uIGNvbXBpbGVFdmVudFVpKGV2ZW50RGVmLCBldmVudFVpQmFzZXMpIHtcbiAgICBsZXQgdWlzID0gW107XG4gICAgaWYgKGV2ZW50VWlCYXNlc1snJ10pIHtcbiAgICAgICAgdWlzLnB1c2goZXZlbnRVaUJhc2VzWycnXSk7XG4gICAgfVxuICAgIGlmIChldmVudFVpQmFzZXNbZXZlbnREZWYuZGVmSWRdKSB7XG4gICAgICAgIHVpcy5wdXNoKGV2ZW50VWlCYXNlc1tldmVudERlZi5kZWZJZF0pO1xuICAgIH1cbiAgICB1aXMucHVzaChldmVudERlZi51aSk7XG4gICAgcmV0dXJuIGNvbWJpbmVFdmVudFVpcyh1aXMpO1xufVxuZnVuY3Rpb24gc29ydEV2ZW50U2VncyhzZWdzLCBldmVudE9yZGVyU3BlY3MpIHtcbiAgICBsZXQgb2JqcyA9IHNlZ3MubWFwKGJ1aWxkU2VnQ29tcGFyZU9iaik7XG4gICAgb2Jqcy5zb3J0KChvYmowLCBvYmoxKSA9PiBjb21wYXJlQnlGaWVsZFNwZWNzKG9iajAsIG9iajEsIGV2ZW50T3JkZXJTcGVjcykpO1xuICAgIHJldHVybiBvYmpzLm1hcCgoYykgPT4gYy5fc2VnKTtcbn1cbi8vIHJldHVybnMgYSBvYmplY3Qgd2l0aCBhbGwgcHJpbWl0aXZlIHByb3BzIHRoYXQgY2FuIGJlIGNvbXBhcmVkXG5mdW5jdGlvbiBidWlsZFNlZ0NvbXBhcmVPYmooc2VnKSB7XG4gICAgbGV0IHsgZXZlbnRSYW5nZSB9ID0gc2VnO1xuICAgIGxldCBldmVudERlZiA9IGV2ZW50UmFuZ2UuZGVmO1xuICAgIGxldCByYW5nZSA9IGV2ZW50UmFuZ2UuaW5zdGFuY2UgPyBldmVudFJhbmdlLmluc3RhbmNlLnJhbmdlIDogZXZlbnRSYW5nZS5yYW5nZTtcbiAgICBsZXQgc3RhcnQgPSByYW5nZS5zdGFydCA/IHJhbmdlLnN0YXJ0LnZhbHVlT2YoKSA6IDA7IC8vIFRPRE86IGJldHRlciBzdXBwb3J0IGZvciBvcGVuLXJhbmdlIGV2ZW50c1xuICAgIGxldCBlbmQgPSByYW5nZS5lbmQgPyByYW5nZS5lbmQudmFsdWVPZigpIDogMDsgLy8gXCJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50RGVmLmV4dGVuZGVkUHJvcHMpLCBldmVudERlZiksIHsgaWQ6IGV2ZW50RGVmLnB1YmxpY0lkLCBzdGFydCxcbiAgICAgICAgZW5kLCBkdXJhdGlvbjogZW5kIC0gc3RhcnQsIGFsbERheTogTnVtYmVyKGV2ZW50RGVmLmFsbERheSksIF9zZWc6IHNlZyB9KTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVTZWdEcmFnZ2FibGUoc2VnLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgcGx1Z2luSG9va3MgfSA9IGNvbnRleHQ7XG4gICAgbGV0IHRyYW5zZm9ybWVycyA9IHBsdWdpbkhvb2tzLmlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzO1xuICAgIGxldCB7IGRlZiwgdWkgfSA9IHNlZy5ldmVudFJhbmdlO1xuICAgIGxldCB2YWwgPSB1aS5zdGFydEVkaXRhYmxlO1xuICAgIGZvciAobGV0IHRyYW5zZm9ybWVyIG9mIHRyYW5zZm9ybWVycykge1xuICAgICAgICB2YWwgPSB0cmFuc2Zvcm1lcih2YWwsIGRlZiwgdWksIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuZnVuY3Rpb24gY29tcHV0ZVNlZ1N0YXJ0UmVzaXphYmxlKHNlZywgY29udGV4dCkge1xuICAgIHJldHVybiBzZWcuaXNTdGFydCAmJiBzZWcuZXZlbnRSYW5nZS51aS5kdXJhdGlvbkVkaXRhYmxlICYmIGNvbnRleHQub3B0aW9ucy5ldmVudFJlc2l6YWJsZUZyb21TdGFydDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVTZWdFbmRSZXNpemFibGUoc2VnLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHNlZy5pc0VuZCAmJiBzZWcuZXZlbnRSYW5nZS51aS5kdXJhdGlvbkVkaXRhYmxlO1xufVxuZnVuY3Rpb24gYnVpbGRTZWdUaW1lVGV4dChzZWcsIHRpbWVGb3JtYXQsIGNvbnRleHQsIGRlZmF1bHREaXNwbGF5RXZlbnRUaW1lLCAvLyBkZWZhdWx0cyB0byB0cnVlXG5kZWZhdWx0RGlzcGxheUV2ZW50RW5kLCAvLyBkZWZhdWx0cyB0byB0cnVlXG5zdGFydE92ZXJyaWRlLCBlbmRPdmVycmlkZSkge1xuICAgIGxldCB7IGRhdGVFbnYsIG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgbGV0IHsgZGlzcGxheUV2ZW50VGltZSwgZGlzcGxheUV2ZW50RW5kIH0gPSBvcHRpb25zO1xuICAgIGxldCBldmVudERlZiA9IHNlZy5ldmVudFJhbmdlLmRlZjtcbiAgICBsZXQgZXZlbnRJbnN0YW5jZSA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlO1xuICAgIGlmIChkaXNwbGF5RXZlbnRUaW1lID09IG51bGwpIHtcbiAgICAgICAgZGlzcGxheUV2ZW50VGltZSA9IGRlZmF1bHREaXNwbGF5RXZlbnRUaW1lICE9PSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRpc3BsYXlFdmVudEVuZCA9PSBudWxsKSB7XG4gICAgICAgIGRpc3BsYXlFdmVudEVuZCA9IGRlZmF1bHREaXNwbGF5RXZlbnRFbmQgIT09IGZhbHNlO1xuICAgIH1cbiAgICBsZXQgd2hvbGVFdmVudFN0YXJ0ID0gZXZlbnRJbnN0YW5jZS5yYW5nZS5zdGFydDtcbiAgICBsZXQgd2hvbGVFdmVudEVuZCA9IGV2ZW50SW5zdGFuY2UucmFuZ2UuZW5kO1xuICAgIGxldCBzZWdTdGFydCA9IHN0YXJ0T3ZlcnJpZGUgfHwgc2VnLnN0YXJ0IHx8IHNlZy5ldmVudFJhbmdlLnJhbmdlLnN0YXJ0O1xuICAgIGxldCBzZWdFbmQgPSBlbmRPdmVycmlkZSB8fCBzZWcuZW5kIHx8IHNlZy5ldmVudFJhbmdlLnJhbmdlLmVuZDtcbiAgICBsZXQgaXNTdGFydERheSA9IHN0YXJ0T2ZEYXkod2hvbGVFdmVudFN0YXJ0KS52YWx1ZU9mKCkgPT09IHN0YXJ0T2ZEYXkoc2VnU3RhcnQpLnZhbHVlT2YoKTtcbiAgICBsZXQgaXNFbmREYXkgPSBzdGFydE9mRGF5KGFkZE1zKHdob2xlRXZlbnRFbmQsIC0xKSkudmFsdWVPZigpID09PSBzdGFydE9mRGF5KGFkZE1zKHNlZ0VuZCwgLTEpKS52YWx1ZU9mKCk7XG4gICAgaWYgKGRpc3BsYXlFdmVudFRpbWUgJiYgIWV2ZW50RGVmLmFsbERheSAmJiAoaXNTdGFydERheSB8fCBpc0VuZERheSkpIHtcbiAgICAgICAgc2VnU3RhcnQgPSBpc1N0YXJ0RGF5ID8gd2hvbGVFdmVudFN0YXJ0IDogc2VnU3RhcnQ7XG4gICAgICAgIHNlZ0VuZCA9IGlzRW5kRGF5ID8gd2hvbGVFdmVudEVuZCA6IHNlZ0VuZDtcbiAgICAgICAgaWYgKGRpc3BsYXlFdmVudEVuZCAmJiBldmVudERlZi5oYXNFbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKHNlZ1N0YXJ0LCBzZWdFbmQsIHRpbWVGb3JtYXQsIHtcbiAgICAgICAgICAgICAgICBmb3JjZWRTdGFydFR6bzogc3RhcnRPdmVycmlkZSA/IG51bGwgOiBldmVudEluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLFxuICAgICAgICAgICAgICAgIGZvcmNlZEVuZFR6bzogZW5kT3ZlcnJpZGUgPyBudWxsIDogZXZlbnRJbnN0YW5jZS5mb3JjZWRFbmRUem8sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXQoc2VnU3RhcnQsIHRpbWVGb3JtYXQsIHtcbiAgICAgICAgICAgIGZvcmNlZFR6bzogc3RhcnRPdmVycmlkZSA/IG51bGwgOiBldmVudEluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLCAvLyBub29vb28sIHNhbWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cbmZ1bmN0aW9uIGdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlLCBub3dEYXRlKSB7XG4gICAgbGV0IHNlZ1JhbmdlID0gc2VnLmV2ZW50UmFuZ2UucmFuZ2U7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNQYXN0OiBzZWdSYW5nZS5lbmQgPD0gKG5vd0RhdGUgfHwgdG9kYXlSYW5nZS5zdGFydCksXG4gICAgICAgIGlzRnV0dXJlOiBzZWdSYW5nZS5zdGFydCA+PSAobm93RGF0ZSB8fCB0b2RheVJhbmdlLmVuZCksXG4gICAgICAgIGlzVG9kYXk6IHRvZGF5UmFuZ2UgJiYgcmFuZ2VDb250YWluc01hcmtlcih0b2RheVJhbmdlLCBzZWdSYW5nZS5zdGFydCksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50Q2xhc3NOYW1lcyhwcm9wcykge1xuICAgIGxldCBjbGFzc05hbWVzID0gWydmYy1ldmVudCddO1xuICAgIGlmIChwcm9wcy5pc01pcnJvcikge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LW1pcnJvcicpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNEcmFnZ2FibGUpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1kcmFnZ2FibGUnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzU3RhcnRSZXNpemFibGUgfHwgcHJvcHMuaXNFbmRSZXNpemFibGUpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1yZXNpemFibGUnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1kcmFnZ2luZycpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNSZXNpemluZykge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXJlc2l6aW5nJyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc1NlbGVjdGVkKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtc2VsZWN0ZWQnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzU3RhcnQpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1zdGFydCcpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNFbmQpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1lbmQnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzUGFzdCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXBhc3QnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzVG9kYXkpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC10b2RheScpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNGdXR1cmUpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1mdXR1cmUnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZXM7XG59XG5mdW5jdGlvbiBidWlsZEV2ZW50UmFuZ2VLZXkoZXZlbnRSYW5nZSkge1xuICAgIHJldHVybiBldmVudFJhbmdlLmluc3RhbmNlXG4gICAgICAgID8gZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkXG4gICAgICAgIDogYCR7ZXZlbnRSYW5nZS5kZWYuZGVmSWR9OiR7ZXZlbnRSYW5nZS5yYW5nZS5zdGFydC50b0lTT1N0cmluZygpfWA7XG4gICAgLy8gaW52ZXJzZS1iYWNrZ3JvdW5kIGV2ZW50cyBkb24ndCBoYXZlIHNwZWNpZmljIGluc3RhbmNlcy4gVE9ETzogYmV0dGVyIHNvbHV0aW9uXG59XG5mdW5jdGlvbiBnZXRTZWdBbmNob3JBdHRycyhzZWcsIGNvbnRleHQpIHtcbiAgICBsZXQgeyBkZWYsIGluc3RhbmNlIH0gPSBzZWcuZXZlbnRSYW5nZTtcbiAgICBsZXQgeyB1cmwgfSA9IGRlZjtcbiAgICBpZiAodXJsKSB7XG4gICAgICAgIHJldHVybiB7IGhyZWY6IHVybCB9O1xuICAgIH1cbiAgICBsZXQgeyBlbWl0dGVyLCBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgIGxldCB7IGV2ZW50SW50ZXJhY3RpdmUgfSA9IG9wdGlvbnM7XG4gICAgaWYgKGV2ZW50SW50ZXJhY3RpdmUgPT0gbnVsbCkge1xuICAgICAgICBldmVudEludGVyYWN0aXZlID0gZGVmLmludGVyYWN0aXZlO1xuICAgICAgICBpZiAoZXZlbnRJbnRlcmFjdGl2ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBldmVudEludGVyYWN0aXZlID0gQm9vbGVhbihlbWl0dGVyLmhhc0hhbmRsZXJzKCdldmVudENsaWNrJykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG1vY2sgd2hhdCBoYXBwZW5zIGluIEV2ZW50Q2xpY2tpbmdcbiAgICBpZiAoZXZlbnRJbnRlcmFjdGl2ZSkge1xuICAgICAgICAvLyBvbmx5IGF0dGFjaCBrZXlib2FyZC1yZWxhdGVkIGhhbmRsZXJzIGJlY2F1c2UgY2xpY2sgaGFuZGxlciBpcyBhbHJlYWR5IGRvbmUgaW4gRXZlbnRDbGlja2luZ1xuICAgICAgICByZXR1cm4gY3JlYXRlQXJpYUtleWJvYXJkQXR0cnMoKGV2KSA9PiB7XG4gICAgICAgICAgICBlbWl0dGVyLnRyaWdnZXIoJ2V2ZW50Q2xpY2snLCB7XG4gICAgICAgICAgICAgICAgZWw6IGV2LnRhcmdldCxcbiAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50SW1wbChjb250ZXh0LCBkZWYsIGluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICBqc0V2ZW50OiBldixcbiAgICAgICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7fTtcbn1cblxuY29uc3QgU1RBTkRBUkRfUFJPUFMgPSB7XG4gICAgc3RhcnQ6IGlkZW50aXR5LFxuICAgIGVuZDogaWRlbnRpdHksXG4gICAgYWxsRGF5OiBCb29sZWFuLFxufTtcbmZ1bmN0aW9uIHBhcnNlRGF0ZVNwYW4ocmF3LCBkYXRlRW52LCBkZWZhdWx0RHVyYXRpb24pIHtcbiAgICBsZXQgc3BhbiA9IHBhcnNlT3BlbkRhdGVTcGFuKHJhdywgZGF0ZUVudik7XG4gICAgbGV0IHsgcmFuZ2UgfSA9IHNwYW47XG4gICAgaWYgKCFyYW5nZS5zdGFydCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFyYW5nZS5lbmQpIHtcbiAgICAgICAgaWYgKGRlZmF1bHREdXJhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByYW5nZS5lbmQgPSBkYXRlRW52LmFkZChyYW5nZS5zdGFydCwgZGVmYXVsdER1cmF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHNwYW47XG59XG4vKlxuVE9ETzogc29tZWhvdyBjb21iaW5lIHdpdGggcGFyc2VSYW5nZT9cbldpbGwgcmV0dXJuIG51bGwgaWYgdGhlIHN0YXJ0L2VuZCBwcm9wcyB3ZXJlIHByZXNlbnQgYnV0IHBhcnNlZCBpbnZhbGlkbHkuXG4qL1xuZnVuY3Rpb24gcGFyc2VPcGVuRGF0ZVNwYW4ocmF3LCBkYXRlRW52KSB7XG4gICAgbGV0IHsgcmVmaW5lZDogc3RhbmRhcmRQcm9wcywgZXh0cmEgfSA9IHJlZmluZVByb3BzKHJhdywgU1RBTkRBUkRfUFJPUFMpO1xuICAgIGxldCBzdGFydE1ldGEgPSBzdGFuZGFyZFByb3BzLnN0YXJ0ID8gZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKHN0YW5kYXJkUHJvcHMuc3RhcnQpIDogbnVsbDtcbiAgICBsZXQgZW5kTWV0YSA9IHN0YW5kYXJkUHJvcHMuZW5kID8gZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKHN0YW5kYXJkUHJvcHMuZW5kKSA6IG51bGw7XG4gICAgbGV0IHsgYWxsRGF5IH0gPSBzdGFuZGFyZFByb3BzO1xuICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xuICAgICAgICBhbGxEYXkgPSAoc3RhcnRNZXRhICYmIHN0YXJ0TWV0YS5pc1RpbWVVbnNwZWNpZmllZCkgJiZcbiAgICAgICAgICAgICghZW5kTWV0YSB8fCBlbmRNZXRhLmlzVGltZVVuc3BlY2lmaWVkKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyByYW5nZToge1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0TWV0YSA/IHN0YXJ0TWV0YS5tYXJrZXIgOiBudWxsLFxuICAgICAgICAgICAgZW5kOiBlbmRNZXRhID8gZW5kTWV0YS5tYXJrZXIgOiBudWxsLFxuICAgICAgICB9LCBhbGxEYXkgfSwgZXh0cmEpO1xufVxuZnVuY3Rpb24gaXNEYXRlU3BhbnNFcXVhbChzcGFuMCwgc3BhbjEpIHtcbiAgICByZXR1cm4gcmFuZ2VzRXF1YWwoc3BhbjAucmFuZ2UsIHNwYW4xLnJhbmdlKSAmJlxuICAgICAgICBzcGFuMC5hbGxEYXkgPT09IHNwYW4xLmFsbERheSAmJlxuICAgICAgICBpc1NwYW5Qcm9wc0VxdWFsKHNwYW4wLCBzcGFuMSk7XG59XG4vLyB0aGUgTk9OLURBVEUtUkVMQVRFRCBwcm9wc1xuZnVuY3Rpb24gaXNTcGFuUHJvcHNFcXVhbChzcGFuMCwgc3BhbjEpIHtcbiAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBzcGFuMSkge1xuICAgICAgICBpZiAocHJvcE5hbWUgIT09ICdyYW5nZScgJiYgcHJvcE5hbWUgIT09ICdhbGxEYXknKSB7XG4gICAgICAgICAgICBpZiAoc3BhbjBbcHJvcE5hbWVdICE9PSBzcGFuMVtwcm9wTmFtZV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYXJlIHRoZXJlIGFueSBwcm9wcyB0aGF0IHNwYW4wIGhhcyB0aGF0IHNwYW4xIERPRVNOJ1QgaGF2ZT9cbiAgICAvLyBib3RoIGhhdmUgcmFuZ2UvYWxsRGF5LCBzbyBubyBuZWVkIHRvIHNwZWNpYWwtY2FzZS5cbiAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBzcGFuMCkge1xuICAgICAgICBpZiAoIShwcm9wTmFtZSBpbiBzcGFuMSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRGF0ZVNwYW5BcGkoc3BhbiwgZGF0ZUVudikge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJ1aWxkUmFuZ2VBcGkoc3Bhbi5yYW5nZSwgZGF0ZUVudiwgc3Bhbi5hbGxEYXkpKSwgeyBhbGxEYXk6IHNwYW4uYWxsRGF5IH0pO1xufVxuZnVuY3Rpb24gYnVpbGRSYW5nZUFwaVdpdGhUaW1lWm9uZShyYW5nZSwgZGF0ZUVudiwgb21pdFRpbWUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZFJhbmdlQXBpKHJhbmdlLCBkYXRlRW52LCBvbWl0VGltZSkpLCB7IHRpbWVab25lOiBkYXRlRW52LnRpbWVab25lIH0pO1xufVxuZnVuY3Rpb24gYnVpbGRSYW5nZUFwaShyYW5nZSwgZGF0ZUVudiwgb21pdFRpbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogZGF0ZUVudi50b0RhdGUocmFuZ2Uuc3RhcnQpLFxuICAgICAgICBlbmQ6IGRhdGVFbnYudG9EYXRlKHJhbmdlLmVuZCksXG4gICAgICAgIHN0YXJ0U3RyOiBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5zdGFydCwgeyBvbWl0VGltZSB9KSxcbiAgICAgICAgZW5kU3RyOiBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5lbmQsIHsgb21pdFRpbWUgfSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZhYnJpY2F0ZUV2ZW50UmFuZ2UoZGF0ZVNwYW4sIGV2ZW50VWlCYXNlcywgY29udGV4dCkge1xuICAgIGxldCByZXMgPSByZWZpbmVFdmVudERlZih7IGVkaXRhYmxlOiBmYWxzZSB9LCBjb250ZXh0KTtcbiAgICBsZXQgZGVmID0gcGFyc2VFdmVudERlZihyZXMucmVmaW5lZCwgcmVzLmV4dHJhLCAnJywgLy8gc291cmNlSWRcbiAgICBkYXRlU3Bhbi5hbGxEYXksIHRydWUsIC8vIGhhc0VuZFxuICAgIGNvbnRleHQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlZixcbiAgICAgICAgdWk6IGNvbXBpbGVFdmVudFVpKGRlZiwgZXZlbnRVaUJhc2VzKSxcbiAgICAgICAgaW5zdGFuY2U6IGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmLmRlZklkLCBkYXRlU3Bhbi5yYW5nZSksXG4gICAgICAgIHJhbmdlOiBkYXRlU3Bhbi5yYW5nZSxcbiAgICAgICAgaXNTdGFydDogdHJ1ZSxcbiAgICAgICAgaXNFbmQ6IHRydWUsXG4gICAgfTtcbn1cblxuLypcbmdpdmVuIGEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyBhIHJlc3VsdCBhc3luY2hyb25vdXNseS5cbnRoZSBmdW5jdGlvbiBjYW4gZWl0aGVyIGNhbGwgcGFzc2VkLWluIHN1Y2Nlc3MgYW5kIGZhaWx1cmUgY2FsbGJhY2tzLFxub3IgaXQgY2FuIHJldHVybiBhIHByb21pc2UuXG5pZiB5b3UgbmVlZCB0byBwYXNzIGFkZGl0aW9uYWwgcGFyYW1zIHRvIGZ1bmMsIGJpbmQgdGhlbSBmaXJzdC5cbiovXG5mdW5jdGlvbiB1bnByb21pc2lmeShmdW5jLCBub3JtYWxpemVkU3VjY2Vzc0NhbGxiYWNrLCBub3JtYWxpemVkRmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgLy8gZ3VhcmQgYWdhaW5zdCBzdWNjZXNzL2ZhaWx1cmUgY2FsbGJhY2tzIGJlaW5nIGNhbGxlZCBtb3JlIHRoYW4gb25jZVxuICAgIC8vIGFuZCBndWFyZCBhZ2FpbnN0IGEgcHJvbWlzZSBBTkQgY2FsbGJhY2sgYmVpbmcgdXNlZCB0b2dldGhlci5cbiAgICBsZXQgaXNSZXNvbHZlZCA9IGZhbHNlO1xuICAgIGxldCB3cmFwcGVkU3VjY2VzcyA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgaWYgKCFpc1Jlc29sdmVkKSB7XG4gICAgICAgICAgICBpc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRTdWNjZXNzQ2FsbGJhY2socmVzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IHdyYXBwZWRGYWlsdXJlID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGlmICghaXNSZXNvbHZlZCkge1xuICAgICAgICAgICAgaXNSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICBub3JtYWxpemVkRmFpbHVyZUNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IHJlcyA9IGZ1bmMod3JhcHBlZFN1Y2Nlc3MsIHdyYXBwZWRGYWlsdXJlKTtcbiAgICBpZiAocmVzICYmIHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXMudGhlbih3cmFwcGVkU3VjY2Vzcywgd3JhcHBlZEZhaWx1cmUpO1xuICAgIH1cbn1cblxuY2xhc3MgSnNvblJlcXVlc3RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCByZXNwb25zZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlcXVlc3RKc29uKG1ldGhvZCwgdXJsLCBwYXJhbXMpIHtcbiAgICBtZXRob2QgPSBtZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICBjb25zdCBmZXRjaE9wdGlvbnMgPSB7XG4gICAgICAgIG1ldGhvZCxcbiAgICB9O1xuICAgIGlmIChtZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICtcbiAgICAgICAgICAgIG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZldGNoT3B0aW9ucy5ib2R5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbXMpO1xuICAgICAgICBmZXRjaE9wdGlvbnMuaGVhZGVycyA9IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZldGNoKHVybCwgZmV0Y2hPcHRpb25zKS50aGVuKChmZXRjaFJlcykgPT4ge1xuICAgICAgICBpZiAoZmV0Y2hSZXMub2spIHtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaFJlcy5qc29uKCkudGhlbigocGFyc2VkUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3BhcnNlZFJlc3BvbnNlLCBmZXRjaFJlc107XG4gICAgICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25SZXF1ZXN0RXJyb3IoJ0ZhaWx1cmUgcGFyc2luZyBKU09OJywgZmV0Y2hSZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSnNvblJlcXVlc3RFcnJvcignUmVxdWVzdCBmYWlsZWQnLCBmZXRjaFJlcyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxubGV0IGNhblZHcm93V2l0aGluQ2VsbDtcbmZ1bmN0aW9uIGdldENhblZHcm93V2l0aGluQ2VsbCgpIHtcbiAgICBpZiAoY2FuVkdyb3dXaXRoaW5DZWxsID09IG51bGwpIHtcbiAgICAgICAgY2FuVkdyb3dXaXRoaW5DZWxsID0gY29tcHV0ZUNhblZHcm93V2l0aGluQ2VsbCgpO1xuICAgIH1cbiAgICByZXR1cm4gY2FuVkdyb3dXaXRoaW5DZWxsO1xufVxuZnVuY3Rpb24gY29tcHV0ZUNhblZHcm93V2l0aGluQ2VsbCgpIHtcbiAgICAvLyBmb3IgU1NSLCBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXMgY2FsbCBpbW1lZGlhdGVseSBhdCB0b3AtbGV2ZWxcbiAgICAvLyBUT0RPOiBqdXN0IG1ha2UgdGhpcyBsb2dpYyBleGVjdXRlIHRvcC1sZXZlbCwgaW1tZWRpYXRlbHksIGluc3RlYWQgb2YgZG9pbmcgbGF6aWx5XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBlbC5zdHlsZS50b3AgPSAnMHB4JztcbiAgICBlbC5zdHlsZS5sZWZ0ID0gJzBweCc7XG4gICAgZWwuaW5uZXJIVE1MID0gJzx0YWJsZT48dHI+PHRkPjxkaXY+PC9kaXY+PC90ZD48L3RyPjwvdGFibGU+JztcbiAgICBlbC5xdWVyeVNlbGVjdG9yKCd0YWJsZScpLnN0eWxlLmhlaWdodCA9ICcxMDBweCc7XG4gICAgZWwucXVlcnlTZWxlY3RvcignZGl2Jykuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIGxldCBkaXYgPSBlbC5xdWVyeVNlbGVjdG9yKCdkaXYnKTtcbiAgICBsZXQgcG9zc2libGUgPSBkaXYub2Zmc2V0SGVpZ2h0ID4gMDtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcbiAgICByZXR1cm4gcG9zc2libGU7XG59XG5cbmNsYXNzIENhbGVuZGFyUm9vdCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZm9yUHJpbnQ6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUJlZm9yZVByaW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgZm9yUHJpbnQ6IHRydWUgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVBZnRlclByaW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgZm9yUHJpbnQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IHByb3BzO1xuICAgICAgICBsZXQgeyBmb3JQcmludCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgbGV0IGlzSGVpZ2h0QXV0byA9IGZvclByaW50IHx8IG9wdGlvbnMuaGVpZ2h0ID09PSAnYXV0bycgfHwgb3B0aW9ucy5jb250ZW50SGVpZ2h0ID09PSAnYXV0byc7XG4gICAgICAgIGxldCBoZWlnaHQgPSAoIWlzSGVpZ2h0QXV0byAmJiBvcHRpb25zLmhlaWdodCAhPSBudWxsKSA/IG9wdGlvbnMuaGVpZ2h0IDogJyc7XG4gICAgICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgICAgICAgJ2ZjJyxcbiAgICAgICAgICAgIGZvclByaW50ID8gJ2ZjLW1lZGlhLXByaW50JyA6ICdmYy1tZWRpYS1zY3JlZW4nLFxuICAgICAgICAgICAgYGZjLWRpcmVjdGlvbi0ke29wdGlvbnMuZGlyZWN0aW9ufWAsXG4gICAgICAgICAgICBwcm9wcy50aGVtZS5nZXRDbGFzcygncm9vdCcpLFxuICAgICAgICBdO1xuICAgICAgICBpZiAoIWdldENhblZHcm93V2l0aGluQ2VsbCgpKSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWxpcXVpZC1oYWNrJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuKGNsYXNzTmFtZXMsIGhlaWdodCwgaXNIZWlnaHRBdXRvLCBmb3JQcmludCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBsZXQgeyBlbWl0dGVyIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBlbWl0dGVyLm9uKCdfYmVmb3JlcHJpbnQnLCB0aGlzLmhhbmRsZUJlZm9yZVByaW50KTtcbiAgICAgICAgZW1pdHRlci5vbignX2FmdGVycHJpbnQnLCB0aGlzLmhhbmRsZUFmdGVyUHJpbnQpO1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgbGV0IHsgZW1pdHRlciB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgZW1pdHRlci5vZmYoJ19iZWZvcmVwcmludCcsIHRoaXMuaGFuZGxlQmVmb3JlUHJpbnQpO1xuICAgICAgICBlbWl0dGVyLm9mZignX2FmdGVycHJpbnQnLCB0aGlzLmhhbmRsZUFmdGVyUHJpbnQpO1xuICAgIH1cbn1cblxuY2xhc3MgSW50ZXJhY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gc2V0dGluZ3MuY29tcG9uZW50O1xuICAgICAgICB0aGlzLmlzSGl0Q29tYm9BbGxvd2VkID0gc2V0dGluZ3MuaXNIaXRDb21ib0FsbG93ZWQgfHwgbnVsbDtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZUludGVyYWN0aW9uU2V0dGluZ3MoY29tcG9uZW50LCBpbnB1dCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgZWw6IGlucHV0LmVsLFxuICAgICAgICB1c2VFdmVudENlbnRlcjogaW5wdXQudXNlRXZlbnRDZW50ZXIgIT0gbnVsbCA/IGlucHV0LnVzZUV2ZW50Q2VudGVyIDogdHJ1ZSxcbiAgICAgICAgaXNIaXRDb21ib0FsbG93ZWQ6IGlucHV0LmlzSGl0Q29tYm9BbGxvd2VkIHx8IG51bGwsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlKHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgW3NldHRpbmdzLmNvbXBvbmVudC51aWRdOiBzZXR0aW5ncyxcbiAgICB9O1xufVxuLy8gZ2xvYmFsIHN0YXRlXG5jb25zdCBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUgPSB7fTtcblxuY2xhc3MgQ2FsZW5kYXJJbXBsIHtcbiAgICBnZXRDdXJyZW50RGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLmdldEN1cnJlbnREYXRhKCk7XG4gICAgfVxuICAgIGRpc3BhdGNoKGFjdGlvbikge1xuICAgICAgICB0aGlzLmN1cnJlbnREYXRhTWFuYWdlci5kaXNwYXRjaChhY3Rpb24pO1xuICAgIH1cbiAgICBnZXQgdmlldygpIHsgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudERhdGEoKS52aWV3QXBpOyB9XG4gICAgYmF0Y2hSZW5kZXJpbmcoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgdXBkYXRlU2l6ZSgpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdfcmVzaXplJywgdHJ1ZSk7XG4gICAgfVxuICAgIC8vIE9wdGlvbnNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHNldE9wdGlvbihuYW1lLCB2YWwpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnU0VUX09QVElPTicsXG4gICAgICAgICAgICBvcHRpb25OYW1lOiBuYW1lLFxuICAgICAgICAgICAgcmF3T3B0aW9uVmFsdWU6IHZhbCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldE9wdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnREYXRhTWFuYWdlci5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXRbbmFtZV07XG4gICAgfVxuICAgIGdldEF2YWlsYWJsZUxvY2FsZUNvZGVzKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5nZXRDdXJyZW50RGF0YSgpLmF2YWlsYWJsZVJhd0xvY2FsZXMpO1xuICAgIH1cbiAgICAvLyBUcmlnZ2VyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBvbihoYW5kbGVyTmFtZSwgaGFuZGxlcikge1xuICAgICAgICBsZXQgeyBjdXJyZW50RGF0YU1hbmFnZXIgfSA9IHRoaXM7XG4gICAgICAgIGlmIChjdXJyZW50RGF0YU1hbmFnZXIuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZXJzW2hhbmRsZXJOYW1lXSkge1xuICAgICAgICAgICAgY3VycmVudERhdGFNYW5hZ2VyLmVtaXR0ZXIub24oaGFuZGxlck5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbmtub3duIGxpc3RlbmVyIG5hbWUgJyR7aGFuZGxlck5hbWV9J2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9mZihoYW5kbGVyTmFtZSwgaGFuZGxlcikge1xuICAgICAgICB0aGlzLmN1cnJlbnREYXRhTWFuYWdlci5lbWl0dGVyLm9mZihoYW5kbGVyTmFtZSwgaGFuZGxlcik7XG4gICAgfVxuICAgIC8vIG5vdCBtZWFudCBmb3IgcHVibGljIHVzZVxuICAgIHRyaWdnZXIoaGFuZGxlck5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50RGF0YU1hbmFnZXIuZW1pdHRlci50cmlnZ2VyKGhhbmRsZXJOYW1lLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgLy8gVmlld1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgY2hhbmdlVmlldyh2aWV3VHlwZSwgZGF0ZU9yUmFuZ2UpIHtcbiAgICAgICAgdGhpcy5iYXRjaFJlbmRlcmluZygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICBpZiAoZGF0ZU9yUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZU9yUmFuZ2Uuc3RhcnQgJiYgZGF0ZU9yUmFuZ2UuZW5kKSB7IC8vIGEgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX1ZJRVdfVFlQRScsXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1NFVF9PUFRJT04nLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uTmFtZTogJ3Zpc2libGVSYW5nZScsXG4gICAgICAgICAgICAgICAgICAgICAgICByYXdPcHRpb25WYWx1ZTogZGF0ZU9yUmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfVklFV19UWVBFJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZU1hcmtlcjogZGF0ZUVudi5jcmVhdGVNYXJrZXIoZGF0ZU9yUmFuZ2UpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9WSUVXX1RZUEUnLFxuICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEZvcmNlcyBuYXZpZ2F0aW9uIHRvIGEgdmlldyBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gICAgLy8gYHZpZXdUeXBlYCBjYW4gYmUgYSBzcGVjaWZpYyB2aWV3IG5hbWUgb3IgYSBnZW5lcmljIG9uZSBsaWtlIFwid2Vla1wiIG9yIFwiZGF5XCIuXG4gICAgLy8gbmVlZHMgdG8gY2hhbmdlXG4gICAgem9vbVRvKGRhdGVNYXJrZXIsIHZpZXdUeXBlKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgbGV0IHNwZWM7XG4gICAgICAgIHZpZXdUeXBlID0gdmlld1R5cGUgfHwgJ2RheSc7IC8vIGRheSBpcyBkZWZhdWx0IHpvb21cbiAgICAgICAgc3BlYyA9IHN0YXRlLnZpZXdTcGVjc1t2aWV3VHlwZV0gfHwgdGhpcy5nZXRVbml0Vmlld1NwZWModmlld1R5cGUpO1xuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIGlmIChzcGVjKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX1ZJRVdfVFlQRScsXG4gICAgICAgICAgICAgICAgdmlld1R5cGU6IHNwZWMudHlwZSxcbiAgICAgICAgICAgICAgICBkYXRlTWFya2VyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgICAgIGRhdGVNYXJrZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBHaXZlbiBhIGR1cmF0aW9uIHNpbmd1bGFyIHVuaXQsIGxpa2UgXCJ3ZWVrXCIgb3IgXCJkYXlcIiwgZmluZHMgYSBtYXRjaGluZyB2aWV3IHNwZWMuXG4gICAgLy8gUHJlZmVyZW5jZSBpcyBnaXZlbiB0byB2aWV3cyB0aGF0IGhhdmUgY29ycmVzcG9uZGluZyBidXR0b25zLlxuICAgIGdldFVuaXRWaWV3U3BlYyh1bml0KSB7XG4gICAgICAgIGxldCB7IHZpZXdTcGVjcywgdG9vbGJhckNvbmZpZyB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBsZXQgdmlld1R5cGVzID0gW10uY29uY2F0KHRvb2xiYXJDb25maWcuaGVhZGVyID8gdG9vbGJhckNvbmZpZy5oZWFkZXIudmlld3NXaXRoQnV0dG9ucyA6IFtdLCB0b29sYmFyQ29uZmlnLmZvb3RlciA/IHRvb2xiYXJDb25maWcuZm9vdGVyLnZpZXdzV2l0aEJ1dHRvbnMgOiBbXSk7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgc3BlYztcbiAgICAgICAgZm9yIChsZXQgdmlld1R5cGUgaW4gdmlld1NwZWNzKSB7XG4gICAgICAgICAgICB2aWV3VHlwZXMucHVzaCh2aWV3VHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZpZXdUeXBlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgc3BlYyA9IHZpZXdTcGVjc1t2aWV3VHlwZXNbaV1dO1xuICAgICAgICAgICAgaWYgKHNwZWMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BlYy5zaW5nbGVVbml0ID09PSB1bml0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzcGVjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gQ3VycmVudCBEYXRlXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBwcmV2KCkge1xuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnUFJFVicgfSk7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdORVhUJyB9KTtcbiAgICB9XG4gICAgcHJldlllYXIoKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXG4gICAgICAgICAgICBkYXRlTWFya2VyOiBzdGF0ZS5kYXRlRW52LmFkZFllYXJzKHN0YXRlLmN1cnJlbnREYXRlLCAtMSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZXh0WWVhcigpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9EQVRFJyxcbiAgICAgICAgICAgIGRhdGVNYXJrZXI6IHN0YXRlLmRhdGVFbnYuYWRkWWVhcnMoc3RhdGUuY3VycmVudERhdGUsIDEpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdG9kYXkoKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXG4gICAgICAgICAgICBkYXRlTWFya2VyOiBnZXROb3coc3RhdGUuY2FsZW5kYXJPcHRpb25zLm5vdywgc3RhdGUuZGF0ZUVudiksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnb3RvRGF0ZSh6b25lZERhdGVJbnB1dCkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgZGF0ZU1hcmtlcjogc3RhdGUuZGF0ZUVudi5jcmVhdGVNYXJrZXIoem9uZWREYXRlSW5wdXQpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5jcmVtZW50RGF0ZShkZWx0YUlucHV0KSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgbGV0IGRlbHRhID0gY3JlYXRlRHVyYXRpb24oZGVsdGFJbnB1dCk7XG4gICAgICAgIGlmIChkZWx0YSkgeyAvLyBlbHNlLCB3YXJuIGFib3V0IGludmFsaWQgaW5wdXQ/XG4gICAgICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgICAgIGRhdGVNYXJrZXI6IHN0YXRlLmRhdGVFbnYuYWRkKHN0YXRlLmN1cnJlbnREYXRlLCBkZWx0YSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXREYXRlKCkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHJldHVybiBzdGF0ZS5kYXRlRW52LnRvRGF0ZShzdGF0ZS5jdXJyZW50RGF0ZSk7XG4gICAgfVxuICAgIC8vIERhdGUgRm9ybWF0dGluZyBVdGlsc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZm9ybWF0RGF0ZShkLCBmb3JtYXR0ZXIpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXQoZGF0ZUVudi5jcmVhdGVNYXJrZXIoZCksIGNyZWF0ZUZvcm1hdHRlcihmb3JtYXR0ZXIpKTtcbiAgICB9XG4gICAgLy8gYHNldHRpbmdzYCBpcyBmb3IgZm9ybWF0dGVyIEFORCBpc0VuZEV4Y2x1c2l2ZVxuICAgIGZvcm1hdFJhbmdlKGQwLCBkMSwgc2V0dGluZ3MpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShkYXRlRW52LmNyZWF0ZU1hcmtlcihkMCksIGRhdGVFbnYuY3JlYXRlTWFya2VyKGQxKSwgY3JlYXRlRm9ybWF0dGVyKHNldHRpbmdzKSwgc2V0dGluZ3MpO1xuICAgIH1cbiAgICBmb3JtYXRJc28oZCwgb21pdFRpbWUpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRJc28oZGF0ZUVudi5jcmVhdGVNYXJrZXIoZCksIHsgb21pdFRpbWUgfSk7XG4gICAgfVxuICAgIC8vIERhdGUgU2VsZWN0aW9uIC8gRXZlbnQgU2VsZWN0aW9uIC8gRGF5Q2xpY2tcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHNlbGVjdChkYXRlT3JPYmosIGVuZERhdGUpIHtcbiAgICAgICAgbGV0IHNlbGVjdGlvbklucHV0O1xuICAgICAgICBpZiAoZW5kRGF0ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoZGF0ZU9yT2JqLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25JbnB1dCA9IGRhdGVPck9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbklucHV0ID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogZGF0ZU9yT2JqLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbklucHV0ID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBkYXRlT3JPYmosXG4gICAgICAgICAgICAgICAgZW5kOiBlbmREYXRlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSBwYXJzZURhdGVTcGFuKHNlbGVjdGlvbklucHV0LCBzdGF0ZS5kYXRlRW52LCBjcmVhdGVEdXJhdGlvbih7IGRheXM6IDEgfSkpO1xuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7IC8vIHRocm93IHBhcnNlIGVycm9yIG90aGVyd2lzZT9cbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnU0VMRUNUX0RBVEVTJywgc2VsZWN0aW9uIH0pO1xuICAgICAgICAgICAgdHJpZ2dlckRhdGVTZWxlY3Qoc2VsZWN0aW9uLCBudWxsLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5zZWxlY3QocGV2KSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgaWYgKHN0YXRlLmRhdGVTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRUxFQ1RfREFURVMnIH0pO1xuICAgICAgICAgICAgdHJpZ2dlckRhdGVVbnNlbGVjdChwZXYsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBQdWJsaWMgRXZlbnRzIEFQSVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgYWRkRXZlbnQoZXZlbnRJbnB1dCwgc291cmNlSW5wdXQpIHtcbiAgICAgICAgaWYgKGV2ZW50SW5wdXQgaW5zdGFuY2VvZiBFdmVudEltcGwpIHtcbiAgICAgICAgICAgIGxldCBkZWYgPSBldmVudElucHV0Ll9kZWY7XG4gICAgICAgICAgICBsZXQgaW5zdGFuY2UgPSBldmVudElucHV0Ll9pbnN0YW5jZTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50RGF0YSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgICAgIC8vIG5vdCBhbHJlYWR5IHByZXNlbnQ/IGRvbid0IHdhbnQgdG8gYWRkIGFuIG9sZCBzbmFwc2hvdFxuICAgICAgICAgICAgaWYgKCFjdXJyZW50RGF0YS5ldmVudFN0b3JlLmRlZnNbZGVmLmRlZklkXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQUREX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IGV2ZW50VHVwbGVUb1N0b3JlKHsgZGVmLCBpbnN0YW5jZSB9KSwgLy8gVE9ETzogYmV0dGVyIHV0aWwgZm9yIHR3byBhcmdzP1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50QWRkKGV2ZW50SW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50SW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBsZXQgZXZlbnRTb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2VJbnB1dCBpbnN0YW5jZW9mIEV2ZW50U291cmNlSW1wbCkge1xuICAgICAgICAgICAgZXZlbnRTb3VyY2UgPSBzb3VyY2VJbnB1dC5pbnRlcm5hbEV2ZW50U291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzb3VyY2VJbnB1dCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlSW5wdXQpIHsgLy8gdHJ1ZS4gcGFydCBvZiB0aGUgZmlyc3QgZXZlbnQgc291cmNlXG4gICAgICAgICAgICAgICAgW2V2ZW50U291cmNlXSA9IGhhc2hWYWx1ZXNUb0FycmF5KHN0YXRlLmV2ZW50U291cmNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc291cmNlSW5wdXQgIT0gbnVsbCkgeyAvLyBhbiBJRC4gYWNjZXB0cyBhIG51bWJlciB0b29cbiAgICAgICAgICAgIGxldCBzb3VyY2VBcGkgPSB0aGlzLmdldEV2ZW50U291cmNlQnlJZChzb3VyY2VJbnB1dCk7IC8vIFRPRE86IHVzZSBhbiBpbnRlcm5hbCBmdW5jdGlvblxuICAgICAgICAgICAgaWYgKCFzb3VyY2VBcGkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBmaW5kIGFuIGV2ZW50IHNvdXJjZSB3aXRoIElEIFwiJHtzb3VyY2VJbnB1dH1cImApOyAvLyBUT0RPOiB0ZXN0XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudFNvdXJjZSA9IHNvdXJjZUFwaS5pbnRlcm5hbEV2ZW50U291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0dXBsZSA9IHBhcnNlRXZlbnQoZXZlbnRJbnB1dCwgZXZlbnRTb3VyY2UsIHN0YXRlLCBmYWxzZSk7XG4gICAgICAgIGlmICh0dXBsZSkge1xuICAgICAgICAgICAgbGV0IG5ld0V2ZW50QXBpID0gbmV3IEV2ZW50SW1wbChzdGF0ZSwgdHVwbGUuZGVmLCB0dXBsZS5kZWYucmVjdXJyaW5nRGVmID8gbnVsbCA6IHR1cGxlLmluc3RhbmNlKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdBRERfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBldmVudFR1cGxlVG9TdG9yZSh0dXBsZSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50QWRkKG5ld0V2ZW50QXBpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXdFdmVudEFwaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdHJpZ2dlckV2ZW50QWRkKGV2ZW50QXBpKSB7XG4gICAgICAgIGxldCB7IGVtaXR0ZXIgfSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgZW1pdHRlci50cmlnZ2VyKCdldmVudEFkZCcsIHtcbiAgICAgICAgICAgIGV2ZW50OiBldmVudEFwaSxcbiAgICAgICAgICAgIHJlbGF0ZWRFdmVudHM6IFtdLFxuICAgICAgICAgICAgcmV2ZXJ0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogZXZlbnRBcGlUb1N0b3JlKGV2ZW50QXBpKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBUT0RPOiBvcHRpbWl6ZVxuICAgIGdldEV2ZW50QnlJZChpZCkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIGxldCB7IGRlZnMsIGluc3RhbmNlcyB9ID0gc3RhdGUuZXZlbnRTdG9yZTtcbiAgICAgICAgaWQgPSBTdHJpbmcoaWQpO1xuICAgICAgICBmb3IgKGxldCBkZWZJZCBpbiBkZWZzKSB7XG4gICAgICAgICAgICBsZXQgZGVmID0gZGVmc1tkZWZJZF07XG4gICAgICAgICAgICBpZiAoZGVmLnB1YmxpY0lkID09PSBpZCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWYucmVjdXJyaW5nRGVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRJbXBsKHN0YXRlLCBkZWYsIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5kZWZJZCA9PT0gZGVmLmRlZklkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50SW1wbChzdGF0ZSwgZGVmLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldEV2ZW50cygpIHtcbiAgICAgICAgbGV0IGN1cnJlbnREYXRhID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICByZXR1cm4gYnVpbGRFdmVudEFwaXMoY3VycmVudERhdGEuZXZlbnRTdG9yZSwgY3VycmVudERhdGEpO1xuICAgIH1cbiAgICByZW1vdmVBbGxFdmVudHMoKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnUkVNT1ZFX0FMTF9FVkVOVFMnIH0pO1xuICAgIH1cbiAgICAvLyBQdWJsaWMgRXZlbnQgU291cmNlcyBBUElcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGdldEV2ZW50U291cmNlcygpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBsZXQgc291cmNlSGFzaCA9IHN0YXRlLmV2ZW50U291cmNlcztcbiAgICAgICAgbGV0IHNvdXJjZUFwaXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW50ZXJuYWxJZCBpbiBzb3VyY2VIYXNoKSB7XG4gICAgICAgICAgICBzb3VyY2VBcGlzLnB1c2gobmV3IEV2ZW50U291cmNlSW1wbChzdGF0ZSwgc291cmNlSGFzaFtpbnRlcm5hbElkXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3VyY2VBcGlzO1xuICAgIH1cbiAgICBnZXRFdmVudFNvdXJjZUJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBsZXQgc291cmNlSGFzaCA9IHN0YXRlLmV2ZW50U291cmNlcztcbiAgICAgICAgaWQgPSBTdHJpbmcoaWQpO1xuICAgICAgICBmb3IgKGxldCBzb3VyY2VJZCBpbiBzb3VyY2VIYXNoKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlSGFzaFtzb3VyY2VJZF0ucHVibGljSWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudFNvdXJjZUltcGwoc3RhdGUsIHNvdXJjZUhhc2hbc291cmNlSWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYWRkRXZlbnRTb3VyY2Uoc291cmNlSW5wdXQpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBpZiAoc291cmNlSW5wdXQgaW5zdGFuY2VvZiBFdmVudFNvdXJjZUltcGwpIHtcbiAgICAgICAgICAgIC8vIG5vdCBhbHJlYWR5IHByZXNlbnQ/IGRvbid0IHdhbnQgdG8gYWRkIGFuIG9sZCBzbmFwc2hvdFxuICAgICAgICAgICAgaWYgKCFzdGF0ZS5ldmVudFNvdXJjZXNbc291cmNlSW5wdXQuaW50ZXJuYWxFdmVudFNvdXJjZS5zb3VyY2VJZF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0FERF9FVkVOVF9TT1VSQ0VTJyxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlczogW3NvdXJjZUlucHV0LmludGVybmFsRXZlbnRTb3VyY2VdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZUlucHV0O1xuICAgICAgICB9XG4gICAgICAgIGxldCBldmVudFNvdXJjZSA9IHBhcnNlRXZlbnRTb3VyY2Uoc291cmNlSW5wdXQsIHN0YXRlKTtcbiAgICAgICAgaWYgKGV2ZW50U291cmNlKSB7IC8vIFRPRE86IGVycm9yIG90aGVyd2lzZT9cbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnQUREX0VWRU5UX1NPVVJDRVMnLCBzb3VyY2VzOiBbZXZlbnRTb3VyY2VdIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudFNvdXJjZUltcGwoc3RhdGUsIGV2ZW50U291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmVtb3ZlQWxsRXZlbnRTb3VyY2VzKCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ1JFTU9WRV9BTExfRVZFTlRfU09VUkNFUycgfSk7XG4gICAgfVxuICAgIHJlZmV0Y2hFdmVudHMoKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnRkVUQ0hfRVZFTlRfU09VUkNFUycsIGlzUmVmZXRjaDogdHJ1ZSB9KTtcbiAgICB9XG4gICAgLy8gU2Nyb2xsXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBzY3JvbGxUb1RpbWUodGltZUlucHV0KSB7XG4gICAgICAgIGxldCB0aW1lID0gY3JlYXRlRHVyYXRpb24odGltZUlucHV0KTtcbiAgICAgICAgaWYgKHRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignX3Njcm9sbFJlcXVlc3QnLCB7IHRpbWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBvaW50SW5zaWRlUmVjdChwb2ludCwgcmVjdCkge1xuICAgIHJldHVybiBwb2ludC5sZWZ0ID49IHJlY3QubGVmdCAmJlxuICAgICAgICBwb2ludC5sZWZ0IDwgcmVjdC5yaWdodCAmJlxuICAgICAgICBwb2ludC50b3AgPj0gcmVjdC50b3AgJiZcbiAgICAgICAgcG9pbnQudG9wIDwgcmVjdC5ib3R0b207XG59XG4vLyBSZXR1cm5zIGEgbmV3IHJlY3RhbmdsZSB0aGF0IGlzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3byByZWN0YW5nbGVzLiBJZiB0aGV5IGRvbid0IGludGVyc2VjdCwgcmV0dXJucyBmYWxzZVxuZnVuY3Rpb24gaW50ZXJzZWN0UmVjdHMocmVjdDEsIHJlY3QyKSB7XG4gICAgbGV0IHJlcyA9IHtcbiAgICAgICAgbGVmdDogTWF0aC5tYXgocmVjdDEubGVmdCwgcmVjdDIubGVmdCksXG4gICAgICAgIHJpZ2h0OiBNYXRoLm1pbihyZWN0MS5yaWdodCwgcmVjdDIucmlnaHQpLFxuICAgICAgICB0b3A6IE1hdGgubWF4KHJlY3QxLnRvcCwgcmVjdDIudG9wKSxcbiAgICAgICAgYm90dG9tOiBNYXRoLm1pbihyZWN0MS5ib3R0b20sIHJlY3QyLmJvdHRvbSksXG4gICAgfTtcbiAgICBpZiAocmVzLmxlZnQgPCByZXMucmlnaHQgJiYgcmVzLnRvcCA8IHJlcy5ib3R0b20pIHtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gdHJhbnNsYXRlUmVjdChyZWN0LCBkZWx0YVgsIGRlbHRhWSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IHJlY3QubGVmdCArIGRlbHRhWCxcbiAgICAgICAgcmlnaHQ6IHJlY3QucmlnaHQgKyBkZWx0YVgsXG4gICAgICAgIHRvcDogcmVjdC50b3AgKyBkZWx0YVksXG4gICAgICAgIGJvdHRvbTogcmVjdC5ib3R0b20gKyBkZWx0YVksXG4gICAgfTtcbn1cbi8vIFJldHVybnMgYSBuZXcgcG9pbnQgdGhhdCB3aWxsIGhhdmUgYmVlbiBtb3ZlZCB0byByZXNpZGUgd2l0aGluIHRoZSBnaXZlbiByZWN0YW5nbGVcbmZ1bmN0aW9uIGNvbnN0cmFpblBvaW50KHBvaW50LCByZWN0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogTWF0aC5taW4oTWF0aC5tYXgocG9pbnQubGVmdCwgcmVjdC5sZWZ0KSwgcmVjdC5yaWdodCksXG4gICAgICAgIHRvcDogTWF0aC5taW4oTWF0aC5tYXgocG9pbnQudG9wLCByZWN0LnRvcCksIHJlY3QuYm90dG9tKSxcbiAgICB9O1xufVxuLy8gUmV0dXJucyBhIHBvaW50IHRoYXQgaXMgdGhlIGNlbnRlciBvZiB0aGUgZ2l2ZW4gcmVjdGFuZ2xlXG5mdW5jdGlvbiBnZXRSZWN0Q2VudGVyKHJlY3QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyLFxuICAgICAgICB0b3A6IChyZWN0LnRvcCArIHJlY3QuYm90dG9tKSAvIDIsXG4gICAgfTtcbn1cbi8vIFN1YnRyYWN0cyBwb2ludDIncyBjb29yZGluYXRlcyBmcm9tIHBvaW50MSdzIGNvb3JkaW5hdGVzLCByZXR1cm5pbmcgYSBkZWx0YVxuZnVuY3Rpb24gZGlmZlBvaW50cyhwb2ludDEsIHBvaW50Mikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IHBvaW50MS5sZWZ0IC0gcG9pbnQyLmxlZnQsXG4gICAgICAgIHRvcDogcG9pbnQxLnRvcCAtIHBvaW50Mi50b3AsXG4gICAgfTtcbn1cblxuY29uc3QgRU1QVFlfRVZFTlRfU1RPUkUgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTsgLy8gZm9yIHB1cmVjb21wb25lbnRzLiBUT0RPOiBrZWVwIGVsc2V3aGVyZVxuY2xhc3MgU3BsaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmdldEtleXNGb3JFdmVudERlZnMgPSBtZW1vaXplKHRoaXMuX2dldEtleXNGb3JFdmVudERlZnMpO1xuICAgICAgICB0aGlzLnNwbGl0RGF0ZVNlbGVjdGlvbiA9IG1lbW9pemUodGhpcy5fc3BsaXREYXRlU3Bhbik7XG4gICAgICAgIHRoaXMuc3BsaXRFdmVudFN0b3JlID0gbWVtb2l6ZSh0aGlzLl9zcGxpdEV2ZW50U3RvcmUpO1xuICAgICAgICB0aGlzLnNwbGl0SW5kaXZpZHVhbFVpID0gbWVtb2l6ZSh0aGlzLl9zcGxpdEluZGl2aWR1YWxVaSk7XG4gICAgICAgIHRoaXMuc3BsaXRFdmVudERyYWcgPSBtZW1vaXplKHRoaXMuX3NwbGl0SW50ZXJhY3Rpb24pO1xuICAgICAgICB0aGlzLnNwbGl0RXZlbnRSZXNpemUgPSBtZW1vaXplKHRoaXMuX3NwbGl0SW50ZXJhY3Rpb24pO1xuICAgICAgICB0aGlzLmV2ZW50VWlCdWlsZGVycyA9IHt9OyAvLyBUT0RPOiB0eXBlc2NyaXB0IHByb3RlY3Rpb25cbiAgICB9XG4gICAgc3BsaXRQcm9wcyhwcm9wcykge1xuICAgICAgICBsZXQga2V5SW5mb3MgPSB0aGlzLmdldEtleUluZm8ocHJvcHMpO1xuICAgICAgICBsZXQgZGVmS2V5cyA9IHRoaXMuZ2V0S2V5c0ZvckV2ZW50RGVmcyhwcm9wcy5ldmVudFN0b3JlKTtcbiAgICAgICAgbGV0IGRhdGVTZWxlY3Rpb25zID0gdGhpcy5zcGxpdERhdGVTZWxlY3Rpb24ocHJvcHMuZGF0ZVNlbGVjdGlvbik7XG4gICAgICAgIGxldCBpbmRpdmlkdWFsVWkgPSB0aGlzLnNwbGl0SW5kaXZpZHVhbFVpKHByb3BzLmV2ZW50VWlCYXNlcywgZGVmS2V5cyk7IC8vIHRoZSBpbmRpdmlkdWFsICpiYXNlcypcbiAgICAgICAgbGV0IGV2ZW50U3RvcmVzID0gdGhpcy5zcGxpdEV2ZW50U3RvcmUocHJvcHMuZXZlbnRTdG9yZSwgZGVmS2V5cyk7XG4gICAgICAgIGxldCBldmVudERyYWdzID0gdGhpcy5zcGxpdEV2ZW50RHJhZyhwcm9wcy5ldmVudERyYWcpO1xuICAgICAgICBsZXQgZXZlbnRSZXNpemVzID0gdGhpcy5zcGxpdEV2ZW50UmVzaXplKHByb3BzLmV2ZW50UmVzaXplKTtcbiAgICAgICAgbGV0IHNwbGl0UHJvcHMgPSB7fTtcbiAgICAgICAgdGhpcy5ldmVudFVpQnVpbGRlcnMgPSBtYXBIYXNoKGtleUluZm9zLCAoaW5mbywga2V5KSA9PiB0aGlzLmV2ZW50VWlCdWlsZGVyc1trZXldIHx8IG1lbW9pemUoYnVpbGRFdmVudFVpRm9yS2V5KSk7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBrZXlJbmZvcykge1xuICAgICAgICAgICAgbGV0IGtleUluZm8gPSBrZXlJbmZvc1trZXldO1xuICAgICAgICAgICAgbGV0IGV2ZW50U3RvcmUgPSBldmVudFN0b3Jlc1trZXldIHx8IEVNUFRZX0VWRU5UX1NUT1JFO1xuICAgICAgICAgICAgbGV0IGJ1aWxkRXZlbnRVaSA9IHRoaXMuZXZlbnRVaUJ1aWxkZXJzW2tleV07XG4gICAgICAgICAgICBzcGxpdFByb3BzW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgYnVzaW5lc3NIb3Vyczoga2V5SW5mby5idXNpbmVzc0hvdXJzIHx8IHByb3BzLmJ1c2luZXNzSG91cnMsXG4gICAgICAgICAgICAgICAgZGF0ZVNlbGVjdGlvbjogZGF0ZVNlbGVjdGlvbnNba2V5XSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIGV2ZW50U3RvcmUsXG4gICAgICAgICAgICAgICAgZXZlbnRVaUJhc2VzOiBidWlsZEV2ZW50VWkocHJvcHMuZXZlbnRVaUJhc2VzWycnXSwga2V5SW5mby51aSwgaW5kaXZpZHVhbFVpW2tleV0pLFxuICAgICAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uOiBldmVudFN0b3JlLmluc3RhbmNlc1twcm9wcy5ldmVudFNlbGVjdGlvbl0gPyBwcm9wcy5ldmVudFNlbGVjdGlvbiA6ICcnLFxuICAgICAgICAgICAgICAgIGV2ZW50RHJhZzogZXZlbnREcmFnc1trZXldIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgZXZlbnRSZXNpemU6IGV2ZW50UmVzaXplc1trZXldIHx8IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGxpdFByb3BzO1xuICAgIH1cbiAgICBfc3BsaXREYXRlU3BhbihkYXRlU3Bhbikge1xuICAgICAgICBsZXQgZGF0ZVNwYW5zID0ge307XG4gICAgICAgIGlmIChkYXRlU3Bhbikge1xuICAgICAgICAgICAgbGV0IGtleXMgPSB0aGlzLmdldEtleXNGb3JEYXRlU3BhbihkYXRlU3Bhbik7XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgb2Yga2V5cykge1xuICAgICAgICAgICAgICAgIGRhdGVTcGFuc1trZXldID0gZGF0ZVNwYW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGVTcGFucztcbiAgICB9XG4gICAgX2dldEtleXNGb3JFdmVudERlZnMoZXZlbnRTdG9yZSkge1xuICAgICAgICByZXR1cm4gbWFwSGFzaChldmVudFN0b3JlLmRlZnMsIChldmVudERlZikgPT4gdGhpcy5nZXRLZXlzRm9yRXZlbnREZWYoZXZlbnREZWYpKTtcbiAgICB9XG4gICAgX3NwbGl0RXZlbnRTdG9yZShldmVudFN0b3JlLCBkZWZLZXlzKSB7XG4gICAgICAgIGxldCB7IGRlZnMsIGluc3RhbmNlcyB9ID0gZXZlbnRTdG9yZTtcbiAgICAgICAgbGV0IHNwbGl0U3RvcmVzID0ge307XG4gICAgICAgIGZvciAobGV0IGRlZklkIGluIGRlZnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBvZiBkZWZLZXlzW2RlZklkXSkge1xuICAgICAgICAgICAgICAgIGlmICghc3BsaXRTdG9yZXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBzcGxpdFN0b3Jlc1trZXldID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNwbGl0U3RvcmVzW2tleV0uZGVmc1tkZWZJZF0gPSBkZWZzW2RlZklkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgICAgICAgICAgbGV0IGluc3RhbmNlID0gaW5zdGFuY2VzW2luc3RhbmNlSWRdO1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IG9mIGRlZktleXNbaW5zdGFuY2UuZGVmSWRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNwbGl0U3RvcmVzW2tleV0pIHsgLy8gbXVzdCBoYXZlIGFscmVhZHkgYmVlbiBjcmVhdGVkXG4gICAgICAgICAgICAgICAgICAgIHNwbGl0U3RvcmVzW2tleV0uaW5zdGFuY2VzW2luc3RhbmNlSWRdID0gaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGxpdFN0b3JlcztcbiAgICB9XG4gICAgX3NwbGl0SW5kaXZpZHVhbFVpKGV2ZW50VWlCYXNlcywgZGVmS2V5cykge1xuICAgICAgICBsZXQgc3BsaXRIYXNoZXMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgZGVmSWQgaW4gZXZlbnRVaUJhc2VzKSB7XG4gICAgICAgICAgICBpZiAoZGVmSWQpIHsgLy8gbm90IHRoZSAnJyBrZXlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrZXkgb2YgZGVmS2V5c1tkZWZJZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzcGxpdEhhc2hlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGxpdEhhc2hlc1trZXldID0ge307XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3BsaXRIYXNoZXNba2V5XVtkZWZJZF0gPSBldmVudFVpQmFzZXNbZGVmSWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BsaXRIYXNoZXM7XG4gICAgfVxuICAgIF9zcGxpdEludGVyYWN0aW9uKGludGVyYWN0aW9uKSB7XG4gICAgICAgIGxldCBzcGxpdFN0YXRlcyA9IHt9O1xuICAgICAgICBpZiAoaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgICAgIGxldCBhZmZlY3RlZFN0b3JlcyA9IHRoaXMuX3NwbGl0RXZlbnRTdG9yZShpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cywgdGhpcy5fZ2V0S2V5c0ZvckV2ZW50RGVmcyhpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cykpO1xuICAgICAgICAgICAgLy8gY2FuJ3QgcmVseSBvbiBkZWZLZXlzIGJlY2F1c2UgZXZlbnQgZGF0YSBpcyBtdXRhdGVkXG4gICAgICAgICAgICBsZXQgbXV0YXRlZEtleXNCeURlZklkID0gdGhpcy5fZ2V0S2V5c0ZvckV2ZW50RGVmcyhpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzKTtcbiAgICAgICAgICAgIGxldCBtdXRhdGVkU3RvcmVzID0gdGhpcy5fc3BsaXRFdmVudFN0b3JlKGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMsIG11dGF0ZWRLZXlzQnlEZWZJZCk7XG4gICAgICAgICAgICBsZXQgcG9wdWxhdGUgPSAoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzcGxpdFN0YXRlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0U3RhdGVzW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogYWZmZWN0ZWRTdG9yZXNba2V5XSB8fCBFTVBUWV9FVkVOVF9TVE9SRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudHM6IG11dGF0ZWRTdG9yZXNba2V5XSB8fCBFTVBUWV9FVkVOVF9TVE9SRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRXZlbnQ6IGludGVyYWN0aW9uLmlzRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBhZmZlY3RlZFN0b3Jlcykge1xuICAgICAgICAgICAgICAgIHBvcHVsYXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gbXV0YXRlZFN0b3Jlcykge1xuICAgICAgICAgICAgICAgIHBvcHVsYXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwbGl0U3RhdGVzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRVaUZvcktleShhbGxVaSwgZXZlbnRVaUZvcktleSwgaW5kaXZpZHVhbFVpKSB7XG4gICAgbGV0IGJhc2VQYXJ0cyA9IFtdO1xuICAgIGlmIChhbGxVaSkge1xuICAgICAgICBiYXNlUGFydHMucHVzaChhbGxVaSk7XG4gICAgfVxuICAgIGlmIChldmVudFVpRm9yS2V5KSB7XG4gICAgICAgIGJhc2VQYXJ0cy5wdXNoKGV2ZW50VWlGb3JLZXkpO1xuICAgIH1cbiAgICBsZXQgc3R1ZmYgPSB7XG4gICAgICAgICcnOiBjb21iaW5lRXZlbnRVaXMoYmFzZVBhcnRzKSxcbiAgICB9O1xuICAgIGlmIChpbmRpdmlkdWFsVWkpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzdHVmZiwgaW5kaXZpZHVhbFVpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0dWZmO1xufVxuXG5mdW5jdGlvbiBnZXREYXRlTWV0YShkYXRlLCB0b2RheVJhbmdlLCBub3dEYXRlLCBkYXRlUHJvZmlsZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRvdzogZGF0ZS5nZXRVVENEYXkoKSxcbiAgICAgICAgaXNEaXNhYmxlZDogQm9vbGVhbihkYXRlUHJvZmlsZSAmJiAhcmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgZGF0ZSkpLFxuICAgICAgICBpc090aGVyOiBCb29sZWFuKGRhdGVQcm9maWxlICYmICFyYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZSwgZGF0ZSkpLFxuICAgICAgICBpc1RvZGF5OiBCb29sZWFuKHRvZGF5UmFuZ2UgJiYgcmFuZ2VDb250YWluc01hcmtlcih0b2RheVJhbmdlLCBkYXRlKSksXG4gICAgICAgIGlzUGFzdDogQm9vbGVhbihub3dEYXRlID8gKGRhdGUgPCBub3dEYXRlKSA6IHRvZGF5UmFuZ2UgPyAoZGF0ZSA8IHRvZGF5UmFuZ2Uuc3RhcnQpIDogZmFsc2UpLFxuICAgICAgICBpc0Z1dHVyZTogQm9vbGVhbihub3dEYXRlID8gKGRhdGUgPiBub3dEYXRlKSA6IHRvZGF5UmFuZ2UgPyAoZGF0ZSA+PSB0b2RheVJhbmdlLmVuZCkgOiBmYWxzZSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldERheUNsYXNzTmFtZXMobWV0YSwgdGhlbWUpIHtcbiAgICBsZXQgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgJ2ZjLWRheScsXG4gICAgICAgIGBmYy1kYXktJHtEQVlfSURTW21ldGEuZG93XX1gLFxuICAgIF07XG4gICAgaWYgKG1ldGEuaXNEaXNhYmxlZCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS1kaXNhYmxlZCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKG1ldGEuaXNUb2RheSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1kYXktdG9kYXknKTtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCh0aGVtZS5nZXRDbGFzcygndG9kYXknKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuaXNQYXN0KSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS1wYXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuaXNGdXR1cmUpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZGF5LWZ1dHVyZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLmlzT3RoZXIpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZGF5LW90aGVyJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZXM7XG59XG5mdW5jdGlvbiBnZXRTbG90Q2xhc3NOYW1lcyhtZXRhLCB0aGVtZSkge1xuICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgICAnZmMtc2xvdCcsXG4gICAgICAgIGBmYy1zbG90LSR7REFZX0lEU1ttZXRhLmRvd119YCxcbiAgICBdO1xuICAgIGlmIChtZXRhLmlzRGlzYWJsZWQpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zbG90LWRpc2FibGVkJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAobWV0YS5pc1RvZGF5KSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNsb3QtdG9kYXknKTtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCh0aGVtZS5nZXRDbGFzcygndG9kYXknKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuaXNQYXN0KSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNsb3QtcGFzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLmlzRnV0dXJlKSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNsb3QtZnV0dXJlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZXM7XG59XG5cbmNvbnN0IERBWV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbG9uZycsIGRheTogJ251bWVyaWMnIH0pO1xuY29uc3QgV0VFS19GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrOiAnbG9uZycgfSk7XG5mdW5jdGlvbiBidWlsZE5hdkxpbmtBdHRycyhjb250ZXh0LCBkYXRlTWFya2VyLCB2aWV3VHlwZSA9ICdkYXknLCBpc1RhYmJhYmxlID0gdHJ1ZSkge1xuICAgIGNvbnN0IHsgZGF0ZUVudiwgb3B0aW9ucywgY2FsZW5kYXJBcGkgfSA9IGNvbnRleHQ7XG4gICAgbGV0IGRhdGVTdHIgPSBkYXRlRW52LmZvcm1hdChkYXRlTWFya2VyLCB2aWV3VHlwZSA9PT0gJ3dlZWsnID8gV0VFS19GT1JNQVQgOiBEQVlfRk9STUFUKTtcbiAgICBpZiAob3B0aW9ucy5uYXZMaW5rcykge1xuICAgICAgICBsZXQgem9uZWREYXRlID0gZGF0ZUVudi50b0RhdGUoZGF0ZU1hcmtlcik7XG4gICAgICAgIGNvbnN0IGhhbmRsZUludGVyYWN0aW9uID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBsZXQgY3VzdG9tQWN0aW9uID0gdmlld1R5cGUgPT09ICdkYXknID8gb3B0aW9ucy5uYXZMaW5rRGF5Q2xpY2sgOlxuICAgICAgICAgICAgICAgIHZpZXdUeXBlID09PSAnd2VlaycgPyBvcHRpb25zLm5hdkxpbmtXZWVrQ2xpY2sgOiBudWxsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXN0b21BY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjdXN0b21BY3Rpb24uY2FsbChjYWxlbmRhckFwaSwgZGF0ZUVudi50b0RhdGUoZGF0ZU1hcmtlciksIGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3VzdG9tQWN0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZSA9IGN1c3RvbUFjdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsZW5kYXJBcGkuem9vbVRvKGRhdGVNYXJrZXIsIHZpZXdUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyB0aXRsZTogZm9ybWF0V2l0aE9yZGluYWxzKG9wdGlvbnMubmF2TGlua0hpbnQsIFtkYXRlU3RyLCB6b25lZERhdGVdLCBkYXRlU3RyKSwgJ2RhdGEtbmF2bGluayc6ICcnIH0sIChpc1RhYmJhYmxlXG4gICAgICAgICAgICA/IGNyZWF0ZUFyaWFDbGlja0F0dHJzKGhhbmRsZUludGVyYWN0aW9uKVxuICAgICAgICAgICAgOiB7IG9uQ2xpY2s6IGhhbmRsZUludGVyYWN0aW9uIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgJ2FyaWEtbGFiZWwnOiBkYXRlU3RyIH07XG59XG5cbmxldCBfaXNSdGxTY3JvbGxiYXJPbkxlZnQgPSBudWxsO1xuZnVuY3Rpb24gZ2V0SXNSdGxTY3JvbGxiYXJPbkxlZnQoKSB7XG4gICAgaWYgKF9pc1J0bFNjcm9sbGJhck9uTGVmdCA9PT0gbnVsbCkge1xuICAgICAgICBfaXNSdGxTY3JvbGxiYXJPbkxlZnQgPSBjb21wdXRlSXNSdGxTY3JvbGxiYXJPbkxlZnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9pc1J0bFNjcm9sbGJhck9uTGVmdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVJc1J0bFNjcm9sbGJhck9uTGVmdCgpIHtcbiAgICBsZXQgb3V0ZXJFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGFwcGx5U3R5bGUob3V0ZXJFbCwge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgdG9wOiAtMTAwMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICBvdmVyZmxvdzogJ3Njcm9sbCcsXG4gICAgICAgIGRpcmVjdGlvbjogJ3J0bCcsXG4gICAgfSk7XG4gICAgb3V0ZXJFbC5pbm5lckhUTUwgPSAnPGRpdj48L2Rpdj4nO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob3V0ZXJFbCk7XG4gICAgbGV0IGlubmVyRWwgPSBvdXRlckVsLmZpcnN0Q2hpbGQ7XG4gICAgbGV0IHJlcyA9IGlubmVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCA+IG91dGVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbiAgICByZW1vdmVFbGVtZW50KG91dGVyRWwpO1xuICAgIHJldHVybiByZXM7XG59XG5cbmxldCBfc2Nyb2xsYmFyV2lkdGhzO1xuZnVuY3Rpb24gZ2V0U2Nyb2xsYmFyV2lkdGhzKCkge1xuICAgIGlmICghX3Njcm9sbGJhcldpZHRocykge1xuICAgICAgICBfc2Nyb2xsYmFyV2lkdGhzID0gY29tcHV0ZVNjcm9sbGJhcldpZHRocygpO1xuICAgIH1cbiAgICByZXR1cm4gX3Njcm9sbGJhcldpZHRocztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVTY3JvbGxiYXJXaWR0aHMoKSB7XG4gICAgbGV0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWwuc3R5bGUub3ZlcmZsb3cgPSAnc2Nyb2xsJztcbiAgICBlbC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZWwuc3R5bGUudG9wID0gJy05OTk5cHgnO1xuICAgIGVsLnN0eWxlLmxlZnQgPSAnLTk5OTlweCc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbCk7XG4gICAgbGV0IHJlcyA9IGNvbXB1dGVTY3JvbGxiYXJXaWR0aHNGb3JFbChlbCk7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIFdBUk5JTkc6IHdpbGwgaW5jbHVkZSBib3JkZXJcbmZ1bmN0aW9uIGNvbXB1dGVTY3JvbGxiYXJXaWR0aHNGb3JFbChlbCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGVsLm9mZnNldEhlaWdodCAtIGVsLmNsaWVudEhlaWdodCxcbiAgICAgICAgeTogZWwub2Zmc2V0V2lkdGggLSBlbC5jbGllbnRXaWR0aCxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjb21wdXRlRWRnZXMoZWwsIGdldFBhZGRpbmcgPSBmYWxzZSkge1xuICAgIGxldCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgIGxldCBib3JkZXJMZWZ0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJMZWZ0V2lkdGgsIDEwKSB8fCAwO1xuICAgIGxldCBib3JkZXJSaWdodCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyUmlnaHRXaWR0aCwgMTApIHx8IDA7XG4gICAgbGV0IGJvcmRlclRvcCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyVG9wV2lkdGgsIDEwKSB8fCAwO1xuICAgIGxldCBib3JkZXJCb3R0b20gPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmJvcmRlckJvdHRvbVdpZHRoLCAxMCkgfHwgMDtcbiAgICBsZXQgYmFkU2Nyb2xsYmFyV2lkdGhzID0gY29tcHV0ZVNjcm9sbGJhcldpZHRoc0ZvckVsKGVsKTsgLy8gaW5jbHVkZXMgYm9yZGVyIVxuICAgIGxldCBzY3JvbGxiYXJMZWZ0UmlnaHQgPSBiYWRTY3JvbGxiYXJXaWR0aHMueSAtIGJvcmRlckxlZnQgLSBib3JkZXJSaWdodDtcbiAgICBsZXQgc2Nyb2xsYmFyQm90dG9tID0gYmFkU2Nyb2xsYmFyV2lkdGhzLnggLSBib3JkZXJUb3AgLSBib3JkZXJCb3R0b207XG4gICAgbGV0IHJlcyA9IHtcbiAgICAgICAgYm9yZGVyTGVmdCxcbiAgICAgICAgYm9yZGVyUmlnaHQsXG4gICAgICAgIGJvcmRlclRvcCxcbiAgICAgICAgYm9yZGVyQm90dG9tLFxuICAgICAgICBzY3JvbGxiYXJCb3R0b20sXG4gICAgICAgIHNjcm9sbGJhckxlZnQ6IDAsXG4gICAgICAgIHNjcm9sbGJhclJpZ2h0OiAwLFxuICAgIH07XG4gICAgaWYgKGdldElzUnRsU2Nyb2xsYmFyT25MZWZ0KCkgJiYgY29tcHV0ZWRTdHlsZS5kaXJlY3Rpb24gPT09ICdydGwnKSB7IC8vIGlzIHRoZSBzY3JvbGxiYXIgb24gdGhlIGxlZnQgc2lkZT9cbiAgICAgICAgcmVzLnNjcm9sbGJhckxlZnQgPSBzY3JvbGxiYXJMZWZ0UmlnaHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXMuc2Nyb2xsYmFyUmlnaHQgPSBzY3JvbGxiYXJMZWZ0UmlnaHQ7XG4gICAgfVxuICAgIGlmIChnZXRQYWRkaW5nKSB7XG4gICAgICAgIHJlcy5wYWRkaW5nTGVmdCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ0xlZnQsIDEwKSB8fCAwO1xuICAgICAgICByZXMucGFkZGluZ1JpZ2h0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nUmlnaHQsIDEwKSB8fCAwO1xuICAgICAgICByZXMucGFkZGluZ1RvcCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ1RvcCwgMTApIHx8IDA7XG4gICAgICAgIHJlcy5wYWRkaW5nQm90dG9tID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nQm90dG9tLCAxMCkgfHwgMDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVJbm5lclJlY3QoZWwsIGdvV2l0aGluUGFkZGluZyA9IGZhbHNlLCBkb0Zyb21XaW5kb3dWaWV3cG9ydCkge1xuICAgIGxldCBvdXRlclJlY3QgPSBkb0Zyb21XaW5kb3dWaWV3cG9ydCA/IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogY29tcHV0ZVJlY3QoZWwpO1xuICAgIGxldCBlZGdlcyA9IGNvbXB1dGVFZGdlcyhlbCwgZ29XaXRoaW5QYWRkaW5nKTtcbiAgICBsZXQgcmVzID0ge1xuICAgICAgICBsZWZ0OiBvdXRlclJlY3QubGVmdCArIGVkZ2VzLmJvcmRlckxlZnQgKyBlZGdlcy5zY3JvbGxiYXJMZWZ0LFxuICAgICAgICByaWdodDogb3V0ZXJSZWN0LnJpZ2h0IC0gZWRnZXMuYm9yZGVyUmlnaHQgLSBlZGdlcy5zY3JvbGxiYXJSaWdodCxcbiAgICAgICAgdG9wOiBvdXRlclJlY3QudG9wICsgZWRnZXMuYm9yZGVyVG9wLFxuICAgICAgICBib3R0b206IG91dGVyUmVjdC5ib3R0b20gLSBlZGdlcy5ib3JkZXJCb3R0b20gLSBlZGdlcy5zY3JvbGxiYXJCb3R0b20sXG4gICAgfTtcbiAgICBpZiAoZ29XaXRoaW5QYWRkaW5nKSB7XG4gICAgICAgIHJlcy5sZWZ0ICs9IGVkZ2VzLnBhZGRpbmdMZWZ0O1xuICAgICAgICByZXMucmlnaHQgLT0gZWRnZXMucGFkZGluZ1JpZ2h0O1xuICAgICAgICByZXMudG9wICs9IGVkZ2VzLnBhZGRpbmdUb3A7XG4gICAgICAgIHJlcy5ib3R0b20gLT0gZWRnZXMucGFkZGluZ0JvdHRvbTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVSZWN0KGVsKSB7XG4gICAgbGV0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiByZWN0LmxlZnQgKyB3aW5kb3cuc2Nyb2xsWCxcbiAgICAgICAgdG9wOiByZWN0LnRvcCArIHdpbmRvdy5zY3JvbGxZLFxuICAgICAgICByaWdodDogcmVjdC5yaWdodCArIHdpbmRvdy5zY3JvbGxYLFxuICAgICAgICBib3R0b206IHJlY3QuYm90dG9tICsgd2luZG93LnNjcm9sbFksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVDbGlwcGVkQ2xpZW50UmVjdChlbCkge1xuICAgIGxldCBjbGlwcGluZ1BhcmVudHMgPSBnZXRDbGlwcGluZ1BhcmVudHMoZWwpO1xuICAgIGxldCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgZm9yIChsZXQgY2xpcHBpbmdQYXJlbnQgb2YgY2xpcHBpbmdQYXJlbnRzKSB7XG4gICAgICAgIGxldCBpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3RSZWN0cyhyZWN0LCBjbGlwcGluZ1BhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgICAgIGlmIChpbnRlcnNlY3Rpb24pIHtcbiAgICAgICAgICAgIHJlY3QgPSBpbnRlcnNlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVjdDtcbn1cbi8vIGRvZXMgbm90IHJldHVybiB3aW5kb3dcbmZ1bmN0aW9uIGdldENsaXBwaW5nUGFyZW50cyhlbCkge1xuICAgIGxldCBwYXJlbnRzID0gW107XG4gICAgd2hpbGUgKGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHsgLy8gd2lsbCBzdG9wIHdoZW4gZ2V0cyB0byBkb2N1bWVudCBvciBudWxsXG4gICAgICAgIGxldCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgICAgICBpZiAoY29tcHV0ZWRTdHlsZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgvKGF1dG98c2Nyb2xsKS8pLnRlc3QoY29tcHV0ZWRTdHlsZS5vdmVyZmxvdyArIGNvbXB1dGVkU3R5bGUub3ZlcmZsb3dZICsgY29tcHV0ZWRTdHlsZS5vdmVyZmxvd1gpKSB7XG4gICAgICAgICAgICBwYXJlbnRzLnB1c2goZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsID0gZWwucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudHM7XG59XG5cbi8qXG5SZWNvcmRzIG9mZnNldCBpbmZvcm1hdGlvbiBmb3IgYSBzZXQgb2YgZWxlbWVudHMsIHJlbGF0aXZlIHRvIGFuIG9yaWdpbiBlbGVtZW50LlxuQ2FuIHJlY29yZCB0aGUgbGVmdC9yaWdodCBPUiB0aGUgdG9wL2JvdHRvbSBPUiBib3RoLlxuUHJvdmlkZXMgbWV0aG9kcyBmb3IgcXVlcnlpbmcgdGhlIGNhY2hlIGJ5IHBvc2l0aW9uLlxuKi9cbmNsYXNzIFBvc2l0aW9uQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKG9yaWdpbkVsLCBlbHMsIGlzSG9yaXpvbnRhbCwgaXNWZXJ0aWNhbCkge1xuICAgICAgICB0aGlzLmVscyA9IGVscztcbiAgICAgICAgbGV0IG9yaWdpbkNsaWVudFJlY3QgPSB0aGlzLm9yaWdpbkNsaWVudFJlY3QgPSBvcmlnaW5FbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8gcmVsYXRpdmUgdG8gdmlld3BvcnQgdG9wLWxlZnRcbiAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgdGhpcy5idWlsZEVsSG9yaXpvbnRhbHMob3JpZ2luQ2xpZW50UmVjdC5sZWZ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNWZXJ0aWNhbCkge1xuICAgICAgICAgICAgdGhpcy5idWlsZEVsVmVydGljYWxzKG9yaWdpbkNsaWVudFJlY3QudG9wKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBQb3B1bGF0ZXMgdGhlIGxlZnQvcmlnaHQgaW50ZXJuYWwgY29vcmRpbmF0ZSBhcnJheXNcbiAgICBidWlsZEVsSG9yaXpvbnRhbHMob3JpZ2luQ2xpZW50TGVmdCkge1xuICAgICAgICBsZXQgbGVmdHMgPSBbXTtcbiAgICAgICAgbGV0IHJpZ2h0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBlbCBvZiB0aGlzLmVscykge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGxlZnRzLnB1c2gocmVjdC5sZWZ0IC0gb3JpZ2luQ2xpZW50TGVmdCk7XG4gICAgICAgICAgICByaWdodHMucHVzaChyZWN0LnJpZ2h0IC0gb3JpZ2luQ2xpZW50TGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZWZ0cyA9IGxlZnRzO1xuICAgICAgICB0aGlzLnJpZ2h0cyA9IHJpZ2h0cztcbiAgICB9XG4gICAgLy8gUG9wdWxhdGVzIHRoZSB0b3AvYm90dG9tIGludGVybmFsIGNvb3JkaW5hdGUgYXJyYXlzXG4gICAgYnVpbGRFbFZlcnRpY2FscyhvcmlnaW5DbGllbnRUb3ApIHtcbiAgICAgICAgbGV0IHRvcHMgPSBbXTtcbiAgICAgICAgbGV0IGJvdHRvbXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZWwgb2YgdGhpcy5lbHMpIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB0b3BzLnB1c2gocmVjdC50b3AgLSBvcmlnaW5DbGllbnRUb3ApO1xuICAgICAgICAgICAgYm90dG9tcy5wdXNoKHJlY3QuYm90dG9tIC0gb3JpZ2luQ2xpZW50VG9wKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvcHMgPSB0b3BzO1xuICAgICAgICB0aGlzLmJvdHRvbXMgPSBib3R0b21zO1xuICAgIH1cbiAgICAvLyBHaXZlbiBhIGxlZnQgb2Zmc2V0IChmcm9tIGRvY3VtZW50IGxlZnQpLCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZWwgdGhhdCBpdCBob3Jpem9udGFsbHkgaW50ZXJzZWN0cy5cbiAgICAvLyBJZiBubyBpbnRlcnNlY3Rpb24gaXMgbWFkZSwgcmV0dXJucyB1bmRlZmluZWQuXG4gICAgbGVmdFRvSW5kZXgobGVmdFBvc2l0aW9uKSB7XG4gICAgICAgIGxldCB7IGxlZnRzLCByaWdodHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBsZW4gPSBsZWZ0cy5sZW5ndGg7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChsZWZ0UG9zaXRpb24gPj0gbGVmdHNbaV0gJiYgbGVmdFBvc2l0aW9uIDwgcmlnaHRzW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gVE9ETzogYmV0dGVyXG4gICAgfVxuICAgIC8vIEdpdmVuIGEgdG9wIG9mZnNldCAoZnJvbSBkb2N1bWVudCB0b3ApLCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZWwgdGhhdCBpdCB2ZXJ0aWNhbGx5IGludGVyc2VjdHMuXG4gICAgLy8gSWYgbm8gaW50ZXJzZWN0aW9uIGlzIG1hZGUsIHJldHVybnMgdW5kZWZpbmVkLlxuICAgIHRvcFRvSW5kZXgodG9wUG9zaXRpb24pIHtcbiAgICAgICAgbGV0IHsgdG9wcywgYm90dG9tcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGxlbiA9IHRvcHMubGVuZ3RoO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAodG9wUG9zaXRpb24gPj0gdG9wc1tpXSAmJiB0b3BQb3NpdGlvbiA8IGJvdHRvbXNbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBUT0RPOiBiZXR0ZXJcbiAgICB9XG4gICAgLy8gR2V0cyB0aGUgd2lkdGggb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XG4gICAgZ2V0V2lkdGgobGVmdEluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJpZ2h0c1tsZWZ0SW5kZXhdIC0gdGhpcy5sZWZ0c1tsZWZ0SW5kZXhdO1xuICAgIH1cbiAgICAvLyBHZXRzIHRoZSBoZWlnaHQgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XG4gICAgZ2V0SGVpZ2h0KHRvcEluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdHRvbXNbdG9wSW5kZXhdIC0gdGhpcy50b3BzW3RvcEluZGV4XTtcbiAgICB9XG4gICAgc2ltaWxhclRvKG90aGVyQ2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIHNpbWlsYXJOdW1BcnJheXModGhpcy50b3BzIHx8IFtdLCBvdGhlckNhY2hlLnRvcHMgfHwgW10pICYmXG4gICAgICAgICAgICBzaW1pbGFyTnVtQXJyYXlzKHRoaXMuYm90dG9tcyB8fCBbXSwgb3RoZXJDYWNoZS5ib3R0b21zIHx8IFtdKSAmJlxuICAgICAgICAgICAgc2ltaWxhck51bUFycmF5cyh0aGlzLmxlZnRzIHx8IFtdLCBvdGhlckNhY2hlLmxlZnRzIHx8IFtdKSAmJlxuICAgICAgICAgICAgc2ltaWxhck51bUFycmF5cyh0aGlzLnJpZ2h0cyB8fCBbXSwgb3RoZXJDYWNoZS5yaWdodHMgfHwgW10pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNpbWlsYXJOdW1BcnJheXMoYSwgYikge1xuICAgIGNvbnN0IGxlbiA9IGEubGVuZ3RoO1xuICAgIGlmIChsZW4gIT09IGIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoTWF0aC5yb3VuZChhW2ldKSAhPT0gTWF0aC5yb3VuZChiW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKiBlc2xpbnQgbWF4LWNsYXNzZXMtcGVyLWZpbGU6IFwib2ZmXCIgKi9cbi8qXG5BbiBvYmplY3QgZm9yIGdldHRpbmcvc2V0dGluZyBzY3JvbGwtcmVsYXRlZCBpbmZvcm1hdGlvbiBmb3IgYW4gZWxlbWVudC5cbkludGVybmFsbHksIHRoaXMgaXMgZG9uZSB2ZXJ5IGRpZmZlcmVudGx5IGZvciB3aW5kb3cgdmVyc3VzIERPTSBlbGVtZW50LFxuc28gdGhpcyBvYmplY3Qgc2VydmVzIGFzIGEgY29tbW9uIGludGVyZmFjZS5cbiovXG5jbGFzcyBTY3JvbGxDb250cm9sbGVyIHtcbiAgICBnZXRNYXhTY3JvbGxUb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbEhlaWdodCgpIC0gdGhpcy5nZXRDbGllbnRIZWlnaHQoKTtcbiAgICB9XG4gICAgZ2V0TWF4U2Nyb2xsTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsV2lkdGgoKSAtIHRoaXMuZ2V0Q2xpZW50V2lkdGgoKTtcbiAgICB9XG4gICAgY2FuU2Nyb2xsVmVydGljYWxseSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWF4U2Nyb2xsVG9wKCkgPiAwO1xuICAgIH1cbiAgICBjYW5TY3JvbGxIb3Jpem9udGFsbHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1heFNjcm9sbExlZnQoKSA+IDA7XG4gICAgfVxuICAgIGNhblNjcm9sbFVwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxUb3AoKSA+IDA7XG4gICAgfVxuICAgIGNhblNjcm9sbERvd24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbFRvcCgpIDwgdGhpcy5nZXRNYXhTY3JvbGxUb3AoKTtcbiAgICB9XG4gICAgY2FuU2Nyb2xsTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsTGVmdCgpID4gMDtcbiAgICB9XG4gICAgY2FuU2Nyb2xsUmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbExlZnQoKSA8IHRoaXMuZ2V0TWF4U2Nyb2xsTGVmdCgpO1xuICAgIH1cbn1cbmNsYXNzIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyIGV4dGVuZHMgU2Nyb2xsQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3IoZWwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgIH1cbiAgICBnZXRTY3JvbGxUb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnNjcm9sbFRvcDtcbiAgICB9XG4gICAgZ2V0U2Nyb2xsTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc2Nyb2xsTGVmdDtcbiAgICB9XG4gICAgc2V0U2Nyb2xsVG9wKHRvcCkge1xuICAgICAgICB0aGlzLmVsLnNjcm9sbFRvcCA9IHRvcDtcbiAgICB9XG4gICAgc2V0U2Nyb2xsTGVmdChsZWZ0KSB7XG4gICAgICAgIHRoaXMuZWwuc2Nyb2xsTGVmdCA9IGxlZnQ7XG4gICAgfVxuICAgIGdldFNjcm9sbFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zY3JvbGxXaWR0aDtcbiAgICB9XG4gICAgZ2V0U2Nyb2xsSGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zY3JvbGxIZWlnaHQ7XG4gICAgfVxuICAgIGdldENsaWVudEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuY2xpZW50SGVpZ2h0O1xuICAgIH1cbiAgICBnZXRDbGllbnRXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuY2xpZW50V2lkdGg7XG4gICAgfVxufVxuY2xhc3MgV2luZG93U2Nyb2xsQ29udHJvbGxlciBleHRlbmRzIFNjcm9sbENvbnRyb2xsZXIge1xuICAgIGdldFNjcm9sbFRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5zY3JvbGxZO1xuICAgIH1cbiAgICBnZXRTY3JvbGxMZWZ0KCkge1xuICAgICAgICByZXR1cm4gd2luZG93LnNjcm9sbFg7XG4gICAgfVxuICAgIHNldFNjcm9sbFRvcChuKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGwod2luZG93LnNjcm9sbFgsIG4pO1xuICAgIH1cbiAgICBzZXRTY3JvbGxMZWZ0KG4pIHtcbiAgICAgICAgd2luZG93LnNjcm9sbChuLCB3aW5kb3cuc2Nyb2xsWSk7XG4gICAgfVxuICAgIGdldFNjcm9sbFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoO1xuICAgIH1cbiAgICBnZXRTY3JvbGxIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xuICAgIH1cbiAgICBnZXRDbGllbnRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgIH1cbiAgICBnZXRDbGllbnRXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICB9XG59XG5cbi8qXG5hbiBJTlRFUkFDVEFCTEUgZGF0ZSBjb21wb25lbnRcblxuUFVSUE9TRVM6XG4tIGhvb2sgdXAgdG8gZmcsIGZpbGwsIGFuZCBtaXJyb3IgcmVuZGVyZXJzXG4tIGludGVyZmFjZSBmb3IgZHJhZ2dpbmcgYW5kIGhpdHNcbiovXG5jbGFzcyBEYXRlQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudWlkID0gZ3VpZCgpO1xuICAgIH1cbiAgICAvLyBIaXQgU3lzdGVtXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBwcmVwYXJlSGl0cygpIHtcbiAgICB9XG4gICAgcXVlcnlIaXQocG9zaXRpb25MZWZ0LCBwb3NpdGlvblRvcCwgZWxXaWR0aCwgZWxIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7IC8vIHRoaXMgc2hvdWxkIGJlIGFic3RyYWN0XG4gICAgfVxuICAgIC8vIFBvaW50ZXIgSW50ZXJhY3Rpb24gVXRpbHNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGlzVmFsaWRTZWdEb3duRWwoZWwpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnByb3BzLmV2ZW50RHJhZyAmJiAvLyBIQUNLXG4gICAgICAgICAgICAhdGhpcy5wcm9wcy5ldmVudFJlc2l6ZSAmJiAvLyBIQUNLXG4gICAgICAgICAgICAhZWxlbWVudENsb3Nlc3QoZWwsICcuZmMtZXZlbnQtbWlycm9yJyk7XG4gICAgfVxuICAgIGlzVmFsaWREYXRlRG93bkVsKGVsKSB7XG4gICAgICAgIHJldHVybiAhZWxlbWVudENsb3Nlc3QoZWwsICcuZmMtZXZlbnQ6bm90KC5mYy1iZy1ldmVudCknKSAmJlxuICAgICAgICAgICAgIWVsZW1lbnRDbG9zZXN0KGVsLCAnLmZjLW1vcmUtbGluaycpICYmIC8vIGEgXCJtb3JlLi5cIiBsaW5rXG4gICAgICAgICAgICAhZWxlbWVudENsb3Nlc3QoZWwsICdhW2RhdGEtbmF2bGlua10nKSAmJiAvLyBhIGNsaWNrYWJsZSBuYXYgbGlua1xuICAgICAgICAgICAgIWVsZW1lbnRDbG9zZXN0KGVsLCAnLmZjLXBvcG92ZXInKTsgLy8gaGFja1xuICAgIH1cbn1cblxuY2xhc3MgTmFtZWRUaW1lWm9uZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKHRpbWVab25lTmFtZSkge1xuICAgICAgICB0aGlzLnRpbWVab25lTmFtZSA9IHRpbWVab25lTmFtZTtcbiAgICB9XG59XG5cbmNsYXNzIFNlZ0hpZXJhcmNoeSB7XG4gICAgY29uc3RydWN0b3IoZ2V0RW50cnlUaGlja25lc3MgPSAoZW50cnkpID0+IHtcbiAgICAgICAgLy8gaWYgbm8gdGhpY2tuZXNzIGtub3duLCBhc3N1bWUgMSAoaWYgMCwgc28gc21hbGwgaXQgYWx3YXlzIGZpdHMpXG4gICAgICAgIHJldHVybiBlbnRyeS50aGlja25lc3MgfHwgMTtcbiAgICB9KSB7XG4gICAgICAgIHRoaXMuZ2V0RW50cnlUaGlja25lc3MgPSBnZXRFbnRyeVRoaWNrbmVzcztcbiAgICAgICAgLy8gc2V0dGluZ3NcbiAgICAgICAgdGhpcy5zdHJpY3RPcmRlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFsbG93UmVzbGljaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWF4Q29vcmQgPSAtMTsgLy8gLTEgbWVhbnMgbm8gbWF4XG4gICAgICAgIHRoaXMubWF4U3RhY2tDbnQgPSAtMTsgLy8gLTEgbWVhbnMgbm8gbWF4XG4gICAgICAgIHRoaXMubGV2ZWxDb29yZHMgPSBbXTsgLy8gb3JkZXJlZFxuICAgICAgICB0aGlzLmVudHJpZXNCeUxldmVsID0gW107IC8vIHBhcmFsbGVsIHdpdGggbGV2ZWxDb29yZHNcbiAgICAgICAgdGhpcy5zdGFja0NudHMgPSB7fTsgLy8gVE9ETzogdXNlIGJldHRlciB0ZWNobmlxdWUhP1xuICAgIH1cbiAgICBhZGRTZWdzKGlucHV0cykge1xuICAgICAgICBsZXQgaGlkZGVuRW50cmllcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0RW50cnkoaW5wdXQsIGhpZGRlbkVudHJpZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaWRkZW5FbnRyaWVzO1xuICAgIH1cbiAgICBpbnNlcnRFbnRyeShlbnRyeSwgaGlkZGVuRW50cmllcykge1xuICAgICAgICBsZXQgaW5zZXJ0aW9uID0gdGhpcy5maW5kSW5zZXJ0aW9uKGVudHJ5KTtcbiAgICAgICAgaWYgKHRoaXMuaXNJbnNlcnRpb25WYWxpZChpbnNlcnRpb24sIGVudHJ5KSkge1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRFbnRyeUF0KGVudHJ5LCBpbnNlcnRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVJbnZhbGlkSW5zZXJ0aW9uKGluc2VydGlvbiwgZW50cnksIGhpZGRlbkVudHJpZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzSW5zZXJ0aW9uVmFsaWQoaW5zZXJ0aW9uLCBlbnRyeSkge1xuICAgICAgICByZXR1cm4gKHRoaXMubWF4Q29vcmQgPT09IC0xIHx8IGluc2VydGlvbi5sZXZlbENvb3JkICsgdGhpcy5nZXRFbnRyeVRoaWNrbmVzcyhlbnRyeSkgPD0gdGhpcy5tYXhDb29yZCkgJiZcbiAgICAgICAgICAgICh0aGlzLm1heFN0YWNrQ250ID09PSAtMSB8fCBpbnNlcnRpb24uc3RhY2tDbnQgPCB0aGlzLm1heFN0YWNrQ250KTtcbiAgICB9XG4gICAgaGFuZGxlSW52YWxpZEluc2VydGlvbihpbnNlcnRpb24sIGVudHJ5LCBoaWRkZW5FbnRyaWVzKSB7XG4gICAgICAgIGlmICh0aGlzLmFsbG93UmVzbGljaW5nICYmIGluc2VydGlvbi50b3VjaGluZ0VudHJ5KSB7XG4gICAgICAgICAgICBjb25zdCBoaWRkZW5FbnRyeSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZW50cnkpLCB7IHNwYW46IGludGVyc2VjdFNwYW5zKGVudHJ5LnNwYW4sIGluc2VydGlvbi50b3VjaGluZ0VudHJ5LnNwYW4pIH0pO1xuICAgICAgICAgICAgaGlkZGVuRW50cmllcy5wdXNoKGhpZGRlbkVudHJ5KTtcbiAgICAgICAgICAgIHRoaXMuc3BsaXRFbnRyeShlbnRyeSwgaW5zZXJ0aW9uLnRvdWNoaW5nRW50cnksIGhpZGRlbkVudHJpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGlkZGVuRW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKlxuICAgIERvZXMgTk9UIGFkZCB3aGF0IGhpdCB0aGUgYGJhcnJpZXJgIGludG8gaGlkZGVuRW50cmllcy4gU2hvdWxkIGFscmVhZHkgYmUgZG9uZS5cbiAgICAqL1xuICAgIHNwbGl0RW50cnkoZW50cnksIGJhcnJpZXIsIGhpZGRlbkVudHJpZXMpIHtcbiAgICAgICAgbGV0IGVudHJ5U3BhbiA9IGVudHJ5LnNwYW47XG4gICAgICAgIGxldCBiYXJyaWVyU3BhbiA9IGJhcnJpZXIuc3BhbjtcbiAgICAgICAgaWYgKGVudHJ5U3Bhbi5zdGFydCA8IGJhcnJpZXJTcGFuLnN0YXJ0KSB7XG4gICAgICAgICAgICB0aGlzLmluc2VydEVudHJ5KHtcbiAgICAgICAgICAgICAgICBpbmRleDogZW50cnkuaW5kZXgsXG4gICAgICAgICAgICAgICAgdGhpY2tuZXNzOiBlbnRyeS50aGlja25lc3MsXG4gICAgICAgICAgICAgICAgc3BhbjogeyBzdGFydDogZW50cnlTcGFuLnN0YXJ0LCBlbmQ6IGJhcnJpZXJTcGFuLnN0YXJ0IH0sXG4gICAgICAgICAgICB9LCBoaWRkZW5FbnRyaWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW50cnlTcGFuLmVuZCA+IGJhcnJpZXJTcGFuLmVuZCkge1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRFbnRyeSh7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGVudHJ5LmluZGV4LFxuICAgICAgICAgICAgICAgIHRoaWNrbmVzczogZW50cnkudGhpY2tuZXNzLFxuICAgICAgICAgICAgICAgIHNwYW46IHsgc3RhcnQ6IGJhcnJpZXJTcGFuLmVuZCwgZW5kOiBlbnRyeVNwYW4uZW5kIH0sXG4gICAgICAgICAgICB9LCBoaWRkZW5FbnRyaWVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbnNlcnRFbnRyeUF0KGVudHJ5LCBpbnNlcnRpb24pIHtcbiAgICAgICAgbGV0IHsgZW50cmllc0J5TGV2ZWwsIGxldmVsQ29vcmRzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoaW5zZXJ0aW9uLmxhdGVyYWwgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgYSBuZXcgbGV2ZWxcbiAgICAgICAgICAgIGluc2VydEF0KGxldmVsQ29vcmRzLCBpbnNlcnRpb24ubGV2ZWwsIGluc2VydGlvbi5sZXZlbENvb3JkKTtcbiAgICAgICAgICAgIGluc2VydEF0KGVudHJpZXNCeUxldmVsLCBpbnNlcnRpb24ubGV2ZWwsIFtlbnRyeV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaW5zZXJ0IGludG8gZXhpc3RpbmcgbGV2ZWxcbiAgICAgICAgICAgIGluc2VydEF0KGVudHJpZXNCeUxldmVsW2luc2VydGlvbi5sZXZlbF0sIGluc2VydGlvbi5sYXRlcmFsLCBlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFja0NudHNbYnVpbGRFbnRyeUtleShlbnRyeSldID0gaW5zZXJ0aW9uLnN0YWNrQ250O1xuICAgIH1cbiAgICAvKlxuICAgIGRvZXMgbm90IGNhcmUgYWJvdXQgbGltaXRzXG4gICAgKi9cbiAgICBmaW5kSW5zZXJ0aW9uKG5ld0VudHJ5KSB7XG4gICAgICAgIGxldCB7IGxldmVsQ29vcmRzLCBlbnRyaWVzQnlMZXZlbCwgc3RyaWN0T3JkZXIsIHN0YWNrQ250cyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGxldmVsQ250ID0gbGV2ZWxDb29yZHMubGVuZ3RoO1xuICAgICAgICBsZXQgY2FuZGlkYXRlQ29vcmQgPSAwO1xuICAgICAgICBsZXQgdG91Y2hpbmdMZXZlbCA9IC0xO1xuICAgICAgICBsZXQgdG91Y2hpbmdMYXRlcmFsID0gLTE7XG4gICAgICAgIGxldCB0b3VjaGluZ0VudHJ5ID0gbnVsbDtcbiAgICAgICAgbGV0IHN0YWNrQ250ID0gMDtcbiAgICAgICAgZm9yIChsZXQgdHJhY2tpbmdMZXZlbCA9IDA7IHRyYWNraW5nTGV2ZWwgPCBsZXZlbENudDsgdHJhY2tpbmdMZXZlbCArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFja2luZ0Nvb3JkID0gbGV2ZWxDb29yZHNbdHJhY2tpbmdMZXZlbF07XG4gICAgICAgICAgICAvLyBpZiB0aGUgY3VycmVudCBsZXZlbCBpcyBwYXN0IHRoZSBwbGFjZWQgZW50cnksIHdlIGhhdmUgZm91bmQgYSBnb29kIGVtcHR5IHNwYWNlIGFuZCBjYW4gc3RvcC5cbiAgICAgICAgICAgIC8vIGlmIHN0cmljdE9yZGVyLCBrZWVwIGZpbmRpbmcgbW9yZSBsYXRlcmFsIGludGVyc2VjdGlvbnMuXG4gICAgICAgICAgICBpZiAoIXN0cmljdE9yZGVyICYmIHRyYWNraW5nQ29vcmQgPj0gY2FuZGlkYXRlQ29vcmQgKyB0aGlzLmdldEVudHJ5VGhpY2tuZXNzKG5ld0VudHJ5KSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRyYWNraW5nRW50cmllcyA9IGVudHJpZXNCeUxldmVsW3RyYWNraW5nTGV2ZWxdO1xuICAgICAgICAgICAgbGV0IHRyYWNraW5nRW50cnk7XG4gICAgICAgICAgICBsZXQgc2VhcmNoUmVzID0gYmluYXJ5U2VhcmNoKHRyYWNraW5nRW50cmllcywgbmV3RW50cnkuc3Bhbi5zdGFydCwgZ2V0RW50cnlTcGFuRW5kKTsgLy8gZmluZCBmaXJzdCBlbnRyeSBhZnRlciBuZXdFbnRyeSdzIGVuZFxuICAgICAgICAgICAgbGV0IGxhdGVyYWxJbmRleCA9IHNlYXJjaFJlc1swXSArIHNlYXJjaFJlc1sxXTsgLy8gaWYgZXhhY3QgbWF0Y2ggKHdoaWNoIGRvZXNuJ3QgY29sbGlkZSksIGdvIHRvIG5leHQgb25lXG4gICAgICAgICAgICB3aGlsZSAoIC8vIGxvb3AgdGhyb3VnaCBlbnRyaWVzIHRoYXQgaG9yaXpvbnRhbGx5IGludGVyc2VjdFxuICAgICAgICAgICAgKHRyYWNraW5nRW50cnkgPSB0cmFja2luZ0VudHJpZXNbbGF0ZXJhbEluZGV4XSkgJiYgLy8gYnV0IG5vdCBwYXN0IHRoZSB3aG9sZSBlbnRyeSBsaXN0XG4gICAgICAgICAgICAgICAgdHJhY2tpbmdFbnRyeS5zcGFuLnN0YXJ0IDwgbmV3RW50cnkuc3Bhbi5lbmQgLy8gYW5kIG5vdCBlbnRpcmVseSBwYXN0IG5ld0VudHJ5XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBsZXQgdHJhY2tpbmdFbnRyeUJvdHRvbSA9IHRyYWNraW5nQ29vcmQgKyB0aGlzLmdldEVudHJ5VGhpY2tuZXNzKHRyYWNraW5nRW50cnkpO1xuICAgICAgICAgICAgICAgIC8vIGludGVyc2VjdHMgaW50byB0aGUgdG9wIG9mIHRoZSBjYW5kaWRhdGU/XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNraW5nRW50cnlCb3R0b20gPiBjYW5kaWRhdGVDb29yZCkge1xuICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVDb29yZCA9IHRyYWNraW5nRW50cnlCb3R0b207XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoaW5nRW50cnkgPSB0cmFja2luZ0VudHJ5O1xuICAgICAgICAgICAgICAgICAgICB0b3VjaGluZ0xldmVsID0gdHJhY2tpbmdMZXZlbDtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2hpbmdMYXRlcmFsID0gbGF0ZXJhbEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBidXR0cyB1cCBhZ2FpbnN0IHRvcCBvZiBjYW5kaWRhdGU/ICh3aWxsIGhhcHBlbiBpZiBqdXN0IGludGVyc2VjdGVkIGFzIHdlbGwpXG4gICAgICAgICAgICAgICAgaWYgKHRyYWNraW5nRW50cnlCb3R0b20gPT09IGNhbmRpZGF0ZUNvb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFjY3VtdWxhdGUgdGhlIGhpZ2hlc3QgcG9zc2libGUgc3RhY2tDbnQgb2YgdGhlIHRyYWNraW5nRW50cmllcyB0aGF0IGJ1dHQgdXBcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tDbnQgPSBNYXRoLm1heChzdGFja0NudCwgc3RhY2tDbnRzW2J1aWxkRW50cnlLZXkodHJhY2tpbmdFbnRyeSldICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhdGVyYWxJbmRleCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBkZXN0aW5hdGlvbiBsZXZlbCB3aWxsIGJlIGFmdGVyIHRvdWNoaW5nRW50cnkncyBsZXZlbC4gZmluZCBpdFxuICAgICAgICBsZXQgZGVzdExldmVsID0gMDtcbiAgICAgICAgaWYgKHRvdWNoaW5nRW50cnkpIHtcbiAgICAgICAgICAgIGRlc3RMZXZlbCA9IHRvdWNoaW5nTGV2ZWwgKyAxO1xuICAgICAgICAgICAgd2hpbGUgKGRlc3RMZXZlbCA8IGxldmVsQ250ICYmIGxldmVsQ29vcmRzW2Rlc3RMZXZlbF0gPCBjYW5kaWRhdGVDb29yZCkge1xuICAgICAgICAgICAgICAgIGRlc3RMZXZlbCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGFkZGluZyB0byBhbiBleGlzdGluZyBsZXZlbCwgZmluZCB3aGVyZSB0byBpbnNlcnRcbiAgICAgICAgbGV0IGRlc3RMYXRlcmFsID0gLTE7XG4gICAgICAgIGlmIChkZXN0TGV2ZWwgPCBsZXZlbENudCAmJiBsZXZlbENvb3Jkc1tkZXN0TGV2ZWxdID09PSBjYW5kaWRhdGVDb29yZCkge1xuICAgICAgICAgICAgZGVzdExhdGVyYWwgPSBiaW5hcnlTZWFyY2goZW50cmllc0J5TGV2ZWxbZGVzdExldmVsXSwgbmV3RW50cnkuc3Bhbi5lbmQsIGdldEVudHJ5U3BhbkVuZClbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvdWNoaW5nTGV2ZWwsXG4gICAgICAgICAgICB0b3VjaGluZ0xhdGVyYWwsXG4gICAgICAgICAgICB0b3VjaGluZ0VudHJ5LFxuICAgICAgICAgICAgc3RhY2tDbnQsXG4gICAgICAgICAgICBsZXZlbENvb3JkOiBjYW5kaWRhdGVDb29yZCxcbiAgICAgICAgICAgIGxldmVsOiBkZXN0TGV2ZWwsXG4gICAgICAgICAgICBsYXRlcmFsOiBkZXN0TGF0ZXJhbCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gc29ydGVkIGJ5IGxldmVsQ29vcmQgKGxvd2VzdCB0byBoaWdoZXN0KVxuICAgIHRvUmVjdHMoKSB7XG4gICAgICAgIGxldCB7IGVudHJpZXNCeUxldmVsLCBsZXZlbENvb3JkcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGxldmVsQ250ID0gZW50cmllc0J5TGV2ZWwubGVuZ3RoO1xuICAgICAgICBsZXQgcmVjdHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbGV2ZWwgPSAwOyBsZXZlbCA8IGxldmVsQ250OyBsZXZlbCArPSAxKSB7XG4gICAgICAgICAgICBsZXQgZW50cmllcyA9IGVudHJpZXNCeUxldmVsW2xldmVsXTtcbiAgICAgICAgICAgIGxldCBsZXZlbENvb3JkID0gbGV2ZWxDb29yZHNbbGV2ZWxdO1xuICAgICAgICAgICAgZm9yIChsZXQgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICAgICAgICAgIHJlY3RzLnB1c2goT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBlbnRyeSksIHsgdGhpY2tuZXNzOiB0aGlzLmdldEVudHJ5VGhpY2tuZXNzKGVudHJ5KSwgbGV2ZWxDb29yZCB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY3RzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEVudHJ5U3BhbkVuZChlbnRyeSkge1xuICAgIHJldHVybiBlbnRyeS5zcGFuLmVuZDtcbn1cbmZ1bmN0aW9uIGJ1aWxkRW50cnlLZXkoZW50cnkpIHtcbiAgICByZXR1cm4gZW50cnkuaW5kZXggKyAnOicgKyBlbnRyeS5zcGFuLnN0YXJ0O1xufVxuLy8gcmV0dXJucyBncm91cHMgd2l0aCBlbnRyaWVzIHNvcnRlZCBieSBpbnB1dCBvcmRlclxuZnVuY3Rpb24gZ3JvdXBJbnRlcnNlY3RpbmdFbnRyaWVzKGVudHJpZXMpIHtcbiAgICBsZXQgbWVyZ2VzID0gW107XG4gICAgZm9yIChsZXQgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICBsZXQgZmlsdGVyZWRNZXJnZXMgPSBbXTtcbiAgICAgICAgbGV0IGh1bmdyeU1lcmdlID0ge1xuICAgICAgICAgICAgc3BhbjogZW50cnkuc3BhbixcbiAgICAgICAgICAgIGVudHJpZXM6IFtlbnRyeV0sXG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IG1lcmdlIG9mIG1lcmdlcykge1xuICAgICAgICAgICAgaWYgKGludGVyc2VjdFNwYW5zKG1lcmdlLnNwYW4sIGh1bmdyeU1lcmdlLnNwYW4pKSB7XG4gICAgICAgICAgICAgICAgaHVuZ3J5TWVyZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJpZXM6IG1lcmdlLmVudHJpZXMuY29uY2F0KGh1bmdyeU1lcmdlLmVudHJpZXMpLFxuICAgICAgICAgICAgICAgICAgICBzcGFuOiBqb2luU3BhbnMobWVyZ2Uuc3BhbiwgaHVuZ3J5TWVyZ2Uuc3BhbiksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpbHRlcmVkTWVyZ2VzLnB1c2gobWVyZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbHRlcmVkTWVyZ2VzLnB1c2goaHVuZ3J5TWVyZ2UpO1xuICAgICAgICBtZXJnZXMgPSBmaWx0ZXJlZE1lcmdlcztcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlcztcbn1cbmZ1bmN0aW9uIGpvaW5TcGFucyhzcGFuMCwgc3BhbjEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogTWF0aC5taW4oc3BhbjAuc3RhcnQsIHNwYW4xLnN0YXJ0KSxcbiAgICAgICAgZW5kOiBNYXRoLm1heChzcGFuMC5lbmQsIHNwYW4xLmVuZCksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGludGVyc2VjdFNwYW5zKHNwYW4wLCBzcGFuMSkge1xuICAgIGxldCBzdGFydCA9IE1hdGgubWF4KHNwYW4wLnN0YXJ0LCBzcGFuMS5zdGFydCk7XG4gICAgbGV0IGVuZCA9IE1hdGgubWluKHNwYW4wLmVuZCwgc3BhbjEuZW5kKTtcbiAgICBpZiAoc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8vIGdlbmVyYWwgdXRpbFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBpbnNlcnRBdChhcnIsIGluZGV4LCBpdGVtKSB7XG4gICAgYXJyLnNwbGljZShpbmRleCwgMCwgaXRlbSk7XG59XG5mdW5jdGlvbiBiaW5hcnlTZWFyY2goYSwgc2VhcmNoVmFsLCBnZXRJdGVtVmFsKSB7XG4gICAgbGV0IHN0YXJ0SW5kZXggPSAwO1xuICAgIGxldCBlbmRJbmRleCA9IGEubGVuZ3RoOyAvLyBleGNsdXNpdmVcbiAgICBpZiAoIWVuZEluZGV4IHx8IHNlYXJjaFZhbCA8IGdldEl0ZW1WYWwoYVtzdGFydEluZGV4XSkpIHsgLy8gbm8gaXRlbXMgT1IgYmVmb3JlIGZpcnN0IGl0ZW1cbiAgICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICB9XG4gICAgaWYgKHNlYXJjaFZhbCA+IGdldEl0ZW1WYWwoYVtlbmRJbmRleCAtIDFdKSkgeyAvLyBhZnRlciBsYXN0IGl0ZW1cbiAgICAgICAgcmV0dXJuIFtlbmRJbmRleCwgMF07XG4gICAgfVxuICAgIHdoaWxlIChzdGFydEluZGV4IDwgZW5kSW5kZXgpIHtcbiAgICAgICAgbGV0IG1pZGRsZUluZGV4ID0gTWF0aC5mbG9vcihzdGFydEluZGV4ICsgKGVuZEluZGV4IC0gc3RhcnRJbmRleCkgLyAyKTtcbiAgICAgICAgbGV0IG1pZGRsZVZhbCA9IGdldEl0ZW1WYWwoYVttaWRkbGVJbmRleF0pO1xuICAgICAgICBpZiAoc2VhcmNoVmFsIDwgbWlkZGxlVmFsKSB7XG4gICAgICAgICAgICBlbmRJbmRleCA9IG1pZGRsZUluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNlYXJjaFZhbCA+IG1pZGRsZVZhbCkge1xuICAgICAgICAgICAgc3RhcnRJbmRleCA9IG1pZGRsZUluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gZXF1YWwhXG4gICAgICAgICAgICByZXR1cm4gW21pZGRsZUluZGV4LCAxXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW3N0YXJ0SW5kZXgsIDBdO1xufVxuXG4vKlxuQW4gYWJzdHJhY3Rpb24gZm9yIGEgZHJhZ2dpbmcgaW50ZXJhY3Rpb24gb3JpZ2luYXRpbmcgb24gYW4gZXZlbnQuXG5Eb2VzIGhpZ2hlci1sZXZlbCB0aGluZ3MgdGhhbiBQb2ludGVyRHJhZ2dlciwgc3VjaCBhcyBwb3NzaWJseTpcbi0gYSBcIm1pcnJvclwiIHRoYXQgbW92ZXMgd2l0aCB0aGUgcG9pbnRlclxuLSBhIG1pbmltdW0gbnVtYmVyIG9mIHBpeGVscyBvciBvdGhlciBjcml0ZXJpYSBmb3IgYSB0cnVlIGRyYWcgdG8gYmVnaW5cblxuc3ViY2xhc3NlcyBtdXN0IGVtaXQ6XG4tIHBvaW50ZXJkb3duXG4tIGRyYWdzdGFydFxuLSBkcmFnbW92ZVxuLSBwb2ludGVydXBcbi0gZHJhZ2VuZFxuKi9cbmNsYXNzIEVsZW1lbnREcmFnZ2luZyB7XG4gICAgY29uc3RydWN0b3IoZWwsIHNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgfVxuICAgIHNldE1pcnJvcklzVmlzaWJsZShib29sKSB7XG4gICAgICAgIC8vIG9wdGlvbmFsIGlmIHN1YmNsYXNzIGRvZXNuJ3Qgd2FudCB0byBzdXBwb3J0IGEgbWlycm9yXG4gICAgfVxuICAgIHNldE1pcnJvck5lZWRzUmV2ZXJ0KGJvb2wpIHtcbiAgICAgICAgLy8gb3B0aW9uYWwgaWYgc3ViY2xhc3MgZG9lc24ndCB3YW50IHRvIHN1cHBvcnQgYSBtaXJyb3JcbiAgICB9XG4gICAgc2V0QXV0b1Njcm9sbEVuYWJsZWQoYm9vbCkge1xuICAgICAgICAvLyBvcHRpb25hbFxuICAgIH1cbn1cblxuLy8gVE9ETzogZ2V0IHJpZCBvZiB0aGlzIGluIGZhdm9yIG9mIG9wdGlvbnMgc3lzdGVtLFxuLy8gdGhvIGl0J3MgcmVhbGx5IGVhc3kgdG8gYWNjZXNzIHRoaXMgZ2xvYmFsbHkgcmF0aGVyIHRoYW4gcGFzcyB0aHJ1IG9wdGlvbnMuXG5jb25zdCBjb25maWcgPSB7fTtcblxuLypcbkluZm9ybWF0aW9uIGFib3V0IHdoYXQgd2lsbCBoYXBwZW4gd2hlbiBhbiBleHRlcm5hbCBlbGVtZW50IGlzIGRyYWdnZWQtYW5kLWRyb3BwZWRcbm9udG8gYSBjYWxlbmRhci4gQ29udGFpbnMgaW5mb3JtYXRpb24gZm9yIGNyZWF0aW5nIGFuIGV2ZW50LlxuKi9cbmNvbnN0IERSQUdfTUVUQV9SRUZJTkVSUyA9IHtcbiAgICBzdGFydFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGR1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBjcmVhdGU6IEJvb2xlYW4sXG4gICAgc291cmNlSWQ6IFN0cmluZyxcbn07XG5mdW5jdGlvbiBwYXJzZURyYWdNZXRhKHJhdykge1xuICAgIGxldCB7IHJlZmluZWQsIGV4dHJhIH0gPSByZWZpbmVQcm9wcyhyYXcsIERSQUdfTUVUQV9SRUZJTkVSUyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnRUaW1lOiByZWZpbmVkLnN0YXJ0VGltZSB8fCBudWxsLFxuICAgICAgICBkdXJhdGlvbjogcmVmaW5lZC5kdXJhdGlvbiB8fCBudWxsLFxuICAgICAgICBjcmVhdGU6IHJlZmluZWQuY3JlYXRlICE9IG51bGwgPyByZWZpbmVkLmNyZWF0ZSA6IHRydWUsXG4gICAgICAgIHNvdXJjZUlkOiByZWZpbmVkLnNvdXJjZUlkLFxuICAgICAgICBsZWZ0b3ZlclByb3BzOiBleHRyYSxcbiAgICB9O1xufVxuXG4vLyBDb21wdXRlcyBhIGRlZmF1bHQgY29sdW1uIGhlYWRlciBmb3JtYXR0aW5nIHN0cmluZyBpZiBgY29sRm9ybWF0YCBpcyBub3QgZXhwbGljaXRseSBkZWZpbmVkXG5mdW5jdGlvbiBjb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQoZGF0ZXNSZXBEaXN0aW5jdERheXMsIGRheUNudCkge1xuICAgIC8vIGlmIG1vcmUgdGhhbiBvbmUgd2VlayByb3csIG9yIGlmIHRoZXJlIGFyZSBhIGxvdCBvZiBjb2x1bW5zIHdpdGggbm90IG11Y2ggc3BhY2UsXG4gICAgLy8gcHV0IGp1c3QgdGhlIGRheSBudW1iZXJzIHdpbGwgYmUgaW4gZWFjaCBjZWxsXG4gICAgaWYgKCFkYXRlc1JlcERpc3RpbmN0RGF5cyB8fCBkYXlDbnQgPiAxMCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0dGVyKHsgd2Vla2RheTogJ3Nob3J0JyB9KTsgLy8gXCJTYXRcIlxuICAgIH1cbiAgICBpZiAoZGF5Q250ID4gMSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0dGVyKHsgd2Vla2RheTogJ3Nob3J0JywgbW9udGg6ICdudW1lcmljJywgZGF5OiAnbnVtZXJpYycsIG9taXRDb21tYXM6IHRydWUgfSk7IC8vIFwiU2F0IDExLzEyXCJcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUZvcm1hdHRlcih7IHdlZWtkYXk6ICdsb25nJyB9KTsgLy8gXCJTYXR1cmRheVwiXG59XG5cbmNvbnN0IENMQVNTX05BTUUgPSAnZmMtY29sLWhlYWRlci1jZWxsJzsgLy8gZG8gdGhlIGN1c2hpb24gdG9vPyBub1xuZnVuY3Rpb24gcmVuZGVySW5uZXIkMShyZW5kZXJQcm9wcykge1xuICAgIHJldHVybiByZW5kZXJQcm9wcy50ZXh0O1xufVxuXG4vLyBCQUQgbmFtZSBmb3IgdGhpcyBjbGFzcyBub3cuIHVzZWQgaW4gdGhlIEhlYWRlclxuY2xhc3MgVGFibGVEYXRlQ2VsbCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiwgb3B0aW9ucywgdGhlbWUsIHZpZXdBcGkgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGRhdGUsIGRhdGVQcm9maWxlIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IGRheU1ldGEgPSBnZXREYXRlTWV0YShkYXRlLCBwcm9wcy50b2RheVJhbmdlLCBudWxsLCBkYXRlUHJvZmlsZSk7XG4gICAgICAgIGxldCBjbGFzc05hbWVzID0gW0NMQVNTX05BTUVdLmNvbmNhdChnZXREYXlDbGFzc05hbWVzKGRheU1ldGEsIHRoZW1lKSk7XG4gICAgICAgIGxldCB0ZXh0ID0gZGF0ZUVudi5mb3JtYXQoZGF0ZSwgcHJvcHMuZGF5SGVhZGVyRm9ybWF0KTtcbiAgICAgICAgLy8gaWYgY29sQ250IGlzIDEsIHdlIGFyZSBhbHJlYWR5IGluIGEgZGF5LXZpZXcgYW5kIGRvbid0IG5lZWQgYSBuYXZsaW5rXG4gICAgICAgIGxldCBuYXZMaW5rQXR0cnMgPSAoIWRheU1ldGEuaXNEaXNhYmxlZCAmJiBwcm9wcy5jb2xDbnQgPiAxKVxuICAgICAgICAgICAgPyBidWlsZE5hdkxpbmtBdHRycyh0aGlzLmNvbnRleHQsIGRhdGUpXG4gICAgICAgICAgICA6IHt9O1xuICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IGRhdGU6IGRhdGVFbnYudG9EYXRlKGRhdGUpLCB2aWV3OiB2aWV3QXBpIH0sIHByb3BzLmV4dHJhUmVuZGVyUHJvcHMpLCB7IHRleHQgfSksIGRheU1ldGEpO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciwgeyBlbFRhZzogXCJ0aFwiLCBlbENsYXNzZXM6IGNsYXNzTmFtZXMsIGVsQXR0cnM6IE9iamVjdC5hc3NpZ24oeyByb2xlOiAnY29sdW1uaGVhZGVyJywgY29sU3BhbjogcHJvcHMuY29sU3BhbiwgJ2RhdGEtZGF0ZSc6ICFkYXlNZXRhLmlzRGlzYWJsZWQgPyBmb3JtYXREYXlTdHJpbmcoZGF0ZSkgOiB1bmRlZmluZWQgfSwgcHJvcHMuZXh0cmFEYXRhQXR0cnMpLCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwiZGF5SGVhZGVyQ29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMuZGF5SGVhZGVyQ29udGVudCwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVySW5uZXIkMSwgY2xhc3NOYW1lR2VuZXJhdG9yOiBvcHRpb25zLmRheUhlYWRlckNsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLmRheUhlYWRlckRpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5kYXlIZWFkZXJXaWxsVW5tb3VudCB9LCAoSW5uZXJDb250YWluZXIpID0+IChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXNjcm9sbGdyaWQtc3luYy1pbm5lclwiIH0sICFkYXlNZXRhLmlzRGlzYWJsZWQgJiYgKGNyZWF0ZUVsZW1lbnQoSW5uZXJDb250YWluZXIsIHsgZWxUYWc6IFwiYVwiLCBlbEF0dHJzOiBuYXZMaW5rQXR0cnMsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgICdmYy1jb2wtaGVhZGVyLWNlbGwtY3VzaGlvbicsXG4gICAgICAgICAgICAgICAgcHJvcHMuaXNTdGlja3kgJiYgJ2ZjLXN0aWNreScsXG4gICAgICAgICAgICBdIH0pKSkpKSk7XG4gICAgfVxufVxuXG5jb25zdCBXRUVLREFZX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7IHdlZWtkYXk6ICdsb25nJyB9KTtcbmNsYXNzIFRhYmxlRG93Q2VsbCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGRhdGVFbnYsIHRoZW1lLCB2aWV3QXBpLCBvcHRpb25zIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBkYXRlID0gYWRkRGF5cyhuZXcgRGF0ZSgyNTkyMDAwMDApLCBwcm9wcy5kb3cpOyAvLyBzdGFydCB3aXRoIFN1biwgMDQgSmFuIDE5NzAgMDA6MDA6MDAgR01UXG4gICAgICAgIGxldCBkYXRlTWV0YSA9IHtcbiAgICAgICAgICAgIGRvdzogcHJvcHMuZG93LFxuICAgICAgICAgICAgaXNEaXNhYmxlZDogZmFsc2UsXG4gICAgICAgICAgICBpc0Z1dHVyZTogZmFsc2UsXG4gICAgICAgICAgICBpc1Bhc3Q6IGZhbHNlLFxuICAgICAgICAgICAgaXNUb2RheTogZmFsc2UsXG4gICAgICAgICAgICBpc090aGVyOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHRleHQgPSBkYXRlRW52LmZvcm1hdChkYXRlLCBwcm9wcy5kYXlIZWFkZXJGb3JtYXQpO1xuICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgLy8gVE9ETzogbWFrZSB0aGlzIHB1YmxpYz9cbiAgICAgICAgICAgIGRhdGUgfSwgZGF0ZU1ldGEpLCB7IHZpZXc6IHZpZXdBcGkgfSksIHByb3BzLmV4dHJhUmVuZGVyUHJvcHMpLCB7IHRleHQgfSk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChDb250ZW50Q29udGFpbmVyLCB7IGVsVGFnOiBcInRoXCIsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgIENMQVNTX05BTUUsXG4gICAgICAgICAgICAgICAgLi4uZ2V0RGF5Q2xhc3NOYW1lcyhkYXRlTWV0YSwgdGhlbWUpLFxuICAgICAgICAgICAgICAgIC4uLihwcm9wcy5leHRyYUNsYXNzTmFtZXMgfHwgW10pLFxuICAgICAgICAgICAgXSwgZWxBdHRyczogT2JqZWN0LmFzc2lnbih7IHJvbGU6ICdjb2x1bW5oZWFkZXInLCBjb2xTcGFuOiBwcm9wcy5jb2xTcGFuIH0sIHByb3BzLmV4dHJhRGF0YUF0dHJzKSwgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcImRheUhlYWRlckNvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLmRheUhlYWRlckNvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlcklubmVyJDEsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5kYXlIZWFkZXJDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5kYXlIZWFkZXJEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuZGF5SGVhZGVyV2lsbFVubW91bnQgfSwgKElubmVyQ29udGVudCkgPT4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtc2Nyb2xsZ3JpZC1zeW5jLWlubmVyXCIgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcImFcIiwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgICAgICdmYy1jb2wtaGVhZGVyLWNlbGwtY3VzaGlvbicsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmlzU3RpY2t5ICYmICdmYy1zdGlja3knLFxuICAgICAgICAgICAgICAgIF0sIGVsQXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FyaWEtbGFiZWwnOiBkYXRlRW52LmZvcm1hdChkYXRlLCBXRUVLREFZX0ZPUk1BVCksXG4gICAgICAgICAgICAgICAgfSB9KSkpKSk7XG4gICAgfVxufVxuXG5jbGFzcyBOb3dUaW1lciBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIocHJvcHMsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLmluaXRpYWxOb3dEYXRlID0gZ2V0Tm93KGNvbnRleHQub3B0aW9ucy5ub3csIGNvbnRleHQuZGF0ZUVudik7XG4gICAgICAgIHRoaXMuaW5pdGlhbE5vd1F1ZXJpZWRNcyA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5jb21wdXRlVGltaW5nKCkuY3VycmVudFN0YXRlO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuKHN0YXRlLm5vd0RhdGUsIHN0YXRlLnRvZGF5UmFuZ2UpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5zZXRUaW1lb3V0KCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgICAgaWYgKHByZXZQcm9wcy51bml0ICE9PSB0aGlzLnByb3BzLnVuaXQpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gICAgICAgICAgICB0aGlzLnNldFRpbWVvdXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICB9XG4gICAgY29tcHV0ZVRpbWluZygpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB1bnJvdW5kZWROb3cgPSBhZGRNcyh0aGlzLmluaXRpYWxOb3dEYXRlLCBuZXcgRGF0ZSgpLnZhbHVlT2YoKSAtIHRoaXMuaW5pdGlhbE5vd1F1ZXJpZWRNcyk7XG4gICAgICAgIGxldCBjdXJyZW50VW5pdFN0YXJ0ID0gY29udGV4dC5kYXRlRW52LnN0YXJ0T2YodW5yb3VuZGVkTm93LCBwcm9wcy51bml0KTtcbiAgICAgICAgbGV0IG5leHRVbml0U3RhcnQgPSBjb250ZXh0LmRhdGVFbnYuYWRkKGN1cnJlbnRVbml0U3RhcnQsIGNyZWF0ZUR1cmF0aW9uKDEsIHByb3BzLnVuaXQpKTtcbiAgICAgICAgbGV0IHdhaXRNcyA9IG5leHRVbml0U3RhcnQudmFsdWVPZigpIC0gdW5yb3VuZGVkTm93LnZhbHVlT2YoKTtcbiAgICAgICAgLy8gdGhlcmUgaXMgYSBtYXggc2V0VGltZW91dCBtcyB2YWx1ZSAoaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM0Njg2NTAvOTYzNDIpXG4gICAgICAgIC8vIGVuc3VyZSBubyBsb25nZXIgdGhhbiBhIGRheVxuICAgICAgICB3YWl0TXMgPSBNYXRoLm1pbigxMDAwICogNjAgKiA2MCAqIDI0LCB3YWl0TXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3VycmVudFN0YXRlOiB7IG5vd0RhdGU6IGN1cnJlbnRVbml0U3RhcnQsIHRvZGF5UmFuZ2U6IGJ1aWxkRGF5UmFuZ2UoY3VycmVudFVuaXRTdGFydCkgfSxcbiAgICAgICAgICAgIG5leHRTdGF0ZTogeyBub3dEYXRlOiBuZXh0VW5pdFN0YXJ0LCB0b2RheVJhbmdlOiBidWlsZERheVJhbmdlKG5leHRVbml0U3RhcnQpIH0sXG4gICAgICAgICAgICB3YWl0TXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHNldFRpbWVvdXQoKSB7XG4gICAgICAgIGxldCB7IG5leHRTdGF0ZSwgd2FpdE1zIH0gPSB0aGlzLmNvbXB1dGVUaW1pbmcoKTtcbiAgICAgICAgdGhpcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUobmV4dFN0YXRlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUaW1lb3V0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgd2FpdE1zKTtcbiAgICB9XG4gICAgY2xlYXJUaW1lb3V0KCkge1xuICAgICAgICBpZiAodGhpcy50aW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5Ob3dUaW1lci5jb250ZXh0VHlwZSA9IFZpZXdDb250ZXh0VHlwZTtcbmZ1bmN0aW9uIGJ1aWxkRGF5UmFuZ2UoZGF0ZSkge1xuICAgIGxldCBzdGFydCA9IHN0YXJ0T2ZEYXkoZGF0ZSk7XG4gICAgbGV0IGVuZCA9IGFkZERheXMoc3RhcnQsIDEpO1xuICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcbn1cblxuY2xhc3MgRGF5SGVhZGVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyID0gbWVtb2l6ZShjcmVhdGVEYXlIZWFkZXJGb3JtYXR0ZXIpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGRhdGVzLCBkYXRlUHJvZmlsZSwgZGF0ZXNSZXBEaXN0aW5jdERheXMsIHJlbmRlckludHJvIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQgZGF5SGVhZGVyRm9ybWF0ID0gdGhpcy5jcmVhdGVEYXlIZWFkZXJGb3JtYXR0ZXIoY29udGV4dC5vcHRpb25zLmRheUhlYWRlckZvcm1hdCwgZGF0ZXNSZXBEaXN0aW5jdERheXMsIGRhdGVzLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChOb3dUaW1lciwgeyB1bml0OiBcImRheVwiIH0sIChub3dEYXRlLCB0b2RheVJhbmdlKSA9PiAoY3JlYXRlRWxlbWVudChcInRyXCIsIHsgcm9sZTogXCJyb3dcIiB9LFxuICAgICAgICAgICAgcmVuZGVySW50cm8gJiYgcmVuZGVySW50cm8oJ2RheScpLFxuICAgICAgICAgICAgZGF0ZXMubWFwKChkYXRlKSA9PiAoZGF0ZXNSZXBEaXN0aW5jdERheXMgPyAoY3JlYXRlRWxlbWVudChUYWJsZURhdGVDZWxsLCB7IGtleTogZGF0ZS50b0lTT1N0cmluZygpLCBkYXRlOiBkYXRlLCBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHRvZGF5UmFuZ2UsIGNvbENudDogZGF0ZXMubGVuZ3RoLCBkYXlIZWFkZXJGb3JtYXQ6IGRheUhlYWRlckZvcm1hdCB9KSkgOiAoY3JlYXRlRWxlbWVudChUYWJsZURvd0NlbGwsIHsga2V5OiBkYXRlLmdldFVUQ0RheSgpLCBkb3c6IGRhdGUuZ2V0VVRDRGF5KCksIGRheUhlYWRlckZvcm1hdDogZGF5SGVhZGVyRm9ybWF0IH0pKSkpKSkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVEYXlIZWFkZXJGb3JtYXR0ZXIoZXhwbGljaXRGb3JtYXQsIGRhdGVzUmVwRGlzdGluY3REYXlzLCBkYXRlQ250KSB7XG4gICAgcmV0dXJuIGV4cGxpY2l0Rm9ybWF0IHx8IGNvbXB1dGVGYWxsYmFja0hlYWRlckZvcm1hdChkYXRlc1JlcERpc3RpbmN0RGF5cywgZGF0ZUNudCk7XG59XG5cbmNsYXNzIERheVNlcmllc01vZGVsIHtcbiAgICBjb25zdHJ1Y3RvcihyYW5nZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpIHtcbiAgICAgICAgbGV0IGRhdGUgPSByYW5nZS5zdGFydDtcbiAgICAgICAgbGV0IHsgZW5kIH0gPSByYW5nZTtcbiAgICAgICAgbGV0IGluZGljZXMgPSBbXTtcbiAgICAgICAgbGV0IGRhdGVzID0gW107XG4gICAgICAgIGxldCBkYXlJbmRleCA9IC0xO1xuICAgICAgICB3aGlsZSAoZGF0ZSA8IGVuZCkgeyAvLyBsb29wIGVhY2ggZGF5IGZyb20gc3RhcnQgdG8gZW5kXG4gICAgICAgICAgICBpZiAoZGF0ZVByb2ZpbGVHZW5lcmF0b3IuaXNIaWRkZW5EYXkoZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goZGF5SW5kZXggKyAwLjUpOyAvLyBtYXJrIHRoYXQgaXQncyBiZXR3ZWVuIGluZGljZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRheUluZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGRheUluZGV4KTtcbiAgICAgICAgICAgICAgICBkYXRlcy5wdXNoKGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0ZSA9IGFkZERheXMoZGF0ZSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRlcyA9IGRhdGVzO1xuICAgICAgICB0aGlzLmluZGljZXMgPSBpbmRpY2VzO1xuICAgICAgICB0aGlzLmNudCA9IGRhdGVzLmxlbmd0aDtcbiAgICB9XG4gICAgc2xpY2VSYW5nZShyYW5nZSkge1xuICAgICAgICBsZXQgZmlyc3RJbmRleCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KHJhbmdlLnN0YXJ0KTsgLy8gaW5jbHVzaXZlIGZpcnN0IGluZGV4XG4gICAgICAgIGxldCBsYXN0SW5kZXggPSB0aGlzLmdldERhdGVEYXlJbmRleChhZGREYXlzKHJhbmdlLmVuZCwgLTEpKTsgLy8gaW5jbHVzaXZlIGxhc3QgaW5kZXhcbiAgICAgICAgbGV0IGNsaXBwZWRGaXJzdEluZGV4ID0gTWF0aC5tYXgoMCwgZmlyc3RJbmRleCk7XG4gICAgICAgIGxldCBjbGlwcGVkTGFzdEluZGV4ID0gTWF0aC5taW4odGhpcy5jbnQgLSAxLCBsYXN0SW5kZXgpO1xuICAgICAgICAvLyBkZWFsIHdpdGggaW4tYmV0d2VlbiBpbmRpY2VzXG4gICAgICAgIGNsaXBwZWRGaXJzdEluZGV4ID0gTWF0aC5jZWlsKGNsaXBwZWRGaXJzdEluZGV4KTsgLy8gaW4tYmV0d2VlbiBzdGFydHMgcm91bmQgdG8gbmV4dCBjZWxsXG4gICAgICAgIGNsaXBwZWRMYXN0SW5kZXggPSBNYXRoLmZsb29yKGNsaXBwZWRMYXN0SW5kZXgpOyAvLyBpbi1iZXR3ZWVuIGVuZHMgcm91bmQgdG8gcHJldiBjZWxsXG4gICAgICAgIGlmIChjbGlwcGVkRmlyc3RJbmRleCA8PSBjbGlwcGVkTGFzdEluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZpcnN0SW5kZXg6IGNsaXBwZWRGaXJzdEluZGV4LFxuICAgICAgICAgICAgICAgIGxhc3RJbmRleDogY2xpcHBlZExhc3RJbmRleCxcbiAgICAgICAgICAgICAgICBpc1N0YXJ0OiBmaXJzdEluZGV4ID09PSBjbGlwcGVkRmlyc3RJbmRleCxcbiAgICAgICAgICAgICAgICBpc0VuZDogbGFzdEluZGV4ID09PSBjbGlwcGVkTGFzdEluZGV4LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gR2l2ZW4gYSBkYXRlLCByZXR1cm5zIGl0cyBjaHJvbm9sb2NpYWwgY2VsbC1pbmRleCBmcm9tIHRoZSBmaXJzdCBjZWxsIG9mIHRoZSBncmlkLlxuICAgIC8vIElmIHRoZSBkYXRlIGxpZXMgYmV0d2VlbiBjZWxscyAoYmVjYXVzZSBvZiBoaWRkZW5EYXlzKSwgcmV0dXJucyBhIGZsb2F0aW5nLXBvaW50IHZhbHVlIGJldHdlZW4gb2Zmc2V0cy5cbiAgICAvLyBJZiBiZWZvcmUgdGhlIGZpcnN0IG9mZnNldCwgcmV0dXJucyBhIG5lZ2F0aXZlIG51bWJlci5cbiAgICAvLyBJZiBhZnRlciB0aGUgbGFzdCBvZmZzZXQsIHJldHVybnMgYW4gb2Zmc2V0IHBhc3QgdGhlIGxhc3QgY2VsbCBvZmZzZXQuXG4gICAgLy8gT25seSB3b3JrcyBmb3IgKnN0YXJ0KiBkYXRlcyBvZiBjZWxscy4gV2lsbCBub3Qgd29yayBmb3IgZXhjbHVzaXZlIGVuZCBkYXRlcyBmb3IgY2VsbHMuXG4gICAgZ2V0RGF0ZURheUluZGV4KGRhdGUpIHtcbiAgICAgICAgbGV0IHsgaW5kaWNlcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGRheU9mZnNldCA9IE1hdGguZmxvb3IoZGlmZkRheXModGhpcy5kYXRlc1swXSwgZGF0ZSkpO1xuICAgICAgICBpZiAoZGF5T2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIGluZGljZXNbMF0gLSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXlPZmZzZXQgPj0gaW5kaWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRpY2VzW2luZGljZXMubGVuZ3RoIC0gMV0gKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRpY2VzW2RheU9mZnNldF07XG4gICAgfVxufVxuXG5jbGFzcyBEYXlUYWJsZU1vZGVsIHtcbiAgICBjb25zdHJ1Y3RvcihkYXlTZXJpZXMsIGJyZWFrT25XZWVrcykge1xuICAgICAgICBsZXQgeyBkYXRlcyB9ID0gZGF5U2VyaWVzO1xuICAgICAgICBsZXQgZGF5c1BlclJvdztcbiAgICAgICAgbGV0IGZpcnN0RGF5O1xuICAgICAgICBsZXQgcm93Q250O1xuICAgICAgICBpZiAoYnJlYWtPbldlZWtzKSB7XG4gICAgICAgICAgICAvLyBjb3VudCBjb2x1bW5zIHVudGlsIHRoZSBkYXktb2Ytd2VlayByZXBlYXRzXG4gICAgICAgICAgICBmaXJzdERheSA9IGRhdGVzWzBdLmdldFVUQ0RheSgpO1xuICAgICAgICAgICAgZm9yIChkYXlzUGVyUm93ID0gMTsgZGF5c1BlclJvdyA8IGRhdGVzLmxlbmd0aDsgZGF5c1BlclJvdyArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGVzW2RheXNQZXJSb3ddLmdldFVUQ0RheSgpID09PSBmaXJzdERheSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3dDbnQgPSBNYXRoLmNlaWwoZGF0ZXMubGVuZ3RoIC8gZGF5c1BlclJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByb3dDbnQgPSAxO1xuICAgICAgICAgICAgZGF5c1BlclJvdyA9IGRhdGVzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJvd0NudCA9IHJvd0NudDtcbiAgICAgICAgdGhpcy5jb2xDbnQgPSBkYXlzUGVyUm93O1xuICAgICAgICB0aGlzLmRheVNlcmllcyA9IGRheVNlcmllcztcbiAgICAgICAgdGhpcy5jZWxscyA9IHRoaXMuYnVpbGRDZWxscygpO1xuICAgICAgICB0aGlzLmhlYWRlckRhdGVzID0gdGhpcy5idWlsZEhlYWRlckRhdGVzKCk7XG4gICAgfVxuICAgIGJ1aWxkQ2VsbHMoKSB7XG4gICAgICAgIGxldCByb3dzID0gW107XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHRoaXMucm93Q250OyByb3cgKz0gMSkge1xuICAgICAgICAgICAgbGV0IGNlbGxzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbENudDsgY29sICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjZWxscy5wdXNoKHRoaXMuYnVpbGRDZWxsKHJvdywgY29sKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3dzLnB1c2goY2VsbHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3dzO1xuICAgIH1cbiAgICBidWlsZENlbGwocm93LCBjb2wpIHtcbiAgICAgICAgbGV0IGRhdGUgPSB0aGlzLmRheVNlcmllcy5kYXRlc1tyb3cgKiB0aGlzLmNvbENudCArIGNvbF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXk6IGRhdGUudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGRhdGUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGJ1aWxkSGVhZGVyRGF0ZXMoKSB7XG4gICAgICAgIGxldCBkYXRlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbENudDsgY29sICs9IDEpIHtcbiAgICAgICAgICAgIGRhdGVzLnB1c2godGhpcy5jZWxsc1swXVtjb2xdLmRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlcztcbiAgICB9XG4gICAgc2xpY2VSYW5nZShyYW5nZSkge1xuICAgICAgICBsZXQgeyBjb2xDbnQgfSA9IHRoaXM7XG4gICAgICAgIGxldCBzZXJpZXNTZWcgPSB0aGlzLmRheVNlcmllcy5zbGljZVJhbmdlKHJhbmdlKTtcbiAgICAgICAgbGV0IHNlZ3MgPSBbXTtcbiAgICAgICAgaWYgKHNlcmllc1NlZykge1xuICAgICAgICAgICAgbGV0IHsgZmlyc3RJbmRleCwgbGFzdEluZGV4IH0gPSBzZXJpZXNTZWc7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBmaXJzdEluZGV4O1xuICAgICAgICAgICAgd2hpbGUgKGluZGV4IDw9IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgIGxldCByb3cgPSBNYXRoLmZsb29yKGluZGV4IC8gY29sQ250KTtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dEluZGV4ID0gTWF0aC5taW4oKHJvdyArIDEpICogY29sQ250LCBsYXN0SW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICBzZWdzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICByb3csXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Q29sOiBpbmRleCAlIGNvbENudCxcbiAgICAgICAgICAgICAgICAgICAgbGFzdENvbDogKG5leHRJbmRleCAtIDEpICUgY29sQ250LFxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBzZXJpZXNTZWcuaXNTdGFydCAmJiBpbmRleCA9PT0gZmlyc3RJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IHNlcmllc1NlZy5pc0VuZCAmJiAobmV4dEluZGV4IC0gMSkgPT09IGxhc3RJbmRleCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VncztcbiAgICB9XG59XG5cbmNsYXNzIFNsaWNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc2xpY2VCdXNpbmVzc0hvdXJzID0gbWVtb2l6ZSh0aGlzLl9zbGljZUJ1c2luZXNzSG91cnMpO1xuICAgICAgICB0aGlzLnNsaWNlRGF0ZVNlbGVjdGlvbiA9IG1lbW9pemUodGhpcy5fc2xpY2VEYXRlU3Bhbik7XG4gICAgICAgIHRoaXMuc2xpY2VFdmVudFN0b3JlID0gbWVtb2l6ZSh0aGlzLl9zbGljZUV2ZW50U3RvcmUpO1xuICAgICAgICB0aGlzLnNsaWNlRXZlbnREcmFnID0gbWVtb2l6ZSh0aGlzLl9zbGljZUludGVyYWN0aW9uKTtcbiAgICAgICAgdGhpcy5zbGljZUV2ZW50UmVzaXplID0gbWVtb2l6ZSh0aGlzLl9zbGljZUludGVyYWN0aW9uKTtcbiAgICAgICAgdGhpcy5mb3JjZURheUlmTGlzdEl0ZW0gPSBmYWxzZTsgLy8gaGFja1xuICAgIH1cbiAgICBzbGljZVByb3BzKHByb3BzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgY29udGV4dCwgLi4uZXh0cmFBcmdzKSB7XG4gICAgICAgIGxldCB7IGV2ZW50VWlCYXNlcyB9ID0gcHJvcHM7XG4gICAgICAgIGxldCBldmVudFNlZ3MgPSB0aGlzLnNsaWNlRXZlbnRTdG9yZShwcm9wcy5ldmVudFN0b3JlLCBldmVudFVpQmFzZXMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCAuLi5leHRyYUFyZ3MpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0ZVNlbGVjdGlvblNlZ3M6IHRoaXMuc2xpY2VEYXRlU2VsZWN0aW9uKHByb3BzLmRhdGVTZWxlY3Rpb24sIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBldmVudFVpQmFzZXMsIGNvbnRleHQsIC4uLmV4dHJhQXJncyksXG4gICAgICAgICAgICBidXNpbmVzc0hvdXJTZWdzOiB0aGlzLnNsaWNlQnVzaW5lc3NIb3Vycyhwcm9wcy5idXNpbmVzc0hvdXJzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgY29udGV4dCwgLi4uZXh0cmFBcmdzKSxcbiAgICAgICAgICAgIGZnRXZlbnRTZWdzOiBldmVudFNlZ3MuZmcsXG4gICAgICAgICAgICBiZ0V2ZW50U2VnczogZXZlbnRTZWdzLmJnLFxuICAgICAgICAgICAgZXZlbnREcmFnOiB0aGlzLnNsaWNlRXZlbnREcmFnKHByb3BzLmV2ZW50RHJhZywgZXZlbnRVaUJhc2VzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgLi4uZXh0cmFBcmdzKSxcbiAgICAgICAgICAgIGV2ZW50UmVzaXplOiB0aGlzLnNsaWNlRXZlbnRSZXNpemUocHJvcHMuZXZlbnRSZXNpemUsIGV2ZW50VWlCYXNlcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIC4uLmV4dHJhQXJncyksXG4gICAgICAgICAgICBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sXG4gICAgICAgIH07IC8vIFRPRE86IGdpdmUgaW50ZXJhY3Rpb25TZWdzP1xuICAgIH1cbiAgICBzbGljZU5vd0RhdGUoLy8gZG9lcyBub3QgbWVtb2l6ZVxuICAgIGRhdGUsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBjb250ZXh0LCAuLi5leHRyYUFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NsaWNlRGF0ZVNwYW4oeyByYW5nZTogeyBzdGFydDogZGF0ZSwgZW5kOiBhZGRNcyhkYXRlLCAxKSB9LCBhbGxEYXk6IGZhbHNlIH0sIC8vIGFkZCAxIG1zLCBwcm90ZWN0IGFnYWluc3QgbnVsbCByYW5nZVxuICAgICAgICBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwge30sIGNvbnRleHQsIC4uLmV4dHJhQXJncyk7XG4gICAgfVxuICAgIF9zbGljZUJ1c2luZXNzSG91cnMoYnVzaW5lc3NIb3VycywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIGNvbnRleHQsIC4uLmV4dHJhQXJncykge1xuICAgICAgICBpZiAoIWJ1c2luZXNzSG91cnMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc2xpY2VFdmVudFN0b3JlKGV4cGFuZFJlY3VycmluZyhidXNpbmVzc0hvdXJzLCBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIEJvb2xlYW4obmV4dERheVRocmVzaG9sZCkpLCBjb250ZXh0KSwge30sIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCAuLi5leHRyYUFyZ3MpLmJnO1xuICAgIH1cbiAgICBfc2xpY2VFdmVudFN0b3JlKGV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIC4uLmV4dHJhQXJncykge1xuICAgICAgICBpZiAoZXZlbnRTdG9yZSkge1xuICAgICAgICAgICAgbGV0IHJhbmdlUmVzID0gc2xpY2VFdmVudFN0b3JlKGV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlcywgY29tcHV0ZUFjdGl2ZVJhbmdlKGRhdGVQcm9maWxlLCBCb29sZWFuKG5leHREYXlUaHJlc2hvbGQpKSwgbmV4dERheVRocmVzaG9sZCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJnOiB0aGlzLnNsaWNlRXZlbnRSYW5nZXMocmFuZ2VSZXMuYmcsIGV4dHJhQXJncyksXG4gICAgICAgICAgICAgICAgZmc6IHRoaXMuc2xpY2VFdmVudFJhbmdlcyhyYW5nZVJlcy5mZywgZXh0cmFBcmdzKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgYmc6IFtdLCBmZzogW10gfTtcbiAgICB9XG4gICAgX3NsaWNlSW50ZXJhY3Rpb24oaW50ZXJhY3Rpb24sIGV2ZW50VWlCYXNlcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIC4uLmV4dHJhQXJncykge1xuICAgICAgICBpZiAoIWludGVyYWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmFuZ2VSZXMgPSBzbGljZUV2ZW50U3RvcmUoaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cywgZXZlbnRVaUJhc2VzLCBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIEJvb2xlYW4obmV4dERheVRocmVzaG9sZCkpLCBuZXh0RGF5VGhyZXNob2xkKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlZ3M6IHRoaXMuc2xpY2VFdmVudFJhbmdlcyhyYW5nZVJlcy5mZywgZXh0cmFBcmdzKSxcbiAgICAgICAgICAgIGFmZmVjdGVkSW5zdGFuY2VzOiBpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cy5pbnN0YW5jZXMsXG4gICAgICAgICAgICBpc0V2ZW50OiBpbnRlcmFjdGlvbi5pc0V2ZW50LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfc2xpY2VEYXRlU3BhbihkYXRlU3BhbiwgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIGV2ZW50VWlCYXNlcywgY29udGV4dCwgLi4uZXh0cmFBcmdzKSB7XG4gICAgICAgIGlmICghZGF0ZVNwYW4pIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYWN0aXZlUmFuZ2UgPSBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIEJvb2xlYW4obmV4dERheVRocmVzaG9sZCkpO1xuICAgICAgICBsZXQgYWN0aXZlRGF0ZVNwYW5SYW5nZSA9IGludGVyc2VjdFJhbmdlcyhkYXRlU3Bhbi5yYW5nZSwgYWN0aXZlUmFuZ2UpO1xuICAgICAgICBpZiAoYWN0aXZlRGF0ZVNwYW5SYW5nZSkge1xuICAgICAgICAgICAgZGF0ZVNwYW4gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGVTcGFuKSwgeyByYW5nZTogYWN0aXZlRGF0ZVNwYW5SYW5nZSB9KTtcbiAgICAgICAgICAgIGxldCBldmVudFJhbmdlID0gZmFicmljYXRlRXZlbnRSYW5nZShkYXRlU3BhbiwgZXZlbnRVaUJhc2VzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGxldCBzZWdzID0gdGhpcy5zbGljZVJhbmdlKGRhdGVTcGFuLnJhbmdlLCAuLi5leHRyYUFyZ3MpO1xuICAgICAgICAgICAgZm9yIChsZXQgc2VnIG9mIHNlZ3MpIHtcbiAgICAgICAgICAgICAgICBzZWcuZXZlbnRSYW5nZSA9IGV2ZW50UmFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VncztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIC8qXG4gICAgXCJjb21wbGV0ZVwiIHNlZyBtZWFucyBpdCBoYXMgY29tcG9uZW50IGFuZCBldmVudFJhbmdlXG4gICAgKi9cbiAgICBzbGljZUV2ZW50UmFuZ2VzKGV2ZW50UmFuZ2VzLCBleHRyYUFyZ3MpIHtcbiAgICAgICAgbGV0IHNlZ3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZXZlbnRSYW5nZSBvZiBldmVudFJhbmdlcykge1xuICAgICAgICAgICAgc2Vncy5wdXNoKC4uLnRoaXMuc2xpY2VFdmVudFJhbmdlKGV2ZW50UmFuZ2UsIGV4dHJhQXJncykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdzO1xuICAgIH1cbiAgICAvKlxuICAgIFwiY29tcGxldGVcIiBzZWcgbWVhbnMgaXQgaGFzIGNvbXBvbmVudCBhbmQgZXZlbnRSYW5nZVxuICAgICovXG4gICAgc2xpY2VFdmVudFJhbmdlKGV2ZW50UmFuZ2UsIGV4dHJhQXJncykge1xuICAgICAgICBsZXQgZGF0ZVJhbmdlID0gZXZlbnRSYW5nZS5yYW5nZTtcbiAgICAgICAgLy8gaGFjayB0byBtYWtlIG11bHRpLWRheSBldmVudHMgdGhhdCBhcmUgYmVpbmcgZm9yY2UtZGlzcGxheWVkIGFzIGxpc3QtaXRlbXMgdG8gdGFrZSB1cCBvbmx5IG9uZSBkYXlcbiAgICAgICAgaWYgKHRoaXMuZm9yY2VEYXlJZkxpc3RJdGVtICYmIGV2ZW50UmFuZ2UudWkuZGlzcGxheSA9PT0gJ2xpc3QtaXRlbScpIHtcbiAgICAgICAgICAgIGRhdGVSYW5nZSA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogZGF0ZVJhbmdlLnN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDogYWRkRGF5cyhkYXRlUmFuZ2Uuc3RhcnQsIDEpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2VncyA9IHRoaXMuc2xpY2VSYW5nZShkYXRlUmFuZ2UsIC4uLmV4dHJhQXJncyk7XG4gICAgICAgIGZvciAobGV0IHNlZyBvZiBzZWdzKSB7XG4gICAgICAgICAgICBzZWcuZXZlbnRSYW5nZSA9IGV2ZW50UmFuZ2U7XG4gICAgICAgICAgICBzZWcuaXNTdGFydCA9IGV2ZW50UmFuZ2UuaXNTdGFydCAmJiBzZWcuaXNTdGFydDtcbiAgICAgICAgICAgIHNlZy5pc0VuZCA9IGV2ZW50UmFuZ2UuaXNFbmQgJiYgc2VnLmlzRW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdzO1xuICAgIH1cbn1cbi8qXG5mb3IgaW5jb3Jwb3JhdGluZyBzbG90TWluVGltZS9zbG90TWF4VGltZSBpZiBhcHByb3ByaWF0ZVxuVE9ETzogc2hvdWxkIGJlIHBhcnQgb2YgRGF0ZVByb2ZpbGUhXG5UaW1lbGluZURhdGVQcm9maWxlIGFscmVhZHkgZG9lcyB0aGlzIGJ0d1xuKi9cbmZ1bmN0aW9uIGNvbXB1dGVBY3RpdmVSYW5nZShkYXRlUHJvZmlsZSwgaXNDb21wb25lbnRBbGxEYXkpIHtcbiAgICBsZXQgcmFuZ2UgPSBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZTtcbiAgICBpZiAoaXNDb21wb25lbnRBbGxEYXkpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogYWRkTXMocmFuZ2Uuc3RhcnQsIGRhdGVQcm9maWxlLnNsb3RNaW5UaW1lLm1pbGxpc2Vjb25kcyksXG4gICAgICAgIGVuZDogYWRkTXMocmFuZ2UuZW5kLCBkYXRlUHJvZmlsZS5zbG90TWF4VGltZS5taWxsaXNlY29uZHMgLSA4NjRlNSksIC8vIDg2NGU1ID0gbXMgaW4gYSBkYXlcbiAgICB9O1xufVxuXG4vLyBoaWdoLWxldmVsIHNlZ21lbnRpbmctYXdhcmUgdGVzdGVyIGZ1bmN0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBpc0ludGVyYWN0aW9uVmFsaWQoaW50ZXJhY3Rpb24sIGRhdGVQcm9maWxlLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgaW5zdGFuY2VzIH0gPSBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzO1xuICAgIGZvciAobGV0IGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgIGlmICghcmFuZ2VDb250YWluc1JhbmdlKGRhdGVQcm9maWxlLnZhbGlkUmFuZ2UsIGluc3RhbmNlc1tpbnN0YW5jZUlkXS5yYW5nZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXNOZXdQcm9wc1ZhbGlkKHsgZXZlbnREcmFnOiBpbnRlcmFjdGlvbiB9LCBjb250ZXh0KTsgLy8gSEFDSzogdGhlIGV2ZW50RHJhZyBwcm9wcyBpcyB1c2VkIGZvciBBTEwgaW50ZXJhY3Rpb25zXG59XG5mdW5jdGlvbiBpc0RhdGVTZWxlY3Rpb25WYWxpZChkYXRlU2VsZWN0aW9uLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIGlmICghcmFuZ2VDb250YWluc1JhbmdlKGRhdGVQcm9maWxlLnZhbGlkUmFuZ2UsIGRhdGVTZWxlY3Rpb24ucmFuZ2UpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzTmV3UHJvcHNWYWxpZCh7IGRhdGVTZWxlY3Rpb24gfSwgY29udGV4dCk7XG59XG5mdW5jdGlvbiBpc05ld1Byb3BzVmFsaWQobmV3UHJvcHMsIGNvbnRleHQpIHtcbiAgICBsZXQgY2FsZW5kYXJTdGF0ZSA9IGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKTtcbiAgICBsZXQgcHJvcHMgPSBPYmplY3QuYXNzaWduKHsgYnVzaW5lc3NIb3VyczogY2FsZW5kYXJTdGF0ZS5idXNpbmVzc0hvdXJzLCBkYXRlU2VsZWN0aW9uOiAnJywgZXZlbnRTdG9yZTogY2FsZW5kYXJTdGF0ZS5ldmVudFN0b3JlLCBldmVudFVpQmFzZXM6IGNhbGVuZGFyU3RhdGUuZXZlbnRVaUJhc2VzLCBldmVudFNlbGVjdGlvbjogJycsIGV2ZW50RHJhZzogbnVsbCwgZXZlbnRSZXNpemU6IG51bGwgfSwgbmV3UHJvcHMpO1xuICAgIHJldHVybiAoY29udGV4dC5wbHVnaW5Ib29rcy5pc1Byb3BzVmFsaWQgfHwgaXNQcm9wc1ZhbGlkKShwcm9wcywgY29udGV4dCk7XG59XG5mdW5jdGlvbiBpc1Byb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSA9IHt9LCBmaWx0ZXJDb25maWcpIHtcbiAgICBpZiAoc3RhdGUuZXZlbnREcmFnICYmICFpc0ludGVyYWN0aW9uUHJvcHNWYWxpZChzdGF0ZSwgY29udGV4dCwgZGF0ZVNwYW5NZXRhLCBmaWx0ZXJDb25maWcpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmRhdGVTZWxlY3Rpb24gJiYgIWlzRGF0ZVNlbGVjdGlvblByb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLy8gTW92aW5nIEV2ZW50IFZhbGlkYXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gaXNJbnRlcmFjdGlvblByb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSB7XG4gICAgbGV0IGN1cnJlbnRTdGF0ZSA9IGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKTtcbiAgICBsZXQgaW50ZXJhY3Rpb24gPSBzdGF0ZS5ldmVudERyYWc7IC8vIEhBQ0s6IHRoZSBldmVudERyYWcgcHJvcHMgaXMgdXNlZCBmb3IgQUxMIGludGVyYWN0aW9uc1xuICAgIGxldCBzdWJqZWN0RXZlbnRTdG9yZSA9IGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHM7XG4gICAgbGV0IHN1YmplY3REZWZzID0gc3ViamVjdEV2ZW50U3RvcmUuZGVmcztcbiAgICBsZXQgc3ViamVjdEluc3RhbmNlcyA9IHN1YmplY3RFdmVudFN0b3JlLmluc3RhbmNlcztcbiAgICBsZXQgc3ViamVjdENvbmZpZ3MgPSBjb21waWxlRXZlbnRVaXMoc3ViamVjdERlZnMsIGludGVyYWN0aW9uLmlzRXZlbnQgP1xuICAgICAgICBzdGF0ZS5ldmVudFVpQmFzZXMgOlxuICAgICAgICB7ICcnOiBjdXJyZW50U3RhdGUuc2VsZWN0aW9uQ29uZmlnIH0pO1xuICAgIGlmIChmaWx0ZXJDb25maWcpIHtcbiAgICAgICAgc3ViamVjdENvbmZpZ3MgPSBtYXBIYXNoKHN1YmplY3RDb25maWdzLCBmaWx0ZXJDb25maWcpO1xuICAgIH1cbiAgICAvLyBleGNsdWRlIHRoZSBzdWJqZWN0IGV2ZW50cy4gVE9ETzogZXhjbHVkZSBkZWZzIHRvbz9cbiAgICBsZXQgb3RoZXJFdmVudFN0b3JlID0gZXhjbHVkZUluc3RhbmNlcyhzdGF0ZS5ldmVudFN0b3JlLCBpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cy5pbnN0YW5jZXMpO1xuICAgIGxldCBvdGhlckRlZnMgPSBvdGhlckV2ZW50U3RvcmUuZGVmcztcbiAgICBsZXQgb3RoZXJJbnN0YW5jZXMgPSBvdGhlckV2ZW50U3RvcmUuaW5zdGFuY2VzO1xuICAgIGxldCBvdGhlckNvbmZpZ3MgPSBjb21waWxlRXZlbnRVaXMob3RoZXJEZWZzLCBzdGF0ZS5ldmVudFVpQmFzZXMpO1xuICAgIGZvciAobGV0IHN1YmplY3RJbnN0YW5jZUlkIGluIHN1YmplY3RJbnN0YW5jZXMpIHtcbiAgICAgICAgbGV0IHN1YmplY3RJbnN0YW5jZSA9IHN1YmplY3RJbnN0YW5jZXNbc3ViamVjdEluc3RhbmNlSWRdO1xuICAgICAgICBsZXQgc3ViamVjdFJhbmdlID0gc3ViamVjdEluc3RhbmNlLnJhbmdlO1xuICAgICAgICBsZXQgc3ViamVjdENvbmZpZyA9IHN1YmplY3RDb25maWdzW3N1YmplY3RJbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIGxldCBzdWJqZWN0RGVmID0gc3ViamVjdERlZnNbc3ViamVjdEluc3RhbmNlLmRlZklkXTtcbiAgICAgICAgLy8gY29uc3RyYWludFxuICAgICAgICBpZiAoIWFsbENvbnN0cmFpbnRzUGFzcyhzdWJqZWN0Q29uZmlnLmNvbnN0cmFpbnRzLCBzdWJqZWN0UmFuZ2UsIG90aGVyRXZlbnRTdG9yZSwgc3RhdGUuYnVzaW5lc3NIb3VycywgY29udGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvdmVybGFwXG4gICAgICAgIGxldCB7IGV2ZW50T3ZlcmxhcCB9ID0gY29udGV4dC5vcHRpb25zO1xuICAgICAgICBsZXQgZXZlbnRPdmVybGFwRnVuYyA9IHR5cGVvZiBldmVudE92ZXJsYXAgPT09ICdmdW5jdGlvbicgPyBldmVudE92ZXJsYXAgOiBudWxsO1xuICAgICAgICBmb3IgKGxldCBvdGhlckluc3RhbmNlSWQgaW4gb3RoZXJJbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIGxldCBvdGhlckluc3RhbmNlID0gb3RoZXJJbnN0YW5jZXNbb3RoZXJJbnN0YW5jZUlkXTtcbiAgICAgICAgICAgIC8vIGludGVyc2VjdCEgZXZhbHVhdGVcbiAgICAgICAgICAgIGlmIChyYW5nZXNJbnRlcnNlY3Qoc3ViamVjdFJhbmdlLCBvdGhlckluc3RhbmNlLnJhbmdlKSkge1xuICAgICAgICAgICAgICAgIGxldCBvdGhlck92ZXJsYXAgPSBvdGhlckNvbmZpZ3Nbb3RoZXJJbnN0YW5jZS5kZWZJZF0ub3ZlcmxhcDtcbiAgICAgICAgICAgICAgICAvLyBjb25zaWRlciB0aGUgb3RoZXIgZXZlbnQncyBvdmVybGFwLiBvbmx5IGRvIHRoaXMgaWYgdGhlIHN1YmplY3QgZXZlbnQgaXMgYSBcInJlYWxcIiBldmVudFxuICAgICAgICAgICAgICAgIGlmIChvdGhlck92ZXJsYXAgPT09IGZhbHNlICYmIGludGVyYWN0aW9uLmlzRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3ViamVjdENvbmZpZy5vdmVybGFwID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChldmVudE92ZXJsYXBGdW5jICYmICFldmVudE92ZXJsYXBGdW5jKG5ldyBFdmVudEltcGwoY29udGV4dCwgb3RoZXJEZWZzW290aGVySW5zdGFuY2UuZGVmSWRdLCBvdGhlckluc3RhbmNlKSwgLy8gc3RpbGwgZXZlbnRcbiAgICAgICAgICAgICAgICBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIHN1YmplY3REZWYsIHN1YmplY3RJbnN0YW5jZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWxsb3cgKGEgZnVuY3Rpb24pXG4gICAgICAgIGxldCBjYWxlbmRhckV2ZW50U3RvcmUgPSBjdXJyZW50U3RhdGUuZXZlbnRTdG9yZTsgLy8gbmVlZCBnbG9iYWwtdG8tY2FsZW5kYXIsIG5vdCBsb2NhbCB0byBjb21wb25lbnQgKHNwbGl0dGFibGUpc3RhdGVcbiAgICAgICAgZm9yIChsZXQgc3ViamVjdEFsbG93IG9mIHN1YmplY3RDb25maWcuYWxsb3dzKSB7XG4gICAgICAgICAgICBsZXQgc3ViamVjdERhdGVTcGFuID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRlU3Bhbk1ldGEpLCB7IHJhbmdlOiBzdWJqZWN0SW5zdGFuY2UucmFuZ2UsIGFsbERheTogc3ViamVjdERlZi5hbGxEYXkgfSk7XG4gICAgICAgICAgICBsZXQgb3JpZ0RlZiA9IGNhbGVuZGFyRXZlbnRTdG9yZS5kZWZzW3N1YmplY3REZWYuZGVmSWRdO1xuICAgICAgICAgICAgbGV0IG9yaWdJbnN0YW5jZSA9IGNhbGVuZGFyRXZlbnRTdG9yZS5pbnN0YW5jZXNbc3ViamVjdEluc3RhbmNlSWRdO1xuICAgICAgICAgICAgbGV0IGV2ZW50QXBpO1xuICAgICAgICAgICAgaWYgKG9yaWdEZWYpIHsgLy8gd2FzIHByZXZpb3VzbHkgaW4gdGhlIGNhbGVuZGFyXG4gICAgICAgICAgICAgICAgZXZlbnRBcGkgPSBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIG9yaWdEZWYsIG9yaWdJbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgLy8gd2FzIGFuIGV4dGVybmFsIGV2ZW50XG4gICAgICAgICAgICAgICAgZXZlbnRBcGkgPSBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIHN1YmplY3REZWYpOyAvLyBubyBpbnN0YW5jZSwgYmVjYXVzZSBoYWQgbm8gZGF0ZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3ViamVjdEFsbG93KGJ1aWxkRGF0ZVNwYW5BcGlXaXRoQ29udGV4dChzdWJqZWN0RGF0ZVNwYW4sIGNvbnRleHQpLCBldmVudEFwaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBEYXRlIFNlbGVjdGlvbiBWYWxpZGF0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGlzRGF0ZVNlbGVjdGlvblByb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSB7XG4gICAgbGV0IHJlbGV2YW50RXZlbnRTdG9yZSA9IHN0YXRlLmV2ZW50U3RvcmU7XG4gICAgbGV0IHJlbGV2YW50RGVmcyA9IHJlbGV2YW50RXZlbnRTdG9yZS5kZWZzO1xuICAgIGxldCByZWxldmFudEluc3RhbmNlcyA9IHJlbGV2YW50RXZlbnRTdG9yZS5pbnN0YW5jZXM7XG4gICAgbGV0IHNlbGVjdGlvbiA9IHN0YXRlLmRhdGVTZWxlY3Rpb247XG4gICAgbGV0IHNlbGVjdGlvblJhbmdlID0gc2VsZWN0aW9uLnJhbmdlO1xuICAgIGxldCB7IHNlbGVjdGlvbkNvbmZpZyB9ID0gY29udGV4dC5nZXRDdXJyZW50RGF0YSgpO1xuICAgIGlmIChmaWx0ZXJDb25maWcpIHtcbiAgICAgICAgc2VsZWN0aW9uQ29uZmlnID0gZmlsdGVyQ29uZmlnKHNlbGVjdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIC8vIGNvbnN0cmFpbnRcbiAgICBpZiAoIWFsbENvbnN0cmFpbnRzUGFzcyhzZWxlY3Rpb25Db25maWcuY29uc3RyYWludHMsIHNlbGVjdGlvblJhbmdlLCByZWxldmFudEV2ZW50U3RvcmUsIHN0YXRlLmJ1c2luZXNzSG91cnMsIGNvbnRleHQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gb3ZlcmxhcFxuICAgIGxldCB7IHNlbGVjdE92ZXJsYXAgfSA9IGNvbnRleHQub3B0aW9ucztcbiAgICBsZXQgc2VsZWN0T3ZlcmxhcEZ1bmMgPSB0eXBlb2Ygc2VsZWN0T3ZlcmxhcCA9PT0gJ2Z1bmN0aW9uJyA/IHNlbGVjdE92ZXJsYXAgOiBudWxsO1xuICAgIGZvciAobGV0IHJlbGV2YW50SW5zdGFuY2VJZCBpbiByZWxldmFudEluc3RhbmNlcykge1xuICAgICAgICBsZXQgcmVsZXZhbnRJbnN0YW5jZSA9IHJlbGV2YW50SW5zdGFuY2VzW3JlbGV2YW50SW5zdGFuY2VJZF07XG4gICAgICAgIC8vIGludGVyc2VjdCEgZXZhbHVhdGVcbiAgICAgICAgaWYgKHJhbmdlc0ludGVyc2VjdChzZWxlY3Rpb25SYW5nZSwgcmVsZXZhbnRJbnN0YW5jZS5yYW5nZSkpIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb25Db25maWcub3ZlcmxhcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0T3ZlcmxhcEZ1bmMgJiYgIXNlbGVjdE92ZXJsYXBGdW5jKG5ldyBFdmVudEltcGwoY29udGV4dCwgcmVsZXZhbnREZWZzW3JlbGV2YW50SW5zdGFuY2UuZGVmSWRdLCByZWxldmFudEluc3RhbmNlKSwgbnVsbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYWxsb3cgKGEgZnVuY3Rpb24pXG4gICAgZm9yIChsZXQgc2VsZWN0aW9uQWxsb3cgb2Ygc2VsZWN0aW9uQ29uZmlnLmFsbG93cykge1xuICAgICAgICBsZXQgZnVsbERhdGVTcGFuID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRlU3Bhbk1ldGEpLCBzZWxlY3Rpb24pO1xuICAgICAgICBpZiAoIXNlbGVjdGlvbkFsbG93KGJ1aWxkRGF0ZVNwYW5BcGlXaXRoQ29udGV4dChmdWxsRGF0ZVNwYW4sIGNvbnRleHQpLCBudWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLy8gQ29uc3RyYWludCBVdGlsc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBhbGxDb25zdHJhaW50c1Bhc3MoY29uc3RyYWludHMsIHN1YmplY3RSYW5nZSwgb3RoZXJFdmVudFN0b3JlLCBidXNpbmVzc0hvdXJzVW5leHBhbmRlZCwgY29udGV4dCkge1xuICAgIGZvciAobGV0IGNvbnN0cmFpbnQgb2YgY29uc3RyYWludHMpIHtcbiAgICAgICAgaWYgKCFhbnlSYW5nZXNDb250YWluUmFuZ2UoY29uc3RyYWludFRvUmFuZ2VzKGNvbnN0cmFpbnQsIHN1YmplY3RSYW5nZSwgb3RoZXJFdmVudFN0b3JlLCBidXNpbmVzc0hvdXJzVW5leHBhbmRlZCwgY29udGV4dCksIHN1YmplY3RSYW5nZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNvbnN0cmFpbnRUb1Jhbmdlcyhjb25zdHJhaW50LCBzdWJqZWN0UmFuZ2UsIC8vIGZvciBleHBhbmRpbmcgYSByZWN1cnJpbmcgY29uc3RyYWludCwgb3IgZXhwYW5kaW5nIGJ1c2luZXNzIGhvdXJzXG5vdGhlckV2ZW50U3RvcmUsIC8vIGZvciBpZiBjb25zdHJhaW50IGlzIGFuIGV2ZW4gZ3JvdXAgSURcbmJ1c2luZXNzSG91cnNVbmV4cGFuZGVkLCAvLyBmb3IgaWYgY29uc3RyYWludCBpcyAnYnVzaW5lc3NIb3VycydcbmNvbnRleHQpIHtcbiAgICBpZiAoY29uc3RyYWludCA9PT0gJ2J1c2luZXNzSG91cnMnKSB7XG4gICAgICAgIHJldHVybiBldmVudFN0b3JlVG9SYW5nZXMoZXhwYW5kUmVjdXJyaW5nKGJ1c2luZXNzSG91cnNVbmV4cGFuZGVkLCBzdWJqZWN0UmFuZ2UsIGNvbnRleHQpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb25zdHJhaW50ID09PSAnc3RyaW5nJykgeyAvLyBhbiBncm91cCBJRFxuICAgICAgICByZXR1cm4gZXZlbnRTdG9yZVRvUmFuZ2VzKGZpbHRlckV2ZW50U3RvcmVEZWZzKG90aGVyRXZlbnRTdG9yZSwgKGV2ZW50RGVmKSA9PiBldmVudERlZi5ncm91cElkID09PSBjb25zdHJhaW50KSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29uc3RyYWludCA9PT0gJ29iamVjdCcgJiYgY29uc3RyYWludCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgcmV0dXJuIGV2ZW50U3RvcmVUb1JhbmdlcyhleHBhbmRSZWN1cnJpbmcoY29uc3RyYWludCwgc3ViamVjdFJhbmdlLCBjb250ZXh0KSk7XG4gICAgfVxuICAgIHJldHVybiBbXTsgLy8gaWYgaXQncyBmYWxzZVxufVxuLy8gVE9ETzogbW92ZSB0byBldmVudC1zdG9yZSBmaWxlP1xuZnVuY3Rpb24gZXZlbnRTdG9yZVRvUmFuZ2VzKGV2ZW50U3RvcmUpIHtcbiAgICBsZXQgeyBpbnN0YW5jZXMgfSA9IGV2ZW50U3RvcmU7XG4gICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgIHJhbmdlcy5wdXNoKGluc3RhbmNlc1tpbnN0YW5jZUlkXS5yYW5nZSk7XG4gICAgfVxuICAgIHJldHVybiByYW5nZXM7XG59XG4vLyBUT0RPOiBtb3ZlIHRvIGdlb20gZmlsZT9cbmZ1bmN0aW9uIGFueVJhbmdlc0NvbnRhaW5SYW5nZShvdXRlclJhbmdlcywgaW5uZXJSYW5nZSkge1xuICAgIGZvciAobGV0IG91dGVyUmFuZ2Ugb2Ygb3V0ZXJSYW5nZXMpIHtcbiAgICAgICAgaWYgKHJhbmdlQ29udGFpbnNSYW5nZShvdXRlclJhbmdlLCBpbm5lclJhbmdlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5jb25zdCBWSVNJQkxFX0hJRERFTl9SRSA9IC9eKHZpc2libGV8aGlkZGVuKSQvO1xuY2xhc3MgU2Nyb2xsZXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVFbCA9IChlbCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICAgICAgc2V0UmVmKHRoaXMucHJvcHMuZWxSZWYsIGVsKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgbGlxdWlkLCBsaXF1aWRJc0Fic29sdXRlIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IGlzQWJzb2x1dGUgPSBsaXF1aWQgJiYgbGlxdWlkSXNBYnNvbHV0ZTtcbiAgICAgICAgbGV0IGNsYXNzTmFtZSA9IFsnZmMtc2Nyb2xsZXInXTtcbiAgICAgICAgaWYgKGxpcXVpZCkge1xuICAgICAgICAgICAgaWYgKGxpcXVpZElzQWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUucHVzaCgnZmMtc2Nyb2xsZXItbGlxdWlkLWFic29sdXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUucHVzaCgnZmMtc2Nyb2xsZXItbGlxdWlkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiB0aGlzLmhhbmRsZUVsLCBjbGFzc05hbWU6IGNsYXNzTmFtZS5qb2luKCcgJyksIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3dYOiBwcm9wcy5vdmVyZmxvd1gsXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3dZOiBwcm9wcy5vdmVyZmxvd1ksXG4gICAgICAgICAgICAgICAgbGVmdDogKGlzQWJzb2x1dGUgJiYgLShwcm9wcy5vdmVyY29tZUxlZnQgfHwgMCkpIHx8ICcnLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiAoaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lUmlnaHQgfHwgMCkpIHx8ICcnLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogKGlzQWJzb2x1dGUgJiYgLShwcm9wcy5vdmVyY29tZUJvdHRvbSB8fCAwKSkgfHwgJycsXG4gICAgICAgICAgICAgICAgbWFyZ2luTGVmdDogKCFpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVMZWZ0IHx8IDApKSB8fCAnJyxcbiAgICAgICAgICAgICAgICBtYXJnaW5SaWdodDogKCFpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVSaWdodCB8fCAwKSkgfHwgJycsXG4gICAgICAgICAgICAgICAgbWFyZ2luQm90dG9tOiAoIWlzQWJzb2x1dGUgJiYgLShwcm9wcy5vdmVyY29tZUJvdHRvbSB8fCAwKSkgfHwgJycsXG4gICAgICAgICAgICAgICAgbWF4SGVpZ2h0OiBwcm9wcy5tYXhIZWlnaHQgfHwgJycsXG4gICAgICAgICAgICB9IH0sIHByb3BzLmNoaWxkcmVuKSk7XG4gICAgfVxuICAgIG5lZWRzWFNjcm9sbGluZygpIHtcbiAgICAgICAgaWYgKFZJU0lCTEVfSElEREVOX1JFLnRlc3QodGhpcy5wcm9wcy5vdmVyZmxvd1gpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGVzdGluZyBzY3JvbGxXaWR0aD5jbGllbnRXaWR0aCBpcyB1bnJlbGlhYmxlIGNyb3NzLWJyb3dzZXIgd2hlbiBwaXhlbCBoZWlnaHRzIGFyZW4ndCBpbnRlZ2Vycy5cbiAgICAgICAgLy8gbXVjaCBtb3JlIHJlbGlhYmxlIHRvIHNlZSBpZiBjaGlsZHJlbiBhcmUgdGFsbGVyIHRoYW4gdGhlIHNjcm9sbGVyLCBldmVuIHRobyBkb2Vzbid0IGFjY291bnQgZm9yXG4gICAgICAgIC8vIGlubmVyLWNoaWxkIG1hcmdpbnMgYW5kIGFic29sdXRlIHBvc2l0aW9uaW5nXG4gICAgICAgIGxldCB7IGVsIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcmVhbENsaWVudFdpZHRoID0gdGhpcy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAtIHRoaXMuZ2V0WVNjcm9sbGJhcldpZHRoKCk7XG4gICAgICAgIGxldCB7IGNoaWxkcmVuIH0gPSBlbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgbGV0IGNoaWxkRWwgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoID4gcmVhbENsaWVudFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBuZWVkc1lTY3JvbGxpbmcoKSB7XG4gICAgICAgIGlmIChWSVNJQkxFX0hJRERFTl9SRS50ZXN0KHRoaXMucHJvcHMub3ZlcmZsb3dZKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRlc3Rpbmcgc2Nyb2xsSGVpZ2h0PmNsaWVudEhlaWdodCBpcyB1bnJlbGlhYmxlIGNyb3NzLWJyb3dzZXIgd2hlbiBwaXhlbCBoZWlnaHRzIGFyZW4ndCBpbnRlZ2Vycy5cbiAgICAgICAgLy8gbXVjaCBtb3JlIHJlbGlhYmxlIHRvIHNlZSBpZiBjaGlsZHJlbiBhcmUgdGFsbGVyIHRoYW4gdGhlIHNjcm9sbGVyLCBldmVuIHRobyBkb2Vzbid0IGFjY291bnQgZm9yXG4gICAgICAgIC8vIGlubmVyLWNoaWxkIG1hcmdpbnMgYW5kIGFic29sdXRlIHBvc2l0aW9uaW5nXG4gICAgICAgIGxldCB7IGVsIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcmVhbENsaWVudEhlaWdodCA9IHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0IC0gdGhpcy5nZXRYU2Nyb2xsYmFyV2lkdGgoKTtcbiAgICAgICAgbGV0IHsgY2hpbGRyZW4gfSA9IGVsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGRFbCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0ID4gcmVhbENsaWVudEhlaWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0WFNjcm9sbGJhcldpZHRoKCkge1xuICAgICAgICBpZiAoVklTSUJMRV9ISURERU5fUkUudGVzdCh0aGlzLnByb3BzLm92ZXJmbG93WCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsLm9mZnNldEhlaWdodCAtIHRoaXMuZWwuY2xpZW50SGVpZ2h0OyAvLyBvbmx5IHdvcmtzIGJlY2F1c2Ugd2UgZ3VhcmFudGVlIG5vIGJvcmRlcnMuIFRPRE86IGFkZCB0byBDU1Mgd2l0aCBpbXBvcnRhbnQ/XG4gICAgfVxuICAgIGdldFlTY3JvbGxiYXJXaWR0aCgpIHtcbiAgICAgICAgaWYgKFZJU0lCTEVfSElEREVOX1JFLnRlc3QodGhpcy5wcm9wcy5vdmVyZmxvd1kpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbC5vZmZzZXRXaWR0aCAtIHRoaXMuZWwuY2xpZW50V2lkdGg7IC8vIG9ubHkgd29ya3MgYmVjYXVzZSB3ZSBndWFyYW50ZWUgbm8gYm9yZGVycy4gVE9ETzogYWRkIHRvIENTUyB3aXRoIGltcG9ydGFudD9cbiAgICB9XG59XG5cbi8qXG5UT0RPOiBzb21laG93IGluZmVyIE90aGVyQXJncyBmcm9tIG1hc3RlckNhbGxiYWNrP1xuVE9ETzogaW5mZXIgUmVmVHlwZSBmcm9tIG1hc3RlckNhbGxiYWNrIGlmIHByb3ZpZGVkXG4qL1xuY2xhc3MgUmVmTWFwIHtcbiAgICBjb25zdHJ1Y3RvcihtYXN0ZXJDYWxsYmFjaykge1xuICAgICAgICB0aGlzLm1hc3RlckNhbGxiYWNrID0gbWFzdGVyQ2FsbGJhY2s7XG4gICAgICAgIHRoaXMuY3VycmVudE1hcCA9IHt9O1xuICAgICAgICB0aGlzLmRlcHRocyA9IHt9O1xuICAgICAgICB0aGlzLmNhbGxiYWNrTWFwID0ge307XG4gICAgICAgIHRoaXMuaGFuZGxlVmFsdWUgPSAodmFsLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGxldCB7IGRlcHRocywgY3VycmVudE1hcCB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCByZW1vdmVkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgYWRkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh2YWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBmb3IgYnVnLi4uIEFDVFVBTExZOiBjYW4gcHJvYmFibHkgZG8gYXdheSB3aXRoIHRoaXMgbm93IHRoYXQgY2FsbGVycyBkb24ndCBzaGFyZSBudW1lcmljIGluZGljZXMgYW55bW9yZVxuICAgICAgICAgICAgICAgIHJlbW92ZWQgPSAoa2V5IGluIGN1cnJlbnRNYXApO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXBba2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICBkZXB0aHNba2V5XSA9IChkZXB0aHNba2V5XSB8fCAwKSArIDE7XG4gICAgICAgICAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVwdGhzW2tleV0gLT0gMTtcbiAgICAgICAgICAgICAgICBpZiAoIWRlcHRoc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjdXJyZW50TWFwW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNhbGxiYWNrTWFwW2tleV07XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1hc3RlckNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXN0ZXJDYWxsYmFjayhudWxsLCBTdHJpbmcoa2V5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhZGRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hc3RlckNhbGxiYWNrKHZhbCwgU3RyaW5nKGtleSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgY3JlYXRlUmVmKGtleSkge1xuICAgICAgICBsZXQgcmVmQ2FsbGJhY2sgPSB0aGlzLmNhbGxiYWNrTWFwW2tleV07XG4gICAgICAgIGlmICghcmVmQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJlZkNhbGxiYWNrID0gdGhpcy5jYWxsYmFja01hcFtrZXldID0gKHZhbCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlVmFsdWUodmFsLCBTdHJpbmcoa2V5KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWZDYWxsYmFjaztcbiAgICB9XG4gICAgLy8gVE9ETzogY2hlY2sgY2FsbGVycyB0aGF0IGRvbid0IGNhcmUgYWJvdXQgb3JkZXIuIHNob3VsZCB1c2UgZ2V0QWxsIGluc3RlYWRcbiAgICAvLyBOT1RFOiB0aGlzIG1ldGhvZCBoYXMgYmVjb21lIGxlc3MgdmFsdWFibGUgbm93IHRoYXQgd2UgYXJlIGVuY291cmFnZWQgdG8gbWFwIG9yZGVyIGJ5IHNvbWUgb3RoZXIgaW5kZXhcbiAgICAvLyBUT0RPOiBwcm92aWRlIE9ORSBhcnJheS1leHBvcnQgZnVuY3Rpb24sIGJ1aWxkQXJyYXksIHdoaWNoIGZhaWxzIG9uIG5vbi1udW1lcmljIGluZGV4ZXMuIGNhbGxlciBjYW4gbWFuaXB1bGF0ZSBhbmQgXCJjb2xsZWN0XCJcbiAgICBjb2xsZWN0KHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBzdGVwKSB7XG4gICAgICAgIHJldHVybiBjb2xsZWN0RnJvbUhhc2godGhpcy5jdXJyZW50TWFwLCBzdGFydEluZGV4LCBlbmRJbmRleCwgc3RlcCk7XG4gICAgfVxuICAgIGdldEFsbCgpIHtcbiAgICAgICAgcmV0dXJuIGhhc2hWYWx1ZXNUb0FycmF5KHRoaXMuY3VycmVudE1hcCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjb21wdXRlU2hyaW5rV2lkdGgoY2h1bmtFbHMpIHtcbiAgICBsZXQgc2hyaW5rQ2VsbHMgPSBmaW5kRWxlbWVudHMoY2h1bmtFbHMsICcuZmMtc2Nyb2xsZ3JpZC1zaHJpbmsnKTtcbiAgICBsZXQgbGFyZ2VzdFdpZHRoID0gMDtcbiAgICBmb3IgKGxldCBzaHJpbmtDZWxsIG9mIHNocmlua0NlbGxzKSB7XG4gICAgICAgIGxhcmdlc3RXaWR0aCA9IE1hdGgubWF4KGxhcmdlc3RXaWR0aCwgY29tcHV0ZVNtYWxsZXN0Q2VsbFdpZHRoKHNocmlua0NlbGwpKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguY2VpbChsYXJnZXN0V2lkdGgpOyAvLyA8dGFibGU+IGVsZW1lbnRzIHdvcmsgYmVzdCB3aXRoIGludGVnZXJzLiByb3VuZCB1cCB0byBlbnN1cmUgY29udGVudHMgZml0c1xufVxuZnVuY3Rpb24gZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodChwcm9wcywgc2VjdGlvbkNvbmZpZykge1xuICAgIHJldHVybiBwcm9wcy5saXF1aWQgJiYgc2VjdGlvbkNvbmZpZy5saXF1aWQ7IC8vIGRvZXMgdGhlIHNlY3Rpb24gZG8gbGlxdWlkLWhlaWdodD8gKG5lZWQgdG8gaGF2ZSB3aG9sZSBzY3JvbGxncmlkIGxpcXVpZC1oZWlnaHQgYXMgd2VsbClcbn1cbmZ1bmN0aW9uIGdldEFsbG93WVNjcm9sbGluZyhwcm9wcywgc2VjdGlvbkNvbmZpZykge1xuICAgIHJldHVybiBzZWN0aW9uQ29uZmlnLm1heEhlaWdodCAhPSBudWxsIHx8IC8vIGlmIGl0cyBwb3NzaWJsZSBmb3IgdGhlIGhlaWdodCB0byBtYXggb3V0LCB3ZSBtaWdodCBuZWVkIHNjcm9sbGJhcnNcbiAgICAgICAgZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodChwcm9wcywgc2VjdGlvbkNvbmZpZyk7IC8vIGlmIHRoZSBzZWN0aW9uIGlzIGxpcXVpZCBoZWlnaHQsIGl0IG1pZ2h0IGNvbmRlbnNlIGVub3VnaCB0byByZXF1aXJlIHNjcm9sbGJhcnNcbn1cbi8vIFRPRE86IE9OTFkgdXNlIGBhcmdgLiBmb3JjZSBvdXQgaW50ZXJuYWwgZnVuY3Rpb24gdG8gdXNlIHNhbWUgQVBJXG5mdW5jdGlvbiByZW5kZXJDaHVua0NvbnRlbnQoc2VjdGlvbkNvbmZpZywgY2h1bmtDb25maWcsIGFyZywgaXNIZWFkZXIpIHtcbiAgICBsZXQgeyBleHBhbmRSb3dzIH0gPSBhcmc7XG4gICAgbGV0IGNvbnRlbnQgPSB0eXBlb2YgY2h1bmtDb25maWcuY29udGVudCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgIGNodW5rQ29uZmlnLmNvbnRlbnQoYXJnKSA6XG4gICAgICAgIGNyZWF0ZUVsZW1lbnQoJ3RhYmxlJywge1xuICAgICAgICAgICAgcm9sZTogJ3ByZXNlbnRhdGlvbicsXG4gICAgICAgICAgICBjbGFzc05hbWU6IFtcbiAgICAgICAgICAgICAgICBjaHVua0NvbmZpZy50YWJsZUNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICBzZWN0aW9uQ29uZmlnLnN5bmNSb3dIZWlnaHRzID8gJ2ZjLXNjcm9sbGdyaWQtc3luYy10YWJsZScgOiAnJyxcbiAgICAgICAgICAgIF0uam9pbignICcpLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBtaW5XaWR0aDogYXJnLnRhYmxlTWluV2lkdGgsXG4gICAgICAgICAgICAgICAgd2lkdGg6IGFyZy5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGV4cGFuZFJvd3MgPyBhcmcuY2xpZW50SGVpZ2h0IDogJycsIC8vIGNzcyBgaGVpZ2h0YCBvbiBhIDx0YWJsZT4gc2VydmVzIGFzIGEgbWluLWhlaWdodFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSwgYXJnLnRhYmxlQ29sR3JvdXBOb2RlLCBjcmVhdGVFbGVtZW50KGlzSGVhZGVyID8gJ3RoZWFkJyA6ICd0Ym9keScsIHtcbiAgICAgICAgICAgIHJvbGU6ICdwcmVzZW50YXRpb24nLFxuICAgICAgICB9LCB0eXBlb2YgY2h1bmtDb25maWcucm93Q29udGVudCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBjaHVua0NvbmZpZy5yb3dDb250ZW50KGFyZylcbiAgICAgICAgICAgIDogY2h1bmtDb25maWcucm93Q29udGVudCkpO1xuICAgIHJldHVybiBjb250ZW50O1xufVxuZnVuY3Rpb24gaXNDb2xQcm9wc0VxdWFsKGNvbHMwLCBjb2xzMSkge1xuICAgIHJldHVybiBpc0FycmF5c0VxdWFsKGNvbHMwLCBjb2xzMSwgaXNQcm9wc0VxdWFsKTtcbn1cbmZ1bmN0aW9uIHJlbmRlck1pY3JvQ29sR3JvdXAoY29scywgc2hyaW5rV2lkdGgpIHtcbiAgICBsZXQgY29sTm9kZXMgPSBbXTtcbiAgICAvKlxuICAgIGZvciBDb2xQcm9wcyB3aXRoIHNwYW5zLCBpdCB3b3VsZCBoYXZlIGJlZW4gZ3JlYXQgdG8gbWFrZSBhIHNpbmdsZSA8Y29sIHNwYW49XCJcIj5cbiAgICBIT1dFVkVSLCBDaHJvbWUgd2FzIGdldHRpbmcgbWVzc2luZyB1cCBkaXN0cmlidXRpbmcgdGhlIHdpZHRoIHRvIDx0ZD4vPHRoPiBlbGVtZW50cyB3aXRoIGNvbHNwYW5zLlxuICAgIFNPTFVUSU9OOiBtYWtpbmcgaW5kaXZpZHVhbCA8Y29sPiBlbGVtZW50cyBtYWtlcyBDaHJvbWUgYmVoYXZlLlxuICAgICovXG4gICAgZm9yIChsZXQgY29sUHJvcHMgb2YgY29scykge1xuICAgICAgICBsZXQgc3BhbiA9IGNvbFByb3BzLnNwYW4gfHwgMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGFuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbE5vZGVzLnB1c2goY3JlYXRlRWxlbWVudChcImNvbFwiLCB7IHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjb2xQcm9wcy53aWR0aCA9PT0gJ3NocmluaycgPyBzYW5pdGl6ZVNocmlua1dpZHRoKHNocmlua1dpZHRoKSA6IChjb2xQcm9wcy53aWR0aCB8fCAnJyksXG4gICAgICAgICAgICAgICAgICAgIG1pbldpZHRoOiBjb2xQcm9wcy5taW5XaWR0aCB8fCAnJyxcbiAgICAgICAgICAgICAgICB9IH0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnY29sZ3JvdXAnLCB7fSwgLi4uY29sTm9kZXMpO1xufVxuZnVuY3Rpb24gc2FuaXRpemVTaHJpbmtXaWR0aChzaHJpbmtXaWR0aCkge1xuICAgIC8qIHdoeSA0PyBpZiB3ZSBkbyAwLCBpdCB3aWxsIGtpbGwgYW55IGJvcmRlciwgd2hpY2ggYXJlIG5lZWRlZCBmb3IgY29tcHV0ZVNtYWxsZXN0Q2VsbFdpZHRoXG4gICAgNCBhY2NvdW50cyBmb3IgMiAyLXBpeGVsIGJvcmRlcnMuIFRPRE86IGJldHRlciBzb2x1dGlvbj8gKi9cbiAgICByZXR1cm4gc2hyaW5rV2lkdGggPT0gbnVsbCA/IDQgOiBzaHJpbmtXaWR0aDtcbn1cbmZ1bmN0aW9uIGhhc1Nocmlua1dpZHRoKGNvbHMpIHtcbiAgICBmb3IgKGxldCBjb2wgb2YgY29scykge1xuICAgICAgICBpZiAoY29sLndpZHRoID09PSAnc2hyaW5rJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0U2Nyb2xsR3JpZENsYXNzTmFtZXMobGlxdWlkLCBjb250ZXh0KSB7XG4gICAgbGV0IGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICdmYy1zY3JvbGxncmlkJyxcbiAgICAgICAgY29udGV4dC50aGVtZS5nZXRDbGFzcygndGFibGUnKSxcbiAgICBdO1xuICAgIGlmIChsaXF1aWQpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zY3JvbGxncmlkLWxpcXVpZCcpO1xuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lcztcbn1cbmZ1bmN0aW9uIGdldFNlY3Rpb25DbGFzc05hbWVzKHNlY3Rpb25Db25maWcsIHdob2xlVGFibGVWR3Jvdykge1xuICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uJyxcbiAgICAgICAgYGZjLXNjcm9sbGdyaWQtc2VjdGlvbi0ke3NlY3Rpb25Db25maWcudHlwZX1gLFxuICAgICAgICBzZWN0aW9uQ29uZmlnLmNsYXNzTmFtZSwgLy8gdXNlZD9cbiAgICBdO1xuICAgIGlmICh3aG9sZVRhYmxlVkdyb3cgJiYgc2VjdGlvbkNvbmZpZy5saXF1aWQgJiYgc2VjdGlvbkNvbmZpZy5tYXhIZWlnaHQgPT0gbnVsbCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNjcm9sbGdyaWQtc2VjdGlvbi1saXF1aWQnKTtcbiAgICB9XG4gICAgaWYgKHNlY3Rpb25Db25maWcuaXNTdGlja3kpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zY3JvbGxncmlkLXNlY3Rpb24tc3RpY2t5Jyk7XG4gICAgfVxuICAgIHJldHVybiBjbGFzc05hbWVzO1xufVxuZnVuY3Rpb24gcmVuZGVyU2Nyb2xsU2hpbShhcmcpIHtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtc2Nyb2xsZ3JpZC1zdGlja3ktc2hpbVwiLCBzdHlsZToge1xuICAgICAgICAgICAgd2lkdGg6IGFyZy5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgIG1pbldpZHRoOiBhcmcudGFibGVNaW5XaWR0aCxcbiAgICAgICAgfSB9KSk7XG59XG5mdW5jdGlvbiBnZXRTdGlja3lIZWFkZXJEYXRlcyhvcHRpb25zKSB7XG4gICAgbGV0IHsgc3RpY2t5SGVhZGVyRGF0ZXMgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHN0aWNreUhlYWRlckRhdGVzID09IG51bGwgfHwgc3RpY2t5SGVhZGVyRGF0ZXMgPT09ICdhdXRvJykge1xuICAgICAgICBzdGlja3lIZWFkZXJEYXRlcyA9IG9wdGlvbnMuaGVpZ2h0ID09PSAnYXV0bycgfHwgb3B0aW9ucy52aWV3SGVpZ2h0ID09PSAnYXV0byc7XG4gICAgfVxuICAgIHJldHVybiBzdGlja3lIZWFkZXJEYXRlcztcbn1cbmZ1bmN0aW9uIGdldFN0aWNreUZvb3RlclNjcm9sbGJhcihvcHRpb25zKSB7XG4gICAgbGV0IHsgc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyIH0gPSBvcHRpb25zO1xuICAgIGlmIChzdGlja3lGb290ZXJTY3JvbGxiYXIgPT0gbnVsbCB8fCBzdGlja3lGb290ZXJTY3JvbGxiYXIgPT09ICdhdXRvJykge1xuICAgICAgICBzdGlja3lGb290ZXJTY3JvbGxiYXIgPSBvcHRpb25zLmhlaWdodCA9PT0gJ2F1dG8nIHx8IG9wdGlvbnMudmlld0hlaWdodCA9PT0gJ2F1dG8nO1xuICAgIH1cbiAgICByZXR1cm4gc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyO1xufVxuXG5jbGFzcyBTaW1wbGVTY3JvbGxHcmlkIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucHJvY2Vzc0NvbHMgPSBtZW1vaXplKChhKSA9PiBhLCBpc0NvbFByb3BzRXF1YWwpOyAvLyBzbyB3ZSBnZXQgc2FtZSBgY29sc2AgcHJvcHMgZXZlcnkgdGltZVxuICAgICAgICAvLyB5dWNreSB0byBtZW1vaXplIFZOb2RlcywgYnV0IG11Y2ggbW9yZSBlZmZpY2llbnQgZm9yIGNvbnN1bWVyc1xuICAgICAgICB0aGlzLnJlbmRlck1pY3JvQ29sR3JvdXAgPSBtZW1vaXplKHJlbmRlck1pY3JvQ29sR3JvdXApO1xuICAgICAgICB0aGlzLnNjcm9sbGVyUmVmcyA9IG5ldyBSZWZNYXAoKTtcbiAgICAgICAgdGhpcy5zY3JvbGxlckVsUmVmcyA9IG5ldyBSZWZNYXAodGhpcy5faGFuZGxlU2Nyb2xsZXJFbC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHNocmlua1dpZHRoOiBudWxsLFxuICAgICAgICAgICAgZm9yY2VZU2Nyb2xsYmFyczogZmFsc2UsXG4gICAgICAgICAgICBzY3JvbGxlckNsaWVudFdpZHRoczoge30sXG4gICAgICAgICAgICBzY3JvbGxlckNsaWVudEhlaWdodHM6IHt9LFxuICAgICAgICB9O1xuICAgICAgICAvLyBUT0RPOiBjYW4gZG8gYSByZWFsbHkgc2ltcGxlIHByaW50LXZpZXcuIGRvbnQgbmVlZCB0byBqb2luIHJvd3NcbiAgICAgICAgdGhpcy5oYW5kbGVTaXppbmcgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNhZmVTZXRTdGF0ZShPYmplY3QuYXNzaWduKHsgc2hyaW5rV2lkdGg6IHRoaXMuY29tcHV0ZVNocmlua1dpZHRoKCkgfSwgdGhpcy5jb21wdXRlU2Nyb2xsZXJEaW1zKCkpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgc3RhdGUsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCBzZWN0aW9uQ29uZmlncyA9IHByb3BzLnNlY3Rpb25zIHx8IFtdO1xuICAgICAgICBsZXQgY29scyA9IHRoaXMucHJvY2Vzc0NvbHMocHJvcHMuY29scyk7XG4gICAgICAgIGxldCBtaWNyb0NvbEdyb3VwTm9kZSA9IHRoaXMucmVuZGVyTWljcm9Db2xHcm91cChjb2xzLCBzdGF0ZS5zaHJpbmtXaWR0aCk7XG4gICAgICAgIGxldCBjbGFzc05hbWVzID0gZ2V0U2Nyb2xsR3JpZENsYXNzTmFtZXMocHJvcHMubGlxdWlkLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHByb3BzLmNvbGxhcHNpYmxlV2lkdGgpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2Nyb2xsZ3JpZC1jb2xsYXBzaWJsZScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IG1ha2UgRFJZXG4gICAgICAgIGxldCBjb25maWdDbnQgPSBzZWN0aW9uQ29uZmlncy5sZW5ndGg7XG4gICAgICAgIGxldCBjb25maWdJID0gMDtcbiAgICAgICAgbGV0IGN1cnJlbnRDb25maWc7XG4gICAgICAgIGxldCBoZWFkU2VjdGlvbk5vZGVzID0gW107XG4gICAgICAgIGxldCBib2R5U2VjdGlvbk5vZGVzID0gW107XG4gICAgICAgIGxldCBmb290U2VjdGlvbk5vZGVzID0gW107XG4gICAgICAgIHdoaWxlIChjb25maWdJIDwgY29uZmlnQ250ICYmIChjdXJyZW50Q29uZmlnID0gc2VjdGlvbkNvbmZpZ3NbY29uZmlnSV0pLnR5cGUgPT09ICdoZWFkZXInKSB7XG4gICAgICAgICAgICBoZWFkU2VjdGlvbk5vZGVzLnB1c2godGhpcy5yZW5kZXJTZWN0aW9uKGN1cnJlbnRDb25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCB0cnVlKSk7XG4gICAgICAgICAgICBjb25maWdJICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGNvbmZpZ0kgPCBjb25maWdDbnQgJiYgKGN1cnJlbnRDb25maWcgPSBzZWN0aW9uQ29uZmlnc1tjb25maWdJXSkudHlwZSA9PT0gJ2JvZHknKSB7XG4gICAgICAgICAgICBib2R5U2VjdGlvbk5vZGVzLnB1c2godGhpcy5yZW5kZXJTZWN0aW9uKGN1cnJlbnRDb25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCBmYWxzZSkpO1xuICAgICAgICAgICAgY29uZmlnSSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChjb25maWdJIDwgY29uZmlnQ250ICYmIChjdXJyZW50Q29uZmlnID0gc2VjdGlvbkNvbmZpZ3NbY29uZmlnSV0pLnR5cGUgPT09ICdmb290ZXInKSB7XG4gICAgICAgICAgICBmb290U2VjdGlvbk5vZGVzLnB1c2godGhpcy5yZW5kZXJTZWN0aW9uKGN1cnJlbnRDb25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCB0cnVlKSk7XG4gICAgICAgICAgICBjb25maWdJICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmlyZWZveCBidWc6IHdoZW4gc2V0dGluZyBoZWlnaHQgb24gdGFibGUgYW5kIHRoZXJlIGlzIGEgdGhlYWQgb3IgdGZvb3QsXG4gICAgICAgIC8vIHRoZSBuZWNlc3NhcnkgaGVpZ2h0OjEwMCUgb24gdGhlIGxpcXVpZC1oZWlnaHQgYm9keSBzZWN0aW9uIGZvcmNlcyB0aGUgKndob2xlKiB0YWJsZSB0byBiZSB0YWxsZXIuIChidWcgIzU1MjQpXG4gICAgICAgIC8vIHVzZSBnZXRDYW5WR3Jvd1dpdGhpbkNlbGwgYXMgYSB3YXkgdG8gZGV0ZWN0IHRhYmxlLXN0dXBpZCBmaXJlZm94LlxuICAgICAgICAvLyBpZiBzbywgdXNlIGEgc2ltcGxlciBkb20gc3RydWN0dXJlLCBqYW0gZXZlcnl0aGluZyBpbnRvIGEgbG9uZSB0Ym9keS5cbiAgICAgICAgbGV0IGlzQnVnZ3kgPSAhZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsKCk7XG4gICAgICAgIGNvbnN0IHJvbGVBdHRycyA9IHsgcm9sZTogJ3Jvd2dyb3VwJyB9O1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgndGFibGUnLCB7XG4gICAgICAgICAgICByb2xlOiAnZ3JpZCcsXG4gICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMuam9pbignICcpLFxuICAgICAgICAgICAgc3R5bGU6IHsgaGVpZ2h0OiBwcm9wcy5oZWlnaHQgfSxcbiAgICAgICAgfSwgQm9vbGVhbighaXNCdWdneSAmJiBoZWFkU2VjdGlvbk5vZGVzLmxlbmd0aCkgJiYgY3JlYXRlRWxlbWVudCgndGhlYWQnLCByb2xlQXR0cnMsIC4uLmhlYWRTZWN0aW9uTm9kZXMpLCBCb29sZWFuKCFpc0J1Z2d5ICYmIGJvZHlTZWN0aW9uTm9kZXMubGVuZ3RoKSAmJiBjcmVhdGVFbGVtZW50KCd0Ym9keScsIHJvbGVBdHRycywgLi4uYm9keVNlY3Rpb25Ob2RlcyksIEJvb2xlYW4oIWlzQnVnZ3kgJiYgZm9vdFNlY3Rpb25Ob2Rlcy5sZW5ndGgpICYmIGNyZWF0ZUVsZW1lbnQoJ3Rmb290Jywgcm9sZUF0dHJzLCAuLi5mb290U2VjdGlvbk5vZGVzKSwgaXNCdWdneSAmJiBjcmVhdGVFbGVtZW50KCd0Ym9keScsIHJvbGVBdHRycywgLi4uaGVhZFNlY3Rpb25Ob2RlcywgLi4uYm9keVNlY3Rpb25Ob2RlcywgLi4uZm9vdFNlY3Rpb25Ob2RlcykpO1xuICAgIH1cbiAgICByZW5kZXJTZWN0aW9uKHNlY3Rpb25Db25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCBpc0hlYWRlcikge1xuICAgICAgICBpZiAoJ291dGVyQ29udGVudCcgaW4gc2VjdGlvbkNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCB7IGtleTogc2VjdGlvbkNvbmZpZy5rZXkgfSwgc2VjdGlvbkNvbmZpZy5vdXRlckNvbnRlbnQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IGtleTogc2VjdGlvbkNvbmZpZy5rZXksIHJvbGU6IFwicHJlc2VudGF0aW9uXCIsIGNsYXNzTmFtZTogZ2V0U2VjdGlvbkNsYXNzTmFtZXMoc2VjdGlvbkNvbmZpZywgdGhpcy5wcm9wcy5saXF1aWQpLmpvaW4oJyAnKSB9LCB0aGlzLnJlbmRlckNodW5rVGQoc2VjdGlvbkNvbmZpZywgbWljcm9Db2xHcm91cE5vZGUsIHNlY3Rpb25Db25maWcuY2h1bmssIGlzSGVhZGVyKSkpO1xuICAgIH1cbiAgICByZW5kZXJDaHVua1RkKHNlY3Rpb25Db25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCBjaHVua0NvbmZpZywgaXNIZWFkZXIpIHtcbiAgICAgICAgaWYgKCdvdXRlckNvbnRlbnQnIGluIGNodW5rQ29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gY2h1bmtDb25maWcub3V0ZXJDb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBmb3JjZVlTY3JvbGxiYXJzLCBzY3JvbGxlckNsaWVudFdpZHRocywgc2Nyb2xsZXJDbGllbnRIZWlnaHRzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBsZXQgbmVlZHNZU2Nyb2xsaW5nID0gZ2V0QWxsb3dZU2Nyb2xsaW5nKHByb3BzLCBzZWN0aW9uQ29uZmlnKTsgLy8gVE9ETzogZG8gbGF6aWx5LiBkbyBpbiBzZWN0aW9uIGNvbmZpZz9cbiAgICAgICAgbGV0IGlzTGlxdWlkID0gZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodChwcm9wcywgc2VjdGlvbkNvbmZpZyk7XG4gICAgICAgIC8vIGZvciBgIXByb3BzLmxpcXVpZGAgLSBpcyBXSE9MRSBzY3JvbGxncmlkIG5hdHVyYWwgaGVpZ2h0P1xuICAgICAgICAvLyBUT0RPOiBkbyBzYW1lIHRoaW5nIGluIGFkdmFuY2VkIHNjcm9sbGdyaWQ/IHByb2xseSBub3QgYi9jIGFsd2F5cyBoYXMgaG9yaXpvbnRhbCBzY3JvbGxiYXJzXG4gICAgICAgIGxldCBvdmVyZmxvd1kgPSAhcHJvcHMubGlxdWlkID8gJ3Zpc2libGUnIDpcbiAgICAgICAgICAgIGZvcmNlWVNjcm9sbGJhcnMgPyAnc2Nyb2xsJyA6XG4gICAgICAgICAgICAgICAgIW5lZWRzWVNjcm9sbGluZyA/ICdoaWRkZW4nIDpcbiAgICAgICAgICAgICAgICAgICAgJ2F1dG8nO1xuICAgICAgICBsZXQgc2VjdGlvbktleSA9IHNlY3Rpb25Db25maWcua2V5O1xuICAgICAgICBsZXQgY29udGVudCA9IHJlbmRlckNodW5rQ29udGVudChzZWN0aW9uQ29uZmlnLCBjaHVua0NvbmZpZywge1xuICAgICAgICAgICAgdGFibGVDb2xHcm91cE5vZGU6IG1pY3JvQ29sR3JvdXBOb2RlLFxuICAgICAgICAgICAgdGFibGVNaW5XaWR0aDogJycsXG4gICAgICAgICAgICBjbGllbnRXaWR0aDogKCFwcm9wcy5jb2xsYXBzaWJsZVdpZHRoICYmIHNjcm9sbGVyQ2xpZW50V2lkdGhzW3NlY3Rpb25LZXldICE9PSB1bmRlZmluZWQpID8gc2Nyb2xsZXJDbGllbnRXaWR0aHNbc2VjdGlvbktleV0gOiBudWxsLFxuICAgICAgICAgICAgY2xpZW50SGVpZ2h0OiBzY3JvbGxlckNsaWVudEhlaWdodHNbc2VjdGlvbktleV0gIT09IHVuZGVmaW5lZCA/IHNjcm9sbGVyQ2xpZW50SGVpZ2h0c1tzZWN0aW9uS2V5XSA6IG51bGwsXG4gICAgICAgICAgICBleHBhbmRSb3dzOiBzZWN0aW9uQ29uZmlnLmV4cGFuZFJvd3MsXG4gICAgICAgICAgICBzeW5jUm93SGVpZ2h0czogZmFsc2UsXG4gICAgICAgICAgICByb3dTeW5jSGVpZ2h0czogW10sXG4gICAgICAgICAgICByZXBvcnRSb3dIZWlnaHRDaGFuZ2U6ICgpID0+IHsgfSxcbiAgICAgICAgfSwgaXNIZWFkZXIpO1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChpc0hlYWRlciA/ICd0aCcgOiAndGQnLCB7XG4gICAgICAgICAgICByZWY6IGNodW5rQ29uZmlnLmVsUmVmLFxuICAgICAgICAgICAgcm9sZTogJ3ByZXNlbnRhdGlvbicsXG4gICAgICAgIH0sIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGBmYy1zY3JvbGxlci1oYXJuZXNzJHtpc0xpcXVpZCA/ICcgZmMtc2Nyb2xsZXItaGFybmVzcy1saXF1aWQnIDogJyd9YCB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChTY3JvbGxlciwgeyByZWY6IHRoaXMuc2Nyb2xsZXJSZWZzLmNyZWF0ZVJlZihzZWN0aW9uS2V5KSwgZWxSZWY6IHRoaXMuc2Nyb2xsZXJFbFJlZnMuY3JlYXRlUmVmKHNlY3Rpb25LZXkpLCBvdmVyZmxvd1k6IG92ZXJmbG93WSwgb3ZlcmZsb3dYOiAhcHJvcHMubGlxdWlkID8gJ3Zpc2libGUnIDogJ2hpZGRlbicgLyogbmF0dXJhbCBoZWlnaHQ/ICovLCBtYXhIZWlnaHQ6IHNlY3Rpb25Db25maWcubWF4SGVpZ2h0LCBsaXF1aWQ6IGlzTGlxdWlkLCBsaXF1aWRJc0Fic29sdXRlIC8vIGJlY2F1c2UgaXRzIHdpdGhpbiBhIGhhcm5lc3NcbiAgICAgICAgICAgICAgICA6IHRydWUgfSwgY29udGVudCkpKTtcbiAgICB9XG4gICAgX2hhbmRsZVNjcm9sbGVyRWwoc2Nyb2xsZXJFbCwga2V5KSB7XG4gICAgICAgIGxldCBzZWN0aW9uID0gZ2V0U2VjdGlvbkJ5S2V5KHRoaXMucHJvcHMuc2VjdGlvbnMsIGtleSk7XG4gICAgICAgIGlmIChzZWN0aW9uKSB7XG4gICAgICAgICAgICBzZXRSZWYoc2VjdGlvbi5jaHVuay5zY3JvbGxlckVsUmVmLCBzY3JvbGxlckVsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVTaXppbmcoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmFkZFJlc2l6ZUhhbmRsZXIodGhpcy5oYW5kbGVTaXppbmcpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIC8vIFRPRE86IG5lZWQgYmV0dGVyIHNvbHV0aW9uIHdoZW4gc3RhdGUgY29udGFpbnMgbm9uLXNpemluZyB0aGluZ3NcbiAgICAgICAgdGhpcy5oYW5kbGVTaXppbmcoKTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5yZW1vdmVSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlU2l6aW5nKTtcbiAgICB9XG4gICAgY29tcHV0ZVNocmlua1dpZHRoKCkge1xuICAgICAgICByZXR1cm4gaGFzU2hyaW5rV2lkdGgodGhpcy5wcm9wcy5jb2xzKVxuICAgICAgICAgICAgPyBjb21wdXRlU2hyaW5rV2lkdGgodGhpcy5zY3JvbGxlckVsUmVmcy5nZXRBbGwoKSlcbiAgICAgICAgICAgIDogMDtcbiAgICB9XG4gICAgY29tcHV0ZVNjcm9sbGVyRGltcygpIHtcbiAgICAgICAgbGV0IHNjcm9sbGJhcldpZHRoID0gZ2V0U2Nyb2xsYmFyV2lkdGhzKCk7XG4gICAgICAgIGxldCB7IHNjcm9sbGVyUmVmcywgc2Nyb2xsZXJFbFJlZnMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBmb3JjZVlTY3JvbGxiYXJzID0gZmFsc2U7XG4gICAgICAgIGxldCBzY3JvbGxlckNsaWVudFdpZHRocyA9IHt9O1xuICAgICAgICBsZXQgc2Nyb2xsZXJDbGllbnRIZWlnaHRzID0ge307XG4gICAgICAgIGZvciAobGV0IHNlY3Rpb25LZXkgaW4gc2Nyb2xsZXJSZWZzLmN1cnJlbnRNYXApIHtcbiAgICAgICAgICAgIGxldCBzY3JvbGxlciA9IHNjcm9sbGVyUmVmcy5jdXJyZW50TWFwW3NlY3Rpb25LZXldO1xuICAgICAgICAgICAgaWYgKHNjcm9sbGVyICYmIHNjcm9sbGVyLm5lZWRzWVNjcm9sbGluZygpKSB7XG4gICAgICAgICAgICAgICAgZm9yY2VZU2Nyb2xsYmFycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgc2VjdGlvbiBvZiB0aGlzLnByb3BzLnNlY3Rpb25zKSB7XG4gICAgICAgICAgICBsZXQgc2VjdGlvbktleSA9IHNlY3Rpb24ua2V5O1xuICAgICAgICAgICAgbGV0IHNjcm9sbGVyRWwgPSBzY3JvbGxlckVsUmVmcy5jdXJyZW50TWFwW3NlY3Rpb25LZXldO1xuICAgICAgICAgICAgaWYgKHNjcm9sbGVyRWwpIHtcbiAgICAgICAgICAgICAgICBsZXQgaGFybmVzc0VsID0gc2Nyb2xsZXJFbC5wYXJlbnROb2RlOyAvLyBUT0RPOiB3ZWlyZCB3YXkgdG8gZ2V0IHRoaXMuIG5lZWQgaGFybmVzcyBiL2MgZG9lc24ndCBpbmNsdWRlIHRhYmxlIGJvcmRlcnNcbiAgICAgICAgICAgICAgICBzY3JvbGxlckNsaWVudFdpZHRoc1tzZWN0aW9uS2V5XSA9IE1hdGguZmxvb3IoaGFybmVzc0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC0gKGZvcmNlWVNjcm9sbGJhcnNcbiAgICAgICAgICAgICAgICAgICAgPyBzY3JvbGxiYXJXaWR0aC55IC8vIHVzZSBnbG9iYWwgYmVjYXVzZSBzY3JvbGxlciBtaWdodCBub3QgaGF2ZSBzY3JvbGxiYXJzIHlldCBidXQgd2lsbCBuZWVkIHRoZW0gaW4gZnV0dXJlXG4gICAgICAgICAgICAgICAgICAgIDogMCkpO1xuICAgICAgICAgICAgICAgIHNjcm9sbGVyQ2xpZW50SGVpZ2h0c1tzZWN0aW9uS2V5XSA9IE1hdGguZmxvb3IoaGFybmVzc0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZm9yY2VZU2Nyb2xsYmFycywgc2Nyb2xsZXJDbGllbnRXaWR0aHMsIHNjcm9sbGVyQ2xpZW50SGVpZ2h0cyB9O1xuICAgIH1cbn1cblNpbXBsZVNjcm9sbEdyaWQuYWRkU3RhdGVFcXVhbGl0eSh7XG4gICAgc2Nyb2xsZXJDbGllbnRXaWR0aHM6IGlzUHJvcHNFcXVhbCxcbiAgICBzY3JvbGxlckNsaWVudEhlaWdodHM6IGlzUHJvcHNFcXVhbCxcbn0pO1xuZnVuY3Rpb24gZ2V0U2VjdGlvbkJ5S2V5KHNlY3Rpb25zLCBrZXkpIHtcbiAgICBmb3IgKGxldCBzZWN0aW9uIG9mIHNlY3Rpb25zKSB7XG4gICAgICAgIGlmIChzZWN0aW9uLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gc2VjdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuY2xhc3MgRXZlbnRDb250YWluZXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVFbCA9IChlbCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgICAgc2V0RWxTZWcoZWwsIHRoaXMucHJvcHMuc2VnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgICAgIGNvbnN0IHsgc2VnIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgeyBldmVudFJhbmdlIH0gPSBzZWc7XG4gICAgICAgIGNvbnN0IHsgdWkgfSA9IGV2ZW50UmFuZ2U7XG4gICAgICAgIGNvbnN0IHJlbmRlclByb3BzID0ge1xuICAgICAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEltcGwoY29udGV4dCwgZXZlbnRSYW5nZS5kZWYsIGV2ZW50UmFuZ2UuaW5zdGFuY2UpLFxuICAgICAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxuICAgICAgICAgICAgdGltZVRleHQ6IHByb3BzLnRpbWVUZXh0LFxuICAgICAgICAgICAgdGV4dENvbG9yOiB1aS50ZXh0Q29sb3IsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHVpLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiB1aS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgIGlzRHJhZ2dhYmxlOiAhcHJvcHMuZGlzYWJsZURyYWdnaW5nICYmIGNvbXB1dGVTZWdEcmFnZ2FibGUoc2VnLCBjb250ZXh0KSxcbiAgICAgICAgICAgIGlzU3RhcnRSZXNpemFibGU6ICFwcm9wcy5kaXNhYmxlUmVzaXppbmcgJiYgY29tcHV0ZVNlZ1N0YXJ0UmVzaXphYmxlKHNlZywgY29udGV4dCksXG4gICAgICAgICAgICBpc0VuZFJlc2l6YWJsZTogIXByb3BzLmRpc2FibGVSZXNpemluZyAmJiBjb21wdXRlU2VnRW5kUmVzaXphYmxlKHNlZyksXG4gICAgICAgICAgICBpc01pcnJvcjogQm9vbGVhbihwcm9wcy5pc0RyYWdnaW5nIHx8IHByb3BzLmlzUmVzaXppbmcgfHwgcHJvcHMuaXNEYXRlU2VsZWN0aW5nKSxcbiAgICAgICAgICAgIGlzU3RhcnQ6IEJvb2xlYW4oc2VnLmlzU3RhcnQpLFxuICAgICAgICAgICAgaXNFbmQ6IEJvb2xlYW4oc2VnLmlzRW5kKSxcbiAgICAgICAgICAgIGlzUGFzdDogQm9vbGVhbihwcm9wcy5pc1Bhc3QpLFxuICAgICAgICAgICAgaXNGdXR1cmU6IEJvb2xlYW4ocHJvcHMuaXNGdXR1cmUpLFxuICAgICAgICAgICAgaXNUb2RheTogQm9vbGVhbihwcm9wcy5pc1RvZGF5KSxcbiAgICAgICAgICAgIGlzU2VsZWN0ZWQ6IEJvb2xlYW4ocHJvcHMuaXNTZWxlY3RlZCksXG4gICAgICAgICAgICBpc0RyYWdnaW5nOiBCb29sZWFuKHByb3BzLmlzRHJhZ2dpbmcpLFxuICAgICAgICAgICAgaXNSZXNpemluZzogQm9vbGVhbihwcm9wcy5pc1Jlc2l6aW5nKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzIC8qIGNvbnRhaW5zIGNoaWxkcmVuICovLCB7IGVsUmVmOiB0aGlzLmhhbmRsZUVsLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAuLi5nZXRFdmVudENsYXNzTmFtZXMocmVuZGVyUHJvcHMpLFxuICAgICAgICAgICAgICAgIC4uLnNlZy5ldmVudFJhbmdlLnVpLmNsYXNzTmFtZXMsXG4gICAgICAgICAgICAgICAgLi4uKHByb3BzLmVsQ2xhc3NlcyB8fCBbXSksXG4gICAgICAgICAgICBdLCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwiZXZlbnRDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5ldmVudENvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHByb3BzLmRlZmF1bHRHZW5lcmF0b3IsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5ldmVudENsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLmV2ZW50RGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLmV2ZW50V2lsbFVubW91bnQgfSkpKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICBpZiAodGhpcy5lbCAmJiB0aGlzLnByb3BzLnNlZyAhPT0gcHJldlByb3BzLnNlZykge1xuICAgICAgICAgICAgc2V0RWxTZWcodGhpcy5lbCwgdGhpcy5wcm9wcy5zZWcpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBzaG91bGQgbm90IGJlIGEgcHVyZWNvbXBvbmVudFxuY2xhc3MgU3RhbmRhcmRFdmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgICAgIGxldCB7IHNlZyB9ID0gcHJvcHM7XG4gICAgICAgIGxldCB7IHVpIH0gPSBzZWcuZXZlbnRSYW5nZTtcbiAgICAgICAgbGV0IHRpbWVGb3JtYXQgPSBvcHRpb25zLmV2ZW50VGltZUZvcm1hdCB8fCBwcm9wcy5kZWZhdWx0VGltZUZvcm1hdDtcbiAgICAgICAgbGV0IHRpbWVUZXh0ID0gYnVpbGRTZWdUaW1lVGV4dChzZWcsIHRpbWVGb3JtYXQsIGNvbnRleHQsIHByb3BzLmRlZmF1bHREaXNwbGF5RXZlbnRUaW1lLCBwcm9wcy5kZWZhdWx0RGlzcGxheUV2ZW50RW5kKTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEV2ZW50Q29udGFpbmVyLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcyAvKiBpbmNsdWRlcyBlbFJlZiAqLywgeyBlbFRhZzogXCJhXCIsIGVsU3R5bGU6IHtcbiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogdWkuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB1aS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICB9LCBlbEF0dHJzOiBnZXRTZWdBbmNob3JBdHRycyhzZWcsIGNvbnRleHQpLCBkZWZhdWx0R2VuZXJhdG9yOiByZW5kZXJJbm5lckNvbnRlbnQkMSwgdGltZVRleHQ6IHRpbWVUZXh0IH0pLCAoSW5uZXJDb250ZW50LCBldmVudENvbnRlbnRBcmcpID0+IChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChJbm5lckNvbnRlbnQsIHsgZWxUYWc6IFwiZGl2XCIsIGVsQ2xhc3NlczogWydmYy1ldmVudC1tYWluJ10sIGVsU3R5bGU6IHsgY29sb3I6IGV2ZW50Q29udGVudEFyZy50ZXh0Q29sb3IgfSB9KSxcbiAgICAgICAgICAgIEJvb2xlYW4oZXZlbnRDb250ZW50QXJnLmlzU3RhcnRSZXNpemFibGUpICYmIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXJlc2l6ZXIgZmMtZXZlbnQtcmVzaXplci1zdGFydFwiIH0pKSxcbiAgICAgICAgICAgIEJvb2xlYW4oZXZlbnRDb250ZW50QXJnLmlzRW5kUmVzaXphYmxlKSAmJiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC1yZXNpemVyIGZjLWV2ZW50LXJlc2l6ZXItZW5kXCIgfSkpKSkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZW5kZXJJbm5lckNvbnRlbnQkMShpbm5lclByb3BzKSB7XG4gICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LW1haW4tZnJhbWVcIiB9LFxuICAgICAgICBpbm5lclByb3BzLnRpbWVUZXh0ICYmIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpbWVcIiB9LCBpbm5lclByb3BzLnRpbWVUZXh0KSksXG4gICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtdGl0bGUtY29udGFpbmVyXCIgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtdGl0bGUgZmMtc3RpY2t5XCIgfSwgaW5uZXJQcm9wcy5ldmVudC50aXRsZSB8fCBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBcIlxcdTAwQTBcIikpKSkpO1xufVxuXG5jb25zdCBOb3dJbmRpY2F0b3JDb250YWluZXIgPSAocHJvcHMpID0+IChjcmVhdGVFbGVtZW50KFZpZXdDb250ZXh0VHlwZS5Db25zdW1lciwgbnVsbCwgKGNvbnRleHQpID0+IHtcbiAgICBsZXQgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgIGxldCByZW5kZXJQcm9wcyA9IHtcbiAgICAgICAgaXNBeGlzOiBwcm9wcy5pc0F4aXMsXG4gICAgICAgIGRhdGU6IGNvbnRleHQuZGF0ZUVudi50b0RhdGUocHJvcHMuZGF0ZSksXG4gICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICB9O1xuICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChDb250ZW50Q29udGFpbmVyLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcyAvKiBpbmNsdWRlcyBjaGlsZHJlbiAqLywgeyBlbFRhZzogcHJvcHMuZWxUYWcgfHwgJ2RpdicsIHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogXCJub3dJbmRpY2F0b3JDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5ub3dJbmRpY2F0b3JDb250ZW50LCBjbGFzc05hbWVHZW5lcmF0b3I6IG9wdGlvbnMubm93SW5kaWNhdG9yQ2xhc3NOYW1lcywgZGlkTW91bnQ6IG9wdGlvbnMubm93SW5kaWNhdG9yRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLm5vd0luZGljYXRvcldpbGxVbm1vdW50IH0pKSk7XG59KSk7XG5cbmNvbnN0IERBWV9OVU1fRk9STUFUID0gY3JlYXRlRm9ybWF0dGVyKHsgZGF5OiAnbnVtZXJpYycgfSk7XG5jbGFzcyBEYXlDZWxsQ29udGFpbmVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucmVmaW5lUmVuZGVyUHJvcHMgPSBtZW1vaXplT2JqQXJnKHJlZmluZVJlbmRlclByb3BzKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICAgICAgbGV0IHJlbmRlclByb3BzID0gdGhpcy5yZWZpbmVSZW5kZXJQcm9wcyh7XG4gICAgICAgICAgICBkYXRlOiBwcm9wcy5kYXRlLFxuICAgICAgICAgICAgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLFxuICAgICAgICAgICAgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSxcbiAgICAgICAgICAgIGlzTW9udGhTdGFydDogcHJvcHMuaXNNb250aFN0YXJ0IHx8IGZhbHNlLFxuICAgICAgICAgICAgc2hvd0RheU51bWJlcjogcHJvcHMuc2hvd0RheU51bWJlcixcbiAgICAgICAgICAgIGV4dHJhUmVuZGVyUHJvcHM6IHByb3BzLmV4dHJhUmVuZGVyUHJvcHMsXG4gICAgICAgICAgICB2aWV3QXBpOiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICBkYXRlRW52OiBjb250ZXh0LmRhdGVFbnYsXG4gICAgICAgICAgICBtb250aFN0YXJ0Rm9ybWF0OiBvcHRpb25zLm1vbnRoU3RhcnRGb3JtYXQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMgLyogaW5jbHVkZXMgY2hpbGRyZW4gKi8sIHsgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgLi4uZ2V0RGF5Q2xhc3NOYW1lcyhyZW5kZXJQcm9wcywgY29udGV4dC50aGVtZSksXG4gICAgICAgICAgICAgICAgLi4uKHByb3BzLmVsQ2xhc3NlcyB8fCBbXSksXG4gICAgICAgICAgICBdLCBlbEF0dHJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb3BzLmVsQXR0cnMpLCAocmVuZGVyUHJvcHMuaXNEaXNhYmxlZCA/IHt9IDogeyAnZGF0YS1kYXRlJzogZm9ybWF0RGF5U3RyaW5nKHByb3BzLmRhdGUpIH0pKSwgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcImRheUNlbGxDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5kYXlDZWxsQ29udGVudCwgZGVmYXVsdEdlbmVyYXRvcjogcHJvcHMuZGVmYXVsdEdlbmVyYXRvciwgY2xhc3NOYW1lR2VuZXJhdG9yOiBcbiAgICAgICAgICAgIC8vIGRvbid0IHVzZSBjdXN0b20gY2xhc3NOYW1lcyBpZiBkaXNhYmxlZFxuICAgICAgICAgICAgcmVuZGVyUHJvcHMuaXNEaXNhYmxlZCA/IHVuZGVmaW5lZCA6IG9wdGlvbnMuZGF5Q2VsbENsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLmRheUNlbGxEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuZGF5Q2VsbFdpbGxVbm1vdW50IH0pKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzQ3VzdG9tRGF5Q2VsbENvbnRlbnQob3B0aW9ucykge1xuICAgIHJldHVybiBCb29sZWFuKG9wdGlvbnMuZGF5Q2VsbENvbnRlbnQgfHwgaGFzQ3VzdG9tUmVuZGVyaW5nSGFuZGxlcignZGF5Q2VsbENvbnRlbnQnLCBvcHRpb25zKSk7XG59XG5mdW5jdGlvbiByZWZpbmVSZW5kZXJQcm9wcyhyYXcpIHtcbiAgICBsZXQgeyBkYXRlLCBkYXRlRW52LCBkYXRlUHJvZmlsZSwgaXNNb250aFN0YXJ0IH0gPSByYXc7XG4gICAgbGV0IGRheU1ldGEgPSBnZXREYXRlTWV0YShkYXRlLCByYXcudG9kYXlSYW5nZSwgbnVsbCwgZGF0ZVByb2ZpbGUpO1xuICAgIGxldCBkYXlOdW1iZXJUZXh0ID0gcmF3LnNob3dEYXlOdW1iZXIgPyAoZGF0ZUVudi5mb3JtYXQoZGF0ZSwgaXNNb250aFN0YXJ0ID8gcmF3Lm1vbnRoU3RhcnRGb3JtYXQgOiBEQVlfTlVNX0ZPUk1BVCkpIDogJyc7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgZGF0ZTogZGF0ZUVudi50b0RhdGUoZGF0ZSksIHZpZXc6IHJhdy52aWV3QXBpIH0sIGRheU1ldGEpLCB7IGlzTW9udGhTdGFydCxcbiAgICAgICAgZGF5TnVtYmVyVGV4dCB9KSwgcmF3LmV4dHJhUmVuZGVyUHJvcHMpO1xufVxuXG5jbGFzcyBCZ0V2ZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgc2VnIH0gPSBwcm9wcztcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEV2ZW50Q29udGFpbmVyLCB7IGVsVGFnOiBcImRpdlwiLCBlbENsYXNzZXM6IFsnZmMtYmctZXZlbnQnXSwgZWxTdHlsZTogeyBiYWNrZ3JvdW5kQ29sb3I6IHNlZy5ldmVudFJhbmdlLnVpLmJhY2tncm91bmRDb2xvciB9LCBkZWZhdWx0R2VuZXJhdG9yOiByZW5kZXJJbm5lckNvbnRlbnQsIHNlZzogc2VnLCB0aW1lVGV4dDogXCJcIiwgaXNEcmFnZ2luZzogZmFsc2UsIGlzUmVzaXppbmc6IGZhbHNlLCBpc0RhdGVTZWxlY3Rpbmc6IGZhbHNlLCBpc1NlbGVjdGVkOiBmYWxzZSwgaXNQYXN0OiBwcm9wcy5pc1Bhc3QsIGlzRnV0dXJlOiBwcm9wcy5pc0Z1dHVyZSwgaXNUb2RheTogcHJvcHMuaXNUb2RheSwgZGlzYWJsZURyYWdnaW5nOiB0cnVlLCBkaXNhYmxlUmVzaXppbmc6IHRydWUgfSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbmRlcklubmVyQ29udGVudChwcm9wcykge1xuICAgIGxldCB7IHRpdGxlIH0gPSBwcm9wcy5ldmVudDtcbiAgICByZXR1cm4gdGl0bGUgJiYgKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtdGl0bGVcIiB9LCBwcm9wcy5ldmVudC50aXRsZSkpO1xufVxuZnVuY3Rpb24gcmVuZGVyRmlsbChmaWxsVHlwZSkge1xuICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogYGZjLSR7ZmlsbFR5cGV9YCB9KSk7XG59XG5cbmNvbnN0IFdlZWtOdW1iZXJDb250YWluZXIgPSAocHJvcHMpID0+IChjcmVhdGVFbGVtZW50KFZpZXdDb250ZXh0VHlwZS5Db25zdW1lciwgbnVsbCwgKGNvbnRleHQpID0+IHtcbiAgICBsZXQgeyBkYXRlRW52LCBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgIGxldCB7IGRhdGUgfSA9IHByb3BzO1xuICAgIGxldCBmb3JtYXQgPSBvcHRpb25zLndlZWtOdW1iZXJGb3JtYXQgfHwgcHJvcHMuZGVmYXVsdEZvcm1hdDtcbiAgICBsZXQgbnVtID0gZGF0ZUVudi5jb21wdXRlV2Vla051bWJlcihkYXRlKTsgLy8gVE9ETzogc29tZWhvdyB1c2UgZm9yIGZvcm1hdHRpbmcgYXMgd2VsbD9cbiAgICBsZXQgdGV4dCA9IGRhdGVFbnYuZm9ybWF0KGRhdGUsIGZvcm1hdCk7XG4gICAgbGV0IHJlbmRlclByb3BzID0geyBudW0sIHRleHQsIGRhdGUgfTtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciAvLyB3aHkgaXNuJ3QgV2Vla051bWJlckNvbnRlbnRBcmcgYmVpbmcgYXV0by1kZXRlY3RlZD9cbiAgICAsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzIC8qIGluY2x1ZGVzIGNoaWxkcmVuICovLCB7IHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogXCJ3ZWVrTnVtYmVyQ29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMud2Vla051bWJlckNvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlcklubmVyLCBjbGFzc05hbWVHZW5lcmF0b3I6IG9wdGlvbnMud2Vla051bWJlckNsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLndlZWtOdW1iZXJEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMud2Vla051bWJlcldpbGxVbm1vdW50IH0pKSk7XG59KSk7XG5mdW5jdGlvbiByZW5kZXJJbm5lcihpbm5lclByb3BzKSB7XG4gICAgcmV0dXJuIGlubmVyUHJvcHMudGV4dDtcbn1cblxuY29uc3QgUEFERElOR19GUk9NX1ZJRVdQT1JUID0gMTA7XG5jbGFzcyBQb3BvdmVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICB0aXRsZUlkOiBnZXRVbmlxdWVEb21JZCgpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVJvb3RFbCA9IChlbCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yb290RWwgPSBlbDtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmVsUmVmKSB7XG4gICAgICAgICAgICAgICAgc2V0UmVmKHRoaXMucHJvcHMuZWxSZWYsIGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gVHJpZ2dlcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzICphbnl3aGVyZSogaW4gdGhlIGRvY3VtZW50LCBmb3IgdGhlIGF1dG9IaWRlIGZlYXR1cmVcbiAgICAgICAgdGhpcy5oYW5kbGVEb2N1bWVudE1vdXNlRG93biA9IChldikgPT4ge1xuICAgICAgICAgICAgLy8gb25seSBoaWRlIHRoZSBwb3BvdmVyIGlmIHRoZSBjbGljayBoYXBwZW5lZCBvdXRzaWRlIHRoZSBwb3BvdmVyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRFdmVudFRhcmdldFZpYVJvb3QoZXYpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJvb3RFbC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDbG9zZUNsaWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRG9jdW1lbnRLZXlEb3duID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXYua2V5ID09PSAnRXNjYXBlJykge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2xvc2VDbGljaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUNsb3NlQ2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBvbkNsb3NlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgaWYgKG9uQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICBvbkNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgdGhlbWUsIG9wdGlvbnMgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHsgcHJvcHMsIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgICAgICdmYy1wb3BvdmVyJyxcbiAgICAgICAgICAgIHRoZW1lLmdldENsYXNzKCdwb3BvdmVyJyksXG4gICAgICAgIF0uY29uY2F0KHByb3BzLmV4dHJhQ2xhc3NOYW1lcyB8fCBbXSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVQb3J0YWwoY3JlYXRlRWxlbWVudChcImRpdlwiLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcy5leHRyYUF0dHJzLCB7IGlkOiBwcm9wcy5pZCwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSwgXCJhcmlhLWxhYmVsbGVkYnlcIjogc3RhdGUudGl0bGVJZCwgcmVmOiB0aGlzLmhhbmRsZVJvb3RFbCB9KSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6ICdmYy1wb3BvdmVyLWhlYWRlciAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3BvcG92ZXJIZWFkZXInKSB9LFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcImZjLXBvcG92ZXItdGl0bGVcIiwgaWQ6IHN0YXRlLnRpdGxlSWQgfSwgcHJvcHMudGl0bGUpLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiAnZmMtcG9wb3Zlci1jbG9zZSAnICsgdGhlbWUuZ2V0SWNvbkNsYXNzKCdjbG9zZScpLCB0aXRsZTogb3B0aW9ucy5jbG9zZUhpbnQsIG9uQ2xpY2s6IHRoaXMuaGFuZGxlQ2xvc2VDbGljayB9KSksXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiAnZmMtcG9wb3Zlci1ib2R5ICcgKyB0aGVtZS5nZXRDbGFzcygncG9wb3ZlckNvbnRlbnQnKSB9LCBwcm9wcy5jaGlsZHJlbikpLCBwcm9wcy5wYXJlbnRFbCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZURvY3VtZW50TW91c2VEb3duKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlRG9jdW1lbnRLZXlEb3duKTtcbiAgICAgICAgdGhpcy51cGRhdGVTaXplKCk7XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZURvY3VtZW50TW91c2VEb3duKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlRG9jdW1lbnRLZXlEb3duKTtcbiAgICB9XG4gICAgdXBkYXRlU2l6ZSgpIHtcbiAgICAgICAgbGV0IHsgaXNSdGwgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHsgYWxpZ25tZW50RWwsIGFsaWduR3JpZFRvcCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IHsgcm9vdEVsIH0gPSB0aGlzO1xuICAgICAgICBsZXQgYWxpZ25tZW50UmVjdCA9IGNvbXB1dGVDbGlwcGVkQ2xpZW50UmVjdChhbGlnbm1lbnRFbCk7XG4gICAgICAgIGlmIChhbGlnbm1lbnRSZWN0KSB7XG4gICAgICAgICAgICBsZXQgcG9wb3ZlckRpbXMgPSByb290RWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAvLyBwb3NpdGlvbiByZWxhdGl2ZSB0byB2aWV3cG9ydFxuICAgICAgICAgICAgbGV0IHBvcG92ZXJUb3AgPSBhbGlnbkdyaWRUb3BcbiAgICAgICAgICAgICAgICA/IGVsZW1lbnRDbG9zZXN0KGFsaWdubWVudEVsLCAnLmZjLXNjcm9sbGdyaWQnKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3BcbiAgICAgICAgICAgICAgICA6IGFsaWdubWVudFJlY3QudG9wO1xuICAgICAgICAgICAgbGV0IHBvcG92ZXJMZWZ0ID0gaXNSdGwgPyBhbGlnbm1lbnRSZWN0LnJpZ2h0IC0gcG9wb3ZlckRpbXMud2lkdGggOiBhbGlnbm1lbnRSZWN0LmxlZnQ7XG4gICAgICAgICAgICAvLyBjb25zdHJhaW5cbiAgICAgICAgICAgIHBvcG92ZXJUb3AgPSBNYXRoLm1heChwb3BvdmVyVG9wLCBQQURESU5HX0ZST01fVklFV1BPUlQpO1xuICAgICAgICAgICAgcG9wb3ZlckxlZnQgPSBNYXRoLm1pbihwb3BvdmVyTGVmdCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIC0gUEFERElOR19GUk9NX1ZJRVdQT1JUIC0gcG9wb3ZlckRpbXMud2lkdGgpO1xuICAgICAgICAgICAgcG9wb3ZlckxlZnQgPSBNYXRoLm1heChwb3BvdmVyTGVmdCwgUEFERElOR19GUk9NX1ZJRVdQT1JUKTtcbiAgICAgICAgICAgIGxldCBvcmlnaW4gPSByb290RWwub2Zmc2V0UGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgYXBwbHlTdHlsZShyb290RWwsIHtcbiAgICAgICAgICAgICAgICB0b3A6IHBvcG92ZXJUb3AgLSBvcmlnaW4udG9wLFxuICAgICAgICAgICAgICAgIGxlZnQ6IHBvcG92ZXJMZWZ0IC0gb3JpZ2luLmxlZnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgTW9yZVBvcG92ZXIgZXh0ZW5kcyBEYXRlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVSb290RWwgPSAocm9vdEVsKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJvb3RFbCA9IHJvb3RFbDtcbiAgICAgICAgICAgIGlmIChyb290RWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCh0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsOiByb290RWwsXG4gICAgICAgICAgICAgICAgICAgIHVzZUV2ZW50Q2VudGVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgb3B0aW9ucywgZGF0ZUVudiB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgc3RhcnREYXRlLCB0b2RheVJhbmdlLCBkYXRlUHJvZmlsZSB9ID0gcHJvcHM7XG4gICAgICAgIGxldCB0aXRsZSA9IGRhdGVFbnYuZm9ybWF0KHN0YXJ0RGF0ZSwgb3B0aW9ucy5kYXlQb3BvdmVyRm9ybWF0KTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KERheUNlbGxDb250YWluZXIsIHsgZWxSZWY6IHRoaXMuaGFuZGxlUm9vdEVsLCBkYXRlOiBzdGFydERhdGUsIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogdG9kYXlSYW5nZSB9LCAoSW5uZXJDb250ZW50LCByZW5kZXJQcm9wcywgZWxBdHRycykgPT4gKGNyZWF0ZUVsZW1lbnQoUG9wb3ZlciwgeyBlbFJlZjogZWxBdHRycy5yZWYsIGlkOiBwcm9wcy5pZCwgdGl0bGU6IHRpdGxlLCBleHRyYUNsYXNzTmFtZXM6IFsnZmMtbW9yZS1wb3BvdmVyJ10uY29uY2F0KGVsQXR0cnMuY2xhc3NOYW1lIHx8IFtdKSwgZXh0cmFBdHRyczogZWxBdHRycyAvKiBUT0RPOiBtYWtlIHRoZXNlIHRpbWUtYmFzZWQgd2hlbiBub3Qgd2hvbGUtZGF5PyAqLywgcGFyZW50RWw6IHByb3BzLnBhcmVudEVsLCBhbGlnbm1lbnRFbDogcHJvcHMuYWxpZ25tZW50RWwsIGFsaWduR3JpZFRvcDogcHJvcHMuYWxpZ25HcmlkVG9wLCBvbkNsb3NlOiBwcm9wcy5vbkNsb3NlIH0sXG4gICAgICAgICAgICBoYXNDdXN0b21EYXlDZWxsQ29udGVudChvcHRpb25zKSAmJiAoY3JlYXRlRWxlbWVudChJbm5lckNvbnRlbnQsIHsgZWxUYWc6IFwiZGl2XCIsIGVsQ2xhc3NlczogWydmYy1tb3JlLXBvcG92ZXItbWlzYyddIH0pKSxcbiAgICAgICAgICAgIHByb3BzLmNoaWxkcmVuKSkpKTtcbiAgICB9XG4gICAgcXVlcnlIaXQocG9zaXRpb25MZWZ0LCBwb3NpdGlvblRvcCwgZWxXaWR0aCwgZWxIZWlnaHQpIHtcbiAgICAgICAgbGV0IHsgcm9vdEVsLCBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgaWYgKHBvc2l0aW9uTGVmdCA+PSAwICYmIHBvc2l0aW9uTGVmdCA8IGVsV2lkdGggJiZcbiAgICAgICAgICAgIHBvc2l0aW9uVG9wID49IDAgJiYgcG9zaXRpb25Ub3AgPCBlbEhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICAgICAgZGF0ZVNwYW46IE9iamVjdC5hc3NpZ24oeyBhbGxEYXk6ICFwcm9wcy5mb3JjZVRpbWVkLCByYW5nZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHByb3BzLnN0YXJ0RGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogcHJvcHMuZW5kRGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgfSB9LCBwcm9wcy5leHRyYURhdGVTcGFuKSxcbiAgICAgICAgICAgICAgICBkYXlFbDogcm9vdEVsLFxuICAgICAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICByaWdodDogZWxXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBlbEhlaWdodCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxheWVyOiAxLCAvLyBpbXBvcnRhbnQgd2hlbiBjb21wYXJpbmcgd2l0aCBoaXRzIGZyb20gb3RoZXIgY29tcG9uZW50c1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbmNsYXNzIE1vcmVMaW5rQ29udGFpbmVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBpc1BvcG92ZXJPcGVuOiBmYWxzZSxcbiAgICAgICAgICAgIHBvcG92ZXJJZDogZ2V0VW5pcXVlRG9tSWQoKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVMaW5rRWwgPSAobGlua0VsKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxpbmtFbCA9IGxpbmtFbDtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmVsUmVmKSB7XG4gICAgICAgICAgICAgICAgc2V0UmVmKHRoaXMucHJvcHMuZWxSZWYsIGxpbmtFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlQ2xpY2sgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IHsgbW9yZUxpbmtDbGljayB9ID0gY29udGV4dC5vcHRpb25zO1xuICAgICAgICAgICAgbGV0IGRhdGUgPSBjb21wdXRlUmFuZ2UocHJvcHMpLnN0YXJ0O1xuICAgICAgICAgICAgZnVuY3Rpb24gYnVpbGRQdWJsaWNTZWcoc2VnKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZGVmLCBpbnN0YW5jZSwgcmFuZ2UgfSA9IHNlZy5ldmVudFJhbmdlO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIGRlZiwgaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogY29udGV4dC5kYXRlRW52LnRvRGF0ZShyYW5nZS5zdGFydCksXG4gICAgICAgICAgICAgICAgICAgIGVuZDogY29udGV4dC5kYXRlRW52LnRvRGF0ZShyYW5nZS5lbmQpLFxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBzZWcuaXNTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IHNlZy5pc0VuZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtb3JlTGlua0NsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgbW9yZUxpbmtDbGljayA9IG1vcmVMaW5rQ2xpY2soe1xuICAgICAgICAgICAgICAgICAgICBkYXRlLFxuICAgICAgICAgICAgICAgICAgICBhbGxEYXk6IEJvb2xlYW4ocHJvcHMuYWxsRGF5RGF0ZSksXG4gICAgICAgICAgICAgICAgICAgIGFsbFNlZ3M6IHByb3BzLmFsbFNlZ3MubWFwKGJ1aWxkUHVibGljU2VnKSxcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuU2VnczogcHJvcHMuaGlkZGVuU2Vncy5tYXAoYnVpbGRQdWJsaWNTZWcpLFxuICAgICAgICAgICAgICAgICAgICBqc0V2ZW50OiBldixcbiAgICAgICAgICAgICAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtb3JlTGlua0NsaWNrIHx8IG1vcmVMaW5rQ2xpY2sgPT09ICdwb3BvdmVyJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBpc1BvcG92ZXJPcGVuOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1vcmVMaW5rQ2xpY2sgPT09ICdzdHJpbmcnKSB7IC8vIGEgdmlldyBuYW1lXG4gICAgICAgICAgICAgICAgY29udGV4dC5jYWxlbmRhckFwaS56b29tVG8oZGF0ZSwgbW9yZUxpbmtDbGljayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUG9wb3ZlckNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGlzUG9wb3Zlck9wZW46IGZhbHNlIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFZpZXdDb250ZXh0VHlwZS5Db25zdW1lciwgbnVsbCwgKGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIGxldCB7IHZpZXdBcGksIG9wdGlvbnMsIGNhbGVuZGFyQXBpIH0gPSBjb250ZXh0O1xuICAgICAgICAgICAgbGV0IHsgbW9yZUxpbmtUZXh0IH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgbGV0IHsgbW9yZUNudCB9ID0gcHJvcHM7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSBjb21wdXRlUmFuZ2UocHJvcHMpO1xuICAgICAgICAgICAgbGV0IHRleHQgPSB0eXBlb2YgbW9yZUxpbmtUZXh0ID09PSAnZnVuY3Rpb24nIC8vIFRPRE86IGV2ZW50dWFsbHkgdXNlIGZvcm1hdFdpdGhPcmRpbmFsc1xuICAgICAgICAgICAgICAgID8gbW9yZUxpbmtUZXh0LmNhbGwoY2FsZW5kYXJBcGksIG1vcmVDbnQpXG4gICAgICAgICAgICAgICAgOiBgKyR7bW9yZUNudH0gJHttb3JlTGlua1RleHR9YDtcbiAgICAgICAgICAgIGxldCBoaW50ID0gZm9ybWF0V2l0aE9yZGluYWxzKG9wdGlvbnMubW9yZUxpbmtIaW50LCBbbW9yZUNudF0sIHRleHQpO1xuICAgICAgICAgICAgbGV0IHJlbmRlclByb3BzID0ge1xuICAgICAgICAgICAgICAgIG51bTogbW9yZUNudCxcbiAgICAgICAgICAgICAgICBzaG9ydFRleHQ6IGArJHttb3JlQ250fWAsXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICB2aWV3OiB2aWV3QXBpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgICAgICBCb29sZWFuKHByb3BzLm1vcmVDbnQpICYmIChjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIHsgZWxUYWc6IHByb3BzLmVsVGFnIHx8ICdhJywgZWxSZWY6IHRoaXMuaGFuZGxlTGlua0VsLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLihwcm9wcy5lbENsYXNzZXMgfHwgW10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLW1vcmUtbGluaycsXG4gICAgICAgICAgICAgICAgICAgIF0sIGVsU3R5bGU6IHByb3BzLmVsU3R5bGUsIGVsQXR0cnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9wcy5lbEF0dHJzKSwgY3JlYXRlQXJpYUNsaWNrQXR0cnModGhpcy5oYW5kbGVDbGljaykpLCB7IHRpdGxlOiBoaW50LCAnYXJpYS1leHBhbmRlZCc6IHN0YXRlLmlzUG9wb3Zlck9wZW4sICdhcmlhLWNvbnRyb2xzJzogc3RhdGUuaXNQb3BvdmVyT3BlbiA/IHN0YXRlLnBvcG92ZXJJZCA6ICcnIH0pLCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwibW9yZUxpbmtDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5tb3JlTGlua0NvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHByb3BzLmRlZmF1bHRHZW5lcmF0b3IgfHwgcmVuZGVyTW9yZUxpbmtJbm5lciwgY2xhc3NOYW1lR2VuZXJhdG9yOiBvcHRpb25zLm1vcmVMaW5rQ2xhc3NOYW1lcywgZGlkTW91bnQ6IG9wdGlvbnMubW9yZUxpbmtEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMubW9yZUxpbmtXaWxsVW5tb3VudCB9LCBwcm9wcy5jaGlsZHJlbikpLFxuICAgICAgICAgICAgICAgIHN0YXRlLmlzUG9wb3Zlck9wZW4gJiYgKGNyZWF0ZUVsZW1lbnQoTW9yZVBvcG92ZXIsIHsgaWQ6IHN0YXRlLnBvcG92ZXJJZCwgc3RhcnREYXRlOiByYW5nZS5zdGFydCwgZW5kRGF0ZTogcmFuZ2UuZW5kLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIGV4dHJhRGF0ZVNwYW46IHByb3BzLmV4dHJhRGF0ZVNwYW4sIHBhcmVudEVsOiB0aGlzLnBhcmVudEVsLCBhbGlnbm1lbnRFbDogcHJvcHMuYWxpZ25tZW50RWxSZWYgP1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMuYWxpZ25tZW50RWxSZWYuY3VycmVudCA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmtFbCwgYWxpZ25HcmlkVG9wOiBwcm9wcy5hbGlnbkdyaWRUb3AsIGZvcmNlVGltZWQ6IHByb3BzLmZvcmNlVGltZWQsIG9uQ2xvc2U6IHRoaXMuaGFuZGxlUG9wb3ZlckNsb3NlIH0sIHByb3BzLnBvcG92ZXJDb250ZW50KCkpKSkpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVBhcmVudEVsKCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVQYXJlbnRFbCgpO1xuICAgIH1cbiAgICB1cGRhdGVQYXJlbnRFbCgpIHtcbiAgICAgICAgaWYgKHRoaXMubGlua0VsKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudEVsID0gZWxlbWVudENsb3Nlc3QodGhpcy5saW5rRWwsICcuZmMtdmlldy1oYXJuZXNzJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiByZW5kZXJNb3JlTGlua0lubmVyKHByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzLnRleHQ7XG59XG5mdW5jdGlvbiBjb21wdXRlUmFuZ2UocHJvcHMpIHtcbiAgICBpZiAocHJvcHMuYWxsRGF5RGF0ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhcnQ6IHByb3BzLmFsbERheURhdGUsXG4gICAgICAgICAgICBlbmQ6IGFkZERheXMocHJvcHMuYWxsRGF5RGF0ZSwgMSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGxldCB7IGhpZGRlblNlZ3MgfSA9IHByb3BzO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBjb21wdXRlRWFybGllc3RTZWdTdGFydChoaWRkZW5TZWdzKSxcbiAgICAgICAgZW5kOiBjb21wdXRlTGF0ZXN0U2VnRW5kKGhpZGRlblNlZ3MpLFxuICAgIH07XG59XG5mdW5jdGlvbiBjb21wdXRlRWFybGllc3RTZWdTdGFydChzZWdzKSB7XG4gICAgcmV0dXJuIHNlZ3MucmVkdWNlKHBpY2tFYXJsaWVzdFN0YXJ0KS5ldmVudFJhbmdlLnJhbmdlLnN0YXJ0O1xufVxuZnVuY3Rpb24gcGlja0VhcmxpZXN0U3RhcnQoc2VnMCwgc2VnMSkge1xuICAgIHJldHVybiBzZWcwLmV2ZW50UmFuZ2UucmFuZ2Uuc3RhcnQgPCBzZWcxLmV2ZW50UmFuZ2UucmFuZ2Uuc3RhcnQgPyBzZWcwIDogc2VnMTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVMYXRlc3RTZWdFbmQoc2Vncykge1xuICAgIHJldHVybiBzZWdzLnJlZHVjZShwaWNrTGF0ZXN0RW5kKS5ldmVudFJhbmdlLnJhbmdlLmVuZDtcbn1cbmZ1bmN0aW9uIHBpY2tMYXRlc3RFbmQoc2VnMCwgc2VnMSkge1xuICAgIHJldHVybiBzZWcwLmV2ZW50UmFuZ2UucmFuZ2UuZW5kID4gc2VnMS5ldmVudFJhbmdlLnJhbmdlLmVuZCA/IHNlZzAgOiBzZWcxO1xufVxuXG5jbGFzcyBTdG9yZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgICB9XG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gdmFsdWU7XG4gICAgICAgIGZvciAobGV0IGhhbmRsZXIgb2YgdGhpcy5oYW5kbGVycykge1xuICAgICAgICAgICAgaGFuZGxlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3Vic2NyaWJlKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaGFuZGxlcih0aGlzLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qXG5TdWJzY3JpYmVycyB3aWxsIGdldCBhIExJU1Qgb2YgQ3VzdG9tUmVuZGVyaW5nc1xuKi9cbmNsYXNzIEN1c3RvbVJlbmRlcmluZ1N0b3JlIGV4dGVuZHMgU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm1hcCA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLy8gZm9yIGNvbnNpc3RlbnQgb3JkZXJcbiAgICBoYW5kbGUoY3VzdG9tUmVuZGVyaW5nKSB7XG4gICAgICAgIGNvbnN0IHsgbWFwIH0gPSB0aGlzO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoY3VzdG9tUmVuZGVyaW5nLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICBtYXAuc2V0KGN1c3RvbVJlbmRlcmluZy5pZCwgY3VzdG9tUmVuZGVyaW5nKTtcbiAgICAgICAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hcC5oYXMoY3VzdG9tUmVuZGVyaW5nLmlkKSkge1xuICAgICAgICAgICAgbWFwLmRlbGV0ZShjdXN0b21SZW5kZXJpbmcuaWQpO1xuICAgICAgICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KG1hcCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IGVsZW1lbnRDbG9zZXN0IGFzICQsIG1lbW9pemVPYmpBcmcgYXMgQSwgQmFzZUNvbXBvbmVudCBhcyBCLCBDb250ZW50Q29udGFpbmVyIGFzIEMsIERlbGF5ZWRSdW5uZXIgYXMgRCwgaXNQcm9wc0VxdWFsIGFzIEUsIEVtaXR0ZXIgYXMgRiwgZ2V0SW5pdGlhbERhdGUgYXMgRywgcmFuZ2VDb250YWluc01hcmtlciBhcyBILCBjcmVhdGVFbXB0eUV2ZW50U3RvcmUgYXMgSSwgcmVkdWNlQ3VycmVudERhdGUgYXMgSiwgcmVkdWNlRXZlbnRTdG9yZSBhcyBLLCByZXpvbmVFdmVudFN0b3JlRGF0ZXMgYXMgTCwgbWVyZ2VSYXdPcHRpb25zIGFzIE0sIEJBU0VfT1BUSU9OX1JFRklORVJTIGFzIE4sIENBTEVOREFSX0xJU1RFTkVSX1JFRklORVJTIGFzIE8sIENBTEVOREFSX09QVElPTl9SRUZJTkVSUyBhcyBQLCBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SUyBhcyBRLCBWSUVXX09QVElPTl9SRUZJTkVSUyBhcyBSLCBEYXRlRW52IGFzIFMsIFRoZW1lIGFzIFQsIERhdGVQcm9maWxlR2VuZXJhdG9yIGFzIFUsIFZpZXdDb250ZXh0VHlwZSBhcyBWLCBjcmVhdGVFdmVudFVpIGFzIFcsIHBhcnNlQnVzaW5lc3NIb3VycyBhcyBYLCBzZXRSZWYgYXMgWSwgSW50ZXJhY3Rpb24gYXMgWiwgZ2V0RWxTZWcgYXMgXywgbWFwSGFzaCBhcyBhLCBnZXRTbG90Q2xhc3NOYW1lcyBhcyBhJCwgRXZlbnRJbXBsIGFzIGEwLCBsaXN0ZW5CeVNlbGVjdG9yIGFzIGExLCBsaXN0ZW5Ub0hvdmVyQnlTZWxlY3RvciBhcyBhMiwgUHVyZUNvbXBvbmVudCBhcyBhMywgYnVpbGRWaWV3Q29udGV4dCBhcyBhNCwgZ2V0VW5pcXVlRG9tSWQgYXMgYTUsIHBhcnNlSW50ZXJhY3Rpb25TZXR0aW5ncyBhcyBhNiwgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlIGFzIGE3LCBnZXROb3cgYXMgYTgsIENhbGVuZGFySW1wbCBhcyBhOSwgZGlmZkRhdGVzIGFzIGFBLCByZW1vdmVFeGFjdCBhcyBhQiwgbWVtb2l6ZUFycmF5bGlrZSBhcyBhQywgbWVtb2l6ZUhhc2hsaWtlIGFzIGFELCBpbnRlcnNlY3RSZWN0cyBhcyBhRSwgcG9pbnRJbnNpZGVSZWN0IGFzIGFGLCBjb25zdHJhaW5Qb2ludCBhcyBhRywgZ2V0UmVjdENlbnRlciBhcyBhSCwgZGlmZlBvaW50cyBhcyBhSSwgdHJhbnNsYXRlUmVjdCBhcyBhSiwgY29tcGFyZU9ianMgYXMgYUssIGNvbGxlY3RGcm9tSGFzaCBhcyBhTCwgZmluZEVsZW1lbnRzIGFzIGFNLCBmaW5kRGlyZWN0Q2hpbGRyZW4gYXMgYU4sIHJlbW92ZUVsZW1lbnQgYXMgYU8sIGFwcGx5U3R5bGUgYXMgYVAsIGVsZW1lbnRNYXRjaGVzIGFzIGFRLCBnZXRFdmVudFRhcmdldFZpYVJvb3QgYXMgYVIsIHBhcnNlQ2xhc3NOYW1lcyBhcyBhUywgZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsIGFzIGFULCBtZXJnZUV2ZW50U3RvcmVzIGFzIGFVLCBnZXRSZWxldmFudEV2ZW50cyBhcyBhViwgZXZlbnRUdXBsZVRvU3RvcmUgYXMgYVcsIGNvbWJpbmVFdmVudFVpcyBhcyBhWCwgU3BsaXR0ZXIgYXMgYVksIGdldERheUNsYXNzTmFtZXMgYXMgYVosIGdldERhdGVNZXRhIGFzIGFfLCBmbHVzaFN5bmMgYXMgYWEsIENhbGVuZGFyUm9vdCBhcyBhYiwgUmVuZGVySWQgYXMgYWMsIGVuc3VyZUVsSGFzU3R5bGVzIGFzIGFkLCBhcHBseVN0eWxlUHJvcCBhcyBhZSwgc2xpY2VFdmVudFN0b3JlIGFzIGFmLCBKc29uUmVxdWVzdEVycm9yIGFzIGFnLCBjcmVhdGVDb250ZXh0IGFzIGFoLCByZWZpbmVQcm9wcyBhcyBhaSwgY3JlYXRlRXZlbnRJbnN0YW5jZSBhcyBhaiwgcGFyc2VFdmVudERlZiBhcyBhaywgcmVmaW5lRXZlbnREZWYgYXMgYWwsIHBhZFN0YXJ0IGFzIGFtLCBpc0ludCBhcyBhbiwgcGFyc2VGaWVsZFNwZWNzIGFzIGFvLCBjb21wYXJlQnlGaWVsZFNwZWNzIGFzIGFwLCBmbGV4aWJsZUNvbXBhcmUgYXMgYXEsIHByZXZlbnRTZWxlY3Rpb24gYXMgYXIsIGFsbG93U2VsZWN0aW9uIGFzIGFzLCBwcmV2ZW50Q29udGV4dE1lbnUgYXMgYXQsIGFsbG93Q29udGV4dE1lbnUgYXMgYXUsIGNvbXBhcmVOdW1iZXJzIGFzIGF2LCBlbmFibGVDdXJzb3IgYXMgYXcsIGRpc2FibGVDdXJzb3IgYXMgYXgsIGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UgYXMgYXksIGlzTXVsdGlEYXlSYW5nZSBhcyBheiwgYnVpbGRWaWV3Q2xhc3NOYW1lcyBhcyBiLCBTaW1wbGVTY3JvbGxHcmlkIGFzIGIkLCBidWlsZE5hdkxpbmtBdHRycyBhcyBiMCwgcHJldmVudERlZmF1bHQgYXMgYjEsIHdoZW5UcmFuc2l0aW9uRG9uZSBhcyBiMiwgY29tcHV0ZUlubmVyUmVjdCBhcyBiMywgY29tcHV0ZUVkZ2VzIGFzIGI0LCBnZXRDbGlwcGluZ1BhcmVudHMgYXMgYjUsIGNvbXB1dGVSZWN0IGFzIGI2LCByYW5nZXNFcXVhbCBhcyBiNywgcmFuZ2VzSW50ZXJzZWN0IGFzIGI4LCByYW5nZUNvbnRhaW5zUmFuZ2UgYXMgYjksIFNlZ0hpZXJhcmNoeSBhcyBiQSwgYnVpbGRFbnRyeUtleSBhcyBiQiwgZ2V0RW50cnlTcGFuRW5kIGFzIGJDLCBiaW5hcnlTZWFyY2ggYXMgYkQsIGdyb3VwSW50ZXJzZWN0aW5nRW50cmllcyBhcyBiRSwgaW50ZXJzZWN0U3BhbnMgYXMgYkYsIGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlIGFzIGJHLCBFbGVtZW50RHJhZ2dpbmcgYXMgYkgsIGNvbmZpZyBhcyBiSSwgcGFyc2VEcmFnTWV0YSBhcyBiSiwgRGF5SGVhZGVyIGFzIGJLLCBjb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQgYXMgYkwsIFRhYmxlRGF0ZUNlbGwgYXMgYk0sIFRhYmxlRG93Q2VsbCBhcyBiTiwgRGF5U2VyaWVzTW9kZWwgYXMgYk8sIGhhc0JnUmVuZGVyaW5nIGFzIGJQLCBidWlsZFNlZ1RpbWVUZXh0IGFzIGJRLCBzb3J0RXZlbnRTZWdzIGFzIGJSLCBnZXRTZWdNZXRhIGFzIGJTLCBidWlsZEV2ZW50UmFuZ2VLZXkgYXMgYlQsIGdldFNlZ0FuY2hvckF0dHJzIGFzIGJVLCBEYXlUYWJsZU1vZGVsIGFzIGJWLCBTbGljZXIgYXMgYlcsIGFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUgYXMgYlgsIGlzUHJvcHNWYWxpZCBhcyBiWSwgaXNJbnRlcmFjdGlvblZhbGlkIGFzIGJaLCBpc0RhdGVTZWxlY3Rpb25WYWxpZCBhcyBiXywgUG9zaXRpb25DYWNoZSBhcyBiYSwgU2Nyb2xsQ29udHJvbGxlciBhcyBiYiwgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIgYXMgYmMsIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIgYXMgYmQsIERhdGVDb21wb25lbnQgYXMgYmUsIGlzRGF0ZVNwYW5zRXF1YWwgYXMgYmYsIGFkZE1zIGFzIGJnLCBhZGRXZWVrcyBhcyBiaCwgZGlmZldlZWtzIGFzIGJpLCBkaWZmV2hvbGVXZWVrcyBhcyBiaiwgZGlmZkRheUFuZFRpbWUgYXMgYmssIGRpZmZEYXlzIGFzIGJsLCBpc1ZhbGlkRGF0ZSBhcyBibSwgYXNDbGVhbkRheXMgYXMgYm4sIG11bHRpcGx5RHVyYXRpb24gYXMgYm8sIGFkZER1cmF0aW9ucyBhcyBicCwgYXNSb3VnaE1pbnV0ZXMgYXMgYnEsIGFzUm91Z2hTZWNvbmRzIGFzIGJyLCBhc1JvdWdoTXMgYXMgYnMsIHdob2xlRGl2aWRlRHVyYXRpb25zIGFzIGJ0LCBmb3JtYXRJc29UaW1lU3RyaW5nIGFzIGJ1LCBmb3JtYXREYXlTdHJpbmcgYXMgYnYsIGJ1aWxkSXNvU3RyaW5nIGFzIGJ3LCBmb3JtYXRJc29Nb250aFN0ciBhcyBieCwgTmFtZWRUaW1lWm9uZUltcGwgYXMgYnksIHBhcnNlIGFzIGJ6LCBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IgYXMgYywgaGFzU2hyaW5rV2lkdGggYXMgYzAsIHJlbmRlck1pY3JvQ29sR3JvdXAgYXMgYzEsIGdldFNjcm9sbEdyaWRDbGFzc05hbWVzIGFzIGMyLCBnZXRTZWN0aW9uQ2xhc3NOYW1lcyBhcyBjMywgZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodCBhcyBjNCwgZ2V0QWxsb3dZU2Nyb2xsaW5nIGFzIGM1LCByZW5kZXJDaHVua0NvbnRlbnQgYXMgYzYsIGNvbXB1dGVTaHJpbmtXaWR0aCBhcyBjNywgc2FuaXRpemVTaHJpbmtXaWR0aCBhcyBjOCwgaXNDb2xQcm9wc0VxdWFsIGFzIGM5LCByZW5kZXJTY3JvbGxTaGltIGFzIGNhLCBnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIgYXMgY2IsIGdldFN0aWNreUhlYWRlckRhdGVzIGFzIGNjLCBTY3JvbGxlciBhcyBjZCwgZ2V0U2Nyb2xsYmFyV2lkdGhzIGFzIGNlLCBSZWZNYXAgYXMgY2YsIGdldElzUnRsU2Nyb2xsYmFyT25MZWZ0IGFzIGNnLCBOb3dUaW1lciBhcyBjaCwgU2Nyb2xsUmVzcG9uZGVyIGFzIGNpLCBTdGFuZGFyZEV2ZW50IGFzIGNqLCBOb3dJbmRpY2F0b3JDb250YWluZXIgYXMgY2ssIERheUNlbGxDb250YWluZXIgYXMgY2wsIGhhc0N1c3RvbURheUNlbGxDb250ZW50IGFzIGNtLCBFdmVudENvbnRhaW5lciBhcyBjbiwgcmVuZGVyRmlsbCBhcyBjbywgQmdFdmVudCBhcyBjcCwgV2Vla051bWJlckNvbnRhaW5lciBhcyBjcSwgTW9yZUxpbmtDb250YWluZXIgYXMgY3IsIGNvbXB1dGVFYXJsaWVzdFNlZ1N0YXJ0IGFzIGNzLCBWaWV3Q29udGFpbmVyIGFzIGN0LCB0cmlnZ2VyRGF0ZVNlbGVjdCBhcyBjdSwgZ2V0RGVmYXVsdEV2ZW50RW5kIGFzIGN2LCBpbmplY3RTdHlsZXMgYXMgY3csIGJ1aWxkRWxBdHRycyBhcyBjeCwgQ3VzdG9tUmVuZGVyaW5nU3RvcmUgYXMgY3ksIGNyZWF0ZUR1cmF0aW9uIGFzIGQsIEJBU0VfT1BUSU9OX0RFRkFVTFRTIGFzIGUsIGFycmF5VG9IYXNoIGFzIGYsIGd1aWQgYXMgZywgZmlsdGVySGFzaCBhcyBoLCBpc0FycmF5c0VxdWFsIGFzIGksIGJ1aWxkRXZlbnRTb3VyY2VSZWZpbmVycyBhcyBqLCBmb3JtYXRXaXRoT3JkaW5hbHMgYXMgaywgYnVpbGRSYW5nZUFwaVdpdGhUaW1lWm9uZSBhcyBsLCBtZXJnZVByb3BzIGFzIG0sIGlkZW50aXR5IGFzIG4sIGludGVyc2VjdFJhbmdlcyBhcyBvLCBwYXJzZUV2ZW50U291cmNlIGFzIHAsIHN0YXJ0T2ZEYXkgYXMgcSwgcmVxdWVzdEpzb24gYXMgciwgc3VidHJhY3REdXJhdGlvbnMgYXMgcywgYWRkRGF5cyBhcyB0LCB1bnByb21pc2lmeSBhcyB1LCBoYXNoVmFsdWVzVG9BcnJheSBhcyB2LCBidWlsZEV2ZW50QXBpcyBhcyB3LCBjcmVhdGVGb3JtYXR0ZXIgYXMgeCwgZGlmZldob2xlRGF5cyBhcyB5LCBtZW1vaXplIGFzIHogfTtcbiJdLCJuYW1lcyI6WyJwcmVhY3QiLCJDb21wb25lbnQiLCJjcmVhdGVFbGVtZW50IiwiaXNWYWxpZEVsZW1lbnQiLCJGcmFnbWVudCIsImNyZWF0ZVBvcnRhbCIsInN0eWxlVGV4dHMiLCJzdHlsZUVscyIsIk1hcCIsImluamVjdFN0eWxlcyIsInN0eWxlVGV4dCIsInB1c2giLCJmb3JFYWNoIiwic3R5bGVFbCIsImFwcGVuZFN0eWxlc1RvIiwiZW5zdXJlRWxIYXNTdHlsZXMiLCJlbCIsImlzQ29ubmVjdGVkIiwiZ2V0Um9vdE5vZGUiLCJyZWdpc3RlclN0eWxlc1Jvb3QiLCJyb290Tm9kZSIsImdldCIsInF1ZXJ5U2VsZWN0b3IiLCJkb2N1bWVudCIsInNldEF0dHJpYnV0ZSIsIm5vbmNlIiwiZ2V0Tm9uY2VWYWx1ZSIsInBhcmVudEVsIiwiaGVhZCIsImluc2VydEJlZm9yZSIsImZpcnN0Q2hpbGQiLCJzZXQiLCJoeWRyYXRlU3R5bGVzUm9vdCIsInNoZWV0IiwicnVsZUNudCIsImNzc1J1bGVzIiwibGVuZ3RoIiwic3BsaXQiLCJzdHlsZVN0ciIsImkiLCJ0cmltIiwiaW5zZXJ0UnVsZSIsInF1ZXJpZWROb25jZVZhbHVlIiwidW5kZWZpbmVkIiwicXVlcnlOb25jZVZhbHVlIiwibWV0YVdpdGhOb25jZSIsImhhc0F0dHJpYnV0ZSIsImdldEF0dHJpYnV0ZSIsImVsV2l0aE5vbmNlIiwiY3NzXzI0OHoiLCJEZWxheWVkUnVubmVyIiwiY29uc3RydWN0b3IiLCJkcmFpbmVkT3B0aW9uIiwiaXNSdW5uaW5nIiwiaXNEaXJ0eSIsInBhdXNlRGVwdGhzIiwidGltZW91dElkIiwicmVxdWVzdCIsImRlbGF5IiwiaXNQYXVzZWQiLCJjbGVhclRpbWVvdXQiLCJ0cnlEcmFpbiIsInNldFRpbWVvdXQiLCJiaW5kIiwicGF1c2UiLCJzY29wZSIsInJlc3VtZSIsImZvcmNlIiwiZGVwdGgiLCJPYmplY3QiLCJrZXlzIiwiZHJhaW5lZCIsImNsZWFyIiwicmVtb3ZlRWxlbWVudCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImVsZW1lbnRDbG9zZXN0Iiwic2VsZWN0b3IiLCJjbG9zZXN0IiwiZG9jdW1lbnRFbGVtZW50IiwiY29udGFpbnMiLCJlbGVtZW50TWF0Y2hlcyIsInBhcmVudEVsZW1lbnQiLCJub2RlVHlwZSIsIm1ldGhvZCIsIm1hdGNoZXMiLCJtYXRjaGVzU2VsZWN0b3IiLCJtc01hdGNoZXNTZWxlY3RvciIsImNhbGwiLCJmaW5kRWxlbWVudHMiLCJjb250YWluZXIiLCJjb250YWluZXJzIiwiSFRNTEVsZW1lbnQiLCJhbGxNYXRjaGVzIiwicXVlcnlTZWxlY3RvckFsbCIsImoiLCJmaW5kRGlyZWN0Q2hpbGRyZW4iLCJwYXJlbnQiLCJwYXJlbnRzIiwiY2hpbGROb2RlcyIsImNoaWxkcmVuIiwiY2hpbGROb2RlIiwiUElYRUxfUFJPUF9SRSIsImFwcGx5U3R5bGUiLCJwcm9wcyIsInByb3BOYW1lIiwiYXBwbHlTdHlsZVByb3AiLCJuYW1lIiwidmFsIiwic3R5bGUiLCJ0ZXN0IiwiZ2V0RXZlbnRUYXJnZXRWaWFSb290IiwiZXYiLCJfYSIsIl9iIiwiY29tcG9zZWRQYXRoIiwidGFyZ2V0IiwiZ3VpZCQxIiwiZ2V0VW5pcXVlRG9tSWQiLCJwcmV2ZW50RGVmYXVsdCIsImJ1aWxkRGVsZWdhdGlvbkhhbmRsZXIiLCJoYW5kbGVyIiwibWF0Y2hlZENoaWxkIiwibGlzdGVuQnlTZWxlY3RvciIsImV2ZW50VHlwZSIsImF0dGFjaGVkSGFuZGxlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibGlzdGVuVG9Ib3ZlckJ5U2VsZWN0b3IiLCJvbk1vdXNlRW50ZXIiLCJvbk1vdXNlTGVhdmUiLCJjdXJyZW50TWF0Y2hlZENoaWxkIiwibW91c2VPdmVyRXYiLCJyZWFsT25Nb3VzZUxlYXZlIiwibW91c2VMZWF2ZUV2IiwidHJhbnNpdGlvbkV2ZW50TmFtZXMiLCJ3aGVuVHJhbnNpdGlvbkRvbmUiLCJjYWxsYmFjayIsInJlYWxDYWxsYmFjayIsImV2ZW50TmFtZSIsImNyZWF0ZUFyaWFDbGlja0F0dHJzIiwiYXNzaWduIiwib25DbGljayIsImNyZWF0ZUFyaWFLZXlib2FyZEF0dHJzIiwidGFiSW5kZXgiLCJvbktleURvd24iLCJrZXkiLCJndWlkTnVtYmVyIiwiZ3VpZCIsIlN0cmluZyIsImRpc2FibGVDdXJzb3IiLCJib2R5IiwiY2xhc3NMaXN0IiwiYWRkIiwiZW5hYmxlQ3Vyc29yIiwicmVtb3ZlIiwicHJldmVudFNlbGVjdGlvbiIsInVzZXJTZWxlY3QiLCJ3ZWJraXRVc2VyU2VsZWN0IiwiYWxsb3dTZWxlY3Rpb24iLCJwcmV2ZW50Q29udGV4dE1lbnUiLCJhbGxvd0NvbnRleHRNZW51IiwicGFyc2VGaWVsZFNwZWNzIiwiaW5wdXQiLCJzcGVjcyIsInRva2VucyIsInRva2VuIiwiQXJyYXkiLCJpc0FycmF5IiwiY2hhckF0IiwiZmllbGQiLCJzdWJzdHJpbmciLCJvcmRlciIsImZ1bmMiLCJjb21wYXJlQnlGaWVsZFNwZWNzIiwib2JqMCIsIm9iajEiLCJmaWVsZFNwZWNzIiwiY21wIiwiY29tcGFyZUJ5RmllbGRTcGVjIiwiZmllbGRTcGVjIiwiZmxleGlibGVDb21wYXJlIiwiYSIsImIiLCJsb2NhbGVDb21wYXJlIiwicGFkU3RhcnQiLCJsZW4iLCJzIiwic3Vic3RyIiwiZm9ybWF0V2l0aE9yZGluYWxzIiwiZm9ybWF0dGVyIiwiYXJncyIsImZhbGxiYWNrVGV4dCIsInJlZHVjZSIsInN0ciIsImFyZyIsImluZGV4IiwicmVwbGFjZSIsImNvbXBhcmVOdW1iZXJzIiwiaXNJbnQiLCJuIiwiY29tcHV0ZVNtYWxsZXN0Q2VsbFdpZHRoIiwiY2VsbEVsIiwiYWxsV2lkdGhFbCIsImNvbnRlbnRXaWR0aEVsIiwiRXJyb3IiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3aWR0aCIsIklOVEVSTkFMX1VOSVRTIiwiUEFSU0VfUkUiLCJjcmVhdGVEdXJhdGlvbiIsInVuaXQiLCJwYXJzZVN0cmluZyIsInBhcnNlT2JqZWN0IiwibSIsImV4ZWMiLCJzaWduIiwieWVhcnMiLCJtb250aHMiLCJkYXlzIiwicGFyc2VJbnQiLCJtaWxsaXNlY29uZHMiLCJvYmoiLCJkdXJhdGlvbiIsInllYXIiLCJtb250aCIsImRheSIsImhvdXJzIiwiaG91ciIsIm1pbnV0ZXMiLCJtaW51dGUiLCJzZWNvbmRzIiwic2Vjb25kIiwibWlsbGlzZWNvbmQiLCJtcyIsIndlZWtzIiwid2VlayIsInNwZWNpZmllZFdlZWtzIiwiZHVyYXRpb25zRXF1YWwiLCJkMCIsImQxIiwiYXNDbGVhbkRheXMiLCJkdXIiLCJhZGREdXJhdGlvbnMiLCJzdWJ0cmFjdER1cmF0aW9ucyIsIm11bHRpcGx5RHVyYXRpb24iLCJkIiwiYXNSb3VnaFllYXJzIiwiYXNSb3VnaERheXMiLCJhc1JvdWdoTW9udGhzIiwiYXNSb3VnaE1zIiwiYXNSb3VnaE1pbnV0ZXMiLCJhc1JvdWdoU2Vjb25kcyIsIndob2xlRGl2aWRlRHVyYXRpb25zIiwibnVtZXJhdG9yIiwiZGVub21pbmF0b3IiLCJyZXMiLCJsb2NhbFJlcyIsImdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvciIsInZhbHVlIiwicmVtb3ZlRXhhY3QiLCJhcnJheSIsImV4YWN0VmFsIiwicmVtb3ZlQ250Iiwic3BsaWNlIiwiaXNBcnJheXNFcXVhbCIsImEwIiwiYTEiLCJlcXVhbGl0eUZ1bmMiLCJEQVlfSURTIiwiYWRkV2Vla3MiLCJkYXRlVG9VdGNBcnJheSIsImFycmF5VG9VdGNEYXRlIiwiYWRkRGF5cyIsImFkZE1zIiwiZGlmZldlZWtzIiwibTAiLCJtMSIsImRpZmZEYXlzIiwidmFsdWVPZiIsImRpZmZIb3VycyIsImRpZmZNaW51dGVzIiwiZGlmZlNlY29uZHMiLCJkaWZmRGF5QW5kVGltZSIsIm0wZGF5Iiwic3RhcnRPZkRheSIsIm0xZGF5IiwiTWF0aCIsInJvdW5kIiwiZGlmZldob2xlV2Vla3MiLCJkaWZmV2hvbGVEYXlzIiwidGltZUFzTXMiLCJnZXRVVENGdWxsWWVhciIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRGF0ZSIsInN0YXJ0T2ZIb3VyIiwiZ2V0VVRDSG91cnMiLCJzdGFydE9mTWludXRlIiwiZ2V0VVRDTWludXRlcyIsInN0YXJ0T2ZTZWNvbmQiLCJnZXRVVENTZWNvbmRzIiwid2Vla09mWWVhciIsIm1hcmtlciIsImRvdyIsImRveSIsInkiLCJ3Iiwid2Vla09mR2l2ZW5ZZWFyIiwibmV4dFciLCJtaW4iLCJmaXJzdFdlZWtTdGFydCIsImZpcnN0V2Vla09mZnNldCIsImRheVN0YXJ0IiwiZmxvb3IiLCJmd2QiLCJmd2RsdyIsImdldFVUQ0RheSIsImRhdGVUb0xvY2FsQXJyYXkiLCJkYXRlIiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsImdldERhdGUiLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJnZXRTZWNvbmRzIiwiZ2V0TWlsbGlzZWNvbmRzIiwiYXJyYXlUb0xvY2FsRGF0ZSIsIkRhdGUiLCJnZXRVVENNaWxsaXNlY29uZHMiLCJjb25jYXQiLCJVVEMiLCJpc1ZhbGlkRGF0ZSIsImlzTmFOIiwiYnVpbGRJc29TdHJpbmciLCJ0aW1lWm9uZU9mZnNldCIsInN0cmlwWmVyb1RpbWUiLCJ0b0lTT1N0cmluZyIsImZvcm1hdFRpbWVab25lT2Zmc2V0IiwiZm9ybWF0RGF5U3RyaW5nIiwiZm9ybWF0SXNvTW9udGhTdHIiLCJtYXRjaCIsImZvcm1hdElzb1RpbWVTdHJpbmciLCJkb0lzbyIsImFicyIsIm1pbnMiLCJtZW1vaXplIiwid29ya2VyRnVuYyIsInJlc0VxdWFsaXR5IiwidGVhcmRvd25GdW5jIiwiY3VycmVudEFyZ3MiLCJjdXJyZW50UmVzIiwibmV3QXJncyIsImFwcGx5IiwibWVtb2l6ZU9iakFyZyIsImN1cnJlbnRBcmciLCJuZXdBcmciLCJpc1Byb3BzRXF1YWwiLCJtZW1vaXplQXJyYXlsaWtlIiwiY3VycmVudEFyZ1NldHMiLCJjdXJyZW50UmVzdWx0cyIsIm5ld0FyZ1NldHMiLCJjdXJyZW50TGVuIiwibmV3TGVuIiwibWVtb2l6ZUhhc2hsaWtlIiwiY3VycmVudEFyZ0hhc2giLCJjdXJyZW50UmVzSGFzaCIsIm5ld0FyZ0hhc2giLCJuZXdSZXNIYXNoIiwiRVhURU5ERURfU0VUVElOR1NfQU5EX1NFVkVSSVRJRVMiLCJzZXBhcmF0b3IiLCJvbWl0WmVyb01pbnV0ZSIsIm1lcmlkaWVtIiwib21pdENvbW1hcyIsIlNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTIiwidGltZVpvbmVOYW1lIiwiZXJhIiwid2Vla2RheSIsIk1FUklESUVNX1JFIiwiQ09NTUFfUkUiLCJNVUxUSV9TUEFDRV9SRSIsIkxUUl9SRSIsIlVUQ19SRSIsIk5hdGl2ZUZvcm1hdHRlciIsImZvcm1hdFNldHRpbmdzIiwic3RhbmRhcmREYXRlUHJvcHMiLCJleHRlbmRlZFNldHRpbmdzIiwic2V2ZXJpdHkiLCJtYXgiLCJidWlsZEZvcm1hdHRpbmdGdW5jIiwiZm9ybWF0IiwiY29udGV4dCIsImZvcm1hdFJhbmdlIiwic3RhcnQiLCJlbmQiLCJiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yIiwiZGlmZlNldmVyaXR5IiwiY29tcHV0ZU1hcmtlckRpZmZTZXZlcml0eSIsImNhbGVuZGFyU3lzdGVtIiwiYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsIiwiZnVsbDAiLCJmdWxsMSIsInBhcnRpYWxEYXRlUHJvcHMiLCJjb21wdXRlUGFydGlhbEZvcm1hdHRpbmdPcHRpb25zIiwicGFydGlhbEZvcm1hdHRpbmdGdW5jIiwicGFydGlhbDAiLCJwYXJ0aWFsMSIsImluc2VydGlvbiIsImZpbmRDb21tb25JbnNlcnRpb24iLCJkZWZhdWx0U2VwYXJhdG9yIiwiYmVmb3JlIiwiYWZ0ZXIiLCJnZXRMYXJnZXN0VW5pdCIsInN0YW5kYXJkRGF0ZVByb3BDbnQiLCJmb3JtYXRXZWVrTnVtYmVyIiwiY29tcHV0ZVdlZWtOdW1iZXIiLCJ3ZWVrVGV4dCIsIndlZWtUZXh0TG9uZyIsImxvY2FsZSIsImJ1aWxkTmF0aXZlRm9ybWF0dGluZ0Z1bmMiLCJzYW5pdGl6ZVNldHRpbmdzIiwidGltZVpvbmUiLCJub3JtYWxGb3JtYXQiLCJJbnRsIiwiRGF0ZVRpbWVGb3JtYXQiLCJjb2RlcyIsInplcm9Gb3JtYXQiLCJ6ZXJvUHJvcHMiLCJwb3N0UHJvY2VzcyIsImluamVjdFR6b1N0ciIsInRvTG9jYWxlTG93ZXJDYXNlIiwidHpvU3RyIiwicmVwbGFjZWQiLCJudW0iLCJkaXNwbGF5IiwicGFydHMiLCJzaW1wbGVOdW1iZXJGb3JtYXQiLCJvcHRpb25zIiwiZGlyZWN0aW9uIiwicmV2ZXJzZSIsImpvaW4iLCJjYSIsImdldE1hcmtlclllYXIiLCJnZXRNYXJrZXJNb250aCIsImdldE1hcmtlckRheSIsImJpZ2dlc3RVbml0IiwicGFydGlhbE9wdGlvbnMiLCJpMCIsImZvdW5kMCIsImluZGV4T2YiLCJiZWZvcmUwIiwiYWZ0ZXIwIiwiaTEiLCJmb3VuZDEiLCJiZWZvcmUxIiwiYWZ0ZXIxIiwiZXhwYW5kWm9uZWRNYXJrZXIiLCJkYXRlSW5mbyIsIm1hcmtlclRvQXJyYXkiLCJjcmVhdGVWZXJib3NlRm9ybWF0dGluZ0FyZyIsInN0YXJ0SW5mbyIsImVuZEluZm8iLCJsb2NhbGVDb2RlcyIsIkNtZEZvcm1hdHRlciIsImNtZFN0ciIsImNtZEZvcm1hdHRlciIsIkZ1bmNGb3JtYXR0ZXIiLCJjcmVhdGVGb3JtYXR0ZXIiLCJCQVNFX09QVElPTl9SRUZJTkVSUyIsIm5hdkxpbmtEYXlDbGljayIsImlkZW50aXR5IiwibmF2TGlua1dlZWtDbGljayIsImJvb3RzdHJhcEZvbnRBd2Vzb21lIiwiYnV0dG9uSWNvbnMiLCJjdXN0b21CdXR0b25zIiwiZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24iLCJkZWZhdWx0VGltZWRFdmVudER1cmF0aW9uIiwibmV4dERheVRocmVzaG9sZCIsInNjcm9sbFRpbWUiLCJzY3JvbGxUaW1lUmVzZXQiLCJCb29sZWFuIiwic2xvdE1pblRpbWUiLCJzbG90TWF4VGltZSIsImRheVBvcG92ZXJGb3JtYXQiLCJzbG90RHVyYXRpb24iLCJzbmFwRHVyYXRpb24iLCJoZWFkZXJUb29sYmFyIiwiZm9vdGVyVG9vbGJhciIsImRlZmF1bHRSYW5nZVNlcGFyYXRvciIsInRpdGxlUmFuZ2VTZXBhcmF0b3IiLCJmb3JjZUV2ZW50RHVyYXRpb24iLCJkYXlIZWFkZXJzIiwiZGF5SGVhZGVyRm9ybWF0IiwiZGF5SGVhZGVyQ2xhc3NOYW1lcyIsImRheUhlYWRlckNvbnRlbnQiLCJkYXlIZWFkZXJEaWRNb3VudCIsImRheUhlYWRlcldpbGxVbm1vdW50IiwiZGF5Q2VsbENsYXNzTmFtZXMiLCJkYXlDZWxsQ29udGVudCIsImRheUNlbGxEaWRNb3VudCIsImRheUNlbGxXaWxsVW5tb3VudCIsImluaXRpYWxWaWV3IiwiYXNwZWN0UmF0aW8iLCJOdW1iZXIiLCJ3ZWVrZW5kcyIsIndlZWtOdW1iZXJDYWxjdWxhdGlvbiIsIndlZWtOdW1iZXJzIiwid2Vla051bWJlckNsYXNzTmFtZXMiLCJ3ZWVrTnVtYmVyQ29udGVudCIsIndlZWtOdW1iZXJEaWRNb3VudCIsIndlZWtOdW1iZXJXaWxsVW5tb3VudCIsImVkaXRhYmxlIiwidmlld0NsYXNzTmFtZXMiLCJ2aWV3RGlkTW91bnQiLCJ2aWV3V2lsbFVubW91bnQiLCJub3dJbmRpY2F0b3IiLCJub3dJbmRpY2F0b3JDbGFzc05hbWVzIiwibm93SW5kaWNhdG9yQ29udGVudCIsIm5vd0luZGljYXRvckRpZE1vdW50Iiwibm93SW5kaWNhdG9yV2lsbFVubW91bnQiLCJzaG93Tm9uQ3VycmVudERhdGVzIiwibGF6eUZldGNoaW5nIiwic3RhcnRQYXJhbSIsImVuZFBhcmFtIiwidGltZVpvbmVQYXJhbSIsImxvY2FsZXMiLCJ0aGVtZVN5c3RlbSIsImRyYWdSZXZlcnREdXJhdGlvbiIsImRyYWdTY3JvbGwiLCJhbGxEYXlNYWludGFpbkR1cmF0aW9uIiwidW5zZWxlY3RBdXRvIiwiZHJvcEFjY2VwdCIsImV2ZW50T3JkZXIiLCJldmVudE9yZGVyU3RyaWN0IiwiaGFuZGxlV2luZG93UmVzaXplIiwid2luZG93UmVzaXplRGVsYXkiLCJsb25nUHJlc3NEZWxheSIsImV2ZW50RHJhZ01pbkRpc3RhbmNlIiwiZXhwYW5kUm93cyIsImhlaWdodCIsImNvbnRlbnRIZWlnaHQiLCJ3ZWVrTnVtYmVyRm9ybWF0IiwiZXZlbnRSZXNpemFibGVGcm9tU3RhcnQiLCJkaXNwbGF5RXZlbnRUaW1lIiwiZGlzcGxheUV2ZW50RW5kIiwicHJvZ3Jlc3NpdmVFdmVudFJlbmRlcmluZyIsImJ1c2luZXNzSG91cnMiLCJpbml0aWFsRGF0ZSIsIm5vdyIsImV2ZW50RGF0YVRyYW5zZm9ybSIsInN0aWNreUhlYWRlckRhdGVzIiwic3RpY2t5Rm9vdGVyU2Nyb2xsYmFyIiwidmlld0hlaWdodCIsImRlZmF1bHRBbGxEYXkiLCJldmVudFNvdXJjZUZhaWx1cmUiLCJldmVudFNvdXJjZVN1Y2Nlc3MiLCJldmVudERpc3BsYXkiLCJldmVudFN0YXJ0RWRpdGFibGUiLCJldmVudER1cmF0aW9uRWRpdGFibGUiLCJldmVudE92ZXJsYXAiLCJldmVudENvbnN0cmFpbnQiLCJldmVudEFsbG93IiwiZXZlbnRCYWNrZ3JvdW5kQ29sb3IiLCJldmVudEJvcmRlckNvbG9yIiwiZXZlbnRUZXh0Q29sb3IiLCJldmVudENvbG9yIiwiZXZlbnRDbGFzc05hbWVzIiwiZXZlbnRDb250ZW50IiwiZXZlbnREaWRNb3VudCIsImV2ZW50V2lsbFVubW91bnQiLCJzZWxlY3RDb25zdHJhaW50Iiwic2VsZWN0T3ZlcmxhcCIsInNlbGVjdEFsbG93IiwiZHJvcHBhYmxlIiwidW5zZWxlY3RDYW5jZWwiLCJzbG90TGFiZWxGb3JtYXQiLCJzbG90TGFuZUNsYXNzTmFtZXMiLCJzbG90TGFuZUNvbnRlbnQiLCJzbG90TGFuZURpZE1vdW50Iiwic2xvdExhbmVXaWxsVW5tb3VudCIsInNsb3RMYWJlbENsYXNzTmFtZXMiLCJzbG90TGFiZWxDb250ZW50Iiwic2xvdExhYmVsRGlkTW91bnQiLCJzbG90TGFiZWxXaWxsVW5tb3VudCIsImRheU1heEV2ZW50cyIsImRheU1heEV2ZW50Um93cyIsImRheU1pbldpZHRoIiwic2xvdExhYmVsSW50ZXJ2YWwiLCJhbGxEYXlUZXh0IiwiYWxsRGF5Q2xhc3NOYW1lcyIsImFsbERheUNvbnRlbnQiLCJhbGxEYXlEaWRNb3VudCIsImFsbERheVdpbGxVbm1vdW50Iiwic2xvdE1pbldpZHRoIiwibmF2TGlua3MiLCJldmVudFRpbWVGb3JtYXQiLCJyZXJlbmRlckRlbGF5IiwibW9yZUxpbmtUZXh0IiwibW9yZUxpbmtIaW50Iiwic2VsZWN0TWluRGlzdGFuY2UiLCJzZWxlY3RhYmxlIiwic2VsZWN0TG9uZ1ByZXNzRGVsYXkiLCJldmVudExvbmdQcmVzc0RlbGF5Iiwic2VsZWN0TWlycm9yIiwiZXZlbnRNYXhTdGFjayIsImV2ZW50TWluSGVpZ2h0IiwiZXZlbnRNaW5XaWR0aCIsImV2ZW50U2hvcnRIZWlnaHQiLCJzbG90RXZlbnRPdmVybGFwIiwicGx1Z2lucyIsImZpcnN0RGF5IiwiZGF5Q291bnQiLCJkYXRlQWxpZ25tZW50IiwiZGF0ZUluY3JlbWVudCIsImhpZGRlbkRheXMiLCJmaXhlZFdlZWtDb3VudCIsInZhbGlkUmFuZ2UiLCJ2aXNpYmxlUmFuZ2UiLCJ0aXRsZUZvcm1hdCIsImV2ZW50SW50ZXJhY3RpdmUiLCJub0V2ZW50c1RleHQiLCJ2aWV3SGludCIsIm5hdkxpbmtIaW50IiwiY2xvc2VIaW50IiwidGltZUhpbnQiLCJldmVudEhpbnQiLCJtb3JlTGlua0NsaWNrIiwibW9yZUxpbmtDbGFzc05hbWVzIiwibW9yZUxpbmtDb250ZW50IiwibW9yZUxpbmtEaWRNb3VudCIsIm1vcmVMaW5rV2lsbFVubW91bnQiLCJtb250aFN0YXJ0Rm9ybWF0IiwiaGFuZGxlQ3VzdG9tUmVuZGVyaW5nIiwiY3VzdG9tUmVuZGVyaW5nTWV0YU1hcCIsImN1c3RvbVJlbmRlcmluZ1JlcGxhY2VzIiwiQkFTRV9PUFRJT05fREVGQVVMVFMiLCJjZW50ZXIiLCJDQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUyIsImRhdGVzU2V0IiwiZXZlbnRzU2V0IiwiZXZlbnRBZGQiLCJldmVudENoYW5nZSIsImV2ZW50UmVtb3ZlIiwid2luZG93UmVzaXplIiwiZXZlbnRDbGljayIsImV2ZW50TW91c2VFbnRlciIsImV2ZW50TW91c2VMZWF2ZSIsInNlbGVjdCIsInVuc2VsZWN0IiwibG9hZGluZyIsIl91bm1vdW50IiwiX2JlZm9yZXByaW50IiwiX2FmdGVycHJpbnQiLCJfbm9FdmVudERyb3AiLCJfbm9FdmVudFJlc2l6ZSIsIl9yZXNpemUiLCJfc2Nyb2xsUmVxdWVzdCIsIkNBTEVOREFSX09QVElPTl9SRUZJTkVSUyIsImJ1dHRvblRleHQiLCJidXR0b25IaW50cyIsInZpZXdzIiwiaW5pdGlhbEV2ZW50cyIsImV2ZW50cyIsImV2ZW50U291cmNlcyIsIkNPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTIiwiaXNNYXliZU9iamVjdHNFcXVhbCIsImlzTWF5YmVBcnJheXNFcXVhbCIsIlZJRVdfT1BUSU9OX1JFRklORVJTIiwidHlwZSIsImNvbXBvbmVudCIsImJ1dHRvblRleHRLZXkiLCJkYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzIiwidXNlc01pbk1heFRpbWUiLCJjbGFzc05hbWVzIiwiY29udGVudCIsImRpZE1vdW50Iiwid2lsbFVubW91bnQiLCJtZXJnZVJhd09wdGlvbnMiLCJvcHRpb25TZXRzIiwibWVyZ2VQcm9wcyIsInJlZmluZVByb3BzIiwicmVmaW5lcnMiLCJyZWZpbmVkIiwiZXh0cmEiLCJyYXciLCJoYXNPd25Qcm9wZXJ0eSIsInByb3RvdHlwZSIsInByb3BPYmpzIiwiY29tcGxleFByb3BzTWFwIiwiZGVzdCIsImNvbXBsZXhPYmpzIiwidW5zaGlmdCIsImZpbHRlckhhc2giLCJoYXNoIiwiZmlsdGVyZWQiLCJtYXBIYXNoIiwibmV3SGFzaCIsImFycmF5VG9IYXNoIiwiaXRlbSIsImhhc2hWYWx1ZXNUb0FycmF5IiwiSEFORExFUl9SRSIsImlzTm9uSGFuZGxlclByb3BzRXF1YWwiLCJnZXRVbmVxdWFsUHJvcHMiLCJjb21wYXJlT2JqcyIsIm9sZFByb3BzIiwibmV3UHJvcHMiLCJlcXVhbGl0eUZ1bmNzIiwiaXNPYmpWYWxzRXF1YWwiLCJ2YWwwIiwidmFsMSIsImNvbXBhcmF0b3IiLCJjb2xsZWN0RnJvbUhhc2giLCJzdGFydEluZGV4IiwiZW5kSW5kZXgiLCJzdGVwIiwiY2FsZW5kYXJTeXN0ZW1DbGFzc01hcCIsInJlZ2lzdGVyQ2FsZW5kYXJTeXN0ZW0iLCJ0aGVDbGFzcyIsImNyZWF0ZUNhbGVuZGFyU3lzdGVtIiwiR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW0iLCJhcnJheVRvTWFya2VyIiwiYXJyIiwiSVNPX1JFIiwicGFyc2UiLCJpc1RpbWVVbnNwZWNpZmllZCIsIkRhdGVFbnYiLCJzZXR0aW5ncyIsImlzTmFtZWRUaW1lWm9uZSIsIm5hbWVkVGltZVpvbmVJbXBsIiwiY2FuQ29tcHV0ZU9mZnNldCIsIndlZWtEb3ciLCJ3ZWVrRG95Iiwid2Vla051bWJlckZ1bmMiLCJjcmVhdGVNYXJrZXIiLCJtZXRhIiwiY3JlYXRlTWFya2VyTWV0YSIsImNyZWF0ZU5vd01hcmtlciIsInRpbWVzdGFtcFRvTWFya2VyIiwiZm9yY2VkVHpvIiwiZ2V0WWVhciIsImdldERheSIsInN1YnRyYWN0IiwiYWRkWWVhcnMiLCJhZGRNb250aHMiLCJkaWZmV2hvbGVZZWFycyIsImRpZmZXaG9sZU1vbnRocyIsImdyZWF0ZXN0V2hvbGVVbml0IiwiY291bnREdXJhdGlvbnNCZXR3ZWVuIiwiZGlmZiIsInN0YXJ0T2YiLCJzdGFydE9mWWVhciIsInN0YXJ0T2ZNb250aCIsInN0YXJ0T2ZXZWVrIiwidG9EYXRlIiwiZGF0ZU9wdGlvbnMiLCJvZmZzZXRGb3JNYXJrZXIiLCJpc0VuZEV4Y2x1c2l2ZSIsImZvcmNlZFN0YXJ0VHpvIiwiZm9yY2VkRW5kVHpvIiwiZm9ybWF0SXNvIiwiZXh0cmFPcHRpb25zIiwib21pdFRpbWVab25lT2Zmc2V0Iiwib21pdFRpbWUiLCJ0aW1lc3RhbXBUb0FycmF5IiwiZ2V0VGltZXpvbmVPZmZzZXQiLCJvZmZzZXRGb3JBcnJheSIsIlRoZW1lIiwiY2FsZW5kYXJPcHRpb25zIiwiaWNvbk92ZXJyaWRlT3B0aW9uIiwic2V0SWNvbk92ZXJyaWRlIiwiaWNvbk92ZXJyaWRlSGFzaCIsImljb25DbGFzc2VzQ29weSIsImJ1dHRvbk5hbWUiLCJpY29uQ2xhc3NlcyIsImFwcGx5SWNvbk92ZXJyaWRlUHJlZml4IiwiY2xhc3NOYW1lIiwicHJlZml4IiwiaWNvbk92ZXJyaWRlUHJlZml4IiwiZ2V0Q2xhc3MiLCJjbGFzc2VzIiwiZ2V0SWNvbkNsYXNzIiwiaXNSdGwiLCJydGxJY29uQ2xhc3NlcyIsImJhc2VJY29uQ2xhc3MiLCJnZXRDdXN0b21CdXR0b25JY29uQ2xhc3MiLCJjdXN0b21CdXR0b25Qcm9wcyIsImljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbiIsImZsdXNoU3luYyIsInJ1bkJlZm9yZUZsdXNoIiwib2xkRGVib3VuY2VSZW5kZXJpbmciLCJkZWJvdW5jZVJlbmRlcmluZyIsImNhbGxiYWNrUSIsImV4ZWNDYWxsYmFja1N5bmMiLCJyZW5kZXIiLCJGYWtlQ29tcG9uZW50Iiwic2hpZnQiLCJjb21wb25lbnREaWRNb3VudCIsInNldFN0YXRlIiwiY3JlYXRlQ29udGV4dCIsImRlZmF1bHRWYWx1ZSIsIkNvbnRleHRUeXBlIiwib3JpZ1Byb3ZpZGVyIiwiUHJvdmlkZXIiLCJpc05ldyIsImdldENoaWxkQ29udGV4dCIsImFyZ3VtZW50cyIsInN1YnMiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJfcHJvcHMiLCJjIiwiZm9yY2VVcGRhdGUiLCJzdWIiLCJvbGQiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsIlNjcm9sbFJlc3BvbmRlciIsImV4ZWNGdW5jIiwiZW1pdHRlciIsImhhbmRsZVNjcm9sbFJlcXVlc3QiLCJxdWV1ZWRSZXF1ZXN0IiwiZHJhaW4iLCJvbiIsImZpcmVJbml0aWFsU2Nyb2xsIiwiZGV0YWNoIiwib2ZmIiwidXBkYXRlIiwiaXNEYXRlc05ldyIsInRpbWUiLCJWaWV3Q29udGV4dFR5cGUiLCJidWlsZFZpZXdDb250ZXh0Iiwidmlld1NwZWMiLCJ2aWV3QXBpIiwidmlld09wdGlvbnMiLCJkYXRlUHJvZmlsZUdlbmVyYXRvciIsImRhdGVFbnYiLCJ0aGVtZSIsInBsdWdpbkhvb2tzIiwiZGlzcGF0Y2giLCJnZXRDdXJyZW50RGF0YSIsImNhbGVuZGFyQXBpIiwicmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCIsInVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCIsImFkZFJlc2l6ZUhhbmRsZXIiLCJyZW1vdmVSZXNpemVIYW5kbGVyIiwiY3JlYXRlU2Nyb2xsUmVzcG9uZGVyIiwiUHVyZUNvbXBvbmVudCIsIm5leHRQcm9wcyIsIm5leHRTdGF0ZSIsImRlYnVnIiwiY29uc29sZSIsImxvZyIsInN0YXRlIiwicHJvcEVxdWFsaXR5Iiwic3RhdGVFcXVhbGl0eSIsInNhZmVTZXRTdGF0ZSIsIm5ld1N0YXRlIiwiYWRkUHJvcHNFcXVhbGl0eSIsImFkZFN0YXRlRXF1YWxpdHkiLCJjb250ZXh0VHlwZSIsIkJhc2VDb21wb25lbnQiLCJjcmVhdGUiLCJzZXRSZWYiLCJyZWYiLCJjdXJyZW50IiwiQ29udGVudEluamVjdG9yIiwiaWQiLCJxdWV1ZWREb21Ob2RlcyIsImN1cnJlbnREb21Ob2RlcyIsImhhbmRsZUVsIiwiZ2VuZXJhdG9yTmFtZSIsImhhc0N1c3RvbVJlbmRlcmluZ0hhbmRsZXIiLCJ1cGRhdGVFbFJlZiIsImVsUmVmIiwiY3VzdG9tR2VuZXJhdG9yIiwiZGVmYXVsdEdlbmVyYXRvciIsInJlbmRlclByb3BzIiwiYXR0cnMiLCJidWlsZEVsQXR0cnMiLCJ1c2VEZWZhdWx0IiwiaW5uZXJDb250ZW50IiwiY3VycmVudEdlbmVyYXRvck1ldGEiLCJjdXN0b21HZW5lcmF0b3JSZXMiLCJpc09iamVjdCIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiX19odG1sIiwiaHRtbCIsInNsaWNlIiwiZG9tTm9kZXMiLCJlbFRhZyIsImFwcGx5UXVldWV1ZERvbU5vZGVzIiwidHJpZ2dlckN1c3RvbVJlbmRlcmluZyIsImNvbXBvbmVudERpZFVwZGF0ZSIsImlzQWN0aXZlIiwiZ2VuZXJhdG9yTWV0YSIsImNvbnRhaW5lckVsIiwiYmFzZSIsInJlcG9ydE5ld0NvbnRhaW5lckVsIiwiZWxDbGFzc2VzIiwiZmlsdGVyIiwiaXNUcnV0aHkiLCJuZXdOb2RlIiwiYXBwZW5kQ2hpbGQiLCJlbFN0eWxlIiwiZWxBdHRycyIsImV4dHJhQ2xhc3NOYW1lcyIsIlJlbmRlcklkIiwiQ29udGVudENvbnRhaW5lciIsIklubmVyQ29udGVudCIsIklubmVyQ29udGVudEluamVjdG9yIiwiZGlkTW91bnRNaXNmaXJlIiwiZ2VuZXJhdGVkQ2xhc3NOYW1lcyIsImdlbmVyYXRlQ2xhc3NOYW1lcyIsImNsYXNzTmFtZUdlbmVyYXRvciIsInJlbmRlcklkIiwiY29udGFpbmVyQ29tcG9uZW50IiwicGFyZW50UHJvcHMiLCJWaWV3Q29udGFpbmVyIiwidmlldyIsImJ1aWxkVmlld0NsYXNzTmFtZXMiLCJwYXJzZVJhbmdlIiwiaW52ZXJ0UmFuZ2VzIiwicmFuZ2VzIiwiY29uc3RyYWludFJhbmdlIiwiaW52ZXJ0ZWRSYW5nZXMiLCJkYXRlUmFuZ2UiLCJzb3J0IiwiY29tcGFyZVJhbmdlcyIsInJhbmdlMCIsInJhbmdlMSIsImludGVyc2VjdFJhbmdlcyIsIm5ld1JhbmdlIiwicmFuZ2VzRXF1YWwiLCJyYW5nZXNJbnRlcnNlY3QiLCJyYW5nZUNvbnRhaW5zUmFuZ2UiLCJvdXRlclJhbmdlIiwiaW5uZXJSYW5nZSIsInJhbmdlQ29udGFpbnNNYXJrZXIiLCJyYW5nZSIsImNvbnN0cmFpbk1hcmtlclRvUmFuZ2UiLCJjb21wdXRlQWxpZ25lZERheVJhbmdlIiwidGltZWRSYW5nZSIsImRheUNudCIsImNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UiLCJzdGFydERheSIsImVuZERheSIsImVuZFRpbWVNUyIsImlzTXVsdGlEYXlSYW5nZSIsImRpZmZEYXRlcyIsImRhdGUwIiwiZGF0ZTEiLCJsYXJnZVVuaXQiLCJyZWR1Y2VDdXJyZW50RGF0ZSIsImN1cnJlbnREYXRlIiwiYWN0aW9uIiwiZGF0ZU1hcmtlciIsImdldEluaXRpYWxEYXRlIiwiaW5pdGlhbERhdGVJbnB1dCIsImdldE5vdyIsIm5vd0lucHV0IiwiRGF0ZVByb2ZpbGVHZW5lcmF0b3IiLCJub3dEYXRlIiwiaW5pdEhpZGRlbkRheXMiLCJidWlsZFByZXYiLCJjdXJyZW50RGF0ZVByb2ZpbGUiLCJmb3JjZVRvVmFsaWQiLCJwcmV2RGF0ZSIsImN1cnJlbnRSYW5nZVVuaXQiLCJidWlsZCIsImJ1aWxkTmV4dCIsIm5leHREYXRlIiwiY3VycmVudEluZm8iLCJpc1JhbmdlQWxsRGF5IiwicmVuZGVyUmFuZ2UiLCJhY3RpdmVSYW5nZSIsImlzVmFsaWQiLCJidWlsZFZhbGlkUmFuZ2UiLCJ0cmltSGlkZGVuRGF5cyIsImJ1aWxkQ3VycmVudFJhbmdlSW5mbyIsImJ1aWxkUmVuZGVyUmFuZ2UiLCJhZGp1c3RBY3RpdmVSYW5nZSIsImN1cnJlbnRSYW5nZSIsImJ1aWxkRGF0ZUluY3JlbWVudCIsInZhbGlkUmFuZ2VJbnB1dCIsInNpbXBsZUlucHV0IiwicmVmaW5lUmFuZ2UiLCJkdXJhdGlvblVuaXQiLCJidWlsZFJhbmdlRnJvbUR1cmF0aW9uIiwiYnVpbGRSYW5nZUZyb21EYXlDb3VudCIsImJ1aWxkQ3VzdG9tVmlzaWJsZVJhbmdlIiwiZ2V0RmFsbGJhY2tEdXJhdGlvbiIsImlzSGlkZGVuRGF5Iiwic2tpcEhpZGRlbkRheXMiLCJjb21wdXRlUmVzIiwicnVubmluZ0NvdW50IiwidmlzaWJsZVJhbmdlSW5wdXQiLCJmYWxsYmFjayIsImN1c3RvbUFsaWdubWVudCIsInJhbmdlSW5wdXQiLCJpc0hpZGRlbkRheUhhc2giLCJpbmMiLCJpc0V4Y2x1c2l2ZSIsImNyZWF0ZUV2ZW50SW5zdGFuY2UiLCJkZWZJZCIsImluc3RhbmNlSWQiLCJwYXJzZVJlY3VycmluZyIsInJlY3VycmluZ1R5cGVzIiwicGFyc2VkIiwiYWxsRGF5IiwiYWxsRGF5R3Vlc3MiLCJ0eXBlRGF0YSIsInR5cGVJZCIsImV4cGFuZFJlY3VycmluZyIsImV2ZW50U3RvcmUiLCJmcmFtaW5nUmFuZ2UiLCJkZWZzIiwiaW5zdGFuY2VzIiwiaW5zdGFuY2UiLCJyZWN1cnJpbmdEZWYiLCJkZWYiLCJzdGFydHMiLCJleHBhbmRSZWN1cnJpbmdSYW5nZXMiLCJldmVudERlZiIsInR5cGVEZWYiLCJtYXJrZXJzIiwiZXhwYW5kIiwibWFwIiwiRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlMiLCJncm91cElkIiwidGl0bGUiLCJ1cmwiLCJpbnRlcmFjdGl2ZSIsIkVWRU5UX0RBVEVfUkVGSU5FUlMiLCJFVkVOVF9SRUZJTkVSUyIsImV4dGVuZGVkUHJvcHMiLCJwYXJzZUV2ZW50IiwiZXZlbnRTb3VyY2UiLCJhbGxvd09wZW5SYW5nZSIsImJ1aWxkRXZlbnRSZWZpbmVycyIsImRlZklkTWFwIiwiaW5zdGFuY2VJZE1hcCIsInJlZmluZUV2ZW50RGVmIiwiY29tcHV0ZUlzRGVmYXVsdEFsbERheSIsInJlY3VycmluZ1JlcyIsInBhcnNlRXZlbnREZWYiLCJzb3VyY2VJZCIsInNpbmdsZVJlcyIsInBhcnNlU2luZ2xlIiwiaGFzRW5kIiwicHVibGljSWQiLCJFVkVOVF9VSV9SRUZJTkVSUyIsImV2ZW50UmVmaW5lcnMiLCJ1aSIsImNyZWF0ZUV2ZW50VWkiLCJtZW1iZXJBZGRlciIsImV2ZW50RGVmTWVtYmVyQWRkZXJzIiwiZnJlZXplIiwic3RhcnRNZXRhIiwic3RhcnRNYXJrZXIiLCJlbmRNZXRhIiwiZW5kTWFya2VyIiwic3RhcnRJbnB1dCIsInBhcnNlRXZlbnRzIiwicmF3RXZlbnRzIiwiY3JlYXRlRW1wdHlFdmVudFN0b3JlIiwicmF3RXZlbnQiLCJ0dXBsZSIsImV2ZW50VHVwbGVUb1N0b3JlIiwiZ2V0UmVsZXZhbnRFdmVudHMiLCJuZXdTdG9yZSIsImZpbHRlckV2ZW50U3RvcmVEZWZzIiwibG9va0RlZiIsImlzRXZlbnREZWZzR3JvdXBlZCIsImRlZjAiLCJkZWYxIiwibWVyZ2VFdmVudFN0b3JlcyIsInN0b3JlMCIsInN0b3JlMSIsImZpbHRlckZ1bmMiLCJleGNsdWRlU3ViRXZlbnRTdG9yZSIsIm1hc3RlciIsImZpbHRlcmVkRGVmcyIsImZpbHRlcmVkSW5zdGFuY2VzIiwibm9ybWFsaXplQ29uc3RyYWludCIsInBhcnNlQ2xhc3NOYW1lcyIsInN0YXJ0RWRpdGFibGUiLCJkdXJhdGlvbkVkaXRhYmxlIiwiY29uc3RyYWludCIsIm92ZXJsYXAiLCJhbGxvdyIsImNvbG9yIiwiYmFja2dyb3VuZENvbG9yIiwiYm9yZGVyQ29sb3IiLCJ0ZXh0Q29sb3IiLCJFTVBUWV9FVkVOVF9VSSIsImNvbnN0cmFpbnRzIiwiYWxsb3dzIiwiY29tYmluZUV2ZW50VWlzIiwidWlzIiwiY29tYmluZVR3b0V2ZW50VWlzIiwiaXRlbTAiLCJpdGVtMSIsIkVWRU5UX1NPVVJDRV9SRUZJTkVSUyIsInN1Y2Nlc3MiLCJmYWlsdXJlIiwicGFyc2VFdmVudFNvdXJjZSIsImJ1aWxkRXZlbnRTb3VyY2VSZWZpbmVycyIsInJhd09iaiIsIm1ldGFSZXMiLCJidWlsZEV2ZW50U291cmNlTWV0YSIsIl9yYXciLCJpc0ZldGNoaW5nIiwibGF0ZXN0RmV0Y2hJZCIsImZldGNoUmFuZ2UiLCJzb3VyY2VEZWZJZCIsImV2ZW50U291cmNlUmVmaW5lcnMiLCJldmVudFNvdXJjZURlZnMiLCJwYXJzZU1ldGEiLCJyZWR1Y2VFdmVudFN0b3JlIiwiZGF0ZVByb2ZpbGUiLCJyZWNlaXZlUmF3RXZlbnRzIiwiZmV0Y2hJZCIsInJlc2V0UmF3RXZlbnRzIiwiYWRkRXZlbnQiLCJleGNsdWRlRXZlbnRzQnlTb3VyY2VJZCIsInN1YnNldCIsInRyYW5zZm9ybVJhd0V2ZW50cyIsImV4aXN0aW5nRXZlbnRTdG9yZSIsImJ1aWxkUHVibGljSWRNYXBzIiwibmV3RXZlbnRTdG9yZSIsImNhbEVhY2hUcmFuc2Zvcm0iLCJzb3VyY2VFYWNoVHJhbnNmb3JtIiwidHJhbnNmb3JtRWFjaFJhd0V2ZW50IiwicmVmaW5lZEV2ZW50cyIsInJlZmluZWRFdmVudCIsImV4cGFuZFJhbmdlIiwicmV6b25lRXZlbnRTdG9yZURhdGVzIiwib2xkRGF0ZUVudiIsIm5ld0RhdGVFbnYiLCJleGNsdWRlSW5zdGFuY2VzIiwicmVtb3ZhbHMiLCJFbWl0dGVyIiwiaGFuZGxlcnMiLCJ0aGlzQ29udGV4dCIsInNldFRoaXNDb250ZXh0Iiwic2V0T3B0aW9ucyIsImFkZFRvSGFzaCIsInJlbW92ZUZyb21IYXNoIiwidHJpZ2dlciIsImF0dGFjaGVkSGFuZGxlcnMiLCJvcHRpb25IYW5kbGVyIiwiaGFzSGFuZGxlcnMiLCJERUZfREVGQVVMVFMiLCJzdGFydFRpbWUiLCJlbmRUaW1lIiwiZGF5c09mV2VlayIsInBhcnNlQnVzaW5lc3NIb3VycyIsInJlZmluZUlucHV0cyIsInJhd0RlZnMiLCJyYXdEZWYiLCJ0cmlnZ2VyRGF0ZVNlbGVjdCIsInNlbGVjdGlvbiIsInBldiIsImJ1aWxkRGF0ZVNwYW5BcGlXaXRoQ29udGV4dCIsImpzRXZlbnQiLCJvcmlnRXZlbnQiLCJ0cmlnZ2VyRGF0ZVVuc2VsZWN0IiwiZGF0ZVNwYW4iLCJ0cmFuc2Zvcm0iLCJkYXRlU3BhblRyYW5zZm9ybXMiLCJidWlsZERhdGVTcGFuQXBpIiwiZ2V0RGVmYXVsdEV2ZW50RW5kIiwiYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZSIsImV2ZW50Q29uZmlnQmFzZSIsIm11dGF0aW9uIiwiZXZlbnRDb25maWdzIiwiY29tcGlsZUV2ZW50VWlzIiwiYXBwbHlNdXRhdGlvblRvRXZlbnREZWYiLCJhcHBseU11dGF0aW9uVG9FdmVudEluc3RhbmNlIiwiZXZlbnRDb25maWciLCJzdGFuZGFyZFByb3BzIiwic3RhcnREZWx0YSIsImVuZERlbHRhIiwiY29weSIsImFwcGxpZXIiLCJldmVudERlZk11dGF0aW9uQXBwbGllcnMiLCJldmVudEluc3RhbmNlIiwiZm9yY2VBbGxEYXkiLCJjbGVhckVuZCIsImRhdGVzRGVsdGEiLCJFdmVudFNvdXJjZUltcGwiLCJpbnRlcm5hbEV2ZW50U291cmNlIiwicmVmZXRjaCIsInNvdXJjZUlkcyIsImlzUmVmZXRjaCIsIkV2ZW50SW1wbCIsIl9jb250ZXh0IiwiX2RlZiIsIl9pbnN0YW5jZSIsInNldFByb3AiLCJ3YXJuIiwibXV0YXRlIiwic2V0RXh0ZW5kZWRQcm9wIiwic2V0U3RhcnQiLCJpbnN0YW5jZVJhbmdlIiwiZ3JhbnVsYXJpdHkiLCJtYWludGFpbkR1cmF0aW9uIiwic2V0RW5kIiwiZW5kSW5wdXQiLCJzZXREYXRlcyIsIm1vdmVTdGFydCIsImRlbHRhSW5wdXQiLCJkZWx0YSIsIm1vdmVFbmQiLCJtb3ZlRGF0ZXMiLCJzZXRBbGxEYXkiLCJmb3JtYXRJbnB1dCIsInJlbGV2YW50RXZlbnRzIiwib2xkRXZlbnQiLCJldmVudCIsInJlbGF0ZWRFdmVudHMiLCJidWlsZEV2ZW50QXBpcyIsInJldmVydCIsImFzU3RvcmUiLCJldmVudEFwaVRvU3RvcmUiLCJzb3VyY2UiLCJzdGFydFN0ciIsImVuZFN0ciIsInRvUGxhaW5PYmplY3QiLCJjb2xsYXBzZUNvbG9yIiwiY29sbGFwc2VFeHRlbmRlZFByb3BzIiwidG9KU09OIiwiZXZlbnRBcGkiLCJleGNsdWRlSW5zdGFuY2UiLCJldmVudEFwaXMiLCJleGNsdWRlSW5zdGFuY2VJZCIsInNsaWNlRXZlbnRTdG9yZSIsImV2ZW50VWlCYXNlcyIsImludmVyc2VCZ0J5R3JvdXBJZCIsImludmVyc2VCZ0J5RGVmSWQiLCJkZWZCeUdyb3VwSWQiLCJiZ1JhbmdlcyIsImZnUmFuZ2VzIiwiZXZlbnRVaXMiLCJvcmlnUmFuZ2UiLCJub3JtYWxSYW5nZSIsInNsaWNlZFJhbmdlIiwiaXNTdGFydCIsImlzRW5kIiwiaW52ZXJ0ZWRSYW5nZSIsImJnIiwiZmciLCJoYXNCZ1JlbmRlcmluZyIsInNldEVsU2VnIiwic2VnIiwiZmNTZWciLCJnZXRFbFNlZyIsImV2ZW50RGVmcyIsImNvbXBpbGVFdmVudFVpIiwic29ydEV2ZW50U2VncyIsInNlZ3MiLCJldmVudE9yZGVyU3BlY3MiLCJvYmpzIiwiYnVpbGRTZWdDb21wYXJlT2JqIiwiX3NlZyIsImV2ZW50UmFuZ2UiLCJjb21wdXRlU2VnRHJhZ2dhYmxlIiwidHJhbnNmb3JtZXJzIiwiaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnMiLCJ0cmFuc2Zvcm1lciIsImNvbXB1dGVTZWdTdGFydFJlc2l6YWJsZSIsImNvbXB1dGVTZWdFbmRSZXNpemFibGUiLCJidWlsZFNlZ1RpbWVUZXh0IiwidGltZUZvcm1hdCIsImRlZmF1bHREaXNwbGF5RXZlbnRUaW1lIiwiZGVmYXVsdERpc3BsYXlFdmVudEVuZCIsInN0YXJ0T3ZlcnJpZGUiLCJlbmRPdmVycmlkZSIsIndob2xlRXZlbnRTdGFydCIsIndob2xlRXZlbnRFbmQiLCJzZWdTdGFydCIsInNlZ0VuZCIsImlzU3RhcnREYXkiLCJpc0VuZERheSIsImdldFNlZ01ldGEiLCJ0b2RheVJhbmdlIiwic2VnUmFuZ2UiLCJpc1Bhc3QiLCJpc0Z1dHVyZSIsImlzVG9kYXkiLCJnZXRFdmVudENsYXNzTmFtZXMiLCJpc01pcnJvciIsImlzRHJhZ2dhYmxlIiwiaXNTdGFydFJlc2l6YWJsZSIsImlzRW5kUmVzaXphYmxlIiwiaXNEcmFnZ2luZyIsImlzUmVzaXppbmciLCJpc1NlbGVjdGVkIiwiYnVpbGRFdmVudFJhbmdlS2V5IiwiZ2V0U2VnQW5jaG9yQXR0cnMiLCJocmVmIiwiU1RBTkRBUkRfUFJPUFMiLCJwYXJzZURhdGVTcGFuIiwiZGVmYXVsdER1cmF0aW9uIiwic3BhbiIsInBhcnNlT3BlbkRhdGVTcGFuIiwiaXNEYXRlU3BhbnNFcXVhbCIsInNwYW4wIiwic3BhbjEiLCJpc1NwYW5Qcm9wc0VxdWFsIiwiYnVpbGRSYW5nZUFwaSIsImJ1aWxkUmFuZ2VBcGlXaXRoVGltZVpvbmUiLCJmYWJyaWNhdGVFdmVudFJhbmdlIiwidW5wcm9taXNpZnkiLCJub3JtYWxpemVkU3VjY2Vzc0NhbGxiYWNrIiwibm9ybWFsaXplZEZhaWx1cmVDYWxsYmFjayIsImlzUmVzb2x2ZWQiLCJ3cmFwcGVkU3VjY2VzcyIsIndyYXBwZWRGYWlsdXJlIiwiZXJyb3IiLCJ0aGVuIiwiSnNvblJlcXVlc3RFcnJvciIsIm1lc3NhZ2UiLCJyZXNwb25zZSIsInJlcXVlc3RKc29uIiwicGFyYW1zIiwidG9VcHBlckNhc2UiLCJmZXRjaE9wdGlvbnMiLCJVUkxTZWFyY2hQYXJhbXMiLCJoZWFkZXJzIiwiZmV0Y2giLCJmZXRjaFJlcyIsIm9rIiwianNvbiIsInBhcnNlZFJlc3BvbnNlIiwiY2FuVkdyb3dXaXRoaW5DZWxsIiwiZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsIiwiY29tcHV0ZUNhblZHcm93V2l0aGluQ2VsbCIsInBvc2l0aW9uIiwidG9wIiwibGVmdCIsImlubmVySFRNTCIsImRpdiIsInBvc3NpYmxlIiwib2Zmc2V0SGVpZ2h0IiwiQ2FsZW5kYXJSb290IiwiZm9yUHJpbnQiLCJoYW5kbGVCZWZvcmVQcmludCIsImhhbmRsZUFmdGVyUHJpbnQiLCJpc0hlaWdodEF1dG8iLCJJbnRlcmFjdGlvbiIsImlzSGl0Q29tYm9BbGxvd2VkIiwiZGVzdHJveSIsInBhcnNlSW50ZXJhY3Rpb25TZXR0aW5ncyIsInVzZUV2ZW50Q2VudGVyIiwiaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUiLCJ1aWQiLCJpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUiLCJDYWxlbmRhckltcGwiLCJjdXJyZW50RGF0YU1hbmFnZXIiLCJiYXRjaFJlbmRlcmluZyIsInVwZGF0ZVNpemUiLCJzZXRPcHRpb24iLCJvcHRpb25OYW1lIiwicmF3T3B0aW9uVmFsdWUiLCJnZXRPcHRpb24iLCJjdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXQiLCJnZXRBdmFpbGFibGVMb2NhbGVDb2RlcyIsImF2YWlsYWJsZVJhd0xvY2FsZXMiLCJoYW5kbGVyTmFtZSIsImN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVycyIsImNoYW5nZVZpZXciLCJ2aWV3VHlwZSIsImRhdGVPclJhbmdlIiwiem9vbVRvIiwic3BlYyIsInZpZXdTcGVjcyIsImdldFVuaXRWaWV3U3BlYyIsInRvb2xiYXJDb25maWciLCJ2aWV3VHlwZXMiLCJoZWFkZXIiLCJ2aWV3c1dpdGhCdXR0b25zIiwiZm9vdGVyIiwic2luZ2xlVW5pdCIsInByZXYiLCJuZXh0IiwicHJldlllYXIiLCJuZXh0WWVhciIsInRvZGF5IiwiZ290b0RhdGUiLCJ6b25lZERhdGVJbnB1dCIsImluY3JlbWVudERhdGUiLCJmb3JtYXREYXRlIiwiZGF0ZU9yT2JqIiwiZW5kRGF0ZSIsInNlbGVjdGlvbklucHV0IiwiZGF0ZVNlbGVjdGlvbiIsImV2ZW50SW5wdXQiLCJzb3VyY2VJbnB1dCIsImN1cnJlbnREYXRhIiwidHJpZ2dlckV2ZW50QWRkIiwic291cmNlQXBpIiwiZ2V0RXZlbnRTb3VyY2VCeUlkIiwibmV3RXZlbnRBcGkiLCJnZXRFdmVudEJ5SWQiLCJnZXRFdmVudHMiLCJyZW1vdmVBbGxFdmVudHMiLCJnZXRFdmVudFNvdXJjZXMiLCJzb3VyY2VIYXNoIiwic291cmNlQXBpcyIsImludGVybmFsSWQiLCJhZGRFdmVudFNvdXJjZSIsInNvdXJjZXMiLCJyZW1vdmVBbGxFdmVudFNvdXJjZXMiLCJyZWZldGNoRXZlbnRzIiwic2Nyb2xsVG9UaW1lIiwidGltZUlucHV0IiwicG9pbnRJbnNpZGVSZWN0IiwicG9pbnQiLCJyZWN0IiwicmlnaHQiLCJib3R0b20iLCJpbnRlcnNlY3RSZWN0cyIsInJlY3QxIiwicmVjdDIiLCJ0cmFuc2xhdGVSZWN0IiwiZGVsdGFYIiwiZGVsdGFZIiwiY29uc3RyYWluUG9pbnQiLCJnZXRSZWN0Q2VudGVyIiwiZGlmZlBvaW50cyIsInBvaW50MSIsInBvaW50MiIsIkVNUFRZX0VWRU5UX1NUT1JFIiwiU3BsaXR0ZXIiLCJnZXRLZXlzRm9yRXZlbnREZWZzIiwiX2dldEtleXNGb3JFdmVudERlZnMiLCJzcGxpdERhdGVTZWxlY3Rpb24iLCJfc3BsaXREYXRlU3BhbiIsInNwbGl0RXZlbnRTdG9yZSIsIl9zcGxpdEV2ZW50U3RvcmUiLCJzcGxpdEluZGl2aWR1YWxVaSIsIl9zcGxpdEluZGl2aWR1YWxVaSIsInNwbGl0RXZlbnREcmFnIiwiX3NwbGl0SW50ZXJhY3Rpb24iLCJzcGxpdEV2ZW50UmVzaXplIiwiZXZlbnRVaUJ1aWxkZXJzIiwic3BsaXRQcm9wcyIsImtleUluZm9zIiwiZ2V0S2V5SW5mbyIsImRlZktleXMiLCJkYXRlU2VsZWN0aW9ucyIsImluZGl2aWR1YWxVaSIsImV2ZW50U3RvcmVzIiwiZXZlbnREcmFncyIsImV2ZW50RHJhZyIsImV2ZW50UmVzaXplcyIsImV2ZW50UmVzaXplIiwiaW5mbyIsImJ1aWxkRXZlbnRVaUZvcktleSIsImtleUluZm8iLCJidWlsZEV2ZW50VWkiLCJldmVudFNlbGVjdGlvbiIsImRhdGVTcGFucyIsImdldEtleXNGb3JEYXRlU3BhbiIsImdldEtleXNGb3JFdmVudERlZiIsInNwbGl0U3RvcmVzIiwic3BsaXRIYXNoZXMiLCJpbnRlcmFjdGlvbiIsInNwbGl0U3RhdGVzIiwiYWZmZWN0ZWRTdG9yZXMiLCJhZmZlY3RlZEV2ZW50cyIsIm11dGF0ZWRLZXlzQnlEZWZJZCIsIm11dGF0ZWRFdmVudHMiLCJtdXRhdGVkU3RvcmVzIiwicG9wdWxhdGUiLCJpc0V2ZW50IiwiYWxsVWkiLCJldmVudFVpRm9yS2V5IiwiYmFzZVBhcnRzIiwic3R1ZmYiLCJnZXREYXRlTWV0YSIsImlzRGlzYWJsZWQiLCJpc090aGVyIiwiZ2V0RGF5Q2xhc3NOYW1lcyIsImdldFNsb3RDbGFzc05hbWVzIiwiREFZX0ZPUk1BVCIsIldFRUtfRk9STUFUIiwiYnVpbGROYXZMaW5rQXR0cnMiLCJpc1RhYmJhYmxlIiwiZGF0ZVN0ciIsInpvbmVkRGF0ZSIsImhhbmRsZUludGVyYWN0aW9uIiwiY3VzdG9tQWN0aW9uIiwiX2lzUnRsU2Nyb2xsYmFyT25MZWZ0IiwiZ2V0SXNSdGxTY3JvbGxiYXJPbkxlZnQiLCJjb21wdXRlSXNSdGxTY3JvbGxiYXJPbkxlZnQiLCJvdXRlckVsIiwiYm9yZGVyIiwicGFkZGluZyIsIm92ZXJmbG93IiwiaW5uZXJFbCIsIl9zY3JvbGxiYXJXaWR0aHMiLCJnZXRTY3JvbGxiYXJXaWR0aHMiLCJjb21wdXRlU2Nyb2xsYmFyV2lkdGhzIiwiY29tcHV0ZVNjcm9sbGJhcldpZHRoc0ZvckVsIiwieCIsImNsaWVudEhlaWdodCIsIm9mZnNldFdpZHRoIiwiY2xpZW50V2lkdGgiLCJjb21wdXRlRWRnZXMiLCJnZXRQYWRkaW5nIiwiY29tcHV0ZWRTdHlsZSIsIndpbmRvdyIsImdldENvbXB1dGVkU3R5bGUiLCJib3JkZXJMZWZ0IiwiYm9yZGVyTGVmdFdpZHRoIiwiYm9yZGVyUmlnaHQiLCJib3JkZXJSaWdodFdpZHRoIiwiYm9yZGVyVG9wIiwiYm9yZGVyVG9wV2lkdGgiLCJib3JkZXJCb3R0b20iLCJib3JkZXJCb3R0b21XaWR0aCIsImJhZFNjcm9sbGJhcldpZHRocyIsInNjcm9sbGJhckxlZnRSaWdodCIsInNjcm9sbGJhckJvdHRvbSIsInNjcm9sbGJhckxlZnQiLCJzY3JvbGxiYXJSaWdodCIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1JpZ2h0IiwicGFkZGluZ1RvcCIsInBhZGRpbmdCb3R0b20iLCJjb21wdXRlSW5uZXJSZWN0IiwiZ29XaXRoaW5QYWRkaW5nIiwiZG9Gcm9tV2luZG93Vmlld3BvcnQiLCJvdXRlclJlY3QiLCJjb21wdXRlUmVjdCIsImVkZ2VzIiwic2Nyb2xsWCIsInNjcm9sbFkiLCJjb21wdXRlQ2xpcHBlZENsaWVudFJlY3QiLCJjbGlwcGluZ1BhcmVudHMiLCJnZXRDbGlwcGluZ1BhcmVudHMiLCJjbGlwcGluZ1BhcmVudCIsImludGVyc2VjdGlvbiIsIm92ZXJmbG93WSIsIm92ZXJmbG93WCIsIlBvc2l0aW9uQ2FjaGUiLCJvcmlnaW5FbCIsImVscyIsImlzSG9yaXpvbnRhbCIsImlzVmVydGljYWwiLCJvcmlnaW5DbGllbnRSZWN0IiwiYnVpbGRFbEhvcml6b250YWxzIiwiYnVpbGRFbFZlcnRpY2FscyIsIm9yaWdpbkNsaWVudExlZnQiLCJsZWZ0cyIsInJpZ2h0cyIsIm9yaWdpbkNsaWVudFRvcCIsInRvcHMiLCJib3R0b21zIiwibGVmdFRvSW5kZXgiLCJsZWZ0UG9zaXRpb24iLCJ0b3BUb0luZGV4IiwidG9wUG9zaXRpb24iLCJnZXRXaWR0aCIsImxlZnRJbmRleCIsImdldEhlaWdodCIsInRvcEluZGV4Iiwic2ltaWxhclRvIiwib3RoZXJDYWNoZSIsInNpbWlsYXJOdW1BcnJheXMiLCJTY3JvbGxDb250cm9sbGVyIiwiZ2V0TWF4U2Nyb2xsVG9wIiwiZ2V0U2Nyb2xsSGVpZ2h0IiwiZ2V0Q2xpZW50SGVpZ2h0IiwiZ2V0TWF4U2Nyb2xsTGVmdCIsImdldFNjcm9sbFdpZHRoIiwiZ2V0Q2xpZW50V2lkdGgiLCJjYW5TY3JvbGxWZXJ0aWNhbGx5IiwiY2FuU2Nyb2xsSG9yaXpvbnRhbGx5IiwiY2FuU2Nyb2xsVXAiLCJnZXRTY3JvbGxUb3AiLCJjYW5TY3JvbGxEb3duIiwiY2FuU2Nyb2xsTGVmdCIsImdldFNjcm9sbExlZnQiLCJjYW5TY3JvbGxSaWdodCIsIkVsZW1lbnRTY3JvbGxDb250cm9sbGVyIiwic2Nyb2xsVG9wIiwic2Nyb2xsTGVmdCIsInNldFNjcm9sbFRvcCIsInNldFNjcm9sbExlZnQiLCJzY3JvbGxXaWR0aCIsInNjcm9sbEhlaWdodCIsIldpbmRvd1Njcm9sbENvbnRyb2xsZXIiLCJzY3JvbGwiLCJEYXRlQ29tcG9uZW50IiwicHJlcGFyZUhpdHMiLCJxdWVyeUhpdCIsInBvc2l0aW9uTGVmdCIsInBvc2l0aW9uVG9wIiwiZWxXaWR0aCIsImVsSGVpZ2h0IiwiaXNWYWxpZFNlZ0Rvd25FbCIsImlzVmFsaWREYXRlRG93bkVsIiwiTmFtZWRUaW1lWm9uZUltcGwiLCJTZWdIaWVyYXJjaHkiLCJnZXRFbnRyeVRoaWNrbmVzcyIsImVudHJ5IiwidGhpY2tuZXNzIiwic3RyaWN0T3JkZXIiLCJhbGxvd1Jlc2xpY2luZyIsIm1heENvb3JkIiwibWF4U3RhY2tDbnQiLCJsZXZlbENvb3JkcyIsImVudHJpZXNCeUxldmVsIiwic3RhY2tDbnRzIiwiYWRkU2VncyIsImlucHV0cyIsImhpZGRlbkVudHJpZXMiLCJpbnNlcnRFbnRyeSIsImZpbmRJbnNlcnRpb24iLCJpc0luc2VydGlvblZhbGlkIiwiaW5zZXJ0RW50cnlBdCIsImhhbmRsZUludmFsaWRJbnNlcnRpb24iLCJsZXZlbENvb3JkIiwic3RhY2tDbnQiLCJ0b3VjaGluZ0VudHJ5IiwiaGlkZGVuRW50cnkiLCJpbnRlcnNlY3RTcGFucyIsInNwbGl0RW50cnkiLCJiYXJyaWVyIiwiZW50cnlTcGFuIiwiYmFycmllclNwYW4iLCJsYXRlcmFsIiwiaW5zZXJ0QXQiLCJsZXZlbCIsImJ1aWxkRW50cnlLZXkiLCJuZXdFbnRyeSIsImxldmVsQ250IiwiY2FuZGlkYXRlQ29vcmQiLCJ0b3VjaGluZ0xldmVsIiwidG91Y2hpbmdMYXRlcmFsIiwidHJhY2tpbmdMZXZlbCIsInRyYWNraW5nQ29vcmQiLCJ0cmFja2luZ0VudHJpZXMiLCJ0cmFja2luZ0VudHJ5Iiwic2VhcmNoUmVzIiwiYmluYXJ5U2VhcmNoIiwiZ2V0RW50cnlTcGFuRW5kIiwibGF0ZXJhbEluZGV4IiwidHJhY2tpbmdFbnRyeUJvdHRvbSIsImRlc3RMZXZlbCIsImRlc3RMYXRlcmFsIiwidG9SZWN0cyIsInJlY3RzIiwiZW50cmllcyIsImdyb3VwSW50ZXJzZWN0aW5nRW50cmllcyIsIm1lcmdlcyIsImZpbHRlcmVkTWVyZ2VzIiwiaHVuZ3J5TWVyZ2UiLCJtZXJnZSIsImpvaW5TcGFucyIsInNlYXJjaFZhbCIsImdldEl0ZW1WYWwiLCJtaWRkbGVJbmRleCIsIm1pZGRsZVZhbCIsIkVsZW1lbnREcmFnZ2luZyIsInNldE1pcnJvcklzVmlzaWJsZSIsImJvb2wiLCJzZXRNaXJyb3JOZWVkc1JldmVydCIsInNldEF1dG9TY3JvbGxFbmFibGVkIiwiY29uZmlnIiwiRFJBR19NRVRBX1JFRklORVJTIiwicGFyc2VEcmFnTWV0YSIsImxlZnRvdmVyUHJvcHMiLCJjb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQiLCJkYXRlc1JlcERpc3RpbmN0RGF5cyIsIkNMQVNTX05BTUUiLCJyZW5kZXJJbm5lciQxIiwidGV4dCIsIlRhYmxlRGF0ZUNlbGwiLCJkYXlNZXRhIiwibmF2TGlua0F0dHJzIiwiY29sQ250IiwiZXh0cmFSZW5kZXJQcm9wcyIsInJvbGUiLCJjb2xTcGFuIiwiZXh0cmFEYXRhQXR0cnMiLCJJbm5lckNvbnRhaW5lciIsImlzU3RpY2t5IiwiV0VFS0RBWV9GT1JNQVQiLCJUYWJsZURvd0NlbGwiLCJkYXRlTWV0YSIsIk5vd1RpbWVyIiwiaW5pdGlhbE5vd0RhdGUiLCJpbml0aWFsTm93UXVlcmllZE1zIiwiY29tcHV0ZVRpbWluZyIsImN1cnJlbnRTdGF0ZSIsInByZXZQcm9wcyIsInVucm91bmRlZE5vdyIsImN1cnJlbnRVbml0U3RhcnQiLCJuZXh0VW5pdFN0YXJ0Iiwid2FpdE1zIiwiYnVpbGREYXlSYW5nZSIsIkRheUhlYWRlciIsImNyZWF0ZURheUhlYWRlckZvcm1hdHRlciIsImRhdGVzIiwicmVuZGVySW50cm8iLCJleHBsaWNpdEZvcm1hdCIsImRhdGVDbnQiLCJEYXlTZXJpZXNNb2RlbCIsImluZGljZXMiLCJkYXlJbmRleCIsImNudCIsInNsaWNlUmFuZ2UiLCJmaXJzdEluZGV4IiwiZ2V0RGF0ZURheUluZGV4IiwibGFzdEluZGV4IiwiY2xpcHBlZEZpcnN0SW5kZXgiLCJjbGlwcGVkTGFzdEluZGV4IiwiY2VpbCIsImRheU9mZnNldCIsIkRheVRhYmxlTW9kZWwiLCJkYXlTZXJpZXMiLCJicmVha09uV2Vla3MiLCJkYXlzUGVyUm93Iiwicm93Q250IiwiY2VsbHMiLCJidWlsZENlbGxzIiwiaGVhZGVyRGF0ZXMiLCJidWlsZEhlYWRlckRhdGVzIiwicm93cyIsInJvdyIsImNvbCIsImJ1aWxkQ2VsbCIsInNlcmllc1NlZyIsIm5leHRJbmRleCIsImZpcnN0Q29sIiwibGFzdENvbCIsIlNsaWNlciIsInNsaWNlQnVzaW5lc3NIb3VycyIsIl9zbGljZUJ1c2luZXNzSG91cnMiLCJzbGljZURhdGVTZWxlY3Rpb24iLCJfc2xpY2VEYXRlU3BhbiIsIl9zbGljZUV2ZW50U3RvcmUiLCJzbGljZUV2ZW50RHJhZyIsIl9zbGljZUludGVyYWN0aW9uIiwic2xpY2VFdmVudFJlc2l6ZSIsImZvcmNlRGF5SWZMaXN0SXRlbSIsInNsaWNlUHJvcHMiLCJleHRyYUFyZ3MiLCJldmVudFNlZ3MiLCJkYXRlU2VsZWN0aW9uU2VncyIsImJ1c2luZXNzSG91clNlZ3MiLCJmZ0V2ZW50U2VncyIsImJnRXZlbnRTZWdzIiwic2xpY2VOb3dEYXRlIiwiY29tcHV0ZUFjdGl2ZVJhbmdlIiwicmFuZ2VSZXMiLCJzbGljZUV2ZW50UmFuZ2VzIiwiYWZmZWN0ZWRJbnN0YW5jZXMiLCJhY3RpdmVEYXRlU3BhblJhbmdlIiwiZXZlbnRSYW5nZXMiLCJzbGljZUV2ZW50UmFuZ2UiLCJpc0NvbXBvbmVudEFsbERheSIsImlzSW50ZXJhY3Rpb25WYWxpZCIsImlzTmV3UHJvcHNWYWxpZCIsImlzRGF0ZVNlbGVjdGlvblZhbGlkIiwiY2FsZW5kYXJTdGF0ZSIsImlzUHJvcHNWYWxpZCIsImRhdGVTcGFuTWV0YSIsImZpbHRlckNvbmZpZyIsImlzSW50ZXJhY3Rpb25Qcm9wc1ZhbGlkIiwiaXNEYXRlU2VsZWN0aW9uUHJvcHNWYWxpZCIsInN1YmplY3RFdmVudFN0b3JlIiwic3ViamVjdERlZnMiLCJzdWJqZWN0SW5zdGFuY2VzIiwic3ViamVjdENvbmZpZ3MiLCJzZWxlY3Rpb25Db25maWciLCJvdGhlckV2ZW50U3RvcmUiLCJvdGhlckRlZnMiLCJvdGhlckluc3RhbmNlcyIsIm90aGVyQ29uZmlncyIsInN1YmplY3RJbnN0YW5jZUlkIiwic3ViamVjdEluc3RhbmNlIiwic3ViamVjdFJhbmdlIiwic3ViamVjdENvbmZpZyIsInN1YmplY3REZWYiLCJhbGxDb25zdHJhaW50c1Bhc3MiLCJldmVudE92ZXJsYXBGdW5jIiwib3RoZXJJbnN0YW5jZUlkIiwib3RoZXJJbnN0YW5jZSIsIm90aGVyT3ZlcmxhcCIsImNhbGVuZGFyRXZlbnRTdG9yZSIsInN1YmplY3RBbGxvdyIsInN1YmplY3REYXRlU3BhbiIsIm9yaWdEZWYiLCJvcmlnSW5zdGFuY2UiLCJyZWxldmFudEV2ZW50U3RvcmUiLCJyZWxldmFudERlZnMiLCJyZWxldmFudEluc3RhbmNlcyIsInNlbGVjdGlvblJhbmdlIiwic2VsZWN0T3ZlcmxhcEZ1bmMiLCJyZWxldmFudEluc3RhbmNlSWQiLCJyZWxldmFudEluc3RhbmNlIiwic2VsZWN0aW9uQWxsb3ciLCJmdWxsRGF0ZVNwYW4iLCJidXNpbmVzc0hvdXJzVW5leHBhbmRlZCIsImFueVJhbmdlc0NvbnRhaW5SYW5nZSIsImNvbnN0cmFpbnRUb1JhbmdlcyIsImV2ZW50U3RvcmVUb1JhbmdlcyIsIm91dGVyUmFuZ2VzIiwiVklTSUJMRV9ISURERU5fUkUiLCJTY3JvbGxlciIsImxpcXVpZCIsImxpcXVpZElzQWJzb2x1dGUiLCJpc0Fic29sdXRlIiwib3ZlcmNvbWVMZWZ0Iiwib3ZlcmNvbWVSaWdodCIsIm92ZXJjb21lQm90dG9tIiwibWFyZ2luTGVmdCIsIm1hcmdpblJpZ2h0IiwibWFyZ2luQm90dG9tIiwibWF4SGVpZ2h0IiwibmVlZHNYU2Nyb2xsaW5nIiwicmVhbENsaWVudFdpZHRoIiwiZ2V0WVNjcm9sbGJhcldpZHRoIiwiY2hpbGRFbCIsIm5lZWRzWVNjcm9sbGluZyIsInJlYWxDbGllbnRIZWlnaHQiLCJnZXRYU2Nyb2xsYmFyV2lkdGgiLCJSZWZNYXAiLCJtYXN0ZXJDYWxsYmFjayIsImN1cnJlbnRNYXAiLCJkZXB0aHMiLCJjYWxsYmFja01hcCIsImhhbmRsZVZhbHVlIiwicmVtb3ZlZCIsImFkZGVkIiwiY3JlYXRlUmVmIiwicmVmQ2FsbGJhY2siLCJjb2xsZWN0IiwiZ2V0QWxsIiwiY29tcHV0ZVNocmlua1dpZHRoIiwiY2h1bmtFbHMiLCJzaHJpbmtDZWxscyIsImxhcmdlc3RXaWR0aCIsInNocmlua0NlbGwiLCJnZXRTZWN0aW9uSGFzTGlxdWlkSGVpZ2h0Iiwic2VjdGlvbkNvbmZpZyIsImdldEFsbG93WVNjcm9sbGluZyIsInJlbmRlckNodW5rQ29udGVudCIsImNodW5rQ29uZmlnIiwiaXNIZWFkZXIiLCJ0YWJsZUNsYXNzTmFtZSIsInN5bmNSb3dIZWlnaHRzIiwibWluV2lkdGgiLCJ0YWJsZU1pbldpZHRoIiwidGFibGVDb2xHcm91cE5vZGUiLCJyb3dDb250ZW50IiwiaXNDb2xQcm9wc0VxdWFsIiwiY29sczAiLCJjb2xzMSIsInJlbmRlck1pY3JvQ29sR3JvdXAiLCJjb2xzIiwic2hyaW5rV2lkdGgiLCJjb2xOb2RlcyIsImNvbFByb3BzIiwic2FuaXRpemVTaHJpbmtXaWR0aCIsImhhc1Nocmlua1dpZHRoIiwiZ2V0U2Nyb2xsR3JpZENsYXNzTmFtZXMiLCJnZXRTZWN0aW9uQ2xhc3NOYW1lcyIsIndob2xlVGFibGVWR3JvdyIsInJlbmRlclNjcm9sbFNoaW0iLCJnZXRTdGlja3lIZWFkZXJEYXRlcyIsImdldFN0aWNreUZvb3RlclNjcm9sbGJhciIsIlNpbXBsZVNjcm9sbEdyaWQiLCJwcm9jZXNzQ29scyIsInNjcm9sbGVyUmVmcyIsInNjcm9sbGVyRWxSZWZzIiwiX2hhbmRsZVNjcm9sbGVyRWwiLCJmb3JjZVlTY3JvbGxiYXJzIiwic2Nyb2xsZXJDbGllbnRXaWR0aHMiLCJzY3JvbGxlckNsaWVudEhlaWdodHMiLCJoYW5kbGVTaXppbmciLCJjb21wdXRlU2Nyb2xsZXJEaW1zIiwic2VjdGlvbkNvbmZpZ3MiLCJzZWN0aW9ucyIsIm1pY3JvQ29sR3JvdXBOb2RlIiwiY29sbGFwc2libGVXaWR0aCIsImNvbmZpZ0NudCIsImNvbmZpZ0kiLCJjdXJyZW50Q29uZmlnIiwiaGVhZFNlY3Rpb25Ob2RlcyIsImJvZHlTZWN0aW9uTm9kZXMiLCJmb290U2VjdGlvbk5vZGVzIiwicmVuZGVyU2VjdGlvbiIsImlzQnVnZ3kiLCJyb2xlQXR0cnMiLCJvdXRlckNvbnRlbnQiLCJyZW5kZXJDaHVua1RkIiwiY2h1bmsiLCJpc0xpcXVpZCIsInNlY3Rpb25LZXkiLCJyb3dTeW5jSGVpZ2h0cyIsInJlcG9ydFJvd0hlaWdodENoYW5nZSIsInNjcm9sbGVyRWwiLCJzZWN0aW9uIiwiZ2V0U2VjdGlvbkJ5S2V5Iiwic2Nyb2xsZXJFbFJlZiIsInNjcm9sbGJhcldpZHRoIiwic2Nyb2xsZXIiLCJoYXJuZXNzRWwiLCJFdmVudENvbnRhaW5lciIsInRpbWVUZXh0IiwiZGlzYWJsZURyYWdnaW5nIiwiZGlzYWJsZVJlc2l6aW5nIiwiaXNEYXRlU2VsZWN0aW5nIiwiU3RhbmRhcmRFdmVudCIsImRlZmF1bHRUaW1lRm9ybWF0IiwicmVuZGVySW5uZXJDb250ZW50JDEiLCJldmVudENvbnRlbnRBcmciLCJpbm5lclByb3BzIiwiTm93SW5kaWNhdG9yQ29udGFpbmVyIiwiQ29uc3VtZXIiLCJpc0F4aXMiLCJEQVlfTlVNX0ZPUk1BVCIsIkRheUNlbGxDb250YWluZXIiLCJyZWZpbmVSZW5kZXJQcm9wcyIsImlzTW9udGhTdGFydCIsInNob3dEYXlOdW1iZXIiLCJoYXNDdXN0b21EYXlDZWxsQ29udGVudCIsImRheU51bWJlclRleHQiLCJCZ0V2ZW50IiwicmVuZGVySW5uZXJDb250ZW50IiwicmVuZGVyRmlsbCIsImZpbGxUeXBlIiwiV2Vla051bWJlckNvbnRhaW5lciIsImRlZmF1bHRGb3JtYXQiLCJyZW5kZXJJbm5lciIsIlBBRERJTkdfRlJPTV9WSUVXUE9SVCIsIlBvcG92ZXIiLCJ0aXRsZUlkIiwiaGFuZGxlUm9vdEVsIiwicm9vdEVsIiwiaGFuZGxlRG9jdW1lbnRNb3VzZURvd24iLCJoYW5kbGVDbG9zZUNsaWNrIiwiaGFuZGxlRG9jdW1lbnRLZXlEb3duIiwib25DbG9zZSIsImV4dHJhQXR0cnMiLCJhbGlnbm1lbnRFbCIsImFsaWduR3JpZFRvcCIsImFsaWdubWVudFJlY3QiLCJwb3BvdmVyRGltcyIsInBvcG92ZXJUb3AiLCJwb3BvdmVyTGVmdCIsIm9yaWdpbiIsIm9mZnNldFBhcmVudCIsIk1vcmVQb3BvdmVyIiwic3RhcnREYXRlIiwiZm9yY2VUaW1lZCIsImV4dHJhRGF0ZVNwYW4iLCJkYXlFbCIsImxheWVyIiwiTW9yZUxpbmtDb250YWluZXIiLCJpc1BvcG92ZXJPcGVuIiwicG9wb3ZlcklkIiwiaGFuZGxlTGlua0VsIiwibGlua0VsIiwiaGFuZGxlQ2xpY2siLCJjb21wdXRlUmFuZ2UiLCJidWlsZFB1YmxpY1NlZyIsImFsbERheURhdGUiLCJhbGxTZWdzIiwiaGlkZGVuU2VncyIsImhhbmRsZVBvcG92ZXJDbG9zZSIsIm1vcmVDbnQiLCJoaW50Iiwic2hvcnRUZXh0IiwicmVuZGVyTW9yZUxpbmtJbm5lciIsImFsaWdubWVudEVsUmVmIiwicG9wb3ZlckNvbnRlbnQiLCJ1cGRhdGVQYXJlbnRFbCIsImNvbXB1dGVFYXJsaWVzdFNlZ1N0YXJ0IiwiY29tcHV0ZUxhdGVzdFNlZ0VuZCIsInBpY2tFYXJsaWVzdFN0YXJ0Iiwic2VnMCIsInNlZzEiLCJwaWNrTGF0ZXN0RW5kIiwiU3RvcmUiLCJjdXJyZW50VmFsdWUiLCJzdWJzY3JpYmUiLCJDdXN0b21SZW5kZXJpbmdTdG9yZSIsImhhbmRsZSIsImN1c3RvbVJlbmRlcmluZyIsInVwZGF0ZWQiLCJoYXMiLCJkZWxldGUiLCIkIiwiQSIsIkIiLCJDIiwiRCIsIkUiLCJGIiwiRyIsIkgiLCJJIiwiSiIsIksiLCJMIiwiTSIsIk4iLCJPIiwiUCIsIlEiLCJSIiwiUyIsIlQiLCJVIiwiViIsIlciLCJYIiwiWSIsIloiLCJfIiwiYSQiLCJhMiIsImEzIiwiYTQiLCJhNSIsImE2IiwiYTciLCJhOCIsImE5IiwiYUEiLCJhQiIsImFDIiwiYUQiLCJhRSIsImFGIiwiYUciLCJhSCIsImFJIiwiYUoiLCJhSyIsImFMIiwiYU0iLCJhTiIsImFPIiwiYVAiLCJhUSIsImFSIiwiYVMiLCJhVCIsImFVIiwiYVYiLCJhVyIsImFYIiwiYVkiLCJhWiIsImFfIiwiYWEiLCJhYiIsImFjIiwiYWQiLCJhZSIsImFmIiwiYWciLCJhaCIsImFpIiwiYWoiLCJhayIsImFsIiwiYW0iLCJhbiIsImFvIiwiYXAiLCJhcSIsImFyIiwiYXMiLCJhdCIsImF1IiwiYXYiLCJhdyIsImF4IiwiYXkiLCJheiIsImIkIiwiYjAiLCJiMSIsImIyIiwiYjMiLCJiNCIsImI1IiwiYjYiLCJiNyIsImI4IiwiYjkiLCJiQSIsImJCIiwiYkMiLCJiRCIsImJFIiwiYkYiLCJiRyIsImJIIiwiYkkiLCJiSiIsImJLIiwiYkwiLCJiTSIsImJOIiwiYk8iLCJiUCIsImJRIiwiYlIiLCJiUyIsImJUIiwiYlUiLCJiViIsImJXIiwiYlgiLCJiWSIsImJaIiwiYl8iLCJiYSIsImJiIiwiYmMiLCJiZCIsImJlIiwiYmYiLCJiaCIsImJpIiwiYmoiLCJiayIsImJsIiwiYm0iLCJibiIsImJvIiwiYnAiLCJicSIsImJyIiwiYnMiLCJidCIsImJ1IiwiYnYiLCJidyIsImJ4IiwiYnkiLCJieiIsImMwIiwiYzEiLCJjMiIsImMzIiwiYzQiLCJjNSIsImM2IiwiYzciLCJjOCIsImM5IiwiY2IiLCJjYyIsImNkIiwiY2UiLCJjZiIsImNnIiwiY2giLCJjaSIsImNqIiwiY2siLCJjbCIsImNtIiwiY24iLCJjbyIsImNwIiwiY3EiLCJjciIsImNzIiwiY3QiLCJjdSIsImN2IiwiY3ciLCJjeCIsImN5IiwiZSIsImYiLCJnIiwiaCIsImsiLCJsIiwibyIsInAiLCJxIiwiciIsInQiLCJ1IiwidiIsInoiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@fullcalendar/core/internal-common.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@fullcalendar/core/locales/de.js":
/*!*******************************************************!*\
  !*** ./node_modules/@fullcalendar/core/locales/de.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ l17)\n/* harmony export */ });\nfunction affix(buttonText) {\n    return buttonText === \"Tag\" || buttonText === \"Monat\" ? \"r\" : buttonText === \"Jahr\" ? \"s\" : \"\";\n}\nvar l17 = {\n    code: \"de\",\n    week: {\n        dow: 1,\n        doy: 4\n    },\n    buttonText: {\n        prev: \"Zur\\xfcck\",\n        next: \"Vor\",\n        today: \"Heute\",\n        year: \"Jahr\",\n        month: \"Monat\",\n        week: \"Woche\",\n        day: \"Tag\",\n        list: \"Termin\\xfcbersicht\"\n    },\n    weekText: \"KW\",\n    weekTextLong: \"Woche\",\n    allDayText: \"Ganzt\\xe4gig\",\n    moreLinkText (n) {\n        return \"+ weitere \" + n;\n    },\n    noEventsText: \"Keine Ereignisse anzuzeigen\",\n    buttonHints: {\n        prev (buttonText) {\n            return `Vorherige${affix(buttonText)} ${buttonText}`;\n        },\n        next (buttonText) {\n            return `Nchste${affix(buttonText)} ${buttonText}`;\n        },\n        today (buttonText) {\n            //  Heute, Diese Woche, Dieser Monat, Dieses Jahr\n            if (buttonText === \"Tag\") {\n                return \"Heute\";\n            }\n            return `Diese${affix(buttonText)} ${buttonText}`;\n        }\n    },\n    viewHint (buttonText) {\n        //  Tagesansicht, Wochenansicht, Monatsansicht, Jahresansicht\n        const glue = buttonText === \"Woche\" ? \"n\" : buttonText === \"Monat\" ? \"s\" : \"es\";\n        return buttonText + glue + \"ansicht\";\n    },\n    navLinkHint: \"Gehe zu $0\",\n    moreLinkHint (eventCnt) {\n        return \"Zeige \" + (eventCnt === 1 ? \"ein weiteres Ereignis\" : eventCnt + \" weitere Ereignisse\");\n    },\n    closeHint: \"Schlie\\xdfen\",\n    timeHint: \"Uhrzeit\",\n    eventHint: \"Ereignis\"\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL2xvY2FsZXMvZGUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLFNBQVNBLE1BQU1DLFVBQVU7SUFDckIsT0FBTyxlQUFnQixTQUFTQSxlQUFlLFVBQVcsTUFDdERBLGVBQWUsU0FBUyxNQUFNO0FBQ3RDO0FBQ0EsSUFBSUMsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE1BQU07UUFDRkMsS0FBSztRQUNMQyxLQUFLO0lBQ1Q7SUFDQUwsWUFBWTtRQUNSTSxNQUFNO1FBQ05DLE1BQU07UUFDTkMsT0FBTztRQUNQQyxNQUFNO1FBQ05DLE9BQU87UUFDUFAsTUFBTTtRQUNOUSxLQUFLO1FBQ0xDLE1BQU07SUFDVjtJQUNBQyxVQUFVO0lBQ1ZDLGNBQWM7SUFDZEMsWUFBWTtJQUNaQyxjQUFhQyxDQUFDO1FBQ1YsT0FBTyxlQUFlQTtJQUMxQjtJQUNBQyxjQUFjO0lBQ2RDLGFBQWE7UUFDVGIsTUFBS04sVUFBVTtZQUNYLE9BQU8sQ0FBQyxTQUFTLEVBQUVELE1BQU1DLFlBQVksQ0FBQyxFQUFFQSxXQUFXLENBQUM7UUFDeEQ7UUFDQU8sTUFBS1AsVUFBVTtZQUNYLE9BQU8sQ0FBQyxPQUFPLEVBQUVELE1BQU1DLFlBQVksQ0FBQyxFQUFFQSxXQUFXLENBQUM7UUFDdEQ7UUFDQVEsT0FBTVIsVUFBVTtZQUNaLGtEQUFrRDtZQUNsRCxJQUFJQSxlQUFlLE9BQU87Z0JBQ3RCLE9BQU87WUFDWDtZQUNBLE9BQU8sQ0FBQyxLQUFLLEVBQUVELE1BQU1DLFlBQVksQ0FBQyxFQUFFQSxXQUFXLENBQUM7UUFDcEQ7SUFDSjtJQUNBb0IsVUFBU3BCLFVBQVU7UUFDZiw4REFBOEQ7UUFDOUQsTUFBTXFCLE9BQU9yQixlQUFlLFVBQVUsTUFBTUEsZUFBZSxVQUFVLE1BQU07UUFDM0UsT0FBT0EsYUFBYXFCLE9BQU87SUFDL0I7SUFDQUMsYUFBYTtJQUNiQyxjQUFhQyxRQUFRO1FBQ2pCLE9BQU8sV0FBWUEsQ0FBQUEsYUFBYSxJQUM1QiwwQkFDQUEsV0FBVyxxQkFBb0I7SUFDdkM7SUFDQUMsV0FBVztJQUNYQyxVQUFVO0lBQ1ZDLFdBQVc7QUFDZjtBQUUwQiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlaGFzcG9ydC1tYW5hZ2VtZW50Ly4vbm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9sb2NhbGVzL2RlLmpzPzM4ZWMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gYWZmaXgoYnV0dG9uVGV4dCkge1xuICAgIHJldHVybiAoYnV0dG9uVGV4dCA9PT0gJ1RhZycgfHwgYnV0dG9uVGV4dCA9PT0gJ01vbmF0JykgPyAncicgOlxuICAgICAgICBidXR0b25UZXh0ID09PSAnSmFocicgPyAncycgOiAnJztcbn1cbnZhciBsMTcgPSB7XG4gICAgY29kZTogJ2RlJyxcbiAgICB3ZWVrOiB7XG4gICAgICAgIGRvdzogMSxcbiAgICAgICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgfSxcbiAgICBidXR0b25UZXh0OiB7XG4gICAgICAgIHByZXY6ICdadXLDvGNrJyxcbiAgICAgICAgbmV4dDogJ1ZvcicsXG4gICAgICAgIHRvZGF5OiAnSGV1dGUnLFxuICAgICAgICB5ZWFyOiAnSmFocicsXG4gICAgICAgIG1vbnRoOiAnTW9uYXQnLFxuICAgICAgICB3ZWVrOiAnV29jaGUnLFxuICAgICAgICBkYXk6ICdUYWcnLFxuICAgICAgICBsaXN0OiAnVGVybWluw7xiZXJzaWNodCcsXG4gICAgfSxcbiAgICB3ZWVrVGV4dDogJ0tXJyxcbiAgICB3ZWVrVGV4dExvbmc6ICdXb2NoZScsXG4gICAgYWxsRGF5VGV4dDogJ0dhbnp0w6RnaWcnLFxuICAgIG1vcmVMaW5rVGV4dChuKSB7XG4gICAgICAgIHJldHVybiAnKyB3ZWl0ZXJlICcgKyBuO1xuICAgIH0sXG4gICAgbm9FdmVudHNUZXh0OiAnS2VpbmUgRXJlaWduaXNzZSBhbnp1emVpZ2VuJyxcbiAgICBidXR0b25IaW50czoge1xuICAgICAgICBwcmV2KGJ1dHRvblRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBgVm9yaGVyaWdlJHthZmZpeChidXR0b25UZXh0KX0gJHtidXR0b25UZXh0fWA7XG4gICAgICAgIH0sXG4gICAgICAgIG5leHQoYnV0dG9uVGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGBOw6RjaHN0ZSR7YWZmaXgoYnV0dG9uVGV4dCl9ICR7YnV0dG9uVGV4dH1gO1xuICAgICAgICB9LFxuICAgICAgICB0b2RheShidXR0b25UZXh0KSB7XG4gICAgICAgICAgICAvLyDihpIgSGV1dGUsIERpZXNlIFdvY2hlLCBEaWVzZXIgTW9uYXQsIERpZXNlcyBKYWhyXG4gICAgICAgICAgICBpZiAoYnV0dG9uVGV4dCA9PT0gJ1RhZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0hldXRlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBgRGllc2Uke2FmZml4KGJ1dHRvblRleHQpfSAke2J1dHRvblRleHR9YDtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHZpZXdIaW50KGJ1dHRvblRleHQpIHtcbiAgICAgICAgLy8g4oaSIFRhZ2VzYW5zaWNodCwgV29jaGVuYW5zaWNodCwgTW9uYXRzYW5zaWNodCwgSmFocmVzYW5zaWNodFxuICAgICAgICBjb25zdCBnbHVlID0gYnV0dG9uVGV4dCA9PT0gJ1dvY2hlJyA/ICduJyA6IGJ1dHRvblRleHQgPT09ICdNb25hdCcgPyAncycgOiAnZXMnO1xuICAgICAgICByZXR1cm4gYnV0dG9uVGV4dCArIGdsdWUgKyAnYW5zaWNodCc7XG4gICAgfSxcbiAgICBuYXZMaW5rSGludDogJ0dlaGUgenUgJDAnLFxuICAgIG1vcmVMaW5rSGludChldmVudENudCkge1xuICAgICAgICByZXR1cm4gJ1plaWdlICcgKyAoZXZlbnRDbnQgPT09IDEgP1xuICAgICAgICAgICAgJ2VpbiB3ZWl0ZXJlcyBFcmVpZ25pcycgOlxuICAgICAgICAgICAgZXZlbnRDbnQgKyAnIHdlaXRlcmUgRXJlaWduaXNzZScpO1xuICAgIH0sXG4gICAgY2xvc2VIaW50OiAnU2NobGllw59lbicsXG4gICAgdGltZUhpbnQ6ICdVaHJ6ZWl0JyxcbiAgICBldmVudEhpbnQ6ICdFcmVpZ25pcycsXG59O1xuXG5leHBvcnQgeyBsMTcgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbImFmZml4IiwiYnV0dG9uVGV4dCIsImwxNyIsImNvZGUiLCJ3ZWVrIiwiZG93IiwiZG95IiwicHJldiIsIm5leHQiLCJ0b2RheSIsInllYXIiLCJtb250aCIsImRheSIsImxpc3QiLCJ3ZWVrVGV4dCIsIndlZWtUZXh0TG9uZyIsImFsbERheVRleHQiLCJtb3JlTGlua1RleHQiLCJuIiwibm9FdmVudHNUZXh0IiwiYnV0dG9uSGludHMiLCJ2aWV3SGludCIsImdsdWUiLCJuYXZMaW5rSGludCIsIm1vcmVMaW5rSGludCIsImV2ZW50Q250IiwiY2xvc2VIaW50IiwidGltZUhpbnQiLCJldmVudEhpbnQiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@fullcalendar/core/locales/de.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@fullcalendar/daygrid/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@fullcalendar/daygrid/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ index)\n/* harmony export */ });\n/* harmony import */ var _fullcalendar_core_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fullcalendar/core/index.js */ \"(ssr)/./node_modules/@fullcalendar/core/index.js\");\n/* harmony import */ var _internal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal.js */ \"(ssr)/./node_modules/@fullcalendar/daygrid/internal.js\");\n\n\n\n\nvar index = (0,_fullcalendar_core_index_js__WEBPACK_IMPORTED_MODULE_0__.createPlugin)({\n    name: \"@fullcalendar/daygrid\",\n    initialView: \"dayGridMonth\",\n    views: {\n        dayGrid: {\n            component: _internal_js__WEBPACK_IMPORTED_MODULE_1__.DayGridView,\n            dateProfileGeneratorClass: _internal_js__WEBPACK_IMPORTED_MODULE_1__.TableDateProfileGenerator\n        },\n        dayGridDay: {\n            type: \"dayGrid\",\n            duration: {\n                days: 1\n            }\n        },\n        dayGridWeek: {\n            type: \"dayGrid\",\n            duration: {\n                weeks: 1\n            }\n        },\n        dayGridMonth: {\n            type: \"dayGrid\",\n            duration: {\n                months: 1\n            },\n            fixedWeekCount: true\n        },\n        dayGridYear: {\n            type: \"dayGrid\",\n            duration: {\n                years: 1\n            }\n        }\n    }\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9kYXlncmlkL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEyRDtBQUM0QjtBQUMvQztBQUNGO0FBRXRDLElBQUlJLFFBQVFKLHlFQUFZQSxDQUFDO0lBQ3JCSyxNQUFNO0lBQ05DLGFBQWE7SUFDYkMsT0FBTztRQUNIQyxTQUFTO1lBQ0xDLFdBQVdQLHFEQUFZQTtZQUN2QlEsMkJBQTJCUCxtRUFBeUJBO1FBQ3hEO1FBQ0FRLFlBQVk7WUFDUkMsTUFBTTtZQUNOQyxVQUFVO2dCQUFFQyxNQUFNO1lBQUU7UUFDeEI7UUFDQUMsYUFBYTtZQUNUSCxNQUFNO1lBQ05DLFVBQVU7Z0JBQUVHLE9BQU87WUFBRTtRQUN6QjtRQUNBQyxjQUFjO1lBQ1ZMLE1BQU07WUFDTkMsVUFBVTtnQkFBRUssUUFBUTtZQUFFO1lBQ3RCQyxnQkFBZ0I7UUFDcEI7UUFDQUMsYUFBYTtZQUNUUixNQUFNO1lBQ05DLFVBQVU7Z0JBQUVRLE9BQU87WUFBRTtRQUN6QjtJQUNKO0FBQ0o7QUFFNEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWhhc3BvcnQtbWFuYWdlbWVudC8uL25vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2RheWdyaWQvaW5kZXguanM/YzFjNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVQbHVnaW4gfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUvaW5kZXguanMnO1xuaW1wb3J0IHsgRGF5R3JpZFZpZXcgYXMgRGF5VGFibGVWaWV3LCBUYWJsZURhdGVQcm9maWxlR2VuZXJhdG9yIH0gZnJvbSAnLi9pbnRlcm5hbC5qcyc7XG5pbXBvcnQgJ0BmdWxsY2FsZW5kYXIvY29yZS9pbnRlcm5hbC5qcyc7XG5pbXBvcnQgJ0BmdWxsY2FsZW5kYXIvY29yZS9wcmVhY3QuanMnO1xuXG52YXIgaW5kZXggPSBjcmVhdGVQbHVnaW4oe1xuICAgIG5hbWU6ICdAZnVsbGNhbGVuZGFyL2RheWdyaWQnLFxuICAgIGluaXRpYWxWaWV3OiAnZGF5R3JpZE1vbnRoJyxcbiAgICB2aWV3czoge1xuICAgICAgICBkYXlHcmlkOiB7XG4gICAgICAgICAgICBjb21wb25lbnQ6IERheVRhYmxlVmlldyxcbiAgICAgICAgICAgIGRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3M6IFRhYmxlRGF0ZVByb2ZpbGVHZW5lcmF0b3IsXG4gICAgICAgIH0sXG4gICAgICAgIGRheUdyaWREYXk6IHtcbiAgICAgICAgICAgIHR5cGU6ICdkYXlHcmlkJyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB7IGRheXM6IDEgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZGF5R3JpZFdlZWs6IHtcbiAgICAgICAgICAgIHR5cGU6ICdkYXlHcmlkJyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB7IHdlZWtzOiAxIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGRheUdyaWRNb250aDoge1xuICAgICAgICAgICAgdHlwZTogJ2RheUdyaWQnLFxuICAgICAgICAgICAgZHVyYXRpb246IHsgbW9udGhzOiAxIH0sXG4gICAgICAgICAgICBmaXhlZFdlZWtDb3VudDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgZGF5R3JpZFllYXI6IHtcbiAgICAgICAgICAgIHR5cGU6ICdkYXlHcmlkJyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB7IHllYXJzOiAxIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBpbmRleCBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOlsiY3JlYXRlUGx1Z2luIiwiRGF5R3JpZFZpZXciLCJEYXlUYWJsZVZpZXciLCJUYWJsZURhdGVQcm9maWxlR2VuZXJhdG9yIiwiaW5kZXgiLCJuYW1lIiwiaW5pdGlhbFZpZXciLCJ2aWV3cyIsImRheUdyaWQiLCJjb21wb25lbnQiLCJkYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzIiwiZGF5R3JpZERheSIsInR5cGUiLCJkdXJhdGlvbiIsImRheXMiLCJkYXlHcmlkV2VlayIsIndlZWtzIiwiZGF5R3JpZE1vbnRoIiwibW9udGhzIiwiZml4ZWRXZWVrQ291bnQiLCJkYXlHcmlkWWVhciIsInllYXJzIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@fullcalendar/daygrid/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@fullcalendar/daygrid/internal.js":
/*!********************************************************!*\
  !*** ./node_modules/@fullcalendar/daygrid/internal.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DayGridView: () => (/* binding */ DayTableView),\n/* harmony export */   DayTable: () => (/* binding */ DayTable),\n/* harmony export */   DayTableSlicer: () => (/* binding */ DayTableSlicer),\n/* harmony export */   Table: () => (/* binding */ Table),\n/* harmony export */   TableDateProfileGenerator: () => (/* binding */ TableDateProfileGenerator),\n/* harmony export */   TableRows: () => (/* binding */ TableRows),\n/* harmony export */   TableView: () => (/* binding */ TableView),\n/* harmony export */   buildDayTableModel: () => (/* binding */ buildDayTableModel),\n/* harmony export */   buildDayTableRenderRange: () => (/* binding */ buildDayTableRenderRange)\n/* harmony export */ });\n/* harmony import */ var _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fullcalendar/core/internal.js */ \"(ssr)/./node_modules/@fullcalendar/core/internal-common.js\");\n/* harmony import */ var _fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fullcalendar/core/preact.js */ \"(ssr)/./node_modules/preact/dist/preact.mjs\");\n\n\n/* An abstract class for the daygrid views, as well as month view. Renders one or more rows of day cells.\n----------------------------------------------------------------------------------------------------------------------*/ // It is a manager for a Table subcomponent, which does most of the heavy lifting.\n// It is responsible for managing width/height.\nclass TableView extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.be {\n    constructor(){\n        super(...arguments);\n        this.headerElRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n    }\n    renderSimpleLayout(headerRowContent, bodyContent) {\n        let { props, context } = this;\n        let sections = [];\n        let stickyHeaderDates = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cc)(context.options);\n        if (headerRowContent) {\n            sections.push({\n                type: \"header\",\n                key: \"header\",\n                isSticky: stickyHeaderDates,\n                chunk: {\n                    elRef: this.headerElRef,\n                    tableClassName: \"fc-col-header\",\n                    rowContent: headerRowContent\n                }\n            });\n        }\n        sections.push({\n            type: \"body\",\n            key: \"body\",\n            liquid: true,\n            chunk: {\n                content: bodyContent\n            }\n        });\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ct, {\n            elClasses: [\n                \"fc-daygrid\"\n            ],\n            viewSpec: context.viewSpec\n        }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.b$, {\n            liquid: !props.isHeightAuto && !props.forPrint,\n            collapsibleWidth: props.forPrint,\n            cols: [],\n            sections: sections\n        }));\n    }\n    renderHScrollLayout(headerRowContent, bodyContent, colCnt, dayMinWidth) {\n        let ScrollGrid = this.context.pluginHooks.scrollGridImpl;\n        if (!ScrollGrid) {\n            throw new Error(\"No ScrollGrid implementation\");\n        }\n        let { props, context } = this;\n        let stickyHeaderDates = !props.forPrint && (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cc)(context.options);\n        let stickyFooterScrollbar = !props.forPrint && (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cb)(context.options);\n        let sections = [];\n        if (headerRowContent) {\n            sections.push({\n                type: \"header\",\n                key: \"header\",\n                isSticky: stickyHeaderDates,\n                chunks: [\n                    {\n                        key: \"main\",\n                        elRef: this.headerElRef,\n                        tableClassName: \"fc-col-header\",\n                        rowContent: headerRowContent\n                    }\n                ]\n            });\n        }\n        sections.push({\n            type: \"body\",\n            key: \"body\",\n            liquid: true,\n            chunks: [\n                {\n                    key: \"main\",\n                    content: bodyContent\n                }\n            ]\n        });\n        if (stickyFooterScrollbar) {\n            sections.push({\n                type: \"footer\",\n                key: \"footer\",\n                isSticky: true,\n                chunks: [\n                    {\n                        key: \"main\",\n                        content: _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ca\n                    }\n                ]\n            });\n        }\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ct, {\n            elClasses: [\n                \"fc-daygrid\"\n            ],\n            viewSpec: context.viewSpec\n        }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ScrollGrid, {\n            liquid: !props.isHeightAuto && !props.forPrint,\n            forPrint: props.forPrint,\n            collapsibleWidth: props.forPrint,\n            colGroups: [\n                {\n                    cols: [\n                        {\n                            span: colCnt,\n                            minWidth: dayMinWidth\n                        }\n                    ]\n                }\n            ],\n            sections: sections\n        }));\n    }\n}\nfunction splitSegsByRow(segs, rowCnt) {\n    let byRow = [];\n    for(let i = 0; i < rowCnt; i += 1){\n        byRow[i] = [];\n    }\n    for (let seg of segs){\n        byRow[seg.row].push(seg);\n    }\n    return byRow;\n}\nfunction splitSegsByFirstCol(segs, colCnt) {\n    let byCol = [];\n    for(let i = 0; i < colCnt; i += 1){\n        byCol[i] = [];\n    }\n    for (let seg of segs){\n        byCol[seg.firstCol].push(seg);\n    }\n    return byCol;\n}\nfunction splitInteractionByRow(ui, rowCnt) {\n    let byRow = [];\n    if (!ui) {\n        for(let i = 0; i < rowCnt; i += 1){\n            byRow[i] = null;\n        }\n    } else {\n        for(let i = 0; i < rowCnt; i += 1){\n            byRow[i] = {\n                affectedInstances: ui.affectedInstances,\n                isEvent: ui.isEvent,\n                segs: []\n            };\n        }\n        for (let seg of ui.segs){\n            byRow[seg.row].segs.push(seg);\n        }\n    }\n    return byRow;\n}\nconst DEFAULT_TABLE_EVENT_TIME_FORMAT = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.x)({\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    omitZeroMinute: true,\n    meridiem: \"narrow\"\n});\nfunction hasListItemDisplay(seg) {\n    let { display } = seg.eventRange.ui;\n    return display === \"list-item\" || display === \"auto\" && !seg.eventRange.def.allDay && seg.firstCol === seg.lastCol && // can't be multi-day\n    seg.isStart && // \"\n    seg.isEnd // \"\n    ;\n}\nclass TableBlockEvent extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    render() {\n        let { props } = this;\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cj, Object.assign({}, props, {\n            elClasses: [\n                \"fc-daygrid-event\",\n                \"fc-daygrid-block-event\",\n                \"fc-h-event\"\n            ],\n            defaultTimeFormat: DEFAULT_TABLE_EVENT_TIME_FORMAT,\n            defaultDisplayEventEnd: props.defaultDisplayEventEnd,\n            disableResizing: !props.seg.eventRange.def.allDay\n        }));\n    }\n}\nclass TableListItemEvent extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    render() {\n        let { props, context } = this;\n        let { options } = context;\n        let { seg } = props;\n        let timeFormat = options.eventTimeFormat || DEFAULT_TABLE_EVENT_TIME_FORMAT;\n        let timeText = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bQ)(seg, timeFormat, context, true, props.defaultDisplayEventEnd);\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cn, Object.assign({}, props, {\n            elTag: \"a\",\n            elClasses: [\n                \"fc-daygrid-event\",\n                \"fc-daygrid-dot-event\"\n            ],\n            elAttrs: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bU)(props.seg, context),\n            defaultGenerator: renderInnerContent,\n            timeText: timeText,\n            isResizing: false,\n            isDateSelecting: false\n        }));\n    }\n}\nfunction renderInnerContent(renderProps) {\n    return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-daygrid-event-dot\",\n        style: {\n            borderColor: renderProps.borderColor || renderProps.backgroundColor\n        }\n    }), renderProps.timeText && (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-event-time\"\n    }, renderProps.timeText), (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-event-title\"\n    }, renderProps.event.title || (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, \"\\xa0\")));\n}\nclass TableCellMoreLink extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    constructor(){\n        super(...arguments);\n        this.compileSegs = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(compileSegs);\n    }\n    render() {\n        let { props } = this;\n        let { allSegs, invisibleSegs } = this.compileSegs(props.singlePlacements);\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cr, {\n            elClasses: [\n                \"fc-daygrid-more-link\"\n            ],\n            dateProfile: props.dateProfile,\n            todayRange: props.todayRange,\n            allDayDate: props.allDayDate,\n            moreCnt: props.moreCnt,\n            allSegs: allSegs,\n            hiddenSegs: invisibleSegs,\n            alignmentElRef: props.alignmentElRef,\n            alignGridTop: props.alignGridTop,\n            extraDateSpan: props.extraDateSpan,\n            popoverContent: ()=>{\n                let isForcedInvisible = (props.eventDrag ? props.eventDrag.affectedInstances : null) || (props.eventResize ? props.eventResize.affectedInstances : null) || {};\n                return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, allSegs.map((seg)=>{\n                    let instanceId = seg.eventRange.instance.instanceId;\n                    return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                        className: \"fc-daygrid-event-harness\",\n                        key: instanceId,\n                        style: {\n                            visibility: isForcedInvisible[instanceId] ? \"hidden\" : \"\"\n                        }\n                    }, hasListItemDisplay(seg) ? (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableListItemEvent, Object.assign({\n                        seg: seg,\n                        isDragging: false,\n                        isSelected: instanceId === props.eventSelection,\n                        defaultDisplayEventEnd: false\n                    }, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bS)(seg, props.todayRange))) : (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableBlockEvent, Object.assign({\n                        seg: seg,\n                        isDragging: false,\n                        isResizing: false,\n                        isDateSelecting: false,\n                        isSelected: instanceId === props.eventSelection,\n                        defaultDisplayEventEnd: false\n                    }, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bS)(seg, props.todayRange))));\n                }));\n            }\n        });\n    }\n}\nfunction compileSegs(singlePlacements) {\n    let allSegs = [];\n    let invisibleSegs = [];\n    for (let placement of singlePlacements){\n        allSegs.push(placement.seg);\n        if (!placement.isVisible) {\n            invisibleSegs.push(placement.seg);\n        }\n    }\n    return {\n        allSegs,\n        invisibleSegs\n    };\n}\nconst DEFAULT_WEEK_NUM_FORMAT = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.x)({\n    week: \"narrow\"\n});\nclass TableCell extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.be {\n    constructor(){\n        super(...arguments);\n        this.rootElRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        this.state = {\n            dayNumberId: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.a5)()\n        };\n        this.handleRootEl = (el)=>{\n            (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.Y)(this.rootElRef, el);\n            (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.Y)(this.props.elRef, el);\n        };\n    }\n    render() {\n        let { context, props, state, rootElRef } = this;\n        let { options, dateEnv } = context;\n        let { date, dateProfile } = props;\n        // TODO: memoize this?\n        const isMonthStart = props.showDayNumber && shouldDisplayMonthStart(date, dateProfile.currentRange, dateEnv);\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cl, {\n            elTag: \"td\",\n            elRef: this.handleRootEl,\n            elClasses: [\n                \"fc-daygrid-day\",\n                ...props.extraClassNames || []\n            ],\n            elAttrs: Object.assign(Object.assign(Object.assign({}, props.extraDataAttrs), props.showDayNumber ? {\n                \"aria-labelledby\": state.dayNumberId\n            } : {}), {\n                role: \"gridcell\"\n            }),\n            defaultGenerator: renderTopInner,\n            date: date,\n            dateProfile: dateProfile,\n            todayRange: props.todayRange,\n            showDayNumber: props.showDayNumber,\n            isMonthStart: isMonthStart,\n            extraRenderProps: props.extraRenderProps\n        }, (InnerContent, renderProps)=>(0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                ref: props.innerElRef,\n                className: \"fc-daygrid-day-frame fc-scrollgrid-sync-inner\",\n                style: {\n                    minHeight: props.minHeight\n                }\n            }, props.showWeekNumber && (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cq, {\n                elTag: \"a\",\n                elClasses: [\n                    \"fc-daygrid-week-number\"\n                ],\n                elAttrs: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.b0)(context, date, \"week\"),\n                date: date,\n                defaultFormat: DEFAULT_WEEK_NUM_FORMAT\n            }), !renderProps.isDisabled && (props.showDayNumber || (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cm)(options) || props.forceDayTop) ? (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-daygrid-day-top\"\n            }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(InnerContent, {\n                elTag: \"a\",\n                elClasses: [\n                    \"fc-daygrid-day-number\",\n                    isMonthStart && \"fc-daygrid-month-start\"\n                ],\n                elAttrs: Object.assign(Object.assign({}, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.b0)(context, date)), {\n                    id: state.dayNumberId\n                })\n            })) : props.showDayNumber ? // for creating correct amount of space (see issue #7162)\n            (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-daygrid-day-top\",\n                style: {\n                    visibility: \"hidden\"\n                }\n            }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"a\", {\n                className: \"fc-daygrid-day-number\"\n            }, \"\\xa0\")) : undefined, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-daygrid-day-events\",\n                ref: props.fgContentElRef\n            }, props.fgContent, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-daygrid-day-bottom\",\n                style: {\n                    marginTop: props.moreMarginTop\n                }\n            }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableCellMoreLink, {\n                allDayDate: date,\n                singlePlacements: props.singlePlacements,\n                moreCnt: props.moreCnt,\n                alignmentElRef: rootElRef,\n                alignGridTop: !props.showDayNumber,\n                extraDateSpan: props.extraDateSpan,\n                dateProfile: props.dateProfile,\n                eventSelection: props.eventSelection,\n                eventDrag: props.eventDrag,\n                eventResize: props.eventResize,\n                todayRange: props.todayRange\n            }))), (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-daygrid-day-bg\"\n            }, props.bgContent)));\n    }\n}\nfunction renderTopInner(props) {\n    return props.dayNumberText || (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, \"\\xa0\");\n}\nfunction shouldDisplayMonthStart(date, currentRange, dateEnv) {\n    const { start: currentStart, end: currentEnd } = currentRange;\n    const currentEndIncl = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bg)(currentEnd, -1);\n    const currentFirstYear = dateEnv.getYear(currentStart);\n    const currentFirstMonth = dateEnv.getMonth(currentStart);\n    const currentLastYear = dateEnv.getYear(currentEndIncl);\n    const currentLastMonth = dateEnv.getMonth(currentEndIncl);\n    // spans more than one month?\n    return !(currentFirstYear === currentLastYear && currentFirstMonth === currentLastMonth) && Boolean(// first date in current view?\n    date.valueOf() === currentStart.valueOf() || // a month-start that's within the current range?\n    dateEnv.getDay(date) === 1 && date.valueOf() < currentEnd.valueOf());\n}\nfunction generateSegKey(seg) {\n    return seg.eventRange.instance.instanceId + \":\" + seg.firstCol;\n}\nfunction generateSegUid(seg) {\n    return generateSegKey(seg) + \":\" + seg.lastCol;\n}\nfunction computeFgSegPlacement(segs, dayMaxEvents, dayMaxEventRows, strictOrder, segHeights, maxContentHeight, cells) {\n    let hierarchy = new DayGridSegHierarchy((segEntry)=>{\n        // TODO: more DRY with generateSegUid\n        let segUid = segs[segEntry.index].eventRange.instance.instanceId + \":\" + segEntry.span.start + \":\" + (segEntry.span.end - 1);\n        // if no thickness known, assume 1 (if 0, so small it always fits)\n        return segHeights[segUid] || 1;\n    });\n    hierarchy.allowReslicing = true;\n    hierarchy.strictOrder = strictOrder;\n    if (dayMaxEvents === true || dayMaxEventRows === true) {\n        hierarchy.maxCoord = maxContentHeight;\n        hierarchy.hiddenConsumes = true;\n    } else if (typeof dayMaxEvents === \"number\") {\n        hierarchy.maxStackCnt = dayMaxEvents;\n    } else if (typeof dayMaxEventRows === \"number\") {\n        hierarchy.maxStackCnt = dayMaxEventRows;\n        hierarchy.hiddenConsumes = true;\n    }\n    // create segInputs only for segs with known heights\n    let segInputs = [];\n    let unknownHeightSegs = [];\n    for(let i = 0; i < segs.length; i += 1){\n        let seg = segs[i];\n        let segUid = generateSegUid(seg);\n        let eventHeight = segHeights[segUid];\n        if (eventHeight != null) {\n            segInputs.push({\n                index: i,\n                span: {\n                    start: seg.firstCol,\n                    end: seg.lastCol + 1\n                }\n            });\n        } else {\n            unknownHeightSegs.push(seg);\n        }\n    }\n    let hiddenEntries = hierarchy.addSegs(segInputs);\n    let segRects = hierarchy.toRects();\n    let { singleColPlacements, multiColPlacements, leftoverMargins } = placeRects(segRects, segs, cells);\n    let moreCnts = [];\n    let moreMarginTops = [];\n    // add segs with unknown heights\n    for (let seg of unknownHeightSegs){\n        multiColPlacements[seg.firstCol].push({\n            seg,\n            isVisible: false,\n            isAbsolute: true,\n            absoluteTop: 0,\n            marginTop: 0\n        });\n        for(let col = seg.firstCol; col <= seg.lastCol; col += 1){\n            singleColPlacements[col].push({\n                seg: resliceSeg(seg, col, col + 1, cells),\n                isVisible: false,\n                isAbsolute: false,\n                absoluteTop: 0,\n                marginTop: 0\n            });\n        }\n    }\n    // add the hidden entries\n    for(let col = 0; col < cells.length; col += 1){\n        moreCnts.push(0);\n    }\n    for (let hiddenEntry of hiddenEntries){\n        let seg = segs[hiddenEntry.index];\n        let hiddenSpan = hiddenEntry.span;\n        multiColPlacements[hiddenSpan.start].push({\n            seg: resliceSeg(seg, hiddenSpan.start, hiddenSpan.end, cells),\n            isVisible: false,\n            isAbsolute: true,\n            absoluteTop: 0,\n            marginTop: 0\n        });\n        for(let col = hiddenSpan.start; col < hiddenSpan.end; col += 1){\n            moreCnts[col] += 1;\n            singleColPlacements[col].push({\n                seg: resliceSeg(seg, col, col + 1, cells),\n                isVisible: false,\n                isAbsolute: false,\n                absoluteTop: 0,\n                marginTop: 0\n            });\n        }\n    }\n    // deal with leftover margins\n    for(let col = 0; col < cells.length; col += 1){\n        moreMarginTops.push(leftoverMargins[col]);\n    }\n    return {\n        singleColPlacements,\n        multiColPlacements,\n        moreCnts,\n        moreMarginTops\n    };\n}\n// rects ordered by top coord, then left\nfunction placeRects(allRects, segs, cells) {\n    let rectsByEachCol = groupRectsByEachCol(allRects, cells.length);\n    let singleColPlacements = [];\n    let multiColPlacements = [];\n    let leftoverMargins = [];\n    for(let col = 0; col < cells.length; col += 1){\n        let rects = rectsByEachCol[col];\n        // compute all static segs in singlePlacements\n        let singlePlacements = [];\n        let currentHeight = 0;\n        let currentMarginTop = 0;\n        for (let rect of rects){\n            let seg = segs[rect.index];\n            singlePlacements.push({\n                seg: resliceSeg(seg, col, col + 1, cells),\n                isVisible: true,\n                isAbsolute: false,\n                absoluteTop: rect.levelCoord,\n                marginTop: rect.levelCoord - currentHeight\n            });\n            currentHeight = rect.levelCoord + rect.thickness;\n        }\n        // compute mixed static/absolute segs in multiPlacements\n        let multiPlacements = [];\n        currentHeight = 0;\n        currentMarginTop = 0;\n        for (let rect of rects){\n            let seg = segs[rect.index];\n            let isAbsolute = rect.span.end - rect.span.start > 1; // multi-column?\n            let isFirstCol = rect.span.start === col;\n            currentMarginTop += rect.levelCoord - currentHeight; // amount of space since bottom of previous seg\n            currentHeight = rect.levelCoord + rect.thickness; // height will now be bottom of current seg\n            if (isAbsolute) {\n                currentMarginTop += rect.thickness;\n                if (isFirstCol) {\n                    multiPlacements.push({\n                        seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),\n                        isVisible: true,\n                        isAbsolute: true,\n                        absoluteTop: rect.levelCoord,\n                        marginTop: 0\n                    });\n                }\n            } else if (isFirstCol) {\n                multiPlacements.push({\n                    seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),\n                    isVisible: true,\n                    isAbsolute: false,\n                    absoluteTop: rect.levelCoord,\n                    marginTop: currentMarginTop\n                });\n                currentMarginTop = 0;\n            }\n        }\n        singleColPlacements.push(singlePlacements);\n        multiColPlacements.push(multiPlacements);\n        leftoverMargins.push(currentMarginTop);\n    }\n    return {\n        singleColPlacements,\n        multiColPlacements,\n        leftoverMargins\n    };\n}\nfunction groupRectsByEachCol(rects, colCnt) {\n    let rectsByEachCol = [];\n    for(let col = 0; col < colCnt; col += 1){\n        rectsByEachCol.push([]);\n    }\n    for (let rect of rects){\n        for(let col = rect.span.start; col < rect.span.end; col += 1){\n            rectsByEachCol[col].push(rect);\n        }\n    }\n    return rectsByEachCol;\n}\nfunction resliceSeg(seg, spanStart, spanEnd, cells) {\n    if (seg.firstCol === spanStart && seg.lastCol === spanEnd - 1) {\n        return seg;\n    }\n    let eventRange = seg.eventRange;\n    let origRange = eventRange.range;\n    let slicedRange = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.o)(origRange, {\n        start: cells[spanStart].date,\n        end: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.t)(cells[spanEnd - 1].date, 1)\n    });\n    return Object.assign(Object.assign({}, seg), {\n        firstCol: spanStart,\n        lastCol: spanEnd - 1,\n        eventRange: {\n            def: eventRange.def,\n            ui: Object.assign(Object.assign({}, eventRange.ui), {\n                durationEditable: false\n            }),\n            instance: eventRange.instance,\n            range: slicedRange\n        },\n        isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(),\n        isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf()\n    });\n}\nclass DayGridSegHierarchy extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bA {\n    constructor(){\n        super(...arguments);\n        // config\n        this.hiddenConsumes = false;\n        // allows us to keep hidden entries in the hierarchy so they take up space\n        this.forceHidden = {};\n    }\n    addSegs(segInputs) {\n        const hiddenSegs = super.addSegs(segInputs);\n        const { entriesByLevel } = this;\n        const excludeHidden = (entry)=>!this.forceHidden[(0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bB)(entry)];\n        // remove the forced-hidden segs\n        for(let level = 0; level < entriesByLevel.length; level += 1){\n            entriesByLevel[level] = entriesByLevel[level].filter(excludeHidden);\n        }\n        return hiddenSegs;\n    }\n    handleInvalidInsertion(insertion, entry, hiddenEntries) {\n        const { entriesByLevel, forceHidden } = this;\n        const { touchingEntry, touchingLevel, touchingLateral } = insertion;\n        // the entry that the new insertion is touching must be hidden\n        if (this.hiddenConsumes && touchingEntry) {\n            const touchingEntryId = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bB)(touchingEntry);\n            if (!forceHidden[touchingEntryId]) {\n                if (this.allowReslicing) {\n                    // split up the touchingEntry, reinsert it\n                    const hiddenEntry = Object.assign(Object.assign({}, touchingEntry), {\n                        span: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bF)(touchingEntry.span, entry.span)\n                    });\n                    // reinsert the area that turned into a \"more\" link (so no other entries try to\n                    // occupy the space) but mark it forced-hidden\n                    const hiddenEntryId = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bB)(hiddenEntry);\n                    forceHidden[hiddenEntryId] = true;\n                    entriesByLevel[touchingLevel][touchingLateral] = hiddenEntry;\n                    hiddenEntries.push(hiddenEntry);\n                    this.splitEntry(touchingEntry, entry, hiddenEntries);\n                } else {\n                    forceHidden[touchingEntryId] = true;\n                    hiddenEntries.push(touchingEntry);\n                }\n            }\n        }\n        // will try to reslice...\n        super.handleInvalidInsertion(insertion, entry, hiddenEntries);\n    }\n}\nclass TableRow extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.be {\n    constructor(){\n        super(...arguments);\n        this.cellElRefs = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cf(); // the <td>\n        this.frameElRefs = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cf(); // the fc-daygrid-day-frame\n        this.fgElRefs = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cf(); // the fc-daygrid-day-events\n        this.segHarnessRefs = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cf(); // indexed by \"instanceId:firstCol\"\n        this.rootElRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        this.state = {\n            framePositions: null,\n            maxContentHeight: null,\n            segHeights: {}\n        };\n        this.handleResize = (isForced)=>{\n            if (isForced) {\n                this.updateSizing(true); // isExternal=true\n            }\n        };\n    }\n    render() {\n        let { props, state, context } = this;\n        let { options } = context;\n        let colCnt = props.cells.length;\n        let businessHoursByCol = splitSegsByFirstCol(props.businessHourSegs, colCnt);\n        let bgEventSegsByCol = splitSegsByFirstCol(props.bgEventSegs, colCnt);\n        let highlightSegsByCol = splitSegsByFirstCol(this.getHighlightSegs(), colCnt);\n        let mirrorSegsByCol = splitSegsByFirstCol(this.getMirrorSegs(), colCnt);\n        let { singleColPlacements, multiColPlacements, moreCnts, moreMarginTops } = computeFgSegPlacement((0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bR)(props.fgEventSegs, options.eventOrder), props.dayMaxEvents, props.dayMaxEventRows, options.eventOrderStrict, state.segHeights, state.maxContentHeight, props.cells);\n        let isForcedInvisible = props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {};\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", {\n            ref: this.rootElRef,\n            role: \"row\"\n        }, props.renderIntro && props.renderIntro(), props.cells.map((cell, col)=>{\n            let normalFgNodes = this.renderFgSegs(col, props.forPrint ? singleColPlacements[col] : multiColPlacements[col], props.todayRange, isForcedInvisible);\n            let mirrorFgNodes = this.renderFgSegs(col, buildMirrorPlacements(mirrorSegsByCol[col], multiColPlacements), props.todayRange, {}, Boolean(props.eventDrag), Boolean(props.eventResize), false);\n            return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableCell, {\n                key: cell.key,\n                elRef: this.cellElRefs.createRef(cell.key),\n                innerElRef: this.frameElRefs.createRef(cell.key),\n                dateProfile: props.dateProfile,\n                date: cell.date,\n                showDayNumber: props.showDayNumbers,\n                showWeekNumber: props.showWeekNumbers && col === 0,\n                forceDayTop: props.showWeekNumbers /* even displaying weeknum for row, not necessarily day */ ,\n                todayRange: props.todayRange,\n                eventSelection: props.eventSelection,\n                eventDrag: props.eventDrag,\n                eventResize: props.eventResize,\n                extraRenderProps: cell.extraRenderProps,\n                extraDataAttrs: cell.extraDataAttrs,\n                extraClassNames: cell.extraClassNames,\n                extraDateSpan: cell.extraDateSpan,\n                moreCnt: moreCnts[col],\n                moreMarginTop: moreMarginTops[col],\n                singlePlacements: singleColPlacements[col],\n                fgContentElRef: this.fgElRefs.createRef(cell.key),\n                fgContent: (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, normalFgNodes), (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, mirrorFgNodes)),\n                bgContent: (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, this.renderFillSegs(highlightSegsByCol[col], \"highlight\"), this.renderFillSegs(businessHoursByCol[col], \"non-business\"), this.renderFillSegs(bgEventSegsByCol[col], \"bg-event\")),\n                minHeight: props.cellMinHeight\n            });\n        }));\n    }\n    componentDidMount() {\n        this.updateSizing(true);\n        this.context.addResizeHandler(this.handleResize);\n    }\n    componentDidUpdate(prevProps, prevState) {\n        let currentProps = this.props;\n        this.updateSizing(!(0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.E)(prevProps, currentProps));\n    }\n    componentWillUnmount() {\n        this.context.removeResizeHandler(this.handleResize);\n    }\n    getHighlightSegs() {\n        let { props } = this;\n        if (props.eventDrag && props.eventDrag.segs.length) {\n            return props.eventDrag.segs;\n        }\n        if (props.eventResize && props.eventResize.segs.length) {\n            return props.eventResize.segs;\n        }\n        return props.dateSelectionSegs;\n    }\n    getMirrorSegs() {\n        let { props } = this;\n        if (props.eventResize && props.eventResize.segs.length) {\n            return props.eventResize.segs;\n        }\n        return [];\n    }\n    renderFgSegs(col, segPlacements, todayRange, isForcedInvisible, isDragging, isResizing, isDateSelecting) {\n        let { context } = this;\n        let { eventSelection } = this.props;\n        let { framePositions } = this.state;\n        let defaultDisplayEventEnd = this.props.cells.length === 1; // colCnt === 1\n        let isMirror = isDragging || isResizing || isDateSelecting;\n        let nodes = [];\n        if (framePositions) {\n            for (let placement of segPlacements){\n                let { seg } = placement;\n                let { instanceId } = seg.eventRange.instance;\n                let isVisible = placement.isVisible && !isForcedInvisible[instanceId];\n                let isAbsolute = placement.isAbsolute;\n                let left = \"\";\n                let right = \"\";\n                if (isAbsolute) {\n                    if (context.isRtl) {\n                        right = 0;\n                        left = framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol];\n                    } else {\n                        left = 0;\n                        right = framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol];\n                    }\n                }\n                /*\n                known bug: events that are force to be list-item but span multiple days still take up space in later columns\n                todo: in print view, for multi-day events, don't display title within non-start/end segs\n                */ nodes.push((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                    className: \"fc-daygrid-event-harness\" + (isAbsolute ? \" fc-daygrid-event-harness-abs\" : \"\"),\n                    key: generateSegKey(seg),\n                    ref: isMirror ? null : this.segHarnessRefs.createRef(generateSegUid(seg)),\n                    style: {\n                        visibility: isVisible ? \"\" : \"hidden\",\n                        marginTop: isAbsolute ? \"\" : placement.marginTop,\n                        top: isAbsolute ? placement.absoluteTop : \"\",\n                        left,\n                        right\n                    }\n                }, hasListItemDisplay(seg) ? (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableListItemEvent, Object.assign({\n                    seg: seg,\n                    isDragging: isDragging,\n                    isSelected: instanceId === eventSelection,\n                    defaultDisplayEventEnd: defaultDisplayEventEnd\n                }, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bS)(seg, todayRange))) : (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableBlockEvent, Object.assign({\n                    seg: seg,\n                    isDragging: isDragging,\n                    isResizing: isResizing,\n                    isDateSelecting: isDateSelecting,\n                    isSelected: instanceId === eventSelection,\n                    defaultDisplayEventEnd: defaultDisplayEventEnd\n                }, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bS)(seg, todayRange)))));\n            }\n        }\n        return nodes;\n    }\n    renderFillSegs(segs, fillType) {\n        let { isRtl } = this.context;\n        let { todayRange } = this.props;\n        let { framePositions } = this.state;\n        let nodes = [];\n        if (framePositions) {\n            for (let seg of segs){\n                let leftRightCss = isRtl ? {\n                    right: 0,\n                    left: framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol]\n                } : {\n                    left: 0,\n                    right: framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol]\n                };\n                nodes.push((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                    key: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bT)(seg.eventRange),\n                    className: \"fc-daygrid-bg-harness\",\n                    style: leftRightCss\n                }, fillType === \"bg-event\" ? (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cp, Object.assign({\n                    seg: seg\n                }, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bS)(seg, todayRange))) : (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.co)(fillType)));\n            }\n        }\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, {}, ...nodes);\n    }\n    updateSizing(isExternalSizingChange) {\n        let { props, state, frameElRefs } = this;\n        if (!props.forPrint && props.clientWidth !== null // positioning ready?\n        ) {\n            if (isExternalSizingChange) {\n                let frameEls = props.cells.map((cell)=>frameElRefs.currentMap[cell.key]);\n                if (frameEls.length) {\n                    let originEl = this.rootElRef.current;\n                    let newPositionCache = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ba(originEl, frameEls, true, false);\n                    if (!state.framePositions || !state.framePositions.similarTo(newPositionCache)) {\n                        this.setState({\n                            framePositions: new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ba(originEl, frameEls, true, false)\n                        });\n                    }\n                }\n            }\n            const oldSegHeights = this.state.segHeights;\n            const newSegHeights = this.querySegHeights();\n            const limitByContentHeight = props.dayMaxEvents === true || props.dayMaxEventRows === true;\n            this.safeSetState({\n                // HACK to prevent oscillations of events being shown/hidden from max-event-rows\n                // Essentially, once you compute an element's height, never null-out.\n                // TODO: always display all events, as visibility:hidden?\n                segHeights: Object.assign(Object.assign({}, oldSegHeights), newSegHeights),\n                maxContentHeight: limitByContentHeight ? this.computeMaxContentHeight() : null\n            });\n        }\n    }\n    querySegHeights() {\n        let segElMap = this.segHarnessRefs.currentMap;\n        let segHeights = {};\n        // get the max height amongst instance segs\n        for(let segUid in segElMap){\n            let height = Math.round(segElMap[segUid].getBoundingClientRect().height);\n            segHeights[segUid] = Math.max(segHeights[segUid] || 0, height);\n        }\n        return segHeights;\n    }\n    computeMaxContentHeight() {\n        let firstKey = this.props.cells[0].key;\n        let cellEl = this.cellElRefs.currentMap[firstKey];\n        let fcContainerEl = this.fgElRefs.currentMap[firstKey];\n        return cellEl.getBoundingClientRect().bottom - fcContainerEl.getBoundingClientRect().top;\n    }\n    getCellEls() {\n        let elMap = this.cellElRefs.currentMap;\n        return this.props.cells.map((cell)=>elMap[cell.key]);\n    }\n}\nTableRow.addStateEquality({\n    segHeights: _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.E\n});\nfunction buildMirrorPlacements(mirrorSegs, colPlacements) {\n    if (!mirrorSegs.length) {\n        return [];\n    }\n    let topsByInstanceId = buildAbsoluteTopHash(colPlacements); // TODO: cache this at first render?\n    return mirrorSegs.map((seg)=>({\n            seg,\n            isVisible: true,\n            isAbsolute: true,\n            absoluteTop: topsByInstanceId[seg.eventRange.instance.instanceId],\n            marginTop: 0\n        }));\n}\nfunction buildAbsoluteTopHash(colPlacements) {\n    let topsByInstanceId = {};\n    for (let placements of colPlacements){\n        for (let placement of placements){\n            topsByInstanceId[placement.seg.eventRange.instance.instanceId] = placement.absoluteTop;\n        }\n    }\n    return topsByInstanceId;\n}\nclass TableRows extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.be {\n    constructor(){\n        super(...arguments);\n        this.splitBusinessHourSegs = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitSegsByRow);\n        this.splitBgEventSegs = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitSegsByRow);\n        this.splitFgEventSegs = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitSegsByRow);\n        this.splitDateSelectionSegs = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitSegsByRow);\n        this.splitEventDrag = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitInteractionByRow);\n        this.splitEventResize = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitInteractionByRow);\n        this.rowRefs = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cf();\n    }\n    render() {\n        let { props, context } = this;\n        let rowCnt = props.cells.length;\n        let businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, rowCnt);\n        let bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, rowCnt);\n        let fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, rowCnt);\n        let dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, rowCnt);\n        let eventDragByRow = this.splitEventDrag(props.eventDrag, rowCnt);\n        let eventResizeByRow = this.splitEventResize(props.eventResize, rowCnt);\n        // for DayGrid view with many rows, force a min-height on cells so doesn't appear squished\n        // choose 7 because a month view will have max 6 rows\n        let cellMinHeight = rowCnt >= 7 && props.clientWidth ? props.clientWidth / context.options.aspectRatio / 6 : null;\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ch, {\n            unit: \"day\"\n        }, (nowDate, todayRange)=>(0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, props.cells.map((cells, row)=>(0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableRow, {\n                    ref: this.rowRefs.createRef(row),\n                    key: cells.length ? cells[0].date.toISOString() : row // in case there are no cells (like when resource view is loading)\n                    ,\n                    showDayNumbers: rowCnt > 1,\n                    showWeekNumbers: props.showWeekNumbers,\n                    todayRange: todayRange,\n                    dateProfile: props.dateProfile,\n                    cells: cells,\n                    renderIntro: props.renderRowIntro,\n                    businessHourSegs: businessHourSegsByRow[row],\n                    eventSelection: props.eventSelection,\n                    bgEventSegs: bgEventSegsByRow[row].filter(isSegAllDay),\n                    fgEventSegs: fgEventSegsByRow[row],\n                    dateSelectionSegs: dateSelectionSegsByRow[row],\n                    eventDrag: eventDragByRow[row],\n                    eventResize: eventResizeByRow[row],\n                    dayMaxEvents: props.dayMaxEvents,\n                    dayMaxEventRows: props.dayMaxEventRows,\n                    clientWidth: props.clientWidth,\n                    clientHeight: props.clientHeight,\n                    cellMinHeight: cellMinHeight,\n                    forPrint: props.forPrint\n                }))));\n    }\n    componentDidMount() {\n        this.registerInteractiveComponent();\n    }\n    componentDidUpdate() {\n        // for if started with zero cells\n        this.registerInteractiveComponent();\n    }\n    registerInteractiveComponent() {\n        if (!this.rootEl) {\n            // HACK: need a daygrid wrapper parent to do positioning\n            // NOTE: a daygrid resource view w/o resources can have zero cells\n            const firstCellEl = this.rowRefs.currentMap[0].getCellEls()[0];\n            const rootEl = firstCellEl ? firstCellEl.closest(\".fc-daygrid-body\") : null;\n            if (rootEl) {\n                this.rootEl = rootEl;\n                this.context.registerInteractiveComponent(this, {\n                    el: rootEl,\n                    isHitComboAllowed: this.props.isHitComboAllowed\n                });\n            }\n        }\n    }\n    componentWillUnmount() {\n        if (this.rootEl) {\n            this.context.unregisterInteractiveComponent(this);\n            this.rootEl = null;\n        }\n    }\n    // Hit System\n    // ----------------------------------------------------------------------------------------------------\n    prepareHits() {\n        this.rowPositions = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ba(this.rootEl, this.rowRefs.collect().map((rowObj)=>rowObj.getCellEls()[0]), false, true);\n        this.colPositions = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ba(this.rootEl, this.rowRefs.currentMap[0].getCellEls(), true, false);\n    }\n    queryHit(positionLeft, positionTop) {\n        let { colPositions, rowPositions } = this;\n        let col = colPositions.leftToIndex(positionLeft);\n        let row = rowPositions.topToIndex(positionTop);\n        if (row != null && col != null) {\n            let cell = this.props.cells[row][col];\n            return {\n                dateProfile: this.props.dateProfile,\n                dateSpan: Object.assign({\n                    range: this.getCellRange(row, col),\n                    allDay: true\n                }, cell.extraDateSpan),\n                dayEl: this.getCellEl(row, col),\n                rect: {\n                    left: colPositions.lefts[col],\n                    right: colPositions.rights[col],\n                    top: rowPositions.tops[row],\n                    bottom: rowPositions.bottoms[row]\n                },\n                layer: 0\n            };\n        }\n        return null;\n    }\n    getCellEl(row, col) {\n        return this.rowRefs.currentMap[row].getCellEls()[col]; // TODO: not optimal\n    }\n    getCellRange(row, col) {\n        let start = this.props.cells[row][col].date;\n        let end = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.t)(start, 1);\n        return {\n            start,\n            end\n        };\n    }\n}\nfunction isSegAllDay(seg) {\n    return seg.eventRange.def.allDay;\n}\nclass Table extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.be {\n    constructor(){\n        super(...arguments);\n        this.elRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        this.needsScrollReset = false;\n    }\n    render() {\n        let { props } = this;\n        let { dayMaxEventRows, dayMaxEvents, expandRows } = props;\n        let limitViaBalanced = dayMaxEvents === true || dayMaxEventRows === true;\n        // if rows can't expand to fill fixed height, can't do balanced-height event limit\n        // TODO: best place to normalize these options?\n        if (limitViaBalanced && !expandRows) {\n            limitViaBalanced = false;\n            dayMaxEventRows = null;\n            dayMaxEvents = null;\n        }\n        let classNames = [\n            \"fc-daygrid-body\",\n            limitViaBalanced ? \"fc-daygrid-body-balanced\" : \"fc-daygrid-body-unbalanced\",\n            expandRows ? \"\" : \"fc-daygrid-body-natural\"\n        ];\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            ref: this.elRef,\n            className: classNames.join(\" \"),\n            style: {\n                // these props are important to give this wrapper correct dimensions for interactions\n                // TODO: if we set it here, can we avoid giving to inner tables?\n                width: props.clientWidth,\n                minWidth: props.tableMinWidth\n            }\n        }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"table\", {\n            role: \"presentation\",\n            className: \"fc-scrollgrid-sync-table\",\n            style: {\n                width: props.clientWidth,\n                minWidth: props.tableMinWidth,\n                height: expandRows ? props.clientHeight : \"\"\n            }\n        }, props.colGroupNode, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tbody\", {\n            role: \"presentation\"\n        }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableRows, {\n            dateProfile: props.dateProfile,\n            cells: props.cells,\n            renderRowIntro: props.renderRowIntro,\n            showWeekNumbers: props.showWeekNumbers,\n            clientWidth: props.clientWidth,\n            clientHeight: props.clientHeight,\n            businessHourSegs: props.businessHourSegs,\n            bgEventSegs: props.bgEventSegs,\n            fgEventSegs: props.fgEventSegs,\n            dateSelectionSegs: props.dateSelectionSegs,\n            eventSelection: props.eventSelection,\n            eventDrag: props.eventDrag,\n            eventResize: props.eventResize,\n            dayMaxEvents: dayMaxEvents,\n            dayMaxEventRows: dayMaxEventRows,\n            forPrint: props.forPrint,\n            isHitComboAllowed: props.isHitComboAllowed\n        }))));\n    }\n    componentDidMount() {\n        this.requestScrollReset();\n    }\n    componentDidUpdate(prevProps) {\n        if (prevProps.dateProfile !== this.props.dateProfile) {\n            this.requestScrollReset();\n        } else {\n            this.flushScrollReset();\n        }\n    }\n    requestScrollReset() {\n        this.needsScrollReset = true;\n        this.flushScrollReset();\n    }\n    flushScrollReset() {\n        if (this.needsScrollReset && this.props.clientWidth // sizes computed?\n        ) {\n            const subjectEl = getScrollSubjectEl(this.elRef.current, this.props.dateProfile);\n            if (subjectEl) {\n                const originEl = subjectEl.closest(\".fc-daygrid-body\");\n                const scrollEl = originEl.closest(\".fc-scroller\");\n                const scrollTop = subjectEl.getBoundingClientRect().top - originEl.getBoundingClientRect().top;\n                scrollEl.scrollTop = scrollTop ? scrollTop + 1 : 0; // overcome border\n            }\n            this.needsScrollReset = false;\n        }\n    }\n}\nfunction getScrollSubjectEl(containerEl, dateProfile) {\n    let el;\n    if (dateProfile.currentRangeUnit.match(/year|month/)) {\n        el = containerEl.querySelector(`[data-date=\"${(0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bx)(dateProfile.currentDate)}-01\"]`);\n    // even if view is month-based, first-of-month might be hidden...\n    }\n    if (!el) {\n        el = containerEl.querySelector(`[data-date=\"${(0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bv)(dateProfile.currentDate)}\"]`);\n    // could still be hidden if an interior-view hidden day\n    }\n    return el;\n}\nclass DayTableSlicer extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bW {\n    constructor(){\n        super(...arguments);\n        this.forceDayIfListItem = true;\n    }\n    sliceRange(dateRange, dayTableModel) {\n        return dayTableModel.sliceRange(dateRange);\n    }\n}\nclass DayTable extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.be {\n    constructor(){\n        super(...arguments);\n        this.slicer = new DayTableSlicer();\n        this.tableRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n    }\n    render() {\n        let { props, context } = this;\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(Table, Object.assign({\n            ref: this.tableRef\n        }, this.slicer.sliceProps(props, props.dateProfile, props.nextDayThreshold, context, props.dayTableModel), {\n            dateProfile: props.dateProfile,\n            cells: props.dayTableModel.cells,\n            colGroupNode: props.colGroupNode,\n            tableMinWidth: props.tableMinWidth,\n            renderRowIntro: props.renderRowIntro,\n            dayMaxEvents: props.dayMaxEvents,\n            dayMaxEventRows: props.dayMaxEventRows,\n            showWeekNumbers: props.showWeekNumbers,\n            expandRows: props.expandRows,\n            headerAlignElRef: props.headerAlignElRef,\n            clientWidth: props.clientWidth,\n            clientHeight: props.clientHeight,\n            forPrint: props.forPrint\n        }));\n    }\n}\nclass DayTableView extends TableView {\n    constructor(){\n        super(...arguments);\n        this.buildDayTableModel = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildDayTableModel);\n        this.headerRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        this.tableRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n    // can't override any lifecycle methods from parent\n    }\n    render() {\n        let { options, dateProfileGenerator } = this.context;\n        let { props } = this;\n        let dayTableModel = this.buildDayTableModel(props.dateProfile, dateProfileGenerator);\n        let headerContent = options.dayHeaders && (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bK, {\n            ref: this.headerRef,\n            dateProfile: props.dateProfile,\n            dates: dayTableModel.headerDates,\n            datesRepDistinctDays: dayTableModel.rowCnt === 1\n        });\n        let bodyContent = (contentArg)=>(0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(DayTable, {\n                ref: this.tableRef,\n                dateProfile: props.dateProfile,\n                dayTableModel: dayTableModel,\n                businessHours: props.businessHours,\n                dateSelection: props.dateSelection,\n                eventStore: props.eventStore,\n                eventUiBases: props.eventUiBases,\n                eventSelection: props.eventSelection,\n                eventDrag: props.eventDrag,\n                eventResize: props.eventResize,\n                nextDayThreshold: options.nextDayThreshold,\n                colGroupNode: contentArg.tableColGroupNode,\n                tableMinWidth: contentArg.tableMinWidth,\n                dayMaxEvents: options.dayMaxEvents,\n                dayMaxEventRows: options.dayMaxEventRows,\n                showWeekNumbers: options.weekNumbers,\n                expandRows: !props.isHeightAuto,\n                headerAlignElRef: this.headerElRef,\n                clientWidth: contentArg.clientWidth,\n                clientHeight: contentArg.clientHeight,\n                forPrint: props.forPrint\n            });\n        return options.dayMinWidth ? this.renderHScrollLayout(headerContent, bodyContent, dayTableModel.colCnt, options.dayMinWidth) : this.renderSimpleLayout(headerContent, bodyContent);\n    }\n}\nfunction buildDayTableModel(dateProfile, dateProfileGenerator) {\n    let daySeries = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bO(dateProfile.renderRange, dateProfileGenerator);\n    return new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bV(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));\n}\nclass TableDateProfileGenerator extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.U {\n    // Computes the date range that will be rendered\n    buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay) {\n        let renderRange = super.buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay);\n        let { props } = this;\n        return buildDayTableRenderRange({\n            currentRange: renderRange,\n            snapToWeek: /^(year|month)$/.test(currentRangeUnit),\n            fixedWeekCount: props.fixedWeekCount,\n            dateEnv: props.dateEnv\n        });\n    }\n}\nfunction buildDayTableRenderRange(props) {\n    let { dateEnv, currentRange } = props;\n    let { start, end } = currentRange;\n    let endOfWeek;\n    // year and month views should be aligned with weeks. this is already done for week\n    if (props.snapToWeek) {\n        start = dateEnv.startOfWeek(start);\n        // make end-of-week if not already\n        endOfWeek = dateEnv.startOfWeek(end);\n        if (endOfWeek.valueOf() !== end.valueOf()) {\n            end = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bh)(endOfWeek, 1);\n        }\n    }\n    // ensure 6 weeks\n    if (props.fixedWeekCount) {\n        // TODO: instead of these date-math gymnastics (for multimonth view),\n        // compute dateprofiles of all months, then use start of first and end of last.\n        let lastMonthRenderStart = dateEnv.startOfWeek(dateEnv.startOfMonth((0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.t)(currentRange.end, -1)));\n        let rowCnt = Math.ceil((0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bi)(lastMonthRenderStart, end));\n        end = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bh)(end, 6 - rowCnt);\n    }\n    return {\n        start,\n        end\n    };\n}\nvar css_248z = ':root{--fc-daygrid-event-dot-width:8px}.fc-daygrid-day-events:after,.fc-daygrid-day-events:before,.fc-daygrid-day-frame:after,.fc-daygrid-day-frame:before,.fc-daygrid-event-harness:after,.fc-daygrid-event-harness:before{clear:both;content:\"\";display:table}.fc .fc-daygrid-body{position:relative;z-index:1}.fc .fc-daygrid-day.fc-day-today{background-color:var(--fc-today-bg-color)}.fc .fc-daygrid-day-frame{min-height:100%;position:relative}.fc .fc-daygrid-day-top{display:flex;flex-direction:row-reverse}.fc .fc-day-other .fc-daygrid-day-top{opacity:.3}.fc .fc-daygrid-day-number{padding:4px;position:relative;z-index:4}.fc .fc-daygrid-month-start{font-size:1.1em;font-weight:700}.fc .fc-daygrid-day-events{margin-top:1px}.fc .fc-daygrid-body-balanced .fc-daygrid-day-events{left:0;position:absolute;right:0}.fc .fc-daygrid-body-unbalanced .fc-daygrid-day-events{min-height:2em;position:relative}.fc .fc-daygrid-body-natural .fc-daygrid-day-events{margin-bottom:1em}.fc .fc-daygrid-event-harness{position:relative}.fc .fc-daygrid-event-harness-abs{left:0;position:absolute;right:0;top:0}.fc .fc-daygrid-bg-harness{bottom:0;position:absolute;top:0}.fc .fc-daygrid-day-bg .fc-non-business{z-index:1}.fc .fc-daygrid-day-bg .fc-bg-event{z-index:2}.fc .fc-daygrid-day-bg .fc-highlight{z-index:3}.fc .fc-daygrid-event{margin-top:1px;z-index:6}.fc .fc-daygrid-event.fc-event-mirror{z-index:7}.fc .fc-daygrid-day-bottom{font-size:.85em;margin:0 2px}.fc .fc-daygrid-day-bottom:after,.fc .fc-daygrid-day-bottom:before{clear:both;content:\"\";display:table}.fc .fc-daygrid-more-link{border-radius:3px;cursor:pointer;line-height:1;margin-top:1px;max-width:100%;overflow:hidden;padding:2px;position:relative;white-space:nowrap;z-index:4}.fc .fc-daygrid-more-link:hover{background-color:rgba(0,0,0,.1)}.fc .fc-daygrid-week-number{background-color:var(--fc-neutral-bg-color);color:var(--fc-neutral-text-color);min-width:1.5em;padding:2px;position:absolute;text-align:center;top:0;z-index:5}.fc .fc-more-popover .fc-popover-body{min-width:220px;padding:10px}.fc-direction-ltr .fc-daygrid-event.fc-event-start,.fc-direction-rtl .fc-daygrid-event.fc-event-end{margin-left:2px}.fc-direction-ltr .fc-daygrid-event.fc-event-end,.fc-direction-rtl .fc-daygrid-event.fc-event-start{margin-right:2px}.fc-direction-ltr .fc-daygrid-more-link{float:left}.fc-direction-ltr .fc-daygrid-week-number{border-radius:0 0 3px 0;left:0}.fc-direction-rtl .fc-daygrid-more-link{float:right}.fc-direction-rtl .fc-daygrid-week-number{border-radius:0 0 0 3px;right:0}.fc-liquid-hack .fc-daygrid-day-frame{position:static}.fc-daygrid-event{border-radius:3px;font-size:var(--fc-small-font-size);position:relative;white-space:nowrap}.fc-daygrid-block-event .fc-event-time{font-weight:700}.fc-daygrid-block-event .fc-event-time,.fc-daygrid-block-event .fc-event-title{padding:1px}.fc-daygrid-dot-event{align-items:center;display:flex;padding:2px 0}.fc-daygrid-dot-event .fc-event-title{flex-grow:1;flex-shrink:1;font-weight:700;min-width:0;overflow:hidden}.fc-daygrid-dot-event.fc-event-mirror,.fc-daygrid-dot-event:hover{background:rgba(0,0,0,.1)}.fc-daygrid-dot-event.fc-event-selected:before{bottom:-10px;top:-10px}.fc-daygrid-event-dot{border:calc(var(--fc-daygrid-event-dot-width)/2) solid var(--fc-event-border-color);border-radius:calc(var(--fc-daygrid-event-dot-width)/2);box-sizing:content-box;height:0;margin:0 4px;width:0}.fc-direction-ltr .fc-daygrid-event .fc-event-time{margin-right:3px}.fc-direction-rtl .fc-daygrid-event .fc-event-time{margin-left:3px}';\n(0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cw)(css_248z);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9kYXlncmlkL2ludGVybmFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQTZ0QjtBQUMzb0I7QUFFbEY7c0hBQ3NILEdBQ3RILGtGQUFrRjtBQUNsRiwrQ0FBK0M7QUFDL0MsTUFBTWdELGtCQUFrQmhELDhEQUFhQTtJQUNqQ2lELGFBQWM7UUFDVixLQUFLLElBQUlDO1FBQ1QsSUFBSSxDQUFDQyxXQUFXLEdBQUdOLHVFQUFTQTtJQUNoQztJQUNBTyxtQkFBbUJDLGdCQUFnQixFQUFFQyxXQUFXLEVBQUU7UUFDOUMsSUFBSSxFQUFFQyxLQUFLLEVBQUVDLE9BQU8sRUFBRSxHQUFHLElBQUk7UUFDN0IsSUFBSUMsV0FBVyxFQUFFO1FBQ2pCLElBQUlDLG9CQUFvQnpELGtFQUFvQkEsQ0FBQ3VELFFBQVFHLE9BQU87UUFDNUQsSUFBSU4sa0JBQWtCO1lBQ2xCSSxTQUFTRyxJQUFJLENBQUM7Z0JBQ1ZDLE1BQU07Z0JBQ05DLEtBQUs7Z0JBQ0xDLFVBQVVMO2dCQUNWTSxPQUFPO29CQUNIQyxPQUFPLElBQUksQ0FBQ2QsV0FBVztvQkFDdkJlLGdCQUFnQjtvQkFDaEJDLFlBQVlkO2dCQUNoQjtZQUNKO1FBQ0o7UUFDQUksU0FBU0csSUFBSSxDQUFDO1lBQ1ZDLE1BQU07WUFDTkMsS0FBSztZQUNMTSxRQUFRO1lBQ1JKLE9BQU87Z0JBQUVLLFNBQVNmO1lBQVk7UUFDbEM7UUFDQSxPQUFRUiwyRUFBYUEsQ0FBQzVDLDhEQUFhQSxFQUFFO1lBQUVvRSxXQUFXO2dCQUFDO2FBQWE7WUFBRUMsVUFBVWYsUUFBUWUsUUFBUTtRQUFDLEdBQ3pGekIsMkVBQWFBLENBQUMzQyw4REFBZ0JBLEVBQUU7WUFBRWlFLFFBQVEsQ0FBQ2IsTUFBTWlCLFlBQVksSUFBSSxDQUFDakIsTUFBTWtCLFFBQVE7WUFBRUMsa0JBQWtCbkIsTUFBTWtCLFFBQVE7WUFBRUUsTUFBTSxFQUFFO1lBQTZCbEIsVUFBVUE7UUFBUztJQUNwTDtJQUNBbUIsb0JBQW9CdkIsZ0JBQWdCLEVBQUVDLFdBQVcsRUFBRXVCLE1BQU0sRUFBRUMsV0FBVyxFQUFFO1FBQ3BFLElBQUlDLGFBQWEsSUFBSSxDQUFDdkIsT0FBTyxDQUFDd0IsV0FBVyxDQUFDQyxjQUFjO1FBQ3hELElBQUksQ0FBQ0YsWUFBWTtZQUNiLE1BQU0sSUFBSUcsTUFBTTtRQUNwQjtRQUNBLElBQUksRUFBRTNCLEtBQUssRUFBRUMsT0FBTyxFQUFFLEdBQUcsSUFBSTtRQUM3QixJQUFJRSxvQkFBb0IsQ0FBQ0gsTUFBTWtCLFFBQVEsSUFBSXhFLGtFQUFvQkEsQ0FBQ3VELFFBQVFHLE9BQU87UUFDL0UsSUFBSXdCLHdCQUF3QixDQUFDNUIsTUFBTWtCLFFBQVEsSUFBSXJFLGtFQUF3QkEsQ0FBQ29ELFFBQVFHLE9BQU87UUFDdkYsSUFBSUYsV0FBVyxFQUFFO1FBQ2pCLElBQUlKLGtCQUFrQjtZQUNsQkksU0FBU0csSUFBSSxDQUFDO2dCQUNWQyxNQUFNO2dCQUNOQyxLQUFLO2dCQUNMQyxVQUFVTDtnQkFDVjBCLFFBQVE7b0JBQUM7d0JBQ0R0QixLQUFLO3dCQUNMRyxPQUFPLElBQUksQ0FBQ2QsV0FBVzt3QkFDdkJlLGdCQUFnQjt3QkFDaEJDLFlBQVlkO29CQUNoQjtpQkFBRTtZQUNWO1FBQ0o7UUFDQUksU0FBU0csSUFBSSxDQUFDO1lBQ1ZDLE1BQU07WUFDTkMsS0FBSztZQUNMTSxRQUFRO1lBQ1JnQixRQUFRO2dCQUFDO29CQUNEdEIsS0FBSztvQkFDTE8sU0FBU2Y7Z0JBQ2I7YUFBRTtRQUNWO1FBQ0EsSUFBSTZCLHVCQUF1QjtZQUN2QjFCLFNBQVNHLElBQUksQ0FBQztnQkFDVkMsTUFBTTtnQkFDTkMsS0FBSztnQkFDTEMsVUFBVTtnQkFDVnFCLFFBQVE7b0JBQUM7d0JBQ0R0QixLQUFLO3dCQUNMTyxTQUFTaEUsOERBQWdCQTtvQkFDN0I7aUJBQUU7WUFDVjtRQUNKO1FBQ0EsT0FBUXlDLDJFQUFhQSxDQUFDNUMsOERBQWFBLEVBQUU7WUFBRW9FLFdBQVc7Z0JBQUM7YUFBYTtZQUFFQyxVQUFVZixRQUFRZSxRQUFRO1FBQUMsR0FDekZ6QiwyRUFBYUEsQ0FBQ2lDLFlBQVk7WUFBRVgsUUFBUSxDQUFDYixNQUFNaUIsWUFBWSxJQUFJLENBQUNqQixNQUFNa0IsUUFBUTtZQUFFQSxVQUFVbEIsTUFBTWtCLFFBQVE7WUFBRUMsa0JBQWtCbkIsTUFBTWtCLFFBQVE7WUFBRVksV0FBVztnQkFBQztvQkFBRVYsTUFBTTt3QkFBQzs0QkFBRVcsTUFBTVQ7NEJBQVFVLFVBQVVUO3dCQUFZO3FCQUFFO2dCQUFDO2FBQUU7WUFBRXJCLFVBQVVBO1FBQVM7SUFDck87QUFDSjtBQUVBLFNBQVMrQixlQUFlQyxJQUFJLEVBQUVDLE1BQU07SUFDaEMsSUFBSUMsUUFBUSxFQUFFO0lBQ2QsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLFFBQVFFLEtBQUssRUFBRztRQUNoQ0QsS0FBSyxDQUFDQyxFQUFFLEdBQUcsRUFBRTtJQUNqQjtJQUNBLEtBQUssSUFBSUMsT0FBT0osS0FBTTtRQUNsQkUsS0FBSyxDQUFDRSxJQUFJQyxHQUFHLENBQUMsQ0FBQ2xDLElBQUksQ0FBQ2lDO0lBQ3hCO0lBQ0EsT0FBT0Y7QUFDWDtBQUNBLFNBQVNJLG9CQUFvQk4sSUFBSSxFQUFFWixNQUFNO0lBQ3JDLElBQUltQixRQUFRLEVBQUU7SUFDZCxJQUFLLElBQUlKLElBQUksR0FBR0EsSUFBSWYsUUFBUWUsS0FBSyxFQUFHO1FBQ2hDSSxLQUFLLENBQUNKLEVBQUUsR0FBRyxFQUFFO0lBQ2pCO0lBQ0EsS0FBSyxJQUFJQyxPQUFPSixLQUFNO1FBQ2xCTyxLQUFLLENBQUNILElBQUlJLFFBQVEsQ0FBQyxDQUFDckMsSUFBSSxDQUFDaUM7SUFDN0I7SUFDQSxPQUFPRztBQUNYO0FBQ0EsU0FBU0Usc0JBQXNCQyxFQUFFLEVBQUVULE1BQU07SUFDckMsSUFBSUMsUUFBUSxFQUFFO0lBQ2QsSUFBSSxDQUFDUSxJQUFJO1FBQ0wsSUFBSyxJQUFJUCxJQUFJLEdBQUdBLElBQUlGLFFBQVFFLEtBQUssRUFBRztZQUNoQ0QsS0FBSyxDQUFDQyxFQUFFLEdBQUc7UUFDZjtJQUNKLE9BQ0s7UUFDRCxJQUFLLElBQUlBLElBQUksR0FBR0EsSUFBSUYsUUFBUUUsS0FBSyxFQUFHO1lBQ2hDRCxLQUFLLENBQUNDLEVBQUUsR0FBRztnQkFDUFEsbUJBQW1CRCxHQUFHQyxpQkFBaUI7Z0JBQ3ZDQyxTQUFTRixHQUFHRSxPQUFPO2dCQUNuQlosTUFBTSxFQUFFO1lBQ1o7UUFDSjtRQUNBLEtBQUssSUFBSUksT0FBT00sR0FBR1YsSUFBSSxDQUFFO1lBQ3JCRSxLQUFLLENBQUNFLElBQUlDLEdBQUcsQ0FBQyxDQUFDTCxJQUFJLENBQUM3QixJQUFJLENBQUNpQztRQUM3QjtJQUNKO0lBQ0EsT0FBT0Y7QUFDWDtBQUVBLE1BQU1XLGtDQUFrQ2hHLGlFQUFlQSxDQUFDO0lBQ3BEaUcsTUFBTTtJQUNOQyxRQUFRO0lBQ1JDLGdCQUFnQjtJQUNoQkMsVUFBVTtBQUNkO0FBQ0EsU0FBU0MsbUJBQW1CZCxHQUFHO0lBQzNCLElBQUksRUFBRWUsT0FBTyxFQUFFLEdBQUdmLElBQUlnQixVQUFVLENBQUNWLEVBQUU7SUFDbkMsT0FBT1MsWUFBWSxlQUFnQkEsWUFBWSxVQUMzQyxDQUFDZixJQUFJZ0IsVUFBVSxDQUFDQyxHQUFHLENBQUNDLE1BQU0sSUFDMUJsQixJQUFJSSxRQUFRLEtBQUtKLElBQUltQixPQUFPLElBQUkscUJBQXFCO0lBQ3JEbkIsSUFBSW9CLE9BQU8sSUFBSSxJQUFJO0lBQ25CcEIsSUFBSXFCLEtBQUssQ0FBQyxJQUFJOztBQUV0QjtBQUVBLE1BQU1DLHdCQUF3QjVHLDZEQUFhQTtJQUN2QzZHLFNBQVM7UUFDTCxJQUFJLEVBQUU3RCxLQUFLLEVBQUUsR0FBRyxJQUFJO1FBQ3BCLE9BQVFULDJFQUFhQSxDQUFDdEMsOERBQWFBLEVBQUU2RyxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHL0QsT0FBTztZQUFFZSxXQUFXO2dCQUFDO2dCQUFvQjtnQkFBMEI7YUFBYTtZQUFFaUQsbUJBQW1CakI7WUFBaUNrQix3QkFBd0JqRSxNQUFNaUUsc0JBQXNCO1lBQUVDLGlCQUFpQixDQUFDbEUsTUFBTXNDLEdBQUcsQ0FBQ2dCLFVBQVUsQ0FBQ0MsR0FBRyxDQUFDQyxNQUFNO1FBQUM7SUFDelM7QUFDSjtBQUVBLE1BQU1XLDJCQUEyQm5ILDZEQUFhQTtJQUMxQzZHLFNBQVM7UUFDTCxJQUFJLEVBQUU3RCxLQUFLLEVBQUVDLE9BQU8sRUFBRSxHQUFHLElBQUk7UUFDN0IsSUFBSSxFQUFFRyxPQUFPLEVBQUUsR0FBR0g7UUFDbEIsSUFBSSxFQUFFcUMsR0FBRyxFQUFFLEdBQUd0QztRQUNkLElBQUlvRSxhQUFhaEUsUUFBUWlFLGVBQWUsSUFBSXRCO1FBQzVDLElBQUl1QixXQUFXcEgsa0VBQWdCQSxDQUFDb0YsS0FBSzhCLFlBQVluRSxTQUFTLE1BQU1ELE1BQU1pRSxzQkFBc0I7UUFDNUYsT0FBUTFFLDJFQUFhQSxDQUFDcEMsOERBQWNBLEVBQUUyRyxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHL0QsT0FBTztZQUFFdUUsT0FBTztZQUFLeEQsV0FBVztnQkFBQztnQkFBb0I7YUFBdUI7WUFBRXlELFNBQVNwSCxrRUFBaUJBLENBQUM0QyxNQUFNc0MsR0FBRyxFQUFFckM7WUFBVXdFLGtCQUFrQkM7WUFBb0JKLFVBQVVBO1lBQVVLLFlBQVk7WUFBT0MsaUJBQWlCO1FBQU07SUFDOVI7QUFDSjtBQUNBLFNBQVNGLG1CQUFtQkcsV0FBVztJQUNuQyxPQUFRdEYsMkVBQWFBLENBQUNDLGtFQUFRQSxFQUFFLE1BQzVCRCwyRUFBYUEsQ0FBQyxPQUFPO1FBQUV1RixXQUFXO1FBQXdCQyxPQUFPO1lBQUVDLGFBQWFILFlBQVlHLFdBQVcsSUFBSUgsWUFBWUksZUFBZTtRQUFDO0lBQUUsSUFDeklKLFlBQVlQLFFBQVEsSUFBSy9FLDJFQUFhQSxDQUFDLE9BQU87UUFBRXVGLFdBQVc7SUFBZ0IsR0FBR0QsWUFBWVAsUUFBUSxHQUNsRy9FLDJFQUFhQSxDQUFDLE9BQU87UUFBRXVGLFdBQVc7SUFBaUIsR0FBR0QsWUFBWUssS0FBSyxDQUFDQyxLQUFLLElBQUk1RiwyRUFBYUEsQ0FBQ0Msa0VBQVFBLEVBQUUsTUFBTTtBQUN2SDtBQUVBLE1BQU00RiwwQkFBMEJwSSw2REFBYUE7SUFDekMwQyxhQUFjO1FBQ1YsS0FBSyxJQUFJQztRQUNULElBQUksQ0FBQzBGLFdBQVcsR0FBR2hJLGlFQUFPQSxDQUFDZ0k7SUFDL0I7SUFDQXhCLFNBQVM7UUFDTCxJQUFJLEVBQUU3RCxLQUFLLEVBQUUsR0FBRyxJQUFJO1FBQ3BCLElBQUksRUFBRXNGLE9BQU8sRUFBRUMsYUFBYSxFQUFFLEdBQUcsSUFBSSxDQUFDRixXQUFXLENBQUNyRixNQUFNd0YsZ0JBQWdCO1FBQ3hFLE9BQVFqRywyRUFBYUEsQ0FBQ2pDLDhEQUFpQkEsRUFBRTtZQUFFeUQsV0FBVztnQkFBQzthQUF1QjtZQUFFMEUsYUFBYXpGLE1BQU15RixXQUFXO1lBQUVDLFlBQVkxRixNQUFNMEYsVUFBVTtZQUFFQyxZQUFZM0YsTUFBTTJGLFVBQVU7WUFBRUMsU0FBUzVGLE1BQU00RixPQUFPO1lBQUVOLFNBQVNBO1lBQVNPLFlBQVlOO1lBQWVPLGdCQUFnQjlGLE1BQU04RixjQUFjO1lBQUVDLGNBQWMvRixNQUFNK0YsWUFBWTtZQUFFQyxlQUFlaEcsTUFBTWdHLGFBQWE7WUFBRUMsZ0JBQWdCO2dCQUNyVyxJQUFJQyxvQkFBb0IsQ0FBQ2xHLE1BQU1tRyxTQUFTLEdBQUduRyxNQUFNbUcsU0FBUyxDQUFDdEQsaUJBQWlCLEdBQUcsSUFBRyxLQUM3RTdDLENBQUFBLE1BQU1vRyxXQUFXLEdBQUdwRyxNQUFNb0csV0FBVyxDQUFDdkQsaUJBQWlCLEdBQUcsSUFBRyxLQUM5RCxDQUFDO2dCQUNMLE9BQVF0RCwyRUFBYUEsQ0FBQ0Msa0VBQVFBLEVBQUUsTUFBTThGLFFBQVFlLEdBQUcsQ0FBQyxDQUFDL0Q7b0JBQy9DLElBQUlnRSxhQUFhaEUsSUFBSWdCLFVBQVUsQ0FBQ2lELFFBQVEsQ0FBQ0QsVUFBVTtvQkFDbkQsT0FBUS9HLDJFQUFhQSxDQUFDLE9BQU87d0JBQUV1RixXQUFXO3dCQUE0QnZFLEtBQUsrRjt3QkFBWXZCLE9BQU87NEJBQ3RGeUIsWUFBWU4saUJBQWlCLENBQUNJLFdBQVcsR0FBRyxXQUFXO3dCQUMzRDtvQkFBRSxHQUFHbEQsbUJBQW1CZCxPQUFRL0MsMkVBQWFBLENBQUM0RSxvQkFBb0JMLE9BQU9DLE1BQU0sQ0FBQzt3QkFBRXpCLEtBQUtBO3dCQUFLbUUsWUFBWTt3QkFBT0MsWUFBWUosZUFBZXRHLE1BQU0yRyxjQUFjO3dCQUFFMUMsd0JBQXdCO29CQUFNLEdBQUcxRyxrRUFBVUEsQ0FBQytFLEtBQUt0QyxNQUFNMEYsVUFBVSxNQUFRbkcsMkVBQWFBLENBQUNxRSxpQkFBaUJFLE9BQU9DLE1BQU0sQ0FBQzt3QkFBRXpCLEtBQUtBO3dCQUFLbUUsWUFBWTt3QkFBTzlCLFlBQVk7d0JBQU9DLGlCQUFpQjt3QkFBTzhCLFlBQVlKLGVBQWV0RyxNQUFNMkcsY0FBYzt3QkFBRTFDLHdCQUF3QjtvQkFBTSxHQUFHMUcsa0VBQVVBLENBQUMrRSxLQUFLdEMsTUFBTTBGLFVBQVU7Z0JBQzFkO1lBQ0o7UUFBRTtJQUNWO0FBQ0o7QUFDQSxTQUFTTCxZQUFZRyxnQkFBZ0I7SUFDakMsSUFBSUYsVUFBVSxFQUFFO0lBQ2hCLElBQUlDLGdCQUFnQixFQUFFO0lBQ3RCLEtBQUssSUFBSXFCLGFBQWFwQixpQkFBa0I7UUFDcENGLFFBQVFqRixJQUFJLENBQUN1RyxVQUFVdEUsR0FBRztRQUMxQixJQUFJLENBQUNzRSxVQUFVQyxTQUFTLEVBQUU7WUFDdEJ0QixjQUFjbEYsSUFBSSxDQUFDdUcsVUFBVXRFLEdBQUc7UUFDcEM7SUFDSjtJQUNBLE9BQU87UUFBRWdEO1FBQVNDO0lBQWM7QUFDcEM7QUFFQSxNQUFNdUIsMEJBQTBCL0osaUVBQWVBLENBQUM7SUFBRWdLLE1BQU07QUFBUztBQUNqRSxNQUFNQyxrQkFBa0J2Syw4REFBYUE7SUFDakNpRCxhQUFjO1FBQ1YsS0FBSyxJQUFJQztRQUNULElBQUksQ0FBQ3NILFNBQVMsR0FBRzNILHVFQUFTQTtRQUMxQixJQUFJLENBQUM0SCxLQUFLLEdBQUc7WUFDVEMsYUFBYTNKLGtFQUFjQTtRQUMvQjtRQUNBLElBQUksQ0FBQzRKLFlBQVksR0FBRyxDQUFDQztZQUNqQjVKLGlFQUFNQSxDQUFDLElBQUksQ0FBQ3dKLFNBQVMsRUFBRUk7WUFDdkI1SixpRUFBTUEsQ0FBQyxJQUFJLENBQUN1QyxLQUFLLENBQUNVLEtBQUssRUFBRTJHO1FBQzdCO0lBQ0o7SUFDQXhELFNBQVM7UUFDTCxJQUFJLEVBQUU1RCxPQUFPLEVBQUVELEtBQUssRUFBRWtILEtBQUssRUFBRUQsU0FBUyxFQUFFLEdBQUcsSUFBSTtRQUMvQyxJQUFJLEVBQUU3RyxPQUFPLEVBQUVrSCxPQUFPLEVBQUUsR0FBR3JIO1FBQzNCLElBQUksRUFBRXNILElBQUksRUFBRTlCLFdBQVcsRUFBRSxHQUFHekY7UUFDNUIsc0JBQXNCO1FBQ3RCLE1BQU13SCxlQUFleEgsTUFBTXlILGFBQWEsSUFDcENDLHdCQUF3QkgsTUFBTTlCLFlBQVlrQyxZQUFZLEVBQUVMO1FBQzVELE9BQVEvSCwyRUFBYUEsQ0FBQzdCLDhEQUFnQkEsRUFBRTtZQUFFNkcsT0FBTztZQUFNN0QsT0FBTyxJQUFJLENBQUMwRyxZQUFZO1lBQUVyRyxXQUFXO2dCQUNwRjttQkFDSWYsTUFBTTRILGVBQWUsSUFBSSxFQUFFO2FBQ2xDO1lBQUVwRCxTQUFTVixPQUFPQyxNQUFNLENBQUNELE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBRy9ELE1BQU02SCxjQUFjLEdBQUk3SCxNQUFNeUgsYUFBYSxHQUFHO2dCQUFFLG1CQUFtQlAsTUFBTUMsV0FBVztZQUFDLElBQUksQ0FBQyxJQUFLO2dCQUFFVyxNQUFNO1lBQVc7WUFBSXJELGtCQUFrQnNEO1lBQWdCUixNQUFNQTtZQUFNOUIsYUFBYUE7WUFBYUMsWUFBWTFGLE1BQU0wRixVQUFVO1lBQUUrQixlQUFlekgsTUFBTXlILGFBQWE7WUFBRUQsY0FBY0E7WUFBY1Esa0JBQWtCaEksTUFBTWdJLGdCQUFnQjtRQUFDLEdBQUcsQ0FBQ0MsY0FBY3BELGNBQWlCdEYsMkVBQWFBLENBQUMsT0FBTztnQkFBRTJJLEtBQUtsSSxNQUFNbUksVUFBVTtnQkFBRXJELFdBQVc7Z0JBQWlEQyxPQUFPO29CQUFFcUQsV0FBV3BJLE1BQU1vSSxTQUFTO2dCQUFDO1lBQUUsR0FDbGpCcEksTUFBTXFJLGNBQWMsSUFBSzlJLDJFQUFhQSxDQUFDNUIsOERBQW1CQSxFQUFFO2dCQUFFNEcsT0FBTztnQkFBS3hELFdBQVc7b0JBQUM7aUJBQXlCO2dCQUFFeUQsU0FBUzVHLGtFQUFpQkEsQ0FBQ3FDLFNBQVNzSCxNQUFNO2dCQUFTQSxNQUFNQTtnQkFBTWUsZUFBZXhCO1lBQXdCLElBQ3ZOLENBQUNqQyxZQUFZMEQsVUFBVSxJQUNsQnZJLENBQUFBLE1BQU15SCxhQUFhLElBQUk1SixrRUFBdUJBLENBQUN1QyxZQUFZSixNQUFNd0ksV0FBVyxJQUFLakosMkVBQWFBLENBQUMsT0FBTztnQkFBRXVGLFdBQVc7WUFBcUIsR0FDekl2RiwyRUFBYUEsQ0FBQzBJLGNBQWM7Z0JBQUUxRCxPQUFPO2dCQUFLeEQsV0FBVztvQkFDN0M7b0JBQ0F5RyxnQkFBZ0I7aUJBQ25CO2dCQUFFaEQsU0FBU1YsT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHbkcsa0VBQWlCQSxDQUFDcUMsU0FBU3NILFFBQVE7b0JBQUVrQixJQUFJdkIsTUFBTUMsV0FBVztnQkFBQztZQUFHLE1BQU9uSCxNQUFNeUgsYUFBYSxHQUM1SSx5REFBeUQ7WUFDekRsSSwyRUFBYUEsQ0FBQyxPQUFPO2dCQUFFdUYsV0FBVztnQkFBc0JDLE9BQU87b0JBQUV5QixZQUFZO2dCQUFTO1lBQUUsR0FDcEZqSCwyRUFBYUEsQ0FBQyxLQUFLO2dCQUFFdUYsV0FBVztZQUF3QixHQUFHLFdBQWM0RCxXQUM3RW5KLDJFQUFhQSxDQUFDLE9BQU87Z0JBQUV1RixXQUFXO2dCQUF5Qm9ELEtBQUtsSSxNQUFNMkksY0FBYztZQUFDLEdBQ2pGM0ksTUFBTTRJLFNBQVMsRUFDZnJKLDJFQUFhQSxDQUFDLE9BQU87Z0JBQUV1RixXQUFXO2dCQUF5QkMsT0FBTztvQkFBRThELFdBQVc3SSxNQUFNOEksYUFBYTtnQkFBQztZQUFFLEdBQ2pHdkosMkVBQWFBLENBQUM2RixtQkFBbUI7Z0JBQUVPLFlBQVk0QjtnQkFBTS9CLGtCQUFrQnhGLE1BQU13RixnQkFBZ0I7Z0JBQUVJLFNBQVM1RixNQUFNNEYsT0FBTztnQkFBRUUsZ0JBQWdCbUI7Z0JBQVdsQixjQUFjLENBQUMvRixNQUFNeUgsYUFBYTtnQkFBRXpCLGVBQWVoRyxNQUFNZ0csYUFBYTtnQkFBRVAsYUFBYXpGLE1BQU15RixXQUFXO2dCQUFFa0IsZ0JBQWdCM0csTUFBTTJHLGNBQWM7Z0JBQUVSLFdBQVduRyxNQUFNbUcsU0FBUztnQkFBRUMsYUFBYXBHLE1BQU1vRyxXQUFXO2dCQUFFVixZQUFZMUYsTUFBTTBGLFVBQVU7WUFBQyxNQUNqWW5HLDJFQUFhQSxDQUFDLE9BQU87Z0JBQUV1RixXQUFXO1lBQW9CLEdBQUc5RSxNQUFNK0ksU0FBUztJQUNoRjtBQUNKO0FBQ0EsU0FBU2hCLGVBQWUvSCxLQUFLO0lBQ3pCLE9BQU9BLE1BQU1nSixhQUFhLElBQUl6SiwyRUFBYUEsQ0FBQ0Msa0VBQVFBLEVBQUUsTUFBTTtBQUNoRTtBQUNBLFNBQVNrSSx3QkFBd0JILElBQUksRUFBRUksWUFBWSxFQUFFTCxPQUFPO0lBQ3hELE1BQU0sRUFBRTJCLE9BQU9DLFlBQVksRUFBRUMsS0FBS0MsVUFBVSxFQUFFLEdBQUd6QjtJQUNqRCxNQUFNMEIsaUJBQWlCdkwsa0VBQUtBLENBQUNzTCxZQUFZLENBQUM7SUFDMUMsTUFBTUUsbUJBQW1CaEMsUUFBUWlDLE9BQU8sQ0FBQ0w7SUFDekMsTUFBTU0sb0JBQW9CbEMsUUFBUW1DLFFBQVEsQ0FBQ1A7SUFDM0MsTUFBTVEsa0JBQWtCcEMsUUFBUWlDLE9BQU8sQ0FBQ0Y7SUFDeEMsTUFBTU0sbUJBQW1CckMsUUFBUW1DLFFBQVEsQ0FBQ0o7SUFDMUMsNkJBQTZCO0lBQzdCLE9BQU8sQ0FBRUMsQ0FBQUEscUJBQXFCSSxtQkFBbUJGLHNCQUFzQkcsZ0JBQWUsS0FDbEZDLFFBQ0EsOEJBQThCO0lBQzlCckMsS0FBS3NDLE9BQU8sT0FBT1gsYUFBYVcsT0FBTyxNQUNuQyxpREFBaUQ7SUFDaER2QyxRQUFRd0MsTUFBTSxDQUFDdkMsVUFBVSxLQUFLQSxLQUFLc0MsT0FBTyxLQUFLVCxXQUFXUyxPQUFPO0FBQzlFO0FBRUEsU0FBU0UsZUFBZXpILEdBQUc7SUFDdkIsT0FBT0EsSUFBSWdCLFVBQVUsQ0FBQ2lELFFBQVEsQ0FBQ0QsVUFBVSxHQUFHLE1BQU1oRSxJQUFJSSxRQUFRO0FBQ2xFO0FBQ0EsU0FBU3NILGVBQWUxSCxHQUFHO0lBQ3ZCLE9BQU95SCxlQUFlekgsT0FBTyxNQUFNQSxJQUFJbUIsT0FBTztBQUNsRDtBQUNBLFNBQVN3RyxzQkFBc0IvSCxJQUFJLEVBQ25DZ0ksWUFBWSxFQUFFQyxlQUFlLEVBQUVDLFdBQVcsRUFBRUMsVUFBVSxFQUFFQyxnQkFBZ0IsRUFBRUMsS0FBSztJQUMzRSxJQUFJQyxZQUFZLElBQUlDLG9CQUFvQixDQUFDQztRQUNyQyxxQ0FBcUM7UUFDckMsSUFBSUMsU0FBU3pJLElBQUksQ0FBQ3dJLFNBQVNFLEtBQUssQ0FBQyxDQUFDdEgsVUFBVSxDQUFDaUQsUUFBUSxDQUFDRCxVQUFVLEdBQzVELE1BQU1vRSxTQUFTM0ksSUFBSSxDQUFDa0gsS0FBSyxHQUN6QixNQUFPeUIsQ0FBQUEsU0FBUzNJLElBQUksQ0FBQ29ILEdBQUcsR0FBRztRQUMvQixrRUFBa0U7UUFDbEUsT0FBT2tCLFVBQVUsQ0FBQ00sT0FBTyxJQUFJO0lBQ2pDO0lBQ0FILFVBQVVLLGNBQWMsR0FBRztJQUMzQkwsVUFBVUosV0FBVyxHQUFHQTtJQUN4QixJQUFJRixpQkFBaUIsUUFBUUMsb0JBQW9CLE1BQU07UUFDbkRLLFVBQVVNLFFBQVEsR0FBR1I7UUFDckJFLFVBQVVPLGNBQWMsR0FBRztJQUMvQixPQUNLLElBQUksT0FBT2IsaUJBQWlCLFVBQVU7UUFDdkNNLFVBQVVRLFdBQVcsR0FBR2Q7SUFDNUIsT0FDSyxJQUFJLE9BQU9DLG9CQUFvQixVQUFVO1FBQzFDSyxVQUFVUSxXQUFXLEdBQUdiO1FBQ3hCSyxVQUFVTyxjQUFjLEdBQUc7SUFDL0I7SUFDQSxvREFBb0Q7SUFDcEQsSUFBSUUsWUFBWSxFQUFFO0lBQ2xCLElBQUlDLG9CQUFvQixFQUFFO0lBQzFCLElBQUssSUFBSTdJLElBQUksR0FBR0EsSUFBSUgsS0FBS2lKLE1BQU0sRUFBRTlJLEtBQUssRUFBRztRQUNyQyxJQUFJQyxNQUFNSixJQUFJLENBQUNHLEVBQUU7UUFDakIsSUFBSXNJLFNBQVNYLGVBQWUxSDtRQUM1QixJQUFJOEksY0FBY2YsVUFBVSxDQUFDTSxPQUFPO1FBQ3BDLElBQUlTLGVBQWUsTUFBTTtZQUNyQkgsVUFBVTVLLElBQUksQ0FBQztnQkFDWHVLLE9BQU92STtnQkFDUE4sTUFBTTtvQkFDRmtILE9BQU8zRyxJQUFJSSxRQUFRO29CQUNuQnlHLEtBQUs3RyxJQUFJbUIsT0FBTyxHQUFHO2dCQUN2QjtZQUNKO1FBQ0osT0FDSztZQUNEeUgsa0JBQWtCN0ssSUFBSSxDQUFDaUM7UUFDM0I7SUFDSjtJQUNBLElBQUkrSSxnQkFBZ0JiLFVBQVVjLE9BQU8sQ0FBQ0w7SUFDdEMsSUFBSU0sV0FBV2YsVUFBVWdCLE9BQU87SUFDaEMsSUFBSSxFQUFFQyxtQkFBbUIsRUFBRUMsa0JBQWtCLEVBQUVDLGVBQWUsRUFBRSxHQUFHQyxXQUFXTCxVQUFVckosTUFBTXFJO0lBQzlGLElBQUlzQixXQUFXLEVBQUU7SUFDakIsSUFBSUMsaUJBQWlCLEVBQUU7SUFDdkIsZ0NBQWdDO0lBQ2hDLEtBQUssSUFBSXhKLE9BQU80SSxrQkFBbUI7UUFDL0JRLGtCQUFrQixDQUFDcEosSUFBSUksUUFBUSxDQUFDLENBQUNyQyxJQUFJLENBQUM7WUFDbENpQztZQUNBdUUsV0FBVztZQUNYa0YsWUFBWTtZQUNaQyxhQUFhO1lBQ2JuRCxXQUFXO1FBQ2Y7UUFDQSxJQUFLLElBQUlvRCxNQUFNM0osSUFBSUksUUFBUSxFQUFFdUosT0FBTzNKLElBQUltQixPQUFPLEVBQUV3SSxPQUFPLEVBQUc7WUFDdkRSLG1CQUFtQixDQUFDUSxJQUFJLENBQUM1TCxJQUFJLENBQUM7Z0JBQzFCaUMsS0FBSzRKLFdBQVc1SixLQUFLMkosS0FBS0EsTUFBTSxHQUFHMUI7Z0JBQ25DMUQsV0FBVztnQkFDWGtGLFlBQVk7Z0JBQ1pDLGFBQWE7Z0JBQ2JuRCxXQUFXO1lBQ2Y7UUFDSjtJQUNKO0lBQ0EseUJBQXlCO0lBQ3pCLElBQUssSUFBSW9ELE1BQU0sR0FBR0EsTUFBTTFCLE1BQU1ZLE1BQU0sRUFBRWMsT0FBTyxFQUFHO1FBQzVDSixTQUFTeEwsSUFBSSxDQUFDO0lBQ2xCO0lBQ0EsS0FBSyxJQUFJOEwsZUFBZWQsY0FBZTtRQUNuQyxJQUFJL0ksTUFBTUosSUFBSSxDQUFDaUssWUFBWXZCLEtBQUssQ0FBQztRQUNqQyxJQUFJd0IsYUFBYUQsWUFBWXBLLElBQUk7UUFDakMySixrQkFBa0IsQ0FBQ1UsV0FBV25ELEtBQUssQ0FBQyxDQUFDNUksSUFBSSxDQUFDO1lBQ3RDaUMsS0FBSzRKLFdBQVc1SixLQUFLOEosV0FBV25ELEtBQUssRUFBRW1ELFdBQVdqRCxHQUFHLEVBQUVvQjtZQUN2RDFELFdBQVc7WUFDWGtGLFlBQVk7WUFDWkMsYUFBYTtZQUNibkQsV0FBVztRQUNmO1FBQ0EsSUFBSyxJQUFJb0QsTUFBTUcsV0FBV25ELEtBQUssRUFBRWdELE1BQU1HLFdBQVdqRCxHQUFHLEVBQUU4QyxPQUFPLEVBQUc7WUFDN0RKLFFBQVEsQ0FBQ0ksSUFBSSxJQUFJO1lBQ2pCUixtQkFBbUIsQ0FBQ1EsSUFBSSxDQUFDNUwsSUFBSSxDQUFDO2dCQUMxQmlDLEtBQUs0SixXQUFXNUosS0FBSzJKLEtBQUtBLE1BQU0sR0FBRzFCO2dCQUNuQzFELFdBQVc7Z0JBQ1hrRixZQUFZO2dCQUNaQyxhQUFhO2dCQUNibkQsV0FBVztZQUNmO1FBQ0o7SUFDSjtJQUNBLDZCQUE2QjtJQUM3QixJQUFLLElBQUlvRCxNQUFNLEdBQUdBLE1BQU0xQixNQUFNWSxNQUFNLEVBQUVjLE9BQU8sRUFBRztRQUM1Q0gsZUFBZXpMLElBQUksQ0FBQ3NMLGVBQWUsQ0FBQ00sSUFBSTtJQUM1QztJQUNBLE9BQU87UUFBRVI7UUFBcUJDO1FBQW9CRztRQUFVQztJQUFlO0FBQy9FO0FBQ0Esd0NBQXdDO0FBQ3hDLFNBQVNGLFdBQVdTLFFBQVEsRUFBRW5LLElBQUksRUFBRXFJLEtBQUs7SUFDckMsSUFBSStCLGlCQUFpQkMsb0JBQW9CRixVQUFVOUIsTUFBTVksTUFBTTtJQUMvRCxJQUFJTSxzQkFBc0IsRUFBRTtJQUM1QixJQUFJQyxxQkFBcUIsRUFBRTtJQUMzQixJQUFJQyxrQkFBa0IsRUFBRTtJQUN4QixJQUFLLElBQUlNLE1BQU0sR0FBR0EsTUFBTTFCLE1BQU1ZLE1BQU0sRUFBRWMsT0FBTyxFQUFHO1FBQzVDLElBQUlPLFFBQVFGLGNBQWMsQ0FBQ0wsSUFBSTtRQUMvQiw4Q0FBOEM7UUFDOUMsSUFBSXpHLG1CQUFtQixFQUFFO1FBQ3pCLElBQUlpSCxnQkFBZ0I7UUFDcEIsSUFBSUMsbUJBQW1CO1FBQ3ZCLEtBQUssSUFBSUMsUUFBUUgsTUFBTztZQUNwQixJQUFJbEssTUFBTUosSUFBSSxDQUFDeUssS0FBSy9CLEtBQUssQ0FBQztZQUMxQnBGLGlCQUFpQm5GLElBQUksQ0FBQztnQkFDbEJpQyxLQUFLNEosV0FBVzVKLEtBQUsySixLQUFLQSxNQUFNLEdBQUcxQjtnQkFDbkMxRCxXQUFXO2dCQUNYa0YsWUFBWTtnQkFDWkMsYUFBYVcsS0FBS0MsVUFBVTtnQkFDNUIvRCxXQUFXOEQsS0FBS0MsVUFBVSxHQUFHSDtZQUNqQztZQUNBQSxnQkFBZ0JFLEtBQUtDLFVBQVUsR0FBR0QsS0FBS0UsU0FBUztRQUNwRDtRQUNBLHdEQUF3RDtRQUN4RCxJQUFJQyxrQkFBa0IsRUFBRTtRQUN4QkwsZ0JBQWdCO1FBQ2hCQyxtQkFBbUI7UUFDbkIsS0FBSyxJQUFJQyxRQUFRSCxNQUFPO1lBQ3BCLElBQUlsSyxNQUFNSixJQUFJLENBQUN5SyxLQUFLL0IsS0FBSyxDQUFDO1lBQzFCLElBQUltQixhQUFhWSxLQUFLNUssSUFBSSxDQUFDb0gsR0FBRyxHQUFHd0QsS0FBSzVLLElBQUksQ0FBQ2tILEtBQUssR0FBRyxHQUFHLGdCQUFnQjtZQUN0RSxJQUFJOEQsYUFBYUosS0FBSzVLLElBQUksQ0FBQ2tILEtBQUssS0FBS2dEO1lBQ3JDUyxvQkFBb0JDLEtBQUtDLFVBQVUsR0FBR0gsZUFBZSwrQ0FBK0M7WUFDcEdBLGdCQUFnQkUsS0FBS0MsVUFBVSxHQUFHRCxLQUFLRSxTQUFTLEVBQUUsMkNBQTJDO1lBQzdGLElBQUlkLFlBQVk7Z0JBQ1pXLG9CQUFvQkMsS0FBS0UsU0FBUztnQkFDbEMsSUFBSUUsWUFBWTtvQkFDWkQsZ0JBQWdCek0sSUFBSSxDQUFDO3dCQUNqQmlDLEtBQUs0SixXQUFXNUosS0FBS3FLLEtBQUs1SyxJQUFJLENBQUNrSCxLQUFLLEVBQUUwRCxLQUFLNUssSUFBSSxDQUFDb0gsR0FBRyxFQUFFb0I7d0JBQ3JEMUQsV0FBVzt3QkFDWGtGLFlBQVk7d0JBQ1pDLGFBQWFXLEtBQUtDLFVBQVU7d0JBQzVCL0QsV0FBVztvQkFDZjtnQkFDSjtZQUNKLE9BQ0ssSUFBSWtFLFlBQVk7Z0JBQ2pCRCxnQkFBZ0J6TSxJQUFJLENBQUM7b0JBQ2pCaUMsS0FBSzRKLFdBQVc1SixLQUFLcUssS0FBSzVLLElBQUksQ0FBQ2tILEtBQUssRUFBRTBELEtBQUs1SyxJQUFJLENBQUNvSCxHQUFHLEVBQUVvQjtvQkFDckQxRCxXQUFXO29CQUNYa0YsWUFBWTtvQkFDWkMsYUFBYVcsS0FBS0MsVUFBVTtvQkFDNUIvRCxXQUFXNkQ7Z0JBQ2Y7Z0JBQ0FBLG1CQUFtQjtZQUN2QjtRQUNKO1FBQ0FqQixvQkFBb0JwTCxJQUFJLENBQUNtRjtRQUN6QmtHLG1CQUFtQnJMLElBQUksQ0FBQ3lNO1FBQ3hCbkIsZ0JBQWdCdEwsSUFBSSxDQUFDcU07SUFDekI7SUFDQSxPQUFPO1FBQUVqQjtRQUFxQkM7UUFBb0JDO0lBQWdCO0FBQ3RFO0FBQ0EsU0FBU1ksb0JBQW9CQyxLQUFLLEVBQUVsTCxNQUFNO0lBQ3RDLElBQUlnTCxpQkFBaUIsRUFBRTtJQUN2QixJQUFLLElBQUlMLE1BQU0sR0FBR0EsTUFBTTNLLFFBQVEySyxPQUFPLEVBQUc7UUFDdENLLGVBQWVqTSxJQUFJLENBQUMsRUFBRTtJQUMxQjtJQUNBLEtBQUssSUFBSXNNLFFBQVFILE1BQU87UUFDcEIsSUFBSyxJQUFJUCxNQUFNVSxLQUFLNUssSUFBSSxDQUFDa0gsS0FBSyxFQUFFZ0QsTUFBTVUsS0FBSzVLLElBQUksQ0FBQ29ILEdBQUcsRUFBRThDLE9BQU8sRUFBRztZQUMzREssY0FBYyxDQUFDTCxJQUFJLENBQUM1TCxJQUFJLENBQUNzTTtRQUM3QjtJQUNKO0lBQ0EsT0FBT0w7QUFDWDtBQUNBLFNBQVNKLFdBQVc1SixHQUFHLEVBQUUwSyxTQUFTLEVBQUVDLE9BQU8sRUFBRTFDLEtBQUs7SUFDOUMsSUFBSWpJLElBQUlJLFFBQVEsS0FBS3NLLGFBQWExSyxJQUFJbUIsT0FBTyxLQUFLd0osVUFBVSxHQUFHO1FBQzNELE9BQU8zSztJQUNYO0lBQ0EsSUFBSWdCLGFBQWFoQixJQUFJZ0IsVUFBVTtJQUMvQixJQUFJNEosWUFBWTVKLFdBQVc2SixLQUFLO0lBQ2hDLElBQUlDLGNBQWNyUCxpRUFBZUEsQ0FBQ21QLFdBQVc7UUFDekNqRSxPQUFPc0IsS0FBSyxDQUFDeUMsVUFBVSxDQUFDekYsSUFBSTtRQUM1QjRCLEtBQUtuTCxpRUFBT0EsQ0FBQ3VNLEtBQUssQ0FBQzBDLFVBQVUsRUFBRSxDQUFDMUYsSUFBSSxFQUFFO0lBQzFDO0lBQ0EsT0FBT3pELE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR3pCLE1BQU07UUFBRUksVUFBVXNLO1FBQVd2SixTQUFTd0osVUFBVTtRQUFHM0osWUFBWTtZQUM5RkMsS0FBS0QsV0FBV0MsR0FBRztZQUNuQlgsSUFBSWtCLE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR1QsV0FBV1YsRUFBRSxHQUFHO2dCQUFFeUssa0JBQWtCO1lBQU07WUFDOUU5RyxVQUFVakQsV0FBV2lELFFBQVE7WUFDN0I0RyxPQUFPQztRQUNYO1FBQUcxSixTQUFTcEIsSUFBSW9CLE9BQU8sSUFBSTBKLFlBQVluRSxLQUFLLENBQUNZLE9BQU8sT0FBT3FELFVBQVVqRSxLQUFLLENBQUNZLE9BQU87UUFBSWxHLE9BQU9yQixJQUFJcUIsS0FBSyxJQUFJeUosWUFBWWpFLEdBQUcsQ0FBQ1UsT0FBTyxPQUFPcUQsVUFBVS9ELEdBQUcsQ0FBQ1UsT0FBTztJQUFHO0FBQ3hLO0FBQ0EsTUFBTVksNEJBQTRCeE0sOERBQVlBO0lBQzFDeUIsYUFBYztRQUNWLEtBQUssSUFBSUM7UUFDVCxTQUFTO1FBQ1QsSUFBSSxDQUFDb0wsY0FBYyxHQUFHO1FBQ3RCLDBFQUEwRTtRQUMxRSxJQUFJLENBQUN1QyxXQUFXLEdBQUcsQ0FBQztJQUN4QjtJQUNBaEMsUUFBUUwsU0FBUyxFQUFFO1FBQ2YsTUFBTXBGLGFBQWEsS0FBSyxDQUFDeUYsUUFBUUw7UUFDakMsTUFBTSxFQUFFc0MsY0FBYyxFQUFFLEdBQUcsSUFBSTtRQUMvQixNQUFNQyxnQkFBZ0IsQ0FBQ0MsUUFBVSxDQUFDLElBQUksQ0FBQ0gsV0FBVyxDQUFDcFAsa0VBQWFBLENBQUN1UCxPQUFPO1FBQ3hFLGdDQUFnQztRQUNoQyxJQUFLLElBQUlDLFFBQVEsR0FBR0EsUUFBUUgsZUFBZXBDLE1BQU0sRUFBRXVDLFNBQVMsRUFBRztZQUMzREgsY0FBYyxDQUFDRyxNQUFNLEdBQUdILGNBQWMsQ0FBQ0csTUFBTSxDQUFDQyxNQUFNLENBQUNIO1FBQ3pEO1FBQ0EsT0FBTzNIO0lBQ1g7SUFDQStILHVCQUF1QkMsU0FBUyxFQUFFSixLQUFLLEVBQUVwQyxhQUFhLEVBQUU7UUFDcEQsTUFBTSxFQUFFa0MsY0FBYyxFQUFFRCxXQUFXLEVBQUUsR0FBRyxJQUFJO1FBQzVDLE1BQU0sRUFBRVEsYUFBYSxFQUFFQyxhQUFhLEVBQUVDLGVBQWUsRUFBRSxHQUFHSDtRQUMxRCw4REFBOEQ7UUFDOUQsSUFBSSxJQUFJLENBQUM5QyxjQUFjLElBQUkrQyxlQUFlO1lBQ3RDLE1BQU1HLGtCQUFrQi9QLGtFQUFhQSxDQUFDNFA7WUFDdEMsSUFBSSxDQUFDUixXQUFXLENBQUNXLGdCQUFnQixFQUFFO2dCQUMvQixJQUFJLElBQUksQ0FBQ3BELGNBQWMsRUFBRTtvQkFDckIsMENBQTBDO29CQUMxQyxNQUFNc0IsY0FBY3JJLE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBRytKLGdCQUFnQjt3QkFBRS9MLE1BQU01RCxrRUFBY0EsQ0FBQzJQLGNBQWMvTCxJQUFJLEVBQUUwTCxNQUFNMUwsSUFBSTtvQkFBRTtvQkFDM0gsK0VBQStFO29CQUMvRSw4Q0FBOEM7b0JBQzlDLE1BQU1tTSxnQkFBZ0JoUSxrRUFBYUEsQ0FBQ2lPO29CQUNwQ21CLFdBQVcsQ0FBQ1ksY0FBYyxHQUFHO29CQUM3QlgsY0FBYyxDQUFDUSxjQUFjLENBQUNDLGdCQUFnQixHQUFHN0I7b0JBQ2pEZCxjQUFjaEwsSUFBSSxDQUFDOEw7b0JBQ25CLElBQUksQ0FBQ2dDLFVBQVUsQ0FBQ0wsZUFBZUwsT0FBT3BDO2dCQUMxQyxPQUNLO29CQUNEaUMsV0FBVyxDQUFDVyxnQkFBZ0IsR0FBRztvQkFDL0I1QyxjQUFjaEwsSUFBSSxDQUFDeU47Z0JBQ3ZCO1lBQ0o7UUFDSjtRQUNBLHlCQUF5QjtRQUN6QixLQUFLLENBQUNGLHVCQUF1QkMsV0FBV0osT0FBT3BDO0lBQ25EO0FBQ0o7QUFFQSxNQUFNK0MsaUJBQWlCM1IsOERBQWFBO0lBQ2hDaUQsYUFBYztRQUNWLEtBQUssSUFBSUM7UUFDVCxJQUFJLENBQUMwTyxVQUFVLEdBQUcsSUFBSWpRLDhEQUFNQSxJQUFJLFdBQVc7UUFDM0MsSUFBSSxDQUFDa1EsV0FBVyxHQUFHLElBQUlsUSw4REFBTUEsSUFBSSwyQkFBMkI7UUFDNUQsSUFBSSxDQUFDbVEsUUFBUSxHQUFHLElBQUluUSw4REFBTUEsSUFBSSw0QkFBNEI7UUFDMUQsSUFBSSxDQUFDb1EsY0FBYyxHQUFHLElBQUlwUSw4REFBTUEsSUFBSSxtQ0FBbUM7UUFDdkUsSUFBSSxDQUFDNkksU0FBUyxHQUFHM0gsdUVBQVNBO1FBQzFCLElBQUksQ0FBQzRILEtBQUssR0FBRztZQUNUdUgsZ0JBQWdCO1lBQ2hCbkUsa0JBQWtCO1lBQ2xCRCxZQUFZLENBQUM7UUFDakI7UUFDQSxJQUFJLENBQUNxRSxZQUFZLEdBQUcsQ0FBQ0M7WUFDakIsSUFBSUEsVUFBVTtnQkFDVixJQUFJLENBQUNDLFlBQVksQ0FBQyxPQUFPLGtCQUFrQjtZQUMvQztRQUNKO0lBQ0o7SUFDQS9LLFNBQVM7UUFDTCxJQUFJLEVBQUU3RCxLQUFLLEVBQUVrSCxLQUFLLEVBQUVqSCxPQUFPLEVBQUUsR0FBRyxJQUFJO1FBQ3BDLElBQUksRUFBRUcsT0FBTyxFQUFFLEdBQUdIO1FBQ2xCLElBQUlxQixTQUFTdEIsTUFBTXVLLEtBQUssQ0FBQ1ksTUFBTTtRQUMvQixJQUFJMEQscUJBQXFCck0sb0JBQW9CeEMsTUFBTThPLGdCQUFnQixFQUFFeE47UUFDckUsSUFBSXlOLG1CQUFtQnZNLG9CQUFvQnhDLE1BQU1nUCxXQUFXLEVBQUUxTjtRQUM5RCxJQUFJMk4scUJBQXFCek0sb0JBQW9CLElBQUksQ0FBQzBNLGdCQUFnQixJQUFJNU47UUFDdEUsSUFBSTZOLGtCQUFrQjNNLG9CQUFvQixJQUFJLENBQUM0TSxhQUFhLElBQUk5TjtRQUNoRSxJQUFJLEVBQUVtSyxtQkFBbUIsRUFBRUMsa0JBQWtCLEVBQUVHLFFBQVEsRUFBRUMsY0FBYyxFQUFFLEdBQUc3QixzQkFBc0I1TCxrRUFBYUEsQ0FBQzJCLE1BQU1xUCxXQUFXLEVBQUVqUCxRQUFRa1AsVUFBVSxHQUFHdFAsTUFBTWtLLFlBQVksRUFBRWxLLE1BQU1tSyxlQUFlLEVBQUUvSixRQUFRbVAsZ0JBQWdCLEVBQUVySSxNQUFNbUQsVUFBVSxFQUFFbkQsTUFBTW9ELGdCQUFnQixFQUFFdEssTUFBTXVLLEtBQUs7UUFDbFIsSUFBSXJFLG9CQUNILE1BQU9DLFNBQVMsSUFBSW5HLE1BQU1tRyxTQUFTLENBQUN0RCxpQkFBaUIsSUFDakQ3QyxNQUFNb0csV0FBVyxJQUFJcEcsTUFBTW9HLFdBQVcsQ0FBQ3ZELGlCQUFpQixJQUN6RCxDQUFDO1FBQ0wsT0FBUXRELDJFQUFhQSxDQUFDLE1BQU07WUFBRTJJLEtBQUssSUFBSSxDQUFDakIsU0FBUztZQUFFYSxNQUFNO1FBQU0sR0FDM0Q5SCxNQUFNd1AsV0FBVyxJQUFJeFAsTUFBTXdQLFdBQVcsSUFDdEN4UCxNQUFNdUssS0FBSyxDQUFDbEUsR0FBRyxDQUFDLENBQUNvSixNQUFNeEQ7WUFDbkIsSUFBSXlELGdCQUFnQixJQUFJLENBQUNDLFlBQVksQ0FBQzFELEtBQUtqTSxNQUFNa0IsUUFBUSxHQUFHdUssbUJBQW1CLENBQUNRLElBQUksR0FBR1Asa0JBQWtCLENBQUNPLElBQUksRUFBRWpNLE1BQU0wRixVQUFVLEVBQUVRO1lBQ2xJLElBQUkwSixnQkFBZ0IsSUFBSSxDQUFDRCxZQUFZLENBQUMxRCxLQUFLNEQsc0JBQXNCVixlQUFlLENBQUNsRCxJQUFJLEVBQUVQLHFCQUFxQjFMLE1BQU0wRixVQUFVLEVBQUUsQ0FBQyxHQUFHa0UsUUFBUTVKLE1BQU1tRyxTQUFTLEdBQUd5RCxRQUFRNUosTUFBTW9HLFdBQVcsR0FBRztZQUN4TCxPQUFRN0csMkVBQWFBLENBQUN5SCxXQUFXO2dCQUFFekcsS0FBS2tQLEtBQUtsUCxHQUFHO2dCQUFFRyxPQUFPLElBQUksQ0FBQzJOLFVBQVUsQ0FBQy9PLFNBQVMsQ0FBQ21RLEtBQUtsUCxHQUFHO2dCQUFHNEgsWUFBWSxJQUFJLENBQUNtRyxXQUFXLENBQUNoUCxTQUFTLENBQUNtUSxLQUFLbFAsR0FBRztnQkFBNEVrRixhQUFhekYsTUFBTXlGLFdBQVc7Z0JBQUU4QixNQUFNa0ksS0FBS2xJLElBQUk7Z0JBQUVFLGVBQWV6SCxNQUFNOFAsY0FBYztnQkFBRXpILGdCQUFnQnJJLE1BQU0rUCxlQUFlLElBQUk5RCxRQUFRO2dCQUFHekQsYUFBYXhJLE1BQU0rUCxlQUFlLENBQUMsd0RBQXdEO2dCQUFJckssWUFBWTFGLE1BQU0wRixVQUFVO2dCQUFFaUIsZ0JBQWdCM0csTUFBTTJHLGNBQWM7Z0JBQUVSLFdBQVduRyxNQUFNbUcsU0FBUztnQkFBRUMsYUFBYXBHLE1BQU1vRyxXQUFXO2dCQUFFNEIsa0JBQWtCeUgsS0FBS3pILGdCQUFnQjtnQkFBRUgsZ0JBQWdCNEgsS0FBSzVILGNBQWM7Z0JBQUVELGlCQUFpQjZILEtBQUs3SCxlQUFlO2dCQUFFNUIsZUFBZXlKLEtBQUt6SixhQUFhO2dCQUFFSixTQUFTaUcsUUFBUSxDQUFDSSxJQUFJO2dCQUFFbkQsZUFBZWdELGNBQWMsQ0FBQ0csSUFBSTtnQkFBRXpHLGtCQUFrQmlHLG1CQUFtQixDQUFDUSxJQUFJO2dCQUFFdEQsZ0JBQWdCLElBQUksQ0FBQzRGLFFBQVEsQ0FBQ2pQLFNBQVMsQ0FBQ21RLEtBQUtsUCxHQUFHO2dCQUFHcUksV0FDajNCckosMkVBQWFBLENBQUNDLGtFQUFRQSxFQUFFLE1BQ3BCRCwyRUFBYUEsQ0FBQ0Msa0VBQVFBLEVBQUUsTUFBTWtRLGdCQUM5Qm5RLDJFQUFhQSxDQUFDQyxrRUFBUUEsRUFBRSxNQUFNb1E7Z0JBQWtCN0csV0FDcER4SiwyRUFBYUEsQ0FBQ0Msa0VBQVFBLEVBQUUsTUFDcEIsSUFBSSxDQUFDd1EsY0FBYyxDQUFDZixrQkFBa0IsQ0FBQ2hELElBQUksRUFBRSxjQUM3QyxJQUFJLENBQUMrRCxjQUFjLENBQUNuQixrQkFBa0IsQ0FBQzVDLElBQUksRUFBRSxpQkFDN0MsSUFBSSxDQUFDK0QsY0FBYyxDQUFDakIsZ0JBQWdCLENBQUM5QyxJQUFJLEVBQUU7Z0JBQWU3RCxXQUFXcEksTUFBTWlRLGFBQWE7WUFBQztRQUNyRztJQUNSO0lBQ0FDLG9CQUFvQjtRQUNoQixJQUFJLENBQUN0QixZQUFZLENBQUM7UUFDbEIsSUFBSSxDQUFDM08sT0FBTyxDQUFDa1EsZ0JBQWdCLENBQUMsSUFBSSxDQUFDekIsWUFBWTtJQUNuRDtJQUNBMEIsbUJBQW1CQyxTQUFTLEVBQUVDLFNBQVMsRUFBRTtRQUNyQyxJQUFJQyxlQUFlLElBQUksQ0FBQ3ZRLEtBQUs7UUFDN0IsSUFBSSxDQUFDNE8sWUFBWSxDQUFDLENBQUN0USxpRUFBWUEsQ0FBQytSLFdBQVdFO0lBQy9DO0lBQ0FDLHVCQUF1QjtRQUNuQixJQUFJLENBQUN2USxPQUFPLENBQUN3USxtQkFBbUIsQ0FBQyxJQUFJLENBQUMvQixZQUFZO0lBQ3REO0lBQ0FRLG1CQUFtQjtRQUNmLElBQUksRUFBRWxQLEtBQUssRUFBRSxHQUFHLElBQUk7UUFDcEIsSUFBSUEsTUFBTW1HLFNBQVMsSUFBSW5HLE1BQU1tRyxTQUFTLENBQUNqRSxJQUFJLENBQUNpSixNQUFNLEVBQUU7WUFDaEQsT0FBT25MLE1BQU1tRyxTQUFTLENBQUNqRSxJQUFJO1FBQy9CO1FBQ0EsSUFBSWxDLE1BQU1vRyxXQUFXLElBQUlwRyxNQUFNb0csV0FBVyxDQUFDbEUsSUFBSSxDQUFDaUosTUFBTSxFQUFFO1lBQ3BELE9BQU9uTCxNQUFNb0csV0FBVyxDQUFDbEUsSUFBSTtRQUNqQztRQUNBLE9BQU9sQyxNQUFNMFEsaUJBQWlCO0lBQ2xDO0lBQ0F0QixnQkFBZ0I7UUFDWixJQUFJLEVBQUVwUCxLQUFLLEVBQUUsR0FBRyxJQUFJO1FBQ3BCLElBQUlBLE1BQU1vRyxXQUFXLElBQUlwRyxNQUFNb0csV0FBVyxDQUFDbEUsSUFBSSxDQUFDaUosTUFBTSxFQUFFO1lBQ3BELE9BQU9uTCxNQUFNb0csV0FBVyxDQUFDbEUsSUFBSTtRQUNqQztRQUNBLE9BQU8sRUFBRTtJQUNiO0lBQ0F5TixhQUFhMUQsR0FBRyxFQUFFMEUsYUFBYSxFQUFFakwsVUFBVSxFQUFFUSxpQkFBaUIsRUFBRU8sVUFBVSxFQUFFOUIsVUFBVSxFQUFFQyxlQUFlLEVBQUU7UUFDckcsSUFBSSxFQUFFM0UsT0FBTyxFQUFFLEdBQUcsSUFBSTtRQUN0QixJQUFJLEVBQUUwRyxjQUFjLEVBQUUsR0FBRyxJQUFJLENBQUMzRyxLQUFLO1FBQ25DLElBQUksRUFBRXlPLGNBQWMsRUFBRSxHQUFHLElBQUksQ0FBQ3ZILEtBQUs7UUFDbkMsSUFBSWpELHlCQUF5QixJQUFJLENBQUNqRSxLQUFLLENBQUN1SyxLQUFLLENBQUNZLE1BQU0sS0FBSyxHQUFHLGVBQWU7UUFDM0UsSUFBSXlGLFdBQVduSyxjQUFjOUIsY0FBY0M7UUFDM0MsSUFBSWlNLFFBQVEsRUFBRTtRQUNkLElBQUlwQyxnQkFBZ0I7WUFDaEIsS0FBSyxJQUFJN0gsYUFBYStKLGNBQWU7Z0JBQ2pDLElBQUksRUFBRXJPLEdBQUcsRUFBRSxHQUFHc0U7Z0JBQ2QsSUFBSSxFQUFFTixVQUFVLEVBQUUsR0FBR2hFLElBQUlnQixVQUFVLENBQUNpRCxRQUFRO2dCQUM1QyxJQUFJTSxZQUFZRCxVQUFVQyxTQUFTLElBQUksQ0FBQ1gsaUJBQWlCLENBQUNJLFdBQVc7Z0JBQ3JFLElBQUl5RixhQUFhbkYsVUFBVW1GLFVBQVU7Z0JBQ3JDLElBQUkrRSxPQUFPO2dCQUNYLElBQUlDLFFBQVE7Z0JBQ1osSUFBSWhGLFlBQVk7b0JBQ1osSUFBSTlMLFFBQVErUSxLQUFLLEVBQUU7d0JBQ2ZELFFBQVE7d0JBQ1JELE9BQU9yQyxlQUFld0MsS0FBSyxDQUFDM08sSUFBSW1CLE9BQU8sQ0FBQyxHQUFHZ0wsZUFBZXdDLEtBQUssQ0FBQzNPLElBQUlJLFFBQVEsQ0FBQztvQkFDakYsT0FDSzt3QkFDRG9PLE9BQU87d0JBQ1BDLFFBQVF0QyxlQUFleUMsTUFBTSxDQUFDNU8sSUFBSUksUUFBUSxDQUFDLEdBQUcrTCxlQUFleUMsTUFBTSxDQUFDNU8sSUFBSW1CLE9BQU8sQ0FBQztvQkFDcEY7Z0JBQ0o7Z0JBQ0E7OztnQkFHQSxHQUNBb04sTUFBTXhRLElBQUksQ0FBQ2QsMkVBQWFBLENBQUMsT0FBTztvQkFBRXVGLFdBQVcsNkJBQThCaUgsQ0FBQUEsYUFBYSxrQ0FBa0MsRUFBQztvQkFBSXhMLEtBQUt3SixlQUFlekg7b0JBQU00RixLQUFLMEksV0FBVyxPQUFPLElBQUksQ0FBQ3BDLGNBQWMsQ0FBQ2xQLFNBQVMsQ0FBQzBLLGVBQWUxSDtvQkFBT3lDLE9BQU87d0JBQ25PeUIsWUFBWUssWUFBWSxLQUFLO3dCQUM3QmdDLFdBQVdrRCxhQUFhLEtBQUtuRixVQUFVaUMsU0FBUzt3QkFDaERzSSxLQUFLcEYsYUFBYW5GLFVBQVVvRixXQUFXLEdBQUc7d0JBQzFDOEU7d0JBQ0FDO29CQUNKO2dCQUFFLEdBQUczTixtQkFBbUJkLE9BQVEvQywyRUFBYUEsQ0FBQzRFLG9CQUFvQkwsT0FBT0MsTUFBTSxDQUFDO29CQUFFekIsS0FBS0E7b0JBQUttRSxZQUFZQTtvQkFBWUMsWUFBWUosZUFBZUs7b0JBQWdCMUMsd0JBQXdCQTtnQkFBdUIsR0FBRzFHLGtFQUFVQSxDQUFDK0UsS0FBS29ELGdCQUFrQm5HLDJFQUFhQSxDQUFDcUUsaUJBQWlCRSxPQUFPQyxNQUFNLENBQUM7b0JBQUV6QixLQUFLQTtvQkFBS21FLFlBQVlBO29CQUFZOUIsWUFBWUE7b0JBQVlDLGlCQUFpQkE7b0JBQWlCOEIsWUFBWUosZUFBZUs7b0JBQWdCMUMsd0JBQXdCQTtnQkFBdUIsR0FBRzFHLGtFQUFVQSxDQUFDK0UsS0FBS29EO1lBQ25mO1FBQ0o7UUFDQSxPQUFPbUw7SUFDWDtJQUNBYixlQUFlOU4sSUFBSSxFQUFFa1AsUUFBUSxFQUFFO1FBQzNCLElBQUksRUFBRUosS0FBSyxFQUFFLEdBQUcsSUFBSSxDQUFDL1EsT0FBTztRQUM1QixJQUFJLEVBQUV5RixVQUFVLEVBQUUsR0FBRyxJQUFJLENBQUMxRixLQUFLO1FBQy9CLElBQUksRUFBRXlPLGNBQWMsRUFBRSxHQUFHLElBQUksQ0FBQ3ZILEtBQUs7UUFDbkMsSUFBSTJKLFFBQVEsRUFBRTtRQUNkLElBQUlwQyxnQkFBZ0I7WUFDaEIsS0FBSyxJQUFJbk0sT0FBT0osS0FBTTtnQkFDbEIsSUFBSW1QLGVBQWVMLFFBQVE7b0JBQ3ZCRCxPQUFPO29CQUNQRCxNQUFNckMsZUFBZXdDLEtBQUssQ0FBQzNPLElBQUltQixPQUFPLENBQUMsR0FBR2dMLGVBQWV3QyxLQUFLLENBQUMzTyxJQUFJSSxRQUFRLENBQUM7Z0JBQ2hGLElBQUk7b0JBQ0FvTyxNQUFNO29CQUNOQyxPQUFPdEMsZUFBZXlDLE1BQU0sQ0FBQzVPLElBQUlJLFFBQVEsQ0FBQyxHQUFHK0wsZUFBZXlDLE1BQU0sQ0FBQzVPLElBQUltQixPQUFPLENBQUM7Z0JBQ25GO2dCQUNBb04sTUFBTXhRLElBQUksQ0FBQ2QsMkVBQWFBLENBQUMsT0FBTztvQkFBRWdCLEtBQUtoQyxrRUFBa0JBLENBQUMrRCxJQUFJZ0IsVUFBVTtvQkFBR3dCLFdBQVc7b0JBQXlCQyxPQUFPc007Z0JBQWEsR0FBR0QsYUFBYSxhQUMvSTdSLDJFQUFhQSxDQUFDZiw4REFBT0EsRUFBRXNGLE9BQU9DLE1BQU0sQ0FBQztvQkFBRXpCLEtBQUtBO2dCQUFJLEdBQUcvRSxrRUFBVUEsQ0FBQytFLEtBQUtvRCxnQkFDbkVqSCxrRUFBVUEsQ0FBQzJTO1lBQ25CO1FBQ0o7UUFDQSxPQUFPN1IsMkVBQWFBLENBQUNDLGtFQUFRQSxFQUFFLENBQUMsTUFBTXFSO0lBQzFDO0lBQ0FqQyxhQUFhMEMsc0JBQXNCLEVBQUU7UUFDakMsSUFBSSxFQUFFdFIsS0FBSyxFQUFFa0gsS0FBSyxFQUFFb0gsV0FBVyxFQUFFLEdBQUcsSUFBSTtRQUN4QyxJQUFJLENBQUN0TyxNQUFNa0IsUUFBUSxJQUNmbEIsTUFBTXVSLFdBQVcsS0FBSyxLQUFLLHFCQUFxQjtVQUNsRDtZQUNFLElBQUlELHdCQUF3QjtnQkFDeEIsSUFBSUUsV0FBV3hSLE1BQU11SyxLQUFLLENBQUNsRSxHQUFHLENBQUMsQ0FBQ29KLE9BQVNuQixZQUFZbUQsVUFBVSxDQUFDaEMsS0FBS2xQLEdBQUcsQ0FBQztnQkFDekUsSUFBSWlSLFNBQVNyRyxNQUFNLEVBQUU7b0JBQ2pCLElBQUl1RyxXQUFXLElBQUksQ0FBQ3pLLFNBQVMsQ0FBQzBLLE9BQU87b0JBQ3JDLElBQUlDLG1CQUFtQixJQUFJbFQsOERBQWFBLENBQUNnVCxVQUFVRixVQUFVLE1BQzdEO29CQUNBLElBQUksQ0FBQ3RLLE1BQU11SCxjQUFjLElBQUksQ0FBQ3ZILE1BQU11SCxjQUFjLENBQUNvRCxTQUFTLENBQUNELG1CQUFtQjt3QkFDNUUsSUFBSSxDQUFDRSxRQUFRLENBQUM7NEJBQ1ZyRCxnQkFBZ0IsSUFBSS9QLDhEQUFhQSxDQUFDZ1QsVUFBVUYsVUFBVSxNQUN0RDt3QkFDSjtvQkFDSjtnQkFDSjtZQUNKO1lBQ0EsTUFBTU8sZ0JBQWdCLElBQUksQ0FBQzdLLEtBQUssQ0FBQ21ELFVBQVU7WUFDM0MsTUFBTTJILGdCQUFnQixJQUFJLENBQUNDLGVBQWU7WUFDMUMsTUFBTUMsdUJBQXVCbFMsTUFBTWtLLFlBQVksS0FBSyxRQUFRbEssTUFBTW1LLGVBQWUsS0FBSztZQUN0RixJQUFJLENBQUNnSSxZQUFZLENBQUM7Z0JBQ2QsZ0ZBQWdGO2dCQUNoRixxRUFBcUU7Z0JBQ3JFLHlEQUF5RDtnQkFDekQ5SCxZQUFZdkcsT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHZ08sZ0JBQWdCQztnQkFDNUQxSCxrQkFBa0I0SCx1QkFBdUIsSUFBSSxDQUFDRSx1QkFBdUIsS0FBSztZQUM5RTtRQUNKO0lBQ0o7SUFDQUgsa0JBQWtCO1FBQ2QsSUFBSUksV0FBVyxJQUFJLENBQUM3RCxjQUFjLENBQUNpRCxVQUFVO1FBQzdDLElBQUlwSCxhQUFhLENBQUM7UUFDbEIsMkNBQTJDO1FBQzNDLElBQUssSUFBSU0sVUFBVTBILFNBQVU7WUFDekIsSUFBSUMsU0FBU0MsS0FBS0MsS0FBSyxDQUFDSCxRQUFRLENBQUMxSCxPQUFPLENBQUM4SCxxQkFBcUIsR0FBR0gsTUFBTTtZQUN2RWpJLFVBQVUsQ0FBQ00sT0FBTyxHQUFHNEgsS0FBS0csR0FBRyxDQUFDckksVUFBVSxDQUFDTSxPQUFPLElBQUksR0FBRzJIO1FBQzNEO1FBQ0EsT0FBT2pJO0lBQ1g7SUFDQStILDBCQUEwQjtRQUN0QixJQUFJTyxXQUFXLElBQUksQ0FBQzNTLEtBQUssQ0FBQ3VLLEtBQUssQ0FBQyxFQUFFLENBQUNoSyxHQUFHO1FBQ3RDLElBQUlxUyxTQUFTLElBQUksQ0FBQ3ZFLFVBQVUsQ0FBQ29ELFVBQVUsQ0FBQ2tCLFNBQVM7UUFDakQsSUFBSUUsZ0JBQWdCLElBQUksQ0FBQ3RFLFFBQVEsQ0FBQ2tELFVBQVUsQ0FBQ2tCLFNBQVM7UUFDdEQsT0FBT0MsT0FBT0gscUJBQXFCLEdBQUdLLE1BQU0sR0FBR0QsY0FBY0oscUJBQXFCLEdBQUd0QixHQUFHO0lBQzVGO0lBQ0E0QixhQUFhO1FBQ1QsSUFBSUMsUUFBUSxJQUFJLENBQUMzRSxVQUFVLENBQUNvRCxVQUFVO1FBQ3RDLE9BQU8sSUFBSSxDQUFDelIsS0FBSyxDQUFDdUssS0FBSyxDQUFDbEUsR0FBRyxDQUFDLENBQUNvSixPQUFTdUQsS0FBSyxDQUFDdkQsS0FBS2xQLEdBQUcsQ0FBQztJQUN6RDtBQUNKO0FBQ0E2TixTQUFTNkUsZ0JBQWdCLENBQUM7SUFDdEI1SSxZQUFZL0wsNkRBQVlBO0FBQzVCO0FBQ0EsU0FBU3VSLHNCQUFzQnFELFVBQVUsRUFBRUMsYUFBYTtJQUNwRCxJQUFJLENBQUNELFdBQVcvSCxNQUFNLEVBQUU7UUFDcEIsT0FBTyxFQUFFO0lBQ2I7SUFDQSxJQUFJaUksbUJBQW1CQyxxQkFBcUJGLGdCQUFnQixvQ0FBb0M7SUFDaEcsT0FBT0QsV0FBVzdNLEdBQUcsQ0FBQyxDQUFDL0QsTUFBUztZQUM1QkE7WUFDQXVFLFdBQVc7WUFDWGtGLFlBQVk7WUFDWkMsYUFBYW9ILGdCQUFnQixDQUFDOVEsSUFBSWdCLFVBQVUsQ0FBQ2lELFFBQVEsQ0FBQ0QsVUFBVSxDQUFDO1lBQ2pFdUMsV0FBVztRQUNmO0FBQ0o7QUFDQSxTQUFTd0sscUJBQXFCRixhQUFhO0lBQ3ZDLElBQUlDLG1CQUFtQixDQUFDO0lBQ3hCLEtBQUssSUFBSUUsY0FBY0gsY0FBZTtRQUNsQyxLQUFLLElBQUl2TSxhQUFhME0sV0FBWTtZQUM5QkYsZ0JBQWdCLENBQUN4TSxVQUFVdEUsR0FBRyxDQUFDZ0IsVUFBVSxDQUFDaUQsUUFBUSxDQUFDRCxVQUFVLENBQUMsR0FBR00sVUFBVW9GLFdBQVc7UUFDMUY7SUFDSjtJQUNBLE9BQU9vSDtBQUNYO0FBRUEsTUFBTUcsa0JBQWtCOVcsOERBQWFBO0lBQ2pDaUQsYUFBYztRQUNWLEtBQUssSUFBSUM7UUFDVCxJQUFJLENBQUM2VCxxQkFBcUIsR0FBR25XLGlFQUFPQSxDQUFDNEU7UUFDckMsSUFBSSxDQUFDd1IsZ0JBQWdCLEdBQUdwVyxpRUFBT0EsQ0FBQzRFO1FBQ2hDLElBQUksQ0FBQ3lSLGdCQUFnQixHQUFHclcsaUVBQU9BLENBQUM0RTtRQUNoQyxJQUFJLENBQUMwUixzQkFBc0IsR0FBR3RXLGlFQUFPQSxDQUFDNEU7UUFDdEMsSUFBSSxDQUFDMlIsY0FBYyxHQUFHdlcsaUVBQU9BLENBQUNzRjtRQUM5QixJQUFJLENBQUNrUixnQkFBZ0IsR0FBR3hXLGlFQUFPQSxDQUFDc0Y7UUFDaEMsSUFBSSxDQUFDbVIsT0FBTyxHQUFHLElBQUkxViw4REFBTUE7SUFDN0I7SUFDQXlGLFNBQVM7UUFDTCxJQUFJLEVBQUU3RCxLQUFLLEVBQUVDLE9BQU8sRUFBRSxHQUFHLElBQUk7UUFDN0IsSUFBSWtDLFNBQVNuQyxNQUFNdUssS0FBSyxDQUFDWSxNQUFNO1FBQy9CLElBQUk0SSx3QkFBd0IsSUFBSSxDQUFDUCxxQkFBcUIsQ0FBQ3hULE1BQU04TyxnQkFBZ0IsRUFBRTNNO1FBQy9FLElBQUk2UixtQkFBbUIsSUFBSSxDQUFDUCxnQkFBZ0IsQ0FBQ3pULE1BQU1nUCxXQUFXLEVBQUU3TTtRQUNoRSxJQUFJOFIsbUJBQW1CLElBQUksQ0FBQ1AsZ0JBQWdCLENBQUMxVCxNQUFNcVAsV0FBVyxFQUFFbE47UUFDaEUsSUFBSStSLHlCQUF5QixJQUFJLENBQUNQLHNCQUFzQixDQUFDM1QsTUFBTTBRLGlCQUFpQixFQUFFdk87UUFDbEYsSUFBSWdTLGlCQUFpQixJQUFJLENBQUNQLGNBQWMsQ0FBQzVULE1BQU1tRyxTQUFTLEVBQUVoRTtRQUMxRCxJQUFJaVMsbUJBQW1CLElBQUksQ0FBQ1AsZ0JBQWdCLENBQUM3VCxNQUFNb0csV0FBVyxFQUFFakU7UUFDaEUsMEZBQTBGO1FBQzFGLHFEQUFxRDtRQUNyRCxJQUFJOE4sZ0JBQWdCLFVBQVcsS0FBS2pRLE1BQU11UixXQUFXLEdBQ2pEdlIsTUFBTXVSLFdBQVcsR0FBR3RSLFFBQVFHLE9BQU8sQ0FBQ2lVLFdBQVcsR0FBRyxJQUNsRDtRQUNKLE9BQVE5VSwyRUFBYUEsQ0FBQ1osOERBQVFBLEVBQUU7WUFBRTJWLE1BQU07UUFBTSxHQUFHLENBQUNDLFNBQVM3TyxhQUFnQm5HLDJFQUFhQSxDQUFDQyxrRUFBUUEsRUFBRSxNQUFNUSxNQUFNdUssS0FBSyxDQUFDbEUsR0FBRyxDQUFDLENBQUNrRSxPQUFPaEksTUFBU2hELDJFQUFhQSxDQUFDNk8sVUFBVTtvQkFBRWxHLEtBQUssSUFBSSxDQUFDNEwsT0FBTyxDQUFDeFUsU0FBUyxDQUFDaUQ7b0JBQU1oQyxLQUFLZ0ssTUFBTVksTUFBTSxHQUM3TVosS0FBSyxDQUFDLEVBQUUsQ0FBQ2hELElBQUksQ0FBQ2lOLFdBQVcsS0FDekJqUyxJQUFJLGtFQUFrRTs7b0JBQzFFdU4sZ0JBQWdCM04sU0FBUztvQkFBRzROLGlCQUFpQi9QLE1BQU0rUCxlQUFlO29CQUFFckssWUFBWUE7b0JBQVlELGFBQWF6RixNQUFNeUYsV0FBVztvQkFBRThFLE9BQU9BO29CQUFPaUYsYUFBYXhQLE1BQU15VSxjQUFjO29CQUFFM0Ysa0JBQWtCaUYscUJBQXFCLENBQUN4UixJQUFJO29CQUFFb0UsZ0JBQWdCM0csTUFBTTJHLGNBQWM7b0JBQUVxSSxhQUFhZ0YsZ0JBQWdCLENBQUN6UixJQUFJLENBQUNvTCxNQUFNLENBQUMrRztvQkFBeUJyRixhQUFhNEUsZ0JBQWdCLENBQUMxUixJQUFJO29CQUFFbU8sbUJBQW1Cd0Qsc0JBQXNCLENBQUMzUixJQUFJO29CQUFFNEQsV0FBV2dPLGNBQWMsQ0FBQzVSLElBQUk7b0JBQUU2RCxhQUFhZ08sZ0JBQWdCLENBQUM3UixJQUFJO29CQUFFMkgsY0FBY2xLLE1BQU1rSyxZQUFZO29CQUFFQyxpQkFBaUJuSyxNQUFNbUssZUFBZTtvQkFBRW9ILGFBQWF2UixNQUFNdVIsV0FBVztvQkFBRW9ELGNBQWMzVSxNQUFNMlUsWUFBWTtvQkFBRTFFLGVBQWVBO29CQUFlL08sVUFBVWxCLE1BQU1rQixRQUFRO2dCQUFDO0lBQ3pxQjtJQUNBZ1Asb0JBQW9CO1FBQ2hCLElBQUksQ0FBQzBFLDRCQUE0QjtJQUNyQztJQUNBeEUscUJBQXFCO1FBQ2pCLGlDQUFpQztRQUNqQyxJQUFJLENBQUN3RSw0QkFBNEI7SUFDckM7SUFDQUEsK0JBQStCO1FBQzNCLElBQUksQ0FBQyxJQUFJLENBQUNDLE1BQU0sRUFBRTtZQUNkLHdEQUF3RDtZQUN4RCxrRUFBa0U7WUFDbEUsTUFBTUMsY0FBYyxJQUFJLENBQUNoQixPQUFPLENBQUNyQyxVQUFVLENBQUMsRUFBRSxDQUFDc0IsVUFBVSxFQUFFLENBQUMsRUFBRTtZQUM5RCxNQUFNOEIsU0FBU0MsY0FBY0EsWUFBWUMsT0FBTyxDQUFDLHNCQUFzQjtZQUN2RSxJQUFJRixRQUFRO2dCQUNSLElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtnQkFDZCxJQUFJLENBQUM1VSxPQUFPLENBQUMyVSw0QkFBNEIsQ0FBQyxJQUFJLEVBQUU7b0JBQzVDdk4sSUFBSXdOO29CQUNKRyxtQkFBbUIsSUFBSSxDQUFDaFYsS0FBSyxDQUFDZ1YsaUJBQWlCO2dCQUNuRDtZQUNKO1FBQ0o7SUFDSjtJQUNBeEUsdUJBQXVCO1FBQ25CLElBQUksSUFBSSxDQUFDcUUsTUFBTSxFQUFFO1lBQ2IsSUFBSSxDQUFDNVUsT0FBTyxDQUFDZ1YsOEJBQThCLENBQUMsSUFBSTtZQUNoRCxJQUFJLENBQUNKLE1BQU0sR0FBRztRQUNsQjtJQUNKO0lBQ0EsYUFBYTtJQUNiLHVHQUF1RztJQUN2R0ssY0FBYztRQUNWLElBQUksQ0FBQ0MsWUFBWSxHQUFHLElBQUl6Vyw4REFBYUEsQ0FBQyxJQUFJLENBQUNtVyxNQUFNLEVBQUUsSUFBSSxDQUFDZixPQUFPLENBQUNzQixPQUFPLEdBQUcvTyxHQUFHLENBQUMsQ0FBQ2dQLFNBQVdBLE9BQU90QyxVQUFVLEVBQUUsQ0FBQyxFQUFFLEdBQ2hILE9BQU87UUFDUCxJQUFJLENBQUN1QyxZQUFZLEdBQUcsSUFBSTVXLDhEQUFhQSxDQUFDLElBQUksQ0FBQ21XLE1BQU0sRUFBRSxJQUFJLENBQUNmLE9BQU8sQ0FBQ3JDLFVBQVUsQ0FBQyxFQUFFLENBQUNzQixVQUFVLElBQ3hGLE1BQ0E7SUFDSjtJQUNBd0MsU0FBU0MsWUFBWSxFQUFFQyxXQUFXLEVBQUU7UUFDaEMsSUFBSSxFQUFFSCxZQUFZLEVBQUVILFlBQVksRUFBRSxHQUFHLElBQUk7UUFDekMsSUFBSWxKLE1BQU1xSixhQUFhSSxXQUFXLENBQUNGO1FBQ25DLElBQUlqVCxNQUFNNFMsYUFBYVEsVUFBVSxDQUFDRjtRQUNsQyxJQUFJbFQsT0FBTyxRQUFRMEosT0FBTyxNQUFNO1lBQzVCLElBQUl3RCxPQUFPLElBQUksQ0FBQ3pQLEtBQUssQ0FBQ3VLLEtBQUssQ0FBQ2hJLElBQUksQ0FBQzBKLElBQUk7WUFDckMsT0FBTztnQkFDSHhHLGFBQWEsSUFBSSxDQUFDekYsS0FBSyxDQUFDeUYsV0FBVztnQkFDbkNtUSxVQUFVOVIsT0FBT0MsTUFBTSxDQUFDO29CQUFFb0osT0FBTyxJQUFJLENBQUMwSSxZQUFZLENBQUN0VCxLQUFLMEo7b0JBQU16SSxRQUFRO2dCQUFLLEdBQUdpTSxLQUFLekosYUFBYTtnQkFDaEc4UCxPQUFPLElBQUksQ0FBQ0MsU0FBUyxDQUFDeFQsS0FBSzBKO2dCQUMzQlUsTUFBTTtvQkFDRm1FLE1BQU13RSxhQUFhckUsS0FBSyxDQUFDaEYsSUFBSTtvQkFDN0I4RSxPQUFPdUUsYUFBYXBFLE1BQU0sQ0FBQ2pGLElBQUk7b0JBQy9Ca0YsS0FBS2dFLGFBQWFhLElBQUksQ0FBQ3pULElBQUk7b0JBQzNCdVEsUUFBUXFDLGFBQWFjLE9BQU8sQ0FBQzFULElBQUk7Z0JBQ3JDO2dCQUNBMlQsT0FBTztZQUNYO1FBQ0o7UUFDQSxPQUFPO0lBQ1g7SUFDQUgsVUFBVXhULEdBQUcsRUFBRTBKLEdBQUcsRUFBRTtRQUNoQixPQUFPLElBQUksQ0FBQzZILE9BQU8sQ0FBQ3JDLFVBQVUsQ0FBQ2xQLElBQUksQ0FBQ3dRLFVBQVUsRUFBRSxDQUFDOUcsSUFBSSxFQUFFLG9CQUFvQjtJQUMvRTtJQUNBNEosYUFBYXRULEdBQUcsRUFBRTBKLEdBQUcsRUFBRTtRQUNuQixJQUFJaEQsUUFBUSxJQUFJLENBQUNqSixLQUFLLENBQUN1SyxLQUFLLENBQUNoSSxJQUFJLENBQUMwSixJQUFJLENBQUMxRSxJQUFJO1FBQzNDLElBQUk0QixNQUFNbkwsaUVBQU9BLENBQUNpTCxPQUFPO1FBQ3pCLE9BQU87WUFBRUE7WUFBT0U7UUFBSTtJQUN4QjtBQUNKO0FBQ0EsU0FBU3VMLFlBQVlwUyxHQUFHO0lBQ3BCLE9BQU9BLElBQUlnQixVQUFVLENBQUNDLEdBQUcsQ0FBQ0MsTUFBTTtBQUNwQztBQUVBLE1BQU0yUyxjQUFjMVosOERBQWFBO0lBQzdCaUQsYUFBYztRQUNWLEtBQUssSUFBSUM7UUFDVCxJQUFJLENBQUNlLEtBQUssR0FBR3BCLHVFQUFTQTtRQUN0QixJQUFJLENBQUM4VyxnQkFBZ0IsR0FBRztJQUM1QjtJQUNBdlMsU0FBUztRQUNMLElBQUksRUFBRTdELEtBQUssRUFBRSxHQUFHLElBQUk7UUFDcEIsSUFBSSxFQUFFbUssZUFBZSxFQUFFRCxZQUFZLEVBQUVtTSxVQUFVLEVBQUUsR0FBR3JXO1FBQ3BELElBQUlzVyxtQkFBbUJwTSxpQkFBaUIsUUFBUUMsb0JBQW9CO1FBQ3BFLGtGQUFrRjtRQUNsRiwrQ0FBK0M7UUFDL0MsSUFBSW1NLG9CQUFvQixDQUFDRCxZQUFZO1lBQ2pDQyxtQkFBbUI7WUFDbkJuTSxrQkFBa0I7WUFDbEJELGVBQWU7UUFDbkI7UUFDQSxJQUFJcU0sYUFBYTtZQUNiO1lBQ0FELG1CQUFtQiw2QkFBNkI7WUFDaERELGFBQWEsS0FBSztTQUNyQjtRQUNELE9BQVE5VywyRUFBYUEsQ0FBQyxPQUFPO1lBQUUySSxLQUFLLElBQUksQ0FBQ3hILEtBQUs7WUFBRW9FLFdBQVd5UixXQUFXQyxJQUFJLENBQUM7WUFBTXpSLE9BQU87Z0JBQ2hGLHFGQUFxRjtnQkFDckYsZ0VBQWdFO2dCQUNoRTBSLE9BQU96VyxNQUFNdVIsV0FBVztnQkFDeEJ2UCxVQUFVaEMsTUFBTTBXLGFBQWE7WUFDakM7UUFBRSxHQUNGblgsMkVBQWFBLENBQUMsU0FBUztZQUFFdUksTUFBTTtZQUFnQmhELFdBQVc7WUFBNEJDLE9BQU87Z0JBQ3JGMFIsT0FBT3pXLE1BQU11UixXQUFXO2dCQUN4QnZQLFVBQVVoQyxNQUFNMFcsYUFBYTtnQkFDN0JwRSxRQUFRK0QsYUFBYXJXLE1BQU0yVSxZQUFZLEdBQUc7WUFDOUM7UUFBRSxHQUNGM1UsTUFBTTJXLFlBQVksRUFDbEJwWCwyRUFBYUEsQ0FBQyxTQUFTO1lBQUV1SSxNQUFNO1FBQWUsR0FDMUN2SSwyRUFBYUEsQ0FBQ2dVLFdBQVc7WUFBRTlOLGFBQWF6RixNQUFNeUYsV0FBVztZQUFFOEUsT0FBT3ZLLE1BQU11SyxLQUFLO1lBQUVrSyxnQkFBZ0J6VSxNQUFNeVUsY0FBYztZQUFFMUUsaUJBQWlCL1AsTUFBTStQLGVBQWU7WUFBRXdCLGFBQWF2UixNQUFNdVIsV0FBVztZQUFFb0QsY0FBYzNVLE1BQU0yVSxZQUFZO1lBQUU3RixrQkFBa0I5TyxNQUFNOE8sZ0JBQWdCO1lBQUVFLGFBQWFoUCxNQUFNZ1AsV0FBVztZQUFFSyxhQUFhclAsTUFBTXFQLFdBQVc7WUFBRXFCLG1CQUFtQjFRLE1BQU0wUSxpQkFBaUI7WUFBRS9KLGdCQUFnQjNHLE1BQU0yRyxjQUFjO1lBQUVSLFdBQVduRyxNQUFNbUcsU0FBUztZQUFFQyxhQUFhcEcsTUFBTW9HLFdBQVc7WUFBRThELGNBQWNBO1lBQWNDLGlCQUFpQkE7WUFBaUJqSixVQUFVbEIsTUFBTWtCLFFBQVE7WUFBRThULG1CQUFtQmhWLE1BQU1nVixpQkFBaUI7UUFBQztJQUMxbUI7SUFDQTlFLG9CQUFvQjtRQUNoQixJQUFJLENBQUMwRyxrQkFBa0I7SUFDM0I7SUFDQXhHLG1CQUFtQkMsU0FBUyxFQUFFO1FBQzFCLElBQUlBLFVBQVU1SyxXQUFXLEtBQUssSUFBSSxDQUFDekYsS0FBSyxDQUFDeUYsV0FBVyxFQUFFO1lBQ2xELElBQUksQ0FBQ21SLGtCQUFrQjtRQUMzQixPQUNLO1lBQ0QsSUFBSSxDQUFDQyxnQkFBZ0I7UUFDekI7SUFDSjtJQUNBRCxxQkFBcUI7UUFDakIsSUFBSSxDQUFDUixnQkFBZ0IsR0FBRztRQUN4QixJQUFJLENBQUNTLGdCQUFnQjtJQUN6QjtJQUNBQSxtQkFBbUI7UUFDZixJQUFJLElBQUksQ0FBQ1QsZ0JBQWdCLElBQ3JCLElBQUksQ0FBQ3BXLEtBQUssQ0FBQ3VSLFdBQVcsQ0FBQyxrQkFBa0I7VUFDM0M7WUFDRSxNQUFNdUYsWUFBWUMsbUJBQW1CLElBQUksQ0FBQ3JXLEtBQUssQ0FBQ2lSLE9BQU8sRUFBRSxJQUFJLENBQUMzUixLQUFLLENBQUN5RixXQUFXO1lBQy9FLElBQUlxUixXQUFXO2dCQUNYLE1BQU1wRixXQUFXb0YsVUFBVS9CLE9BQU8sQ0FBQztnQkFDbkMsTUFBTWlDLFdBQVd0RixTQUFTcUQsT0FBTyxDQUFDO2dCQUNsQyxNQUFNa0MsWUFBWUgsVUFBVXJFLHFCQUFxQixHQUFHdEIsR0FBRyxHQUNuRE8sU0FBU2UscUJBQXFCLEdBQUd0QixHQUFHO2dCQUN4QzZGLFNBQVNDLFNBQVMsR0FBR0EsWUFBYUEsWUFBWSxJQUFLLEdBQUcsa0JBQWtCO1lBQzVFO1lBQ0EsSUFBSSxDQUFDYixnQkFBZ0IsR0FBRztRQUM1QjtJQUNKO0FBQ0o7QUFDQSxTQUFTVyxtQkFBbUJHLFdBQVcsRUFBRXpSLFdBQVc7SUFDaEQsSUFBSTRCO0lBQ0osSUFBSTVCLFlBQVkwUixnQkFBZ0IsQ0FBQ0MsS0FBSyxDQUFDLGVBQWU7UUFDbEQvUCxLQUFLNlAsWUFBWUcsYUFBYSxDQUFDLENBQUMsWUFBWSxFQUFFelksa0VBQWlCQSxDQUFDNkcsWUFBWTZSLFdBQVcsRUFBRSxLQUFLLENBQUM7SUFDL0YsaUVBQWlFO0lBQ3JFO0lBQ0EsSUFBSSxDQUFDalEsSUFBSTtRQUNMQSxLQUFLNlAsWUFBWUcsYUFBYSxDQUFDLENBQUMsWUFBWSxFQUFFeFksa0VBQWVBLENBQUM0RyxZQUFZNlIsV0FBVyxFQUFFLEVBQUUsQ0FBQztJQUMxRix1REFBdUQ7SUFDM0Q7SUFDQSxPQUFPalE7QUFDWDtBQUVBLE1BQU1rUSx1QkFBdUJ6WSw4REFBTUE7SUFDL0JZLGFBQWM7UUFDVixLQUFLLElBQUlDO1FBQ1QsSUFBSSxDQUFDNlgsa0JBQWtCLEdBQUc7SUFDOUI7SUFDQUMsV0FBV0MsU0FBUyxFQUFFQyxhQUFhLEVBQUU7UUFDakMsT0FBT0EsY0FBY0YsVUFBVSxDQUFDQztJQUNwQztBQUNKO0FBRUEsTUFBTUUsaUJBQWlCbmIsOERBQWFBO0lBQ2hDaUQsYUFBYztRQUNWLEtBQUssSUFBSUM7UUFDVCxJQUFJLENBQUNrWSxNQUFNLEdBQUcsSUFBSU47UUFDbEIsSUFBSSxDQUFDTyxRQUFRLEdBQUd4WSx1RUFBU0E7SUFDN0I7SUFDQXVFLFNBQVM7UUFDTCxJQUFJLEVBQUU3RCxLQUFLLEVBQUVDLE9BQU8sRUFBRSxHQUFHLElBQUk7UUFDN0IsT0FBUVYsMkVBQWFBLENBQUM0VyxPQUFPclMsT0FBT0MsTUFBTSxDQUFDO1lBQUVtRSxLQUFLLElBQUksQ0FBQzRQLFFBQVE7UUFBQyxHQUFHLElBQUksQ0FBQ0QsTUFBTSxDQUFDRSxVQUFVLENBQUMvWCxPQUFPQSxNQUFNeUYsV0FBVyxFQUFFekYsTUFBTWdZLGdCQUFnQixFQUFFL1gsU0FBU0QsTUFBTTJYLGFBQWEsR0FBRztZQUFFbFMsYUFBYXpGLE1BQU15RixXQUFXO1lBQUU4RSxPQUFPdkssTUFBTTJYLGFBQWEsQ0FBQ3BOLEtBQUs7WUFBRW9NLGNBQWMzVyxNQUFNMlcsWUFBWTtZQUFFRCxlQUFlMVcsTUFBTTBXLGFBQWE7WUFBRWpDLGdCQUFnQnpVLE1BQU15VSxjQUFjO1lBQUV2SyxjQUFjbEssTUFBTWtLLFlBQVk7WUFBRUMsaUJBQWlCbkssTUFBTW1LLGVBQWU7WUFBRTRGLGlCQUFpQi9QLE1BQU0rUCxlQUFlO1lBQUVzRyxZQUFZclcsTUFBTXFXLFVBQVU7WUFBRTRCLGtCQUFrQmpZLE1BQU1pWSxnQkFBZ0I7WUFBRTFHLGFBQWF2UixNQUFNdVIsV0FBVztZQUFFb0QsY0FBYzNVLE1BQU0yVSxZQUFZO1lBQUV6VCxVQUFVbEIsTUFBTWtCLFFBQVE7UUFBQztJQUNwbkI7QUFDSjtBQUVBLE1BQU1nWCxxQkFBcUJ6WTtJQUN2QkMsYUFBYztRQUNWLEtBQUssSUFBSUM7UUFDVCxJQUFJLENBQUN3WSxrQkFBa0IsR0FBRzlhLGlFQUFPQSxDQUFDOGE7UUFDbEMsSUFBSSxDQUFDQyxTQUFTLEdBQUc5WSx1RUFBU0E7UUFDMUIsSUFBSSxDQUFDd1ksUUFBUSxHQUFHeFksdUVBQVNBO0lBQ3pCLG1EQUFtRDtJQUN2RDtJQUNBdUUsU0FBUztRQUNMLElBQUksRUFBRXpELE9BQU8sRUFBRWlZLG9CQUFvQixFQUFFLEdBQUcsSUFBSSxDQUFDcFksT0FBTztRQUNwRCxJQUFJLEVBQUVELEtBQUssRUFBRSxHQUFHLElBQUk7UUFDcEIsSUFBSTJYLGdCQUFnQixJQUFJLENBQUNRLGtCQUFrQixDQUFDblksTUFBTXlGLFdBQVcsRUFBRTRTO1FBQy9ELElBQUlDLGdCQUFnQmxZLFFBQVFtWSxVQUFVLElBQUtoWiwyRUFBYUEsQ0FBQ1IsOERBQVNBLEVBQUU7WUFBRW1KLEtBQUssSUFBSSxDQUFDa1EsU0FBUztZQUFFM1MsYUFBYXpGLE1BQU15RixXQUFXO1lBQUUrUyxPQUFPYixjQUFjYyxXQUFXO1lBQUVDLHNCQUFzQmYsY0FBY3hWLE1BQU0sS0FBSztRQUFFO1FBQzlNLElBQUlwQyxjQUFjLENBQUM0WSxhQUFnQnBaLDJFQUFhQSxDQUFDcVksVUFBVTtnQkFBRTFQLEtBQUssSUFBSSxDQUFDNFAsUUFBUTtnQkFBRXJTLGFBQWF6RixNQUFNeUYsV0FBVztnQkFBRWtTLGVBQWVBO2dCQUFlaUIsZUFBZTVZLE1BQU00WSxhQUFhO2dCQUFFQyxlQUFlN1ksTUFBTTZZLGFBQWE7Z0JBQUVDLFlBQVk5WSxNQUFNOFksVUFBVTtnQkFBRUMsY0FBYy9ZLE1BQU0rWSxZQUFZO2dCQUFFcFMsZ0JBQWdCM0csTUFBTTJHLGNBQWM7Z0JBQUVSLFdBQVduRyxNQUFNbUcsU0FBUztnQkFBRUMsYUFBYXBHLE1BQU1vRyxXQUFXO2dCQUFFNFIsa0JBQWtCNVgsUUFBUTRYLGdCQUFnQjtnQkFBRXJCLGNBQWNnQyxXQUFXSyxpQkFBaUI7Z0JBQUV0QyxlQUFlaUMsV0FBV2pDLGFBQWE7Z0JBQUV4TSxjQUFjOUosUUFBUThKLFlBQVk7Z0JBQUVDLGlCQUFpQi9KLFFBQVErSixlQUFlO2dCQUFFNEYsaUJBQWlCM1AsUUFBUTZZLFdBQVc7Z0JBQUU1QyxZQUFZLENBQUNyVyxNQUFNaUIsWUFBWTtnQkFBRWdYLGtCQUFrQixJQUFJLENBQUNyWSxXQUFXO2dCQUFFMlIsYUFBYW9ILFdBQVdwSCxXQUFXO2dCQUFFb0QsY0FBY2dFLFdBQVdoRSxZQUFZO2dCQUFFelQsVUFBVWxCLE1BQU1rQixRQUFRO1lBQUM7UUFDeHhCLE9BQU9kLFFBQVFtQixXQUFXLEdBQ3BCLElBQUksQ0FBQ0YsbUJBQW1CLENBQUNpWCxlQUFldlksYUFBYTRYLGNBQWNyVyxNQUFNLEVBQUVsQixRQUFRbUIsV0FBVyxJQUM5RixJQUFJLENBQUMxQixrQkFBa0IsQ0FBQ3lZLGVBQWV2WTtJQUNqRDtBQUNKO0FBQ0EsU0FBU29ZLG1CQUFtQjFTLFdBQVcsRUFBRTRTLG9CQUFvQjtJQUN6RCxJQUFJYSxZQUFZLElBQUlsYSw4REFBY0EsQ0FBQ3lHLFlBQVkwVCxXQUFXLEVBQUVkO0lBQzVELE9BQU8sSUFBSXBaLDhEQUFhQSxDQUFDaWEsV0FBVyxrQkFBa0JFLElBQUksQ0FBQzNULFlBQVkwUixnQkFBZ0I7QUFDM0Y7QUFFQSxNQUFNa0Msa0NBQWtDbmEsNkRBQW9CQTtJQUN4RCxnREFBZ0Q7SUFDaERvYSxpQkFBaUIzUixZQUFZLEVBQUV3UCxnQkFBZ0IsRUFBRW9DLGFBQWEsRUFBRTtRQUM1RCxJQUFJSixjQUFjLEtBQUssQ0FBQ0csaUJBQWlCM1IsY0FBY3dQLGtCQUFrQm9DO1FBQ3pFLElBQUksRUFBRXZaLEtBQUssRUFBRSxHQUFHLElBQUk7UUFDcEIsT0FBT3daLHlCQUF5QjtZQUM1QjdSLGNBQWN3UjtZQUNkTSxZQUFZLGlCQUFpQkwsSUFBSSxDQUFDakM7WUFDbEN1QyxnQkFBZ0IxWixNQUFNMFosY0FBYztZQUNwQ3BTLFNBQVN0SCxNQUFNc0gsT0FBTztRQUMxQjtJQUNKO0FBQ0o7QUFDQSxTQUFTa1MseUJBQXlCeFosS0FBSztJQUNuQyxJQUFJLEVBQUVzSCxPQUFPLEVBQUVLLFlBQVksRUFBRSxHQUFHM0g7SUFDaEMsSUFBSSxFQUFFaUosS0FBSyxFQUFFRSxHQUFHLEVBQUUsR0FBR3hCO0lBQ3JCLElBQUlnUztJQUNKLG1GQUFtRjtJQUNuRixJQUFJM1osTUFBTXlaLFVBQVUsRUFBRTtRQUNsQnhRLFFBQVEzQixRQUFRc1MsV0FBVyxDQUFDM1E7UUFDNUIsa0NBQWtDO1FBQ2xDMFEsWUFBWXJTLFFBQVFzUyxXQUFXLENBQUN6UTtRQUNoQyxJQUFJd1EsVUFBVTlQLE9BQU8sT0FBT1YsSUFBSVUsT0FBTyxJQUFJO1lBQ3ZDVixNQUFNaEssa0VBQVFBLENBQUN3YSxXQUFXO1FBQzlCO0lBQ0o7SUFDQSxpQkFBaUI7SUFDakIsSUFBSTNaLE1BQU0wWixjQUFjLEVBQUU7UUFDdEIscUVBQXFFO1FBQ3JFLCtFQUErRTtRQUMvRSxJQUFJRyx1QkFBdUJ2UyxRQUFRc1MsV0FBVyxDQUFDdFMsUUFBUXdTLFlBQVksQ0FBQzliLGlFQUFPQSxDQUFDMkosYUFBYXdCLEdBQUcsRUFBRSxDQUFDO1FBQy9GLElBQUloSCxTQUFTb1EsS0FBS3dILElBQUksQ0FDdEIzYSxrRUFBU0EsQ0FBQ3lhLHNCQUFzQjFRO1FBQ2hDQSxNQUFNaEssa0VBQVFBLENBQUNnSyxLQUFLLElBQUloSDtJQUM1QjtJQUNBLE9BQU87UUFBRThHO1FBQU9FO0lBQUk7QUFDeEI7QUFFQSxJQUFJNlEsV0FBVztBQUNmM2Esa0VBQVlBLENBQUMyYTtBQUUwSiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlaGFzcG9ydC1tYW5hZ2VtZW50Ly4vbm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvZGF5Z3JpZC9pbnRlcm5hbC5qcz85NTE1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERhdGVDb21wb25lbnQsIGdldFN0aWNreUhlYWRlckRhdGVzLCBWaWV3Q29udGFpbmVyLCBTaW1wbGVTY3JvbGxHcmlkLCBnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIsIHJlbmRlclNjcm9sbFNoaW0sIGNyZWF0ZUZvcm1hdHRlciwgQmFzZUNvbXBvbmVudCwgU3RhbmRhcmRFdmVudCwgYnVpbGRTZWdUaW1lVGV4dCwgRXZlbnRDb250YWluZXIsIGdldFNlZ0FuY2hvckF0dHJzLCBtZW1vaXplLCBNb3JlTGlua0NvbnRhaW5lciwgZ2V0U2VnTWV0YSwgZ2V0VW5pcXVlRG9tSWQsIHNldFJlZiwgRGF5Q2VsbENvbnRhaW5lciwgV2Vla051bWJlckNvbnRhaW5lciwgYnVpbGROYXZMaW5rQXR0cnMsIGhhc0N1c3RvbURheUNlbGxDb250ZW50LCBhZGRNcywgaW50ZXJzZWN0UmFuZ2VzLCBhZGREYXlzLCBTZWdIaWVyYXJjaHksIGJ1aWxkRW50cnlLZXksIGludGVyc2VjdFNwYW5zLCBSZWZNYXAsIHNvcnRFdmVudFNlZ3MsIGlzUHJvcHNFcXVhbCwgYnVpbGRFdmVudFJhbmdlS2V5LCBCZ0V2ZW50LCByZW5kZXJGaWxsLCBQb3NpdGlvbkNhY2hlLCBOb3dUaW1lciwgZm9ybWF0SXNvTW9udGhTdHIsIGZvcm1hdERheVN0cmluZywgU2xpY2VyLCBEYXlIZWFkZXIsIERheVNlcmllc01vZGVsLCBEYXlUYWJsZU1vZGVsLCBEYXRlUHJvZmlsZUdlbmVyYXRvciwgYWRkV2Vla3MsIGRpZmZXZWVrcywgaW5qZWN0U3R5bGVzIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb3JlL2ludGVybmFsLmpzJztcbmltcG9ydCB7IGNyZWF0ZVJlZiwgY3JlYXRlRWxlbWVudCwgRnJhZ21lbnQgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUvcHJlYWN0LmpzJztcblxuLyogQW4gYWJzdHJhY3QgY2xhc3MgZm9yIHRoZSBkYXlncmlkIHZpZXdzLCBhcyB3ZWxsIGFzIG1vbnRoIHZpZXcuIFJlbmRlcnMgb25lIG9yIG1vcmUgcm93cyBvZiBkYXkgY2VsbHMuXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8vIEl0IGlzIGEgbWFuYWdlciBmb3IgYSBUYWJsZSBzdWJjb21wb25lbnQsIHdoaWNoIGRvZXMgbW9zdCBvZiB0aGUgaGVhdnkgbGlmdGluZy5cbi8vIEl0IGlzIHJlc3BvbnNpYmxlIGZvciBtYW5hZ2luZyB3aWR0aC9oZWlnaHQuXG5jbGFzcyBUYWJsZVZpZXcgZXh0ZW5kcyBEYXRlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5oZWFkZXJFbFJlZiA9IGNyZWF0ZVJlZigpO1xuICAgIH1cbiAgICByZW5kZXJTaW1wbGVMYXlvdXQoaGVhZGVyUm93Q29udGVudCwgYm9keUNvbnRlbnQpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IFtdO1xuICAgICAgICBsZXQgc3RpY2t5SGVhZGVyRGF0ZXMgPSBnZXRTdGlja3lIZWFkZXJEYXRlcyhjb250ZXh0Lm9wdGlvbnMpO1xuICAgICAgICBpZiAoaGVhZGVyUm93Q29udGVudCkge1xuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2hlYWRlcicsXG4gICAgICAgICAgICAgICAga2V5OiAnaGVhZGVyJyxcbiAgICAgICAgICAgICAgICBpc1N0aWNreTogc3RpY2t5SGVhZGVyRGF0ZXMsXG4gICAgICAgICAgICAgICAgY2h1bms6IHtcbiAgICAgICAgICAgICAgICAgICAgZWxSZWY6IHRoaXMuaGVhZGVyRWxSZWYsXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlQ2xhc3NOYW1lOiAnZmMtY29sLWhlYWRlcicsXG4gICAgICAgICAgICAgICAgICAgIHJvd0NvbnRlbnQ6IGhlYWRlclJvd0NvbnRlbnQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ2JvZHknLFxuICAgICAgICAgICAga2V5OiAnYm9keScsXG4gICAgICAgICAgICBsaXF1aWQ6IHRydWUsXG4gICAgICAgICAgICBjaHVuazogeyBjb250ZW50OiBib2R5Q29udGVudCB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFZpZXdDb250YWluZXIsIHsgZWxDbGFzc2VzOiBbJ2ZjLWRheWdyaWQnXSwgdmlld1NwZWM6IGNvbnRleHQudmlld1NwZWMgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoU2ltcGxlU2Nyb2xsR3JpZCwgeyBsaXF1aWQ6ICFwcm9wcy5pc0hlaWdodEF1dG8gJiYgIXByb3BzLmZvclByaW50LCBjb2xsYXBzaWJsZVdpZHRoOiBwcm9wcy5mb3JQcmludCwgY29sczogW10gLyogVE9ETzogbWFrZSBvcHRpb25hbD8gKi8sIHNlY3Rpb25zOiBzZWN0aW9ucyB9KSkpO1xuICAgIH1cbiAgICByZW5kZXJIU2Nyb2xsTGF5b3V0KGhlYWRlclJvd0NvbnRlbnQsIGJvZHlDb250ZW50LCBjb2xDbnQsIGRheU1pbldpZHRoKSB7XG4gICAgICAgIGxldCBTY3JvbGxHcmlkID0gdGhpcy5jb250ZXh0LnBsdWdpbkhvb2tzLnNjcm9sbEdyaWRJbXBsO1xuICAgICAgICBpZiAoIVNjcm9sbEdyaWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gU2Nyb2xsR3JpZCBpbXBsZW1lbnRhdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgc3RpY2t5SGVhZGVyRGF0ZXMgPSAhcHJvcHMuZm9yUHJpbnQgJiYgZ2V0U3RpY2t5SGVhZGVyRGF0ZXMoY29udGV4dC5vcHRpb25zKTtcbiAgICAgICAgbGV0IHN0aWNreUZvb3RlclNjcm9sbGJhciA9ICFwcm9wcy5mb3JQcmludCAmJiBnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIoY29udGV4dC5vcHRpb25zKTtcbiAgICAgICAgbGV0IHNlY3Rpb25zID0gW107XG4gICAgICAgIGlmIChoZWFkZXJSb3dDb250ZW50KSB7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGVhZGVyJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdoZWFkZXInLFxuICAgICAgICAgICAgICAgIGlzU3RpY2t5OiBzdGlja3lIZWFkZXJEYXRlcyxcbiAgICAgICAgICAgICAgICBjaHVua3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdtYWluJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsUmVmOiB0aGlzLmhlYWRlckVsUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVDbGFzc05hbWU6ICdmYy1jb2wtaGVhZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0NvbnRlbnQ6IGhlYWRlclJvd0NvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICBrZXk6ICdib2R5JyxcbiAgICAgICAgICAgIGxpcXVpZDogdHJ1ZSxcbiAgICAgICAgICAgIGNodW5rczogW3tcbiAgICAgICAgICAgICAgICAgICAga2V5OiAnbWFpbicsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGJvZHlDb250ZW50LFxuICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHN0aWNreUZvb3RlclNjcm9sbGJhcikge1xuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2Zvb3RlcicsXG4gICAgICAgICAgICAgICAga2V5OiAnZm9vdGVyJyxcbiAgICAgICAgICAgICAgICBpc1N0aWNreTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjaHVua3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdtYWluJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHJlbmRlclNjcm9sbFNoaW0sXG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFZpZXdDb250YWluZXIsIHsgZWxDbGFzc2VzOiBbJ2ZjLWRheWdyaWQnXSwgdmlld1NwZWM6IGNvbnRleHQudmlld1NwZWMgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoU2Nyb2xsR3JpZCwgeyBsaXF1aWQ6ICFwcm9wcy5pc0hlaWdodEF1dG8gJiYgIXByb3BzLmZvclByaW50LCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQsIGNvbGxhcHNpYmxlV2lkdGg6IHByb3BzLmZvclByaW50LCBjb2xHcm91cHM6IFt7IGNvbHM6IFt7IHNwYW46IGNvbENudCwgbWluV2lkdGg6IGRheU1pbldpZHRoIH1dIH1dLCBzZWN0aW9uczogc2VjdGlvbnMgfSkpKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNwbGl0U2Vnc0J5Um93KHNlZ3MsIHJvd0NudCkge1xuICAgIGxldCBieVJvdyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93Q250OyBpICs9IDEpIHtcbiAgICAgICAgYnlSb3dbaV0gPSBbXTtcbiAgICB9XG4gICAgZm9yIChsZXQgc2VnIG9mIHNlZ3MpIHtcbiAgICAgICAgYnlSb3dbc2VnLnJvd10ucHVzaChzZWcpO1xuICAgIH1cbiAgICByZXR1cm4gYnlSb3c7XG59XG5mdW5jdGlvbiBzcGxpdFNlZ3NCeUZpcnN0Q29sKHNlZ3MsIGNvbENudCkge1xuICAgIGxldCBieUNvbCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sQ250OyBpICs9IDEpIHtcbiAgICAgICAgYnlDb2xbaV0gPSBbXTtcbiAgICB9XG4gICAgZm9yIChsZXQgc2VnIG9mIHNlZ3MpIHtcbiAgICAgICAgYnlDb2xbc2VnLmZpcnN0Q29sXS5wdXNoKHNlZyk7XG4gICAgfVxuICAgIHJldHVybiBieUNvbDtcbn1cbmZ1bmN0aW9uIHNwbGl0SW50ZXJhY3Rpb25CeVJvdyh1aSwgcm93Q250KSB7XG4gICAgbGV0IGJ5Um93ID0gW107XG4gICAgaWYgKCF1aSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd0NudDsgaSArPSAxKSB7XG4gICAgICAgICAgICBieVJvd1tpXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93Q250OyBpICs9IDEpIHtcbiAgICAgICAgICAgIGJ5Um93W2ldID0ge1xuICAgICAgICAgICAgICAgIGFmZmVjdGVkSW5zdGFuY2VzOiB1aS5hZmZlY3RlZEluc3RhbmNlcyxcbiAgICAgICAgICAgICAgICBpc0V2ZW50OiB1aS5pc0V2ZW50LFxuICAgICAgICAgICAgICAgIHNlZ3M6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBzZWcgb2YgdWkuc2Vncykge1xuICAgICAgICAgICAgYnlSb3dbc2VnLnJvd10uc2Vncy5wdXNoKHNlZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJ5Um93O1xufVxuXG5jb25zdCBERUZBVUxUX1RBQkxFX0VWRU5UX1RJTUVfRk9STUFUID0gY3JlYXRlRm9ybWF0dGVyKHtcbiAgICBob3VyOiAnbnVtZXJpYycsXG4gICAgbWludXRlOiAnMi1kaWdpdCcsXG4gICAgb21pdFplcm9NaW51dGU6IHRydWUsXG4gICAgbWVyaWRpZW06ICduYXJyb3cnLFxufSk7XG5mdW5jdGlvbiBoYXNMaXN0SXRlbURpc3BsYXkoc2VnKSB7XG4gICAgbGV0IHsgZGlzcGxheSB9ID0gc2VnLmV2ZW50UmFuZ2UudWk7XG4gICAgcmV0dXJuIGRpc3BsYXkgPT09ICdsaXN0LWl0ZW0nIHx8IChkaXNwbGF5ID09PSAnYXV0bycgJiZcbiAgICAgICAgIXNlZy5ldmVudFJhbmdlLmRlZi5hbGxEYXkgJiZcbiAgICAgICAgc2VnLmZpcnN0Q29sID09PSBzZWcubGFzdENvbCAmJiAvLyBjYW4ndCBiZSBtdWx0aS1kYXlcbiAgICAgICAgc2VnLmlzU3RhcnQgJiYgLy8gXCJcbiAgICAgICAgc2VnLmlzRW5kIC8vIFwiXG4gICAgKTtcbn1cblxuY2xhc3MgVGFibGVCbG9ja0V2ZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFN0YW5kYXJkRXZlbnQsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7IGVsQ2xhc3NlczogWydmYy1kYXlncmlkLWV2ZW50JywgJ2ZjLWRheWdyaWQtYmxvY2stZXZlbnQnLCAnZmMtaC1ldmVudCddLCBkZWZhdWx0VGltZUZvcm1hdDogREVGQVVMVF9UQUJMRV9FVkVOVF9USU1FX0ZPUk1BVCwgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogcHJvcHMuZGVmYXVsdERpc3BsYXlFdmVudEVuZCwgZGlzYWJsZVJlc2l6aW5nOiAhcHJvcHMuc2VnLmV2ZW50UmFuZ2UuZGVmLmFsbERheSB9KSkpO1xuICAgIH1cbn1cblxuY2xhc3MgVGFibGVMaXN0SXRlbUV2ZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICAgICAgbGV0IHsgc2VnIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IHRpbWVGb3JtYXQgPSBvcHRpb25zLmV2ZW50VGltZUZvcm1hdCB8fCBERUZBVUxUX1RBQkxFX0VWRU5UX1RJTUVfRk9STUFUO1xuICAgICAgICBsZXQgdGltZVRleHQgPSBidWlsZFNlZ1RpbWVUZXh0KHNlZywgdGltZUZvcm1hdCwgY29udGV4dCwgdHJ1ZSwgcHJvcHMuZGVmYXVsdERpc3BsYXlFdmVudEVuZCk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChFdmVudENvbnRhaW5lciwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMsIHsgZWxUYWc6IFwiYVwiLCBlbENsYXNzZXM6IFsnZmMtZGF5Z3JpZC1ldmVudCcsICdmYy1kYXlncmlkLWRvdC1ldmVudCddLCBlbEF0dHJzOiBnZXRTZWdBbmNob3JBdHRycyhwcm9wcy5zZWcsIGNvbnRleHQpLCBkZWZhdWx0R2VuZXJhdG9yOiByZW5kZXJJbm5lckNvbnRlbnQsIHRpbWVUZXh0OiB0aW1lVGV4dCwgaXNSZXNpemluZzogZmFsc2UsIGlzRGF0ZVNlbGVjdGluZzogZmFsc2UgfSkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZW5kZXJJbm5lckNvbnRlbnQocmVuZGVyUHJvcHMpIHtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1ldmVudC1kb3RcIiwgc3R5bGU6IHsgYm9yZGVyQ29sb3I6IHJlbmRlclByb3BzLmJvcmRlckNvbG9yIHx8IHJlbmRlclByb3BzLmJhY2tncm91bmRDb2xvciB9IH0pLFxuICAgICAgICByZW5kZXJQcm9wcy50aW1lVGV4dCAmJiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC10aW1lXCIgfSwgcmVuZGVyUHJvcHMudGltZVRleHQpKSxcbiAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC10aXRsZVwiIH0sIHJlbmRlclByb3BzLmV2ZW50LnRpdGxlIHx8IGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIFwiXFx1MDBBMFwiKSkpKTtcbn1cblxuY2xhc3MgVGFibGVDZWxsTW9yZUxpbmsgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5jb21waWxlU2VncyA9IG1lbW9pemUoY29tcGlsZVNlZ3MpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBhbGxTZWdzLCBpbnZpc2libGVTZWdzIH0gPSB0aGlzLmNvbXBpbGVTZWdzKHByb3BzLnNpbmdsZVBsYWNlbWVudHMpO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoTW9yZUxpbmtDb250YWluZXIsIHsgZWxDbGFzc2VzOiBbJ2ZjLWRheWdyaWQtbW9yZS1saW5rJ10sIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgYWxsRGF5RGF0ZTogcHJvcHMuYWxsRGF5RGF0ZSwgbW9yZUNudDogcHJvcHMubW9yZUNudCwgYWxsU2VnczogYWxsU2VncywgaGlkZGVuU2VnczogaW52aXNpYmxlU2VncywgYWxpZ25tZW50RWxSZWY6IHByb3BzLmFsaWdubWVudEVsUmVmLCBhbGlnbkdyaWRUb3A6IHByb3BzLmFsaWduR3JpZFRvcCwgZXh0cmFEYXRlU3BhbjogcHJvcHMuZXh0cmFEYXRlU3BhbiwgcG9wb3ZlckNvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgaXNGb3JjZWRJbnZpc2libGUgPSAocHJvcHMuZXZlbnREcmFnID8gcHJvcHMuZXZlbnREcmFnLmFmZmVjdGVkSW5zdGFuY2VzIDogbnVsbCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHByb3BzLmV2ZW50UmVzaXplID8gcHJvcHMuZXZlbnRSZXNpemUuYWZmZWN0ZWRJbnN0YW5jZXMgOiBudWxsKSB8fFxuICAgICAgICAgICAgICAgICAgICB7fTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIGFsbFNlZ3MubWFwKChzZWcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluc3RhbmNlSWQgPSBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1ldmVudC1oYXJuZXNzXCIsIGtleTogaW5zdGFuY2VJZCwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBpc0ZvcmNlZEludmlzaWJsZVtpbnN0YW5jZUlkXSA/ICdoaWRkZW4nIDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICB9IH0sIGhhc0xpc3RJdGVtRGlzcGxheShzZWcpID8gKGNyZWF0ZUVsZW1lbnQoVGFibGVMaXN0SXRlbUV2ZW50LCBPYmplY3QuYXNzaWduKHsgc2VnOiBzZWcsIGlzRHJhZ2dpbmc6IGZhbHNlLCBpc1NlbGVjdGVkOiBpbnN0YW5jZUlkID09PSBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogZmFsc2UgfSwgZ2V0U2VnTWV0YShzZWcsIHByb3BzLnRvZGF5UmFuZ2UpKSkpIDogKGNyZWF0ZUVsZW1lbnQoVGFibGVCbG9ja0V2ZW50LCBPYmplY3QuYXNzaWduKHsgc2VnOiBzZWcsIGlzRHJhZ2dpbmc6IGZhbHNlLCBpc1Jlc2l6aW5nOiBmYWxzZSwgaXNEYXRlU2VsZWN0aW5nOiBmYWxzZSwgaXNTZWxlY3RlZDogaW5zdGFuY2VJZCA9PT0gcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGRlZmF1bHREaXNwbGF5RXZlbnRFbmQ6IGZhbHNlIH0sIGdldFNlZ01ldGEoc2VnLCBwcm9wcy50b2RheVJhbmdlKSkpKSkpO1xuICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICB9IH0pKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21waWxlU2VncyhzaW5nbGVQbGFjZW1lbnRzKSB7XG4gICAgbGV0IGFsbFNlZ3MgPSBbXTtcbiAgICBsZXQgaW52aXNpYmxlU2VncyA9IFtdO1xuICAgIGZvciAobGV0IHBsYWNlbWVudCBvZiBzaW5nbGVQbGFjZW1lbnRzKSB7XG4gICAgICAgIGFsbFNlZ3MucHVzaChwbGFjZW1lbnQuc2VnKTtcbiAgICAgICAgaWYgKCFwbGFjZW1lbnQuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICBpbnZpc2libGVTZWdzLnB1c2gocGxhY2VtZW50LnNlZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgYWxsU2VncywgaW52aXNpYmxlU2VncyB9O1xufVxuXG5jb25zdCBERUZBVUxUX1dFRUtfTlVNX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7IHdlZWs6ICduYXJyb3cnIH0pO1xuY2xhc3MgVGFibGVDZWxsIGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucm9vdEVsUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBkYXlOdW1iZXJJZDogZ2V0VW5pcXVlRG9tSWQoKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVSb290RWwgPSAoZWwpID0+IHtcbiAgICAgICAgICAgIHNldFJlZih0aGlzLnJvb3RFbFJlZiwgZWwpO1xuICAgICAgICAgICAgc2V0UmVmKHRoaXMucHJvcHMuZWxSZWYsIGVsKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBjb250ZXh0LCBwcm9wcywgc3RhdGUsIHJvb3RFbFJlZiB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgb3B0aW9ucywgZGF0ZUVudiB9ID0gY29udGV4dDtcbiAgICAgICAgbGV0IHsgZGF0ZSwgZGF0ZVByb2ZpbGUgfSA9IHByb3BzO1xuICAgICAgICAvLyBUT0RPOiBtZW1vaXplIHRoaXM/XG4gICAgICAgIGNvbnN0IGlzTW9udGhTdGFydCA9IHByb3BzLnNob3dEYXlOdW1iZXIgJiZcbiAgICAgICAgICAgIHNob3VsZERpc3BsYXlNb250aFN0YXJ0KGRhdGUsIGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZSwgZGF0ZUVudik7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChEYXlDZWxsQ29udGFpbmVyLCB7IGVsVGFnOiBcInRkXCIsIGVsUmVmOiB0aGlzLmhhbmRsZVJvb3RFbCwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgJ2ZjLWRheWdyaWQtZGF5JyxcbiAgICAgICAgICAgICAgICAuLi4ocHJvcHMuZXh0cmFDbGFzc05hbWVzIHx8IFtdKSxcbiAgICAgICAgICAgIF0sIGVsQXR0cnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9wcy5leHRyYURhdGFBdHRycyksIChwcm9wcy5zaG93RGF5TnVtYmVyID8geyAnYXJpYS1sYWJlbGxlZGJ5Jzogc3RhdGUuZGF5TnVtYmVySWQgfSA6IHt9KSksIHsgcm9sZTogJ2dyaWRjZWxsJyB9KSwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVyVG9wSW5uZXIsIGRhdGU6IGRhdGUsIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgc2hvd0RheU51bWJlcjogcHJvcHMuc2hvd0RheU51bWJlciwgaXNNb250aFN0YXJ0OiBpc01vbnRoU3RhcnQsIGV4dHJhUmVuZGVyUHJvcHM6IHByb3BzLmV4dHJhUmVuZGVyUHJvcHMgfSwgKElubmVyQ29udGVudCwgcmVuZGVyUHJvcHMpID0+IChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiBwcm9wcy5pbm5lckVsUmVmLCBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1kYXktZnJhbWUgZmMtc2Nyb2xsZ3JpZC1zeW5jLWlubmVyXCIsIHN0eWxlOiB7IG1pbkhlaWdodDogcHJvcHMubWluSGVpZ2h0IH0gfSxcbiAgICAgICAgICAgIHByb3BzLnNob3dXZWVrTnVtYmVyICYmIChjcmVhdGVFbGVtZW50KFdlZWtOdW1iZXJDb250YWluZXIsIHsgZWxUYWc6IFwiYVwiLCBlbENsYXNzZXM6IFsnZmMtZGF5Z3JpZC13ZWVrLW51bWJlciddLCBlbEF0dHJzOiBidWlsZE5hdkxpbmtBdHRycyhjb250ZXh0LCBkYXRlLCAnd2VlaycpLCBkYXRlOiBkYXRlLCBkZWZhdWx0Rm9ybWF0OiBERUZBVUxUX1dFRUtfTlVNX0ZPUk1BVCB9KSksXG4gICAgICAgICAgICAhcmVuZGVyUHJvcHMuaXNEaXNhYmxlZCAmJlxuICAgICAgICAgICAgICAgIChwcm9wcy5zaG93RGF5TnVtYmVyIHx8IGhhc0N1c3RvbURheUNlbGxDb250ZW50KG9wdGlvbnMpIHx8IHByb3BzLmZvcmNlRGF5VG9wKSA/IChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LXRvcFwiIH0sXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChJbm5lckNvbnRlbnQsIHsgZWxUYWc6IFwiYVwiLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYy1kYXlncmlkLWRheS1udW1iZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNNb250aFN0YXJ0ICYmICdmYy1kYXlncmlkLW1vbnRoLXN0YXJ0JyxcbiAgICAgICAgICAgICAgICAgICAgXSwgZWxBdHRyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZE5hdkxpbmtBdHRycyhjb250ZXh0LCBkYXRlKSksIHsgaWQ6IHN0YXRlLmRheU51bWJlcklkIH0pIH0pKSkgOiBwcm9wcy5zaG93RGF5TnVtYmVyID8gKFxuICAgICAgICAgICAgLy8gZm9yIGNyZWF0aW5nIGNvcnJlY3QgYW1vdW50IG9mIHNwYWNlIChzZWUgaXNzdWUgIzcxNjIpXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LXRvcFwiLCBzdHlsZTogeyB2aXNpYmlsaXR5OiAnaGlkZGVuJyB9IH0sXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImFcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1kYXktbnVtYmVyXCIgfSwgXCJcXHUwMEEwXCIpKSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LWV2ZW50c1wiLCByZWY6IHByb3BzLmZnQ29udGVudEVsUmVmIH0sXG4gICAgICAgICAgICAgICAgcHJvcHMuZmdDb250ZW50LFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1kYXktYm90dG9tXCIsIHN0eWxlOiB7IG1hcmdpblRvcDogcHJvcHMubW9yZU1hcmdpblRvcCB9IH0sXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoVGFibGVDZWxsTW9yZUxpbmssIHsgYWxsRGF5RGF0ZTogZGF0ZSwgc2luZ2xlUGxhY2VtZW50czogcHJvcHMuc2luZ2xlUGxhY2VtZW50cywgbW9yZUNudDogcHJvcHMubW9yZUNudCwgYWxpZ25tZW50RWxSZWY6IHJvb3RFbFJlZiwgYWxpZ25HcmlkVG9wOiAhcHJvcHMuc2hvd0RheU51bWJlciwgZXh0cmFEYXRlU3BhbjogcHJvcHMuZXh0cmFEYXRlU3BhbiwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZzogcHJvcHMuZXZlbnREcmFnLCBldmVudFJlc2l6ZTogcHJvcHMuZXZlbnRSZXNpemUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UgfSkpKSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1kYXktYmdcIiB9LCBwcm9wcy5iZ0NvbnRlbnQpKSkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZW5kZXJUb3BJbm5lcihwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy5kYXlOdW1iZXJUZXh0IHx8IGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIFwiXFx1MDBBMFwiKTtcbn1cbmZ1bmN0aW9uIHNob3VsZERpc3BsYXlNb250aFN0YXJ0KGRhdGUsIGN1cnJlbnRSYW5nZSwgZGF0ZUVudikge1xuICAgIGNvbnN0IHsgc3RhcnQ6IGN1cnJlbnRTdGFydCwgZW5kOiBjdXJyZW50RW5kIH0gPSBjdXJyZW50UmFuZ2U7XG4gICAgY29uc3QgY3VycmVudEVuZEluY2wgPSBhZGRNcyhjdXJyZW50RW5kLCAtMSk7XG4gICAgY29uc3QgY3VycmVudEZpcnN0WWVhciA9IGRhdGVFbnYuZ2V0WWVhcihjdXJyZW50U3RhcnQpO1xuICAgIGNvbnN0IGN1cnJlbnRGaXJzdE1vbnRoID0gZGF0ZUVudi5nZXRNb250aChjdXJyZW50U3RhcnQpO1xuICAgIGNvbnN0IGN1cnJlbnRMYXN0WWVhciA9IGRhdGVFbnYuZ2V0WWVhcihjdXJyZW50RW5kSW5jbCk7XG4gICAgY29uc3QgY3VycmVudExhc3RNb250aCA9IGRhdGVFbnYuZ2V0TW9udGgoY3VycmVudEVuZEluY2wpO1xuICAgIC8vIHNwYW5zIG1vcmUgdGhhbiBvbmUgbW9udGg/XG4gICAgcmV0dXJuICEoY3VycmVudEZpcnN0WWVhciA9PT0gY3VycmVudExhc3RZZWFyICYmIGN1cnJlbnRGaXJzdE1vbnRoID09PSBjdXJyZW50TGFzdE1vbnRoKSAmJlxuICAgICAgICBCb29sZWFuKFxuICAgICAgICAvLyBmaXJzdCBkYXRlIGluIGN1cnJlbnQgdmlldz9cbiAgICAgICAgZGF0ZS52YWx1ZU9mKCkgPT09IGN1cnJlbnRTdGFydC52YWx1ZU9mKCkgfHxcbiAgICAgICAgICAgIC8vIGEgbW9udGgtc3RhcnQgdGhhdCdzIHdpdGhpbiB0aGUgY3VycmVudCByYW5nZT9cbiAgICAgICAgICAgIChkYXRlRW52LmdldERheShkYXRlKSA9PT0gMSAmJiBkYXRlLnZhbHVlT2YoKSA8IGN1cnJlbnRFbmQudmFsdWVPZigpKSk7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlU2VnS2V5KHNlZykge1xuICAgIHJldHVybiBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkICsgJzonICsgc2VnLmZpcnN0Q29sO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVTZWdVaWQoc2VnKSB7XG4gICAgcmV0dXJuIGdlbmVyYXRlU2VnS2V5KHNlZykgKyAnOicgKyBzZWcubGFzdENvbDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVGZ1NlZ1BsYWNlbWVudChzZWdzLCAvLyBhc3N1bWVkIGFscmVhZHkgc29ydGVkXG5kYXlNYXhFdmVudHMsIGRheU1heEV2ZW50Um93cywgc3RyaWN0T3JkZXIsIHNlZ0hlaWdodHMsIG1heENvbnRlbnRIZWlnaHQsIGNlbGxzKSB7XG4gICAgbGV0IGhpZXJhcmNoeSA9IG5ldyBEYXlHcmlkU2VnSGllcmFyY2h5KChzZWdFbnRyeSkgPT4ge1xuICAgICAgICAvLyBUT0RPOiBtb3JlIERSWSB3aXRoIGdlbmVyYXRlU2VnVWlkXG4gICAgICAgIGxldCBzZWdVaWQgPSBzZWdzW3NlZ0VudHJ5LmluZGV4XS5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQgK1xuICAgICAgICAgICAgJzonICsgc2VnRW50cnkuc3Bhbi5zdGFydCArXG4gICAgICAgICAgICAnOicgKyAoc2VnRW50cnkuc3Bhbi5lbmQgLSAxKTtcbiAgICAgICAgLy8gaWYgbm8gdGhpY2tuZXNzIGtub3duLCBhc3N1bWUgMSAoaWYgMCwgc28gc21hbGwgaXQgYWx3YXlzIGZpdHMpXG4gICAgICAgIHJldHVybiBzZWdIZWlnaHRzW3NlZ1VpZF0gfHwgMTtcbiAgICB9KTtcbiAgICBoaWVyYXJjaHkuYWxsb3dSZXNsaWNpbmcgPSB0cnVlO1xuICAgIGhpZXJhcmNoeS5zdHJpY3RPcmRlciA9IHN0cmljdE9yZGVyO1xuICAgIGlmIChkYXlNYXhFdmVudHMgPT09IHRydWUgfHwgZGF5TWF4RXZlbnRSb3dzID09PSB0cnVlKSB7XG4gICAgICAgIGhpZXJhcmNoeS5tYXhDb29yZCA9IG1heENvbnRlbnRIZWlnaHQ7XG4gICAgICAgIGhpZXJhcmNoeS5oaWRkZW5Db25zdW1lcyA9IHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkYXlNYXhFdmVudHMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGhpZXJhcmNoeS5tYXhTdGFja0NudCA9IGRheU1heEV2ZW50cztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRheU1heEV2ZW50Um93cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaGllcmFyY2h5Lm1heFN0YWNrQ250ID0gZGF5TWF4RXZlbnRSb3dzO1xuICAgICAgICBoaWVyYXJjaHkuaGlkZGVuQ29uc3VtZXMgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBjcmVhdGUgc2VnSW5wdXRzIG9ubHkgZm9yIHNlZ3Mgd2l0aCBrbm93biBoZWlnaHRzXG4gICAgbGV0IHNlZ0lucHV0cyA9IFtdO1xuICAgIGxldCB1bmtub3duSGVpZ2h0U2VncyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBsZXQgc2VnID0gc2Vnc1tpXTtcbiAgICAgICAgbGV0IHNlZ1VpZCA9IGdlbmVyYXRlU2VnVWlkKHNlZyk7XG4gICAgICAgIGxldCBldmVudEhlaWdodCA9IHNlZ0hlaWdodHNbc2VnVWlkXTtcbiAgICAgICAgaWYgKGV2ZW50SGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNlZ0lucHV0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICBzcGFuOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzZWcuZmlyc3RDb2wsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogc2VnLmxhc3RDb2wgKyAxLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVua25vd25IZWlnaHRTZWdzLnB1c2goc2VnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgaGlkZGVuRW50cmllcyA9IGhpZXJhcmNoeS5hZGRTZWdzKHNlZ0lucHV0cyk7XG4gICAgbGV0IHNlZ1JlY3RzID0gaGllcmFyY2h5LnRvUmVjdHMoKTtcbiAgICBsZXQgeyBzaW5nbGVDb2xQbGFjZW1lbnRzLCBtdWx0aUNvbFBsYWNlbWVudHMsIGxlZnRvdmVyTWFyZ2lucyB9ID0gcGxhY2VSZWN0cyhzZWdSZWN0cywgc2VncywgY2VsbHMpO1xuICAgIGxldCBtb3JlQ250cyA9IFtdO1xuICAgIGxldCBtb3JlTWFyZ2luVG9wcyA9IFtdO1xuICAgIC8vIGFkZCBzZWdzIHdpdGggdW5rbm93biBoZWlnaHRzXG4gICAgZm9yIChsZXQgc2VnIG9mIHVua25vd25IZWlnaHRTZWdzKSB7XG4gICAgICAgIG11bHRpQ29sUGxhY2VtZW50c1tzZWcuZmlyc3RDb2xdLnB1c2goe1xuICAgICAgICAgICAgc2VnLFxuICAgICAgICAgICAgaXNWaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGlzQWJzb2x1dGU6IHRydWUsXG4gICAgICAgICAgICBhYnNvbHV0ZVRvcDogMCxcbiAgICAgICAgICAgIG1hcmdpblRvcDogMCxcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAobGV0IGNvbCA9IHNlZy5maXJzdENvbDsgY29sIDw9IHNlZy5sYXN0Q29sOyBjb2wgKz0gMSkge1xuICAgICAgICAgICAgc2luZ2xlQ29sUGxhY2VtZW50c1tjb2xdLnB1c2goe1xuICAgICAgICAgICAgICAgIHNlZzogcmVzbGljZVNlZyhzZWcsIGNvbCwgY29sICsgMSwgY2VsbHMpLFxuICAgICAgICAgICAgICAgIGlzVmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNBYnNvbHV0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgYWJzb2x1dGVUb3A6IDAsXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wOiAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYWRkIHRoZSBoaWRkZW4gZW50cmllc1xuICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNlbGxzLmxlbmd0aDsgY29sICs9IDEpIHtcbiAgICAgICAgbW9yZUNudHMucHVzaCgwKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaGlkZGVuRW50cnkgb2YgaGlkZGVuRW50cmllcykge1xuICAgICAgICBsZXQgc2VnID0gc2Vnc1toaWRkZW5FbnRyeS5pbmRleF07XG4gICAgICAgIGxldCBoaWRkZW5TcGFuID0gaGlkZGVuRW50cnkuc3BhbjtcbiAgICAgICAgbXVsdGlDb2xQbGFjZW1lbnRzW2hpZGRlblNwYW4uc3RhcnRdLnB1c2goe1xuICAgICAgICAgICAgc2VnOiByZXNsaWNlU2VnKHNlZywgaGlkZGVuU3Bhbi5zdGFydCwgaGlkZGVuU3Bhbi5lbmQsIGNlbGxzKSxcbiAgICAgICAgICAgIGlzVmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBpc0Fic29sdXRlOiB0cnVlLFxuICAgICAgICAgICAgYWJzb2x1dGVUb3A6IDAsXG4gICAgICAgICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGxldCBjb2wgPSBoaWRkZW5TcGFuLnN0YXJ0OyBjb2wgPCBoaWRkZW5TcGFuLmVuZDsgY29sICs9IDEpIHtcbiAgICAgICAgICAgIG1vcmVDbnRzW2NvbF0gKz0gMTtcbiAgICAgICAgICAgIHNpbmdsZUNvbFBsYWNlbWVudHNbY29sXS5wdXNoKHtcbiAgICAgICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCBjb2wsIGNvbCArIDEsIGNlbGxzKSxcbiAgICAgICAgICAgICAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzQWJzb2x1dGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFic29sdXRlVG9wOiAwLFxuICAgICAgICAgICAgICAgIG1hcmdpblRvcDogMCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGRlYWwgd2l0aCBsZWZ0b3ZlciBtYXJnaW5zXG4gICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY2VsbHMubGVuZ3RoOyBjb2wgKz0gMSkge1xuICAgICAgICBtb3JlTWFyZ2luVG9wcy5wdXNoKGxlZnRvdmVyTWFyZ2luc1tjb2xdKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2luZ2xlQ29sUGxhY2VtZW50cywgbXVsdGlDb2xQbGFjZW1lbnRzLCBtb3JlQ250cywgbW9yZU1hcmdpblRvcHMgfTtcbn1cbi8vIHJlY3RzIG9yZGVyZWQgYnkgdG9wIGNvb3JkLCB0aGVuIGxlZnRcbmZ1bmN0aW9uIHBsYWNlUmVjdHMoYWxsUmVjdHMsIHNlZ3MsIGNlbGxzKSB7XG4gICAgbGV0IHJlY3RzQnlFYWNoQ29sID0gZ3JvdXBSZWN0c0J5RWFjaENvbChhbGxSZWN0cywgY2VsbHMubGVuZ3RoKTtcbiAgICBsZXQgc2luZ2xlQ29sUGxhY2VtZW50cyA9IFtdO1xuICAgIGxldCBtdWx0aUNvbFBsYWNlbWVudHMgPSBbXTtcbiAgICBsZXQgbGVmdG92ZXJNYXJnaW5zID0gW107XG4gICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY2VsbHMubGVuZ3RoOyBjb2wgKz0gMSkge1xuICAgICAgICBsZXQgcmVjdHMgPSByZWN0c0J5RWFjaENvbFtjb2xdO1xuICAgICAgICAvLyBjb21wdXRlIGFsbCBzdGF0aWMgc2VncyBpbiBzaW5nbGVQbGFjZW1lbnRzXG4gICAgICAgIGxldCBzaW5nbGVQbGFjZW1lbnRzID0gW107XG4gICAgICAgIGxldCBjdXJyZW50SGVpZ2h0ID0gMDtcbiAgICAgICAgbGV0IGN1cnJlbnRNYXJnaW5Ub3AgPSAwO1xuICAgICAgICBmb3IgKGxldCByZWN0IG9mIHJlY3RzKSB7XG4gICAgICAgICAgICBsZXQgc2VnID0gc2Vnc1tyZWN0LmluZGV4XTtcbiAgICAgICAgICAgIHNpbmdsZVBsYWNlbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgc2VnOiByZXNsaWNlU2VnKHNlZywgY29sLCBjb2wgKyAxLCBjZWxscyksXG4gICAgICAgICAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzQWJzb2x1dGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFic29sdXRlVG9wOiByZWN0LmxldmVsQ29vcmQsXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wOiByZWN0LmxldmVsQ29vcmQgLSBjdXJyZW50SGVpZ2h0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjdXJyZW50SGVpZ2h0ID0gcmVjdC5sZXZlbENvb3JkICsgcmVjdC50aGlja25lc3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29tcHV0ZSBtaXhlZCBzdGF0aWMvYWJzb2x1dGUgc2VncyBpbiBtdWx0aVBsYWNlbWVudHNcbiAgICAgICAgbGV0IG11bHRpUGxhY2VtZW50cyA9IFtdO1xuICAgICAgICBjdXJyZW50SGVpZ2h0ID0gMDtcbiAgICAgICAgY3VycmVudE1hcmdpblRvcCA9IDA7XG4gICAgICAgIGZvciAobGV0IHJlY3Qgb2YgcmVjdHMpIHtcbiAgICAgICAgICAgIGxldCBzZWcgPSBzZWdzW3JlY3QuaW5kZXhdO1xuICAgICAgICAgICAgbGV0IGlzQWJzb2x1dGUgPSByZWN0LnNwYW4uZW5kIC0gcmVjdC5zcGFuLnN0YXJ0ID4gMTsgLy8gbXVsdGktY29sdW1uP1xuICAgICAgICAgICAgbGV0IGlzRmlyc3RDb2wgPSByZWN0LnNwYW4uc3RhcnQgPT09IGNvbDtcbiAgICAgICAgICAgIGN1cnJlbnRNYXJnaW5Ub3AgKz0gcmVjdC5sZXZlbENvb3JkIC0gY3VycmVudEhlaWdodDsgLy8gYW1vdW50IG9mIHNwYWNlIHNpbmNlIGJvdHRvbSBvZiBwcmV2aW91cyBzZWdcbiAgICAgICAgICAgIGN1cnJlbnRIZWlnaHQgPSByZWN0LmxldmVsQ29vcmQgKyByZWN0LnRoaWNrbmVzczsgLy8gaGVpZ2h0IHdpbGwgbm93IGJlIGJvdHRvbSBvZiBjdXJyZW50IHNlZ1xuICAgICAgICAgICAgaWYgKGlzQWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TWFyZ2luVG9wICs9IHJlY3QudGhpY2tuZXNzO1xuICAgICAgICAgICAgICAgIGlmIChpc0ZpcnN0Q29sKSB7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpUGxhY2VtZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzogcmVzbGljZVNlZyhzZWcsIHJlY3Quc3Bhbi5zdGFydCwgcmVjdC5zcGFuLmVuZCwgY2VsbHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBYnNvbHV0ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFic29sdXRlVG9wOiByZWN0LmxldmVsQ29vcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRmlyc3RDb2wpIHtcbiAgICAgICAgICAgICAgICBtdWx0aVBsYWNlbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHNlZzogcmVzbGljZVNlZyhzZWcsIHJlY3Quc3Bhbi5zdGFydCwgcmVjdC5zcGFuLmVuZCwgY2VsbHMpLFxuICAgICAgICAgICAgICAgICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGlzQWJzb2x1dGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZVRvcDogcmVjdC5sZXZlbENvb3JkLFxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IGN1cnJlbnRNYXJnaW5Ub3AsIC8vIGNsYWltIHRoZSBtYXJnaW5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjdXJyZW50TWFyZ2luVG9wID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzaW5nbGVDb2xQbGFjZW1lbnRzLnB1c2goc2luZ2xlUGxhY2VtZW50cyk7XG4gICAgICAgIG11bHRpQ29sUGxhY2VtZW50cy5wdXNoKG11bHRpUGxhY2VtZW50cyk7XG4gICAgICAgIGxlZnRvdmVyTWFyZ2lucy5wdXNoKGN1cnJlbnRNYXJnaW5Ub3ApO1xuICAgIH1cbiAgICByZXR1cm4geyBzaW5nbGVDb2xQbGFjZW1lbnRzLCBtdWx0aUNvbFBsYWNlbWVudHMsIGxlZnRvdmVyTWFyZ2lucyB9O1xufVxuZnVuY3Rpb24gZ3JvdXBSZWN0c0J5RWFjaENvbChyZWN0cywgY29sQ250KSB7XG4gICAgbGV0IHJlY3RzQnlFYWNoQ29sID0gW107XG4gICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sQ250OyBjb2wgKz0gMSkge1xuICAgICAgICByZWN0c0J5RWFjaENvbC5wdXNoKFtdKTtcbiAgICB9XG4gICAgZm9yIChsZXQgcmVjdCBvZiByZWN0cykge1xuICAgICAgICBmb3IgKGxldCBjb2wgPSByZWN0LnNwYW4uc3RhcnQ7IGNvbCA8IHJlY3Quc3Bhbi5lbmQ7IGNvbCArPSAxKSB7XG4gICAgICAgICAgICByZWN0c0J5RWFjaENvbFtjb2xdLnB1c2gocmVjdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlY3RzQnlFYWNoQ29sO1xufVxuZnVuY3Rpb24gcmVzbGljZVNlZyhzZWcsIHNwYW5TdGFydCwgc3BhbkVuZCwgY2VsbHMpIHtcbiAgICBpZiAoc2VnLmZpcnN0Q29sID09PSBzcGFuU3RhcnQgJiYgc2VnLmxhc3RDb2wgPT09IHNwYW5FbmQgLSAxKSB7XG4gICAgICAgIHJldHVybiBzZWc7XG4gICAgfVxuICAgIGxldCBldmVudFJhbmdlID0gc2VnLmV2ZW50UmFuZ2U7XG4gICAgbGV0IG9yaWdSYW5nZSA9IGV2ZW50UmFuZ2UucmFuZ2U7XG4gICAgbGV0IHNsaWNlZFJhbmdlID0gaW50ZXJzZWN0UmFuZ2VzKG9yaWdSYW5nZSwge1xuICAgICAgICBzdGFydDogY2VsbHNbc3BhblN0YXJ0XS5kYXRlLFxuICAgICAgICBlbmQ6IGFkZERheXMoY2VsbHNbc3BhbkVuZCAtIDFdLmRhdGUsIDEpLFxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNlZyksIHsgZmlyc3RDb2w6IHNwYW5TdGFydCwgbGFzdENvbDogc3BhbkVuZCAtIDEsIGV2ZW50UmFuZ2U6IHtcbiAgICAgICAgICAgIGRlZjogZXZlbnRSYW5nZS5kZWYsXG4gICAgICAgICAgICB1aTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldmVudFJhbmdlLnVpKSwgeyBkdXJhdGlvbkVkaXRhYmxlOiBmYWxzZSB9KSxcbiAgICAgICAgICAgIGluc3RhbmNlOiBldmVudFJhbmdlLmluc3RhbmNlLFxuICAgICAgICAgICAgcmFuZ2U6IHNsaWNlZFJhbmdlLFxuICAgICAgICB9LCBpc1N0YXJ0OiBzZWcuaXNTdGFydCAmJiBzbGljZWRSYW5nZS5zdGFydC52YWx1ZU9mKCkgPT09IG9yaWdSYW5nZS5zdGFydC52YWx1ZU9mKCksIGlzRW5kOiBzZWcuaXNFbmQgJiYgc2xpY2VkUmFuZ2UuZW5kLnZhbHVlT2YoKSA9PT0gb3JpZ1JhbmdlLmVuZC52YWx1ZU9mKCkgfSk7XG59XG5jbGFzcyBEYXlHcmlkU2VnSGllcmFyY2h5IGV4dGVuZHMgU2VnSGllcmFyY2h5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLy8gY29uZmlnXG4gICAgICAgIHRoaXMuaGlkZGVuQ29uc3VtZXMgPSBmYWxzZTtcbiAgICAgICAgLy8gYWxsb3dzIHVzIHRvIGtlZXAgaGlkZGVuIGVudHJpZXMgaW4gdGhlIGhpZXJhcmNoeSBzbyB0aGV5IHRha2UgdXAgc3BhY2VcbiAgICAgICAgdGhpcy5mb3JjZUhpZGRlbiA9IHt9O1xuICAgIH1cbiAgICBhZGRTZWdzKHNlZ0lucHV0cykge1xuICAgICAgICBjb25zdCBoaWRkZW5TZWdzID0gc3VwZXIuYWRkU2VncyhzZWdJbnB1dHMpO1xuICAgICAgICBjb25zdCB7IGVudHJpZXNCeUxldmVsIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBleGNsdWRlSGlkZGVuID0gKGVudHJ5KSA9PiAhdGhpcy5mb3JjZUhpZGRlbltidWlsZEVudHJ5S2V5KGVudHJ5KV07XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgZm9yY2VkLWhpZGRlbiBzZWdzXG4gICAgICAgIGZvciAobGV0IGxldmVsID0gMDsgbGV2ZWwgPCBlbnRyaWVzQnlMZXZlbC5sZW5ndGg7IGxldmVsICs9IDEpIHtcbiAgICAgICAgICAgIGVudHJpZXNCeUxldmVsW2xldmVsXSA9IGVudHJpZXNCeUxldmVsW2xldmVsXS5maWx0ZXIoZXhjbHVkZUhpZGRlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpZGRlblNlZ3M7XG4gICAgfVxuICAgIGhhbmRsZUludmFsaWRJbnNlcnRpb24oaW5zZXJ0aW9uLCBlbnRyeSwgaGlkZGVuRW50cmllcykge1xuICAgICAgICBjb25zdCB7IGVudHJpZXNCeUxldmVsLCBmb3JjZUhpZGRlbiB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB0b3VjaGluZ0VudHJ5LCB0b3VjaGluZ0xldmVsLCB0b3VjaGluZ0xhdGVyYWwgfSA9IGluc2VydGlvbjtcbiAgICAgICAgLy8gdGhlIGVudHJ5IHRoYXQgdGhlIG5ldyBpbnNlcnRpb24gaXMgdG91Y2hpbmcgbXVzdCBiZSBoaWRkZW5cbiAgICAgICAgaWYgKHRoaXMuaGlkZGVuQ29uc3VtZXMgJiYgdG91Y2hpbmdFbnRyeSkge1xuICAgICAgICAgICAgY29uc3QgdG91Y2hpbmdFbnRyeUlkID0gYnVpbGRFbnRyeUtleSh0b3VjaGluZ0VudHJ5KTtcbiAgICAgICAgICAgIGlmICghZm9yY2VIaWRkZW5bdG91Y2hpbmdFbnRyeUlkXSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFsbG93UmVzbGljaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNwbGl0IHVwIHRoZSB0b3VjaGluZ0VudHJ5LCByZWluc2VydCBpdFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoaWRkZW5FbnRyeSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdG91Y2hpbmdFbnRyeSksIHsgc3BhbjogaW50ZXJzZWN0U3BhbnModG91Y2hpbmdFbnRyeS5zcGFuLCBlbnRyeS5zcGFuKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVpbnNlcnQgdGhlIGFyZWEgdGhhdCB0dXJuZWQgaW50byBhIFwibW9yZVwiIGxpbmsgKHNvIG5vIG90aGVyIGVudHJpZXMgdHJ5IHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIG9jY3VweSB0aGUgc3BhY2UpIGJ1dCBtYXJrIGl0IGZvcmNlZC1oaWRkZW5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGlkZGVuRW50cnlJZCA9IGJ1aWxkRW50cnlLZXkoaGlkZGVuRW50cnkpO1xuICAgICAgICAgICAgICAgICAgICBmb3JjZUhpZGRlbltoaWRkZW5FbnRyeUlkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGVudHJpZXNCeUxldmVsW3RvdWNoaW5nTGV2ZWxdW3RvdWNoaW5nTGF0ZXJhbF0gPSBoaWRkZW5FbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuRW50cmllcy5wdXNoKGhpZGRlbkVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGxpdEVudHJ5KHRvdWNoaW5nRW50cnksIGVudHJ5LCBoaWRkZW5FbnRyaWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcmNlSGlkZGVuW3RvdWNoaW5nRW50cnlJZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBoaWRkZW5FbnRyaWVzLnB1c2godG91Y2hpbmdFbnRyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHdpbGwgdHJ5IHRvIHJlc2xpY2UuLi5cbiAgICAgICAgc3VwZXIuaGFuZGxlSW52YWxpZEluc2VydGlvbihpbnNlcnRpb24sIGVudHJ5LCBoaWRkZW5FbnRyaWVzKTtcbiAgICB9XG59XG5cbmNsYXNzIFRhYmxlUm93IGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuY2VsbEVsUmVmcyA9IG5ldyBSZWZNYXAoKTsgLy8gdGhlIDx0ZD5cbiAgICAgICAgdGhpcy5mcmFtZUVsUmVmcyA9IG5ldyBSZWZNYXAoKTsgLy8gdGhlIGZjLWRheWdyaWQtZGF5LWZyYW1lXG4gICAgICAgIHRoaXMuZmdFbFJlZnMgPSBuZXcgUmVmTWFwKCk7IC8vIHRoZSBmYy1kYXlncmlkLWRheS1ldmVudHNcbiAgICAgICAgdGhpcy5zZWdIYXJuZXNzUmVmcyA9IG5ldyBSZWZNYXAoKTsgLy8gaW5kZXhlZCBieSBcImluc3RhbmNlSWQ6Zmlyc3RDb2xcIlxuICAgICAgICB0aGlzLnJvb3RFbFJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZnJhbWVQb3NpdGlvbnM6IG51bGwsXG4gICAgICAgICAgICBtYXhDb250ZW50SGVpZ2h0OiBudWxsLFxuICAgICAgICAgICAgc2VnSGVpZ2h0czoge30sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUmVzaXplID0gKGlzRm9yY2VkKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNGb3JjZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNpemluZyh0cnVlKTsgLy8gaXNFeHRlcm5hbD10cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIHN0YXRlLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgICAgICBsZXQgY29sQ250ID0gcHJvcHMuY2VsbHMubGVuZ3RoO1xuICAgICAgICBsZXQgYnVzaW5lc3NIb3Vyc0J5Q29sID0gc3BsaXRTZWdzQnlGaXJzdENvbChwcm9wcy5idXNpbmVzc0hvdXJTZWdzLCBjb2xDbnQpO1xuICAgICAgICBsZXQgYmdFdmVudFNlZ3NCeUNvbCA9IHNwbGl0U2Vnc0J5Rmlyc3RDb2wocHJvcHMuYmdFdmVudFNlZ3MsIGNvbENudCk7XG4gICAgICAgIGxldCBoaWdobGlnaHRTZWdzQnlDb2wgPSBzcGxpdFNlZ3NCeUZpcnN0Q29sKHRoaXMuZ2V0SGlnaGxpZ2h0U2VncygpLCBjb2xDbnQpO1xuICAgICAgICBsZXQgbWlycm9yU2Vnc0J5Q29sID0gc3BsaXRTZWdzQnlGaXJzdENvbCh0aGlzLmdldE1pcnJvclNlZ3MoKSwgY29sQ250KTtcbiAgICAgICAgbGV0IHsgc2luZ2xlQ29sUGxhY2VtZW50cywgbXVsdGlDb2xQbGFjZW1lbnRzLCBtb3JlQ250cywgbW9yZU1hcmdpblRvcHMgfSA9IGNvbXB1dGVGZ1NlZ1BsYWNlbWVudChzb3J0RXZlbnRTZWdzKHByb3BzLmZnRXZlbnRTZWdzLCBvcHRpb25zLmV2ZW50T3JkZXIpLCBwcm9wcy5kYXlNYXhFdmVudHMsIHByb3BzLmRheU1heEV2ZW50Um93cywgb3B0aW9ucy5ldmVudE9yZGVyU3RyaWN0LCBzdGF0ZS5zZWdIZWlnaHRzLCBzdGF0ZS5tYXhDb250ZW50SGVpZ2h0LCBwcm9wcy5jZWxscyk7XG4gICAgICAgIGxldCBpc0ZvcmNlZEludmlzaWJsZSA9IC8vIFRPRE86IG1lc3N5IHdheSB0byBjb21wdXRlIHRoaXNcbiAgICAgICAgIChwcm9wcy5ldmVudERyYWcgJiYgcHJvcHMuZXZlbnREcmFnLmFmZmVjdGVkSW5zdGFuY2VzKSB8fFxuICAgICAgICAgICAgKHByb3BzLmV2ZW50UmVzaXplICYmIHByb3BzLmV2ZW50UmVzaXplLmFmZmVjdGVkSW5zdGFuY2VzKSB8fFxuICAgICAgICAgICAge307XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcInRyXCIsIHsgcmVmOiB0aGlzLnJvb3RFbFJlZiwgcm9sZTogXCJyb3dcIiB9LFxuICAgICAgICAgICAgcHJvcHMucmVuZGVySW50cm8gJiYgcHJvcHMucmVuZGVySW50cm8oKSxcbiAgICAgICAgICAgIHByb3BzLmNlbGxzLm1hcCgoY2VsbCwgY29sKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG5vcm1hbEZnTm9kZXMgPSB0aGlzLnJlbmRlckZnU2Vncyhjb2wsIHByb3BzLmZvclByaW50ID8gc2luZ2xlQ29sUGxhY2VtZW50c1tjb2xdIDogbXVsdGlDb2xQbGFjZW1lbnRzW2NvbF0sIHByb3BzLnRvZGF5UmFuZ2UsIGlzRm9yY2VkSW52aXNpYmxlKTtcbiAgICAgICAgICAgICAgICBsZXQgbWlycm9yRmdOb2RlcyA9IHRoaXMucmVuZGVyRmdTZWdzKGNvbCwgYnVpbGRNaXJyb3JQbGFjZW1lbnRzKG1pcnJvclNlZ3NCeUNvbFtjb2xdLCBtdWx0aUNvbFBsYWNlbWVudHMpLCBwcm9wcy50b2RheVJhbmdlLCB7fSwgQm9vbGVhbihwcm9wcy5ldmVudERyYWcpLCBCb29sZWFuKHByb3BzLmV2ZW50UmVzaXplKSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChUYWJsZUNlbGwsIHsga2V5OiBjZWxsLmtleSwgZWxSZWY6IHRoaXMuY2VsbEVsUmVmcy5jcmVhdGVSZWYoY2VsbC5rZXkpLCBpbm5lckVsUmVmOiB0aGlzLmZyYW1lRWxSZWZzLmNyZWF0ZVJlZihjZWxsLmtleSkgLyogRkYgPHRkPiBwcm9ibGVtLCBidXQgb2theSB0byB1c2UgZm9yIGxlZnQvcmlnaHQuIFRPRE86IHJlbmFtZSBwcm9wICovLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGRhdGU6IGNlbGwuZGF0ZSwgc2hvd0RheU51bWJlcjogcHJvcHMuc2hvd0RheU51bWJlcnMsIHNob3dXZWVrTnVtYmVyOiBwcm9wcy5zaG93V2Vla051bWJlcnMgJiYgY29sID09PSAwLCBmb3JjZURheVRvcDogcHJvcHMuc2hvd1dlZWtOdW1iZXJzIC8qIGV2ZW4gZGlzcGxheWluZyB3ZWVrbnVtIGZvciByb3csIG5vdCBuZWNlc3NhcmlseSBkYXkgKi8sIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZXZlbnREcmFnOiBwcm9wcy5ldmVudERyYWcsIGV2ZW50UmVzaXplOiBwcm9wcy5ldmVudFJlc2l6ZSwgZXh0cmFSZW5kZXJQcm9wczogY2VsbC5leHRyYVJlbmRlclByb3BzLCBleHRyYURhdGFBdHRyczogY2VsbC5leHRyYURhdGFBdHRycywgZXh0cmFDbGFzc05hbWVzOiBjZWxsLmV4dHJhQ2xhc3NOYW1lcywgZXh0cmFEYXRlU3BhbjogY2VsbC5leHRyYURhdGVTcGFuLCBtb3JlQ250OiBtb3JlQ250c1tjb2xdLCBtb3JlTWFyZ2luVG9wOiBtb3JlTWFyZ2luVG9wc1tjb2xdLCBzaW5nbGVQbGFjZW1lbnRzOiBzaW5nbGVDb2xQbGFjZW1lbnRzW2NvbF0sIGZnQ29udGVudEVsUmVmOiB0aGlzLmZnRWxSZWZzLmNyZWF0ZVJlZihjZWxsLmtleSksIGZnQ29udGVudDogKCAvLyBGcmFnbWVudCBzY29wZXMgdGhlIGtleXNcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIG5vcm1hbEZnTm9kZXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgbWlycm9yRmdOb2RlcykpKSwgYmdDb250ZW50OiAoIC8vIEZyYWdtZW50IHNjb3BlcyB0aGUga2V5c1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGaWxsU2VncyhoaWdobGlnaHRTZWdzQnlDb2xbY29sXSwgJ2hpZ2hsaWdodCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGaWxsU2VncyhidXNpbmVzc0hvdXJzQnlDb2xbY29sXSwgJ25vbi1idXNpbmVzcycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGaWxsU2VncyhiZ0V2ZW50U2Vnc0J5Q29sW2NvbF0sICdiZy1ldmVudCcpKSksIG1pbkhlaWdodDogcHJvcHMuY2VsbE1pbkhlaWdodCB9KSk7XG4gICAgICAgICAgICB9KSkpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVTaXppbmcodHJ1ZSk7XG4gICAgICAgIHRoaXMuY29udGV4dC5hZGRSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlUmVzaXplKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgICAgIGxldCBjdXJyZW50UHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB0aGlzLnVwZGF0ZVNpemluZyghaXNQcm9wc0VxdWFsKHByZXZQcm9wcywgY3VycmVudFByb3BzKSk7XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB0aGlzLmNvbnRleHQucmVtb3ZlUmVzaXplSGFuZGxlcih0aGlzLmhhbmRsZVJlc2l6ZSk7XG4gICAgfVxuICAgIGdldEhpZ2hsaWdodFNlZ3MoKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBpZiAocHJvcHMuZXZlbnREcmFnICYmIHByb3BzLmV2ZW50RHJhZy5zZWdzLmxlbmd0aCkgeyAvLyBtZXNzeSBjaGVja1xuICAgICAgICAgICAgcmV0dXJuIHByb3BzLmV2ZW50RHJhZy5zZWdzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wcy5ldmVudFJlc2l6ZSAmJiBwcm9wcy5ldmVudFJlc2l6ZS5zZWdzLmxlbmd0aCkgeyAvLyBtZXNzeSBjaGVja1xuICAgICAgICAgICAgcmV0dXJuIHByb3BzLmV2ZW50UmVzaXplLnNlZ3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3BzLmRhdGVTZWxlY3Rpb25TZWdzO1xuICAgIH1cbiAgICBnZXRNaXJyb3JTZWdzKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgaWYgKHByb3BzLmV2ZW50UmVzaXplICYmIHByb3BzLmV2ZW50UmVzaXplLnNlZ3MubGVuZ3RoKSB7IC8vIG1lc3N5IGNoZWNrXG4gICAgICAgICAgICByZXR1cm4gcHJvcHMuZXZlbnRSZXNpemUuc2VncztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJlbmRlckZnU2Vncyhjb2wsIHNlZ1BsYWNlbWVudHMsIHRvZGF5UmFuZ2UsIGlzRm9yY2VkSW52aXNpYmxlLCBpc0RyYWdnaW5nLCBpc1Jlc2l6aW5nLCBpc0RhdGVTZWxlY3RpbmcpIHtcbiAgICAgICAgbGV0IHsgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgZXZlbnRTZWxlY3Rpb24gfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCB7IGZyYW1lUG9zaXRpb25zIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBsZXQgZGVmYXVsdERpc3BsYXlFdmVudEVuZCA9IHRoaXMucHJvcHMuY2VsbHMubGVuZ3RoID09PSAxOyAvLyBjb2xDbnQgPT09IDFcbiAgICAgICAgbGV0IGlzTWlycm9yID0gaXNEcmFnZ2luZyB8fCBpc1Jlc2l6aW5nIHx8IGlzRGF0ZVNlbGVjdGluZztcbiAgICAgICAgbGV0IG5vZGVzID0gW107XG4gICAgICAgIGlmIChmcmFtZVBvc2l0aW9ucykge1xuICAgICAgICAgICAgZm9yIChsZXQgcGxhY2VtZW50IG9mIHNlZ1BsYWNlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBzZWcgfSA9IHBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICBsZXQgeyBpbnN0YW5jZUlkIH0gPSBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZTtcbiAgICAgICAgICAgICAgICBsZXQgaXNWaXNpYmxlID0gcGxhY2VtZW50LmlzVmlzaWJsZSAmJiAhaXNGb3JjZWRJbnZpc2libGVbaW5zdGFuY2VJZF07XG4gICAgICAgICAgICAgICAgbGV0IGlzQWJzb2x1dGUgPSBwbGFjZW1lbnQuaXNBYnNvbHV0ZTtcbiAgICAgICAgICAgICAgICBsZXQgbGVmdCA9ICcnO1xuICAgICAgICAgICAgICAgIGxldCByaWdodCA9ICcnO1xuICAgICAgICAgICAgICAgIGlmIChpc0Fic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LmlzUnRsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gZnJhbWVQb3NpdGlvbnMubGVmdHNbc2VnLmxhc3RDb2xdIC0gZnJhbWVQb3NpdGlvbnMubGVmdHNbc2VnLmZpcnN0Q29sXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSBmcmFtZVBvc2l0aW9ucy5yaWdodHNbc2VnLmZpcnN0Q29sXSAtIGZyYW1lUG9zaXRpb25zLnJpZ2h0c1tzZWcubGFzdENvbF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICBrbm93biBidWc6IGV2ZW50cyB0aGF0IGFyZSBmb3JjZSB0byBiZSBsaXN0LWl0ZW0gYnV0IHNwYW4gbXVsdGlwbGUgZGF5cyBzdGlsbCB0YWtlIHVwIHNwYWNlIGluIGxhdGVyIGNvbHVtbnNcbiAgICAgICAgICAgICAgICB0b2RvOiBpbiBwcmludCB2aWV3LCBmb3IgbXVsdGktZGF5IGV2ZW50cywgZG9uJ3QgZGlzcGxheSB0aXRsZSB3aXRoaW4gbm9uLXN0YXJ0L2VuZCBzZWdzXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6ICdmYy1kYXlncmlkLWV2ZW50LWhhcm5lc3MnICsgKGlzQWJzb2x1dGUgPyAnIGZjLWRheWdyaWQtZXZlbnQtaGFybmVzcy1hYnMnIDogJycpLCBrZXk6IGdlbmVyYXRlU2VnS2V5KHNlZyksIHJlZjogaXNNaXJyb3IgPyBudWxsIDogdGhpcy5zZWdIYXJuZXNzUmVmcy5jcmVhdGVSZWYoZ2VuZXJhdGVTZWdVaWQoc2VnKSksIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBpc1Zpc2libGUgPyAnJyA6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wOiBpc0Fic29sdXRlID8gJycgOiBwbGFjZW1lbnQubWFyZ2luVG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBpc0Fic29sdXRlID8gcGxhY2VtZW50LmFic29sdXRlVG9wIDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICAgICAgICAgIH0gfSwgaGFzTGlzdEl0ZW1EaXNwbGF5KHNlZykgPyAoY3JlYXRlRWxlbWVudChUYWJsZUxpc3RJdGVtRXZlbnQsIE9iamVjdC5hc3NpZ24oeyBzZWc6IHNlZywgaXNEcmFnZ2luZzogaXNEcmFnZ2luZywgaXNTZWxlY3RlZDogaW5zdGFuY2VJZCA9PT0gZXZlbnRTZWxlY3Rpb24sIGRlZmF1bHREaXNwbGF5RXZlbnRFbmQ6IGRlZmF1bHREaXNwbGF5RXZlbnRFbmQgfSwgZ2V0U2VnTWV0YShzZWcsIHRvZGF5UmFuZ2UpKSkpIDogKGNyZWF0ZUVsZW1lbnQoVGFibGVCbG9ja0V2ZW50LCBPYmplY3QuYXNzaWduKHsgc2VnOiBzZWcsIGlzRHJhZ2dpbmc6IGlzRHJhZ2dpbmcsIGlzUmVzaXppbmc6IGlzUmVzaXppbmcsIGlzRGF0ZVNlbGVjdGluZzogaXNEYXRlU2VsZWN0aW5nLCBpc1NlbGVjdGVkOiBpbnN0YW5jZUlkID09PSBldmVudFNlbGVjdGlvbiwgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogZGVmYXVsdERpc3BsYXlFdmVudEVuZCB9LCBnZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSkpKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIHJlbmRlckZpbGxTZWdzKHNlZ3MsIGZpbGxUeXBlKSB7XG4gICAgICAgIGxldCB7IGlzUnRsIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCB7IHRvZGF5UmFuZ2UgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCB7IGZyYW1lUG9zaXRpb25zIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBsZXQgbm9kZXMgPSBbXTtcbiAgICAgICAgaWYgKGZyYW1lUG9zaXRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBzZWcgb2Ygc2Vncykge1xuICAgICAgICAgICAgICAgIGxldCBsZWZ0UmlnaHRDc3MgPSBpc1J0bCA/IHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGZyYW1lUG9zaXRpb25zLmxlZnRzW3NlZy5sYXN0Q29sXSAtIGZyYW1lUG9zaXRpb25zLmxlZnRzW3NlZy5maXJzdENvbF0sXG4gICAgICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGZyYW1lUG9zaXRpb25zLnJpZ2h0c1tzZWcuZmlyc3RDb2xdIC0gZnJhbWVQb3NpdGlvbnMucmlnaHRzW3NlZy5sYXN0Q29sXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGtleTogYnVpbGRFdmVudFJhbmdlS2V5KHNlZy5ldmVudFJhbmdlKSwgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtYmctaGFybmVzc1wiLCBzdHlsZTogbGVmdFJpZ2h0Q3NzIH0sIGZpbGxUeXBlID09PSAnYmctZXZlbnQnID9cbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChCZ0V2ZW50LCBPYmplY3QuYXNzaWduKHsgc2VnOiBzZWcgfSwgZ2V0U2VnTWV0YShzZWcsIHRvZGF5UmFuZ2UpKSkgOlxuICAgICAgICAgICAgICAgICAgICByZW5kZXJGaWxsKGZpbGxUeXBlKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCB7fSwgLi4ubm9kZXMpO1xuICAgIH1cbiAgICB1cGRhdGVTaXppbmcoaXNFeHRlcm5hbFNpemluZ0NoYW5nZSkge1xuICAgICAgICBsZXQgeyBwcm9wcywgc3RhdGUsIGZyYW1lRWxSZWZzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIXByb3BzLmZvclByaW50ICYmXG4gICAgICAgICAgICBwcm9wcy5jbGllbnRXaWR0aCAhPT0gbnVsbCAvLyBwb3NpdGlvbmluZyByZWFkeT9cbiAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoaXNFeHRlcm5hbFNpemluZ0NoYW5nZSkge1xuICAgICAgICAgICAgICAgIGxldCBmcmFtZUVscyA9IHByb3BzLmNlbGxzLm1hcCgoY2VsbCkgPT4gZnJhbWVFbFJlZnMuY3VycmVudE1hcFtjZWxsLmtleV0pO1xuICAgICAgICAgICAgICAgIGlmIChmcmFtZUVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9yaWdpbkVsID0gdGhpcy5yb290RWxSZWYuY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld1Bvc2l0aW9uQ2FjaGUgPSBuZXcgUG9zaXRpb25DYWNoZShvcmlnaW5FbCwgZnJhbWVFbHMsIHRydWUsIC8vIGlzSG9yaXpvbnRhbFxuICAgICAgICAgICAgICAgICAgICBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RhdGUuZnJhbWVQb3NpdGlvbnMgfHwgIXN0YXRlLmZyYW1lUG9zaXRpb25zLnNpbWlsYXJUbyhuZXdQb3NpdGlvbkNhY2hlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVQb3NpdGlvbnM6IG5ldyBQb3NpdGlvbkNhY2hlKG9yaWdpbkVsLCBmcmFtZUVscywgdHJ1ZSwgLy8gaXNIb3Jpem9udGFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvbGRTZWdIZWlnaHRzID0gdGhpcy5zdGF0ZS5zZWdIZWlnaHRzO1xuICAgICAgICAgICAgY29uc3QgbmV3U2VnSGVpZ2h0cyA9IHRoaXMucXVlcnlTZWdIZWlnaHRzKCk7XG4gICAgICAgICAgICBjb25zdCBsaW1pdEJ5Q29udGVudEhlaWdodCA9IHByb3BzLmRheU1heEV2ZW50cyA9PT0gdHJ1ZSB8fCBwcm9wcy5kYXlNYXhFdmVudFJvd3MgPT09IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNhZmVTZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgLy8gSEFDSyB0byBwcmV2ZW50IG9zY2lsbGF0aW9ucyBvZiBldmVudHMgYmVpbmcgc2hvd24vaGlkZGVuIGZyb20gbWF4LWV2ZW50LXJvd3NcbiAgICAgICAgICAgICAgICAvLyBFc3NlbnRpYWxseSwgb25jZSB5b3UgY29tcHV0ZSBhbiBlbGVtZW50J3MgaGVpZ2h0LCBuZXZlciBudWxsLW91dC5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBhbHdheXMgZGlzcGxheSBhbGwgZXZlbnRzLCBhcyB2aXNpYmlsaXR5OmhpZGRlbj9cbiAgICAgICAgICAgICAgICBzZWdIZWlnaHRzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9sZFNlZ0hlaWdodHMpLCBuZXdTZWdIZWlnaHRzKSxcbiAgICAgICAgICAgICAgICBtYXhDb250ZW50SGVpZ2h0OiBsaW1pdEJ5Q29udGVudEhlaWdodCA/IHRoaXMuY29tcHV0ZU1heENvbnRlbnRIZWlnaHQoKSA6IG51bGwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWVyeVNlZ0hlaWdodHMoKSB7XG4gICAgICAgIGxldCBzZWdFbE1hcCA9IHRoaXMuc2VnSGFybmVzc1JlZnMuY3VycmVudE1hcDtcbiAgICAgICAgbGV0IHNlZ0hlaWdodHMgPSB7fTtcbiAgICAgICAgLy8gZ2V0IHRoZSBtYXggaGVpZ2h0IGFtb25nc3QgaW5zdGFuY2Ugc2Vnc1xuICAgICAgICBmb3IgKGxldCBzZWdVaWQgaW4gc2VnRWxNYXApIHtcbiAgICAgICAgICAgIGxldCBoZWlnaHQgPSBNYXRoLnJvdW5kKHNlZ0VsTWFwW3NlZ1VpZF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0KTtcbiAgICAgICAgICAgIHNlZ0hlaWdodHNbc2VnVWlkXSA9IE1hdGgubWF4KHNlZ0hlaWdodHNbc2VnVWlkXSB8fCAwLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdIZWlnaHRzO1xuICAgIH1cbiAgICBjb21wdXRlTWF4Q29udGVudEhlaWdodCgpIHtcbiAgICAgICAgbGV0IGZpcnN0S2V5ID0gdGhpcy5wcm9wcy5jZWxsc1swXS5rZXk7XG4gICAgICAgIGxldCBjZWxsRWwgPSB0aGlzLmNlbGxFbFJlZnMuY3VycmVudE1hcFtmaXJzdEtleV07XG4gICAgICAgIGxldCBmY0NvbnRhaW5lckVsID0gdGhpcy5mZ0VsUmVmcy5jdXJyZW50TWFwW2ZpcnN0S2V5XTtcbiAgICAgICAgcmV0dXJuIGNlbGxFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b20gLSBmY0NvbnRhaW5lckVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgICB9XG4gICAgZ2V0Q2VsbEVscygpIHtcbiAgICAgICAgbGV0IGVsTWFwID0gdGhpcy5jZWxsRWxSZWZzLmN1cnJlbnRNYXA7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNlbGxzLm1hcCgoY2VsbCkgPT4gZWxNYXBbY2VsbC5rZXldKTtcbiAgICB9XG59XG5UYWJsZVJvdy5hZGRTdGF0ZUVxdWFsaXR5KHtcbiAgICBzZWdIZWlnaHRzOiBpc1Byb3BzRXF1YWwsXG59KTtcbmZ1bmN0aW9uIGJ1aWxkTWlycm9yUGxhY2VtZW50cyhtaXJyb3JTZWdzLCBjb2xQbGFjZW1lbnRzKSB7XG4gICAgaWYgKCFtaXJyb3JTZWdzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGxldCB0b3BzQnlJbnN0YW5jZUlkID0gYnVpbGRBYnNvbHV0ZVRvcEhhc2goY29sUGxhY2VtZW50cyk7IC8vIFRPRE86IGNhY2hlIHRoaXMgYXQgZmlyc3QgcmVuZGVyP1xuICAgIHJldHVybiBtaXJyb3JTZWdzLm1hcCgoc2VnKSA9PiAoe1xuICAgICAgICBzZWcsXG4gICAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgaXNBYnNvbHV0ZTogdHJ1ZSxcbiAgICAgICAgYWJzb2x1dGVUb3A6IHRvcHNCeUluc3RhbmNlSWRbc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZF0sXG4gICAgICAgIG1hcmdpblRvcDogMCxcbiAgICB9KSk7XG59XG5mdW5jdGlvbiBidWlsZEFic29sdXRlVG9wSGFzaChjb2xQbGFjZW1lbnRzKSB7XG4gICAgbGV0IHRvcHNCeUluc3RhbmNlSWQgPSB7fTtcbiAgICBmb3IgKGxldCBwbGFjZW1lbnRzIG9mIGNvbFBsYWNlbWVudHMpIHtcbiAgICAgICAgZm9yIChsZXQgcGxhY2VtZW50IG9mIHBsYWNlbWVudHMpIHtcbiAgICAgICAgICAgIHRvcHNCeUluc3RhbmNlSWRbcGxhY2VtZW50LnNlZy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWRdID0gcGxhY2VtZW50LmFic29sdXRlVG9wO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b3BzQnlJbnN0YW5jZUlkO1xufVxuXG5jbGFzcyBUYWJsZVJvd3MgZXh0ZW5kcyBEYXRlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zcGxpdEJ1c2luZXNzSG91clNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Um93KTtcbiAgICAgICAgdGhpcy5zcGxpdEJnRXZlbnRTZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeVJvdyk7XG4gICAgICAgIHRoaXMuc3BsaXRGZ0V2ZW50U2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlSb3cpO1xuICAgICAgICB0aGlzLnNwbGl0RGF0ZVNlbGVjdGlvblNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Um93KTtcbiAgICAgICAgdGhpcy5zcGxpdEV2ZW50RHJhZyA9IG1lbW9pemUoc3BsaXRJbnRlcmFjdGlvbkJ5Um93KTtcbiAgICAgICAgdGhpcy5zcGxpdEV2ZW50UmVzaXplID0gbWVtb2l6ZShzcGxpdEludGVyYWN0aW9uQnlSb3cpO1xuICAgICAgICB0aGlzLnJvd1JlZnMgPSBuZXcgUmVmTWFwKCk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCByb3dDbnQgPSBwcm9wcy5jZWxscy5sZW5ndGg7XG4gICAgICAgIGxldCBidXNpbmVzc0hvdXJTZWdzQnlSb3cgPSB0aGlzLnNwbGl0QnVzaW5lc3NIb3VyU2Vncyhwcm9wcy5idXNpbmVzc0hvdXJTZWdzLCByb3dDbnQpO1xuICAgICAgICBsZXQgYmdFdmVudFNlZ3NCeVJvdyA9IHRoaXMuc3BsaXRCZ0V2ZW50U2Vncyhwcm9wcy5iZ0V2ZW50U2Vncywgcm93Q250KTtcbiAgICAgICAgbGV0IGZnRXZlbnRTZWdzQnlSb3cgPSB0aGlzLnNwbGl0RmdFdmVudFNlZ3MocHJvcHMuZmdFdmVudFNlZ3MsIHJvd0NudCk7XG4gICAgICAgIGxldCBkYXRlU2VsZWN0aW9uU2Vnc0J5Um93ID0gdGhpcy5zcGxpdERhdGVTZWxlY3Rpb25TZWdzKHByb3BzLmRhdGVTZWxlY3Rpb25TZWdzLCByb3dDbnQpO1xuICAgICAgICBsZXQgZXZlbnREcmFnQnlSb3cgPSB0aGlzLnNwbGl0RXZlbnREcmFnKHByb3BzLmV2ZW50RHJhZywgcm93Q250KTtcbiAgICAgICAgbGV0IGV2ZW50UmVzaXplQnlSb3cgPSB0aGlzLnNwbGl0RXZlbnRSZXNpemUocHJvcHMuZXZlbnRSZXNpemUsIHJvd0NudCk7XG4gICAgICAgIC8vIGZvciBEYXlHcmlkIHZpZXcgd2l0aCBtYW55IHJvd3MsIGZvcmNlIGEgbWluLWhlaWdodCBvbiBjZWxscyBzbyBkb2Vzbid0IGFwcGVhciBzcXVpc2hlZFxuICAgICAgICAvLyBjaG9vc2UgNyBiZWNhdXNlIGEgbW9udGggdmlldyB3aWxsIGhhdmUgbWF4IDYgcm93c1xuICAgICAgICBsZXQgY2VsbE1pbkhlaWdodCA9IChyb3dDbnQgPj0gNyAmJiBwcm9wcy5jbGllbnRXaWR0aCkgP1xuICAgICAgICAgICAgcHJvcHMuY2xpZW50V2lkdGggLyBjb250ZXh0Lm9wdGlvbnMuYXNwZWN0UmF0aW8gLyA2IDpcbiAgICAgICAgICAgIG51bGw7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChOb3dUaW1lciwgeyB1bml0OiBcImRheVwiIH0sIChub3dEYXRlLCB0b2RheVJhbmdlKSA9PiAoY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgcHJvcHMuY2VsbHMubWFwKChjZWxscywgcm93KSA9PiAoY3JlYXRlRWxlbWVudChUYWJsZVJvdywgeyByZWY6IHRoaXMucm93UmVmcy5jcmVhdGVSZWYocm93KSwga2V5OiBjZWxscy5sZW5ndGhcbiAgICAgICAgICAgICAgICA/IGNlbGxzWzBdLmRhdGUudG9JU09TdHJpbmcoKSAvKiBiZXN0PyBvciBwdXQga2V5IG9uIGNlbGw/IG9yIHVzZSBkaWZmIGZvcm1hdHRlcj8gKi9cbiAgICAgICAgICAgICAgICA6IHJvdyAvLyBpbiBjYXNlIHRoZXJlIGFyZSBubyBjZWxscyAobGlrZSB3aGVuIHJlc291cmNlIHZpZXcgaXMgbG9hZGluZylcbiAgICAgICAgICAgICwgc2hvd0RheU51bWJlcnM6IHJvd0NudCA+IDEsIHNob3dXZWVrTnVtYmVyczogcHJvcHMuc2hvd1dlZWtOdW1iZXJzLCB0b2RheVJhbmdlOiB0b2RheVJhbmdlLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGNlbGxzOiBjZWxscywgcmVuZGVySW50cm86IHByb3BzLnJlbmRlclJvd0ludHJvLCBidXNpbmVzc0hvdXJTZWdzOiBidXNpbmVzc0hvdXJTZWdzQnlSb3dbcm93XSwgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBiZ0V2ZW50U2VnczogYmdFdmVudFNlZ3NCeVJvd1tyb3ddLmZpbHRlcihpc1NlZ0FsbERheSkgLyogaGFjayAqLywgZmdFdmVudFNlZ3M6IGZnRXZlbnRTZWdzQnlSb3dbcm93XSwgZGF0ZVNlbGVjdGlvblNlZ3M6IGRhdGVTZWxlY3Rpb25TZWdzQnlSb3dbcm93XSwgZXZlbnREcmFnOiBldmVudERyYWdCeVJvd1tyb3ddLCBldmVudFJlc2l6ZTogZXZlbnRSZXNpemVCeVJvd1tyb3ddLCBkYXlNYXhFdmVudHM6IHByb3BzLmRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzOiBwcm9wcy5kYXlNYXhFdmVudFJvd3MsIGNsaWVudFdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0OiBwcm9wcy5jbGllbnRIZWlnaHQsIGNlbGxNaW5IZWlnaHQ6IGNlbGxNaW5IZWlnaHQsIGZvclByaW50OiBwcm9wcy5mb3JQcmludCB9KSkpKSkpKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCgpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIC8vIGZvciBpZiBzdGFydGVkIHdpdGggemVybyBjZWxsc1xuICAgICAgICB0aGlzLnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQoKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJvb3RFbCkge1xuICAgICAgICAgICAgLy8gSEFDSzogbmVlZCBhIGRheWdyaWQgd3JhcHBlciBwYXJlbnQgdG8gZG8gcG9zaXRpb25pbmdcbiAgICAgICAgICAgIC8vIE5PVEU6IGEgZGF5Z3JpZCByZXNvdXJjZSB2aWV3IHcvbyByZXNvdXJjZXMgY2FuIGhhdmUgemVybyBjZWxsc1xuICAgICAgICAgICAgY29uc3QgZmlyc3RDZWxsRWwgPSB0aGlzLnJvd1JlZnMuY3VycmVudE1hcFswXS5nZXRDZWxsRWxzKClbMF07XG4gICAgICAgICAgICBjb25zdCByb290RWwgPSBmaXJzdENlbGxFbCA/IGZpcnN0Q2VsbEVsLmNsb3Nlc3QoJy5mYy1kYXlncmlkLWJvZHknKSA6IG51bGw7XG4gICAgICAgICAgICBpZiAocm9vdEVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290RWwgPSByb290RWw7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQodGhpcywge1xuICAgICAgICAgICAgICAgICAgICBlbDogcm9vdEVsLFxuICAgICAgICAgICAgICAgICAgICBpc0hpdENvbWJvQWxsb3dlZDogdGhpcy5wcm9wcy5pc0hpdENvbWJvQWxsb3dlZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMucm9vdEVsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQudW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5yb290RWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEhpdCBTeXN0ZW1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgcHJlcGFyZUhpdHMoKSB7XG4gICAgICAgIHRoaXMucm93UG9zaXRpb25zID0gbmV3IFBvc2l0aW9uQ2FjaGUodGhpcy5yb290RWwsIHRoaXMucm93UmVmcy5jb2xsZWN0KCkubWFwKChyb3dPYmopID0+IHJvd09iai5nZXRDZWxsRWxzKClbMF0pLCAvLyBmaXJzdCBjZWxsIGVsIGluIGVhY2ggcm93LiBUT0RPOiBub3Qgb3B0aW1hbFxuICAgICAgICBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuY29sUG9zaXRpb25zID0gbmV3IFBvc2l0aW9uQ2FjaGUodGhpcy5yb290RWwsIHRoaXMucm93UmVmcy5jdXJyZW50TWFwWzBdLmdldENlbGxFbHMoKSwgLy8gY2VsbCBlbHMgaW4gZmlyc3Qgcm93XG4gICAgICAgIHRydWUsIC8vIGhvcml6b250YWxcbiAgICAgICAgZmFsc2UpO1xuICAgIH1cbiAgICBxdWVyeUhpdChwb3NpdGlvbkxlZnQsIHBvc2l0aW9uVG9wKSB7XG4gICAgICAgIGxldCB7IGNvbFBvc2l0aW9ucywgcm93UG9zaXRpb25zIH0gPSB0aGlzO1xuICAgICAgICBsZXQgY29sID0gY29sUG9zaXRpb25zLmxlZnRUb0luZGV4KHBvc2l0aW9uTGVmdCk7XG4gICAgICAgIGxldCByb3cgPSByb3dQb3NpdGlvbnMudG9wVG9JbmRleChwb3NpdGlvblRvcCk7XG4gICAgICAgIGlmIChyb3cgIT0gbnVsbCAmJiBjb2wgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGNlbGwgPSB0aGlzLnByb3BzLmNlbGxzW3Jvd11bY29sXTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGU6IHRoaXMucHJvcHMuZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICAgICAgZGF0ZVNwYW46IE9iamVjdC5hc3NpZ24oeyByYW5nZTogdGhpcy5nZXRDZWxsUmFuZ2Uocm93LCBjb2wpLCBhbGxEYXk6IHRydWUgfSwgY2VsbC5leHRyYURhdGVTcGFuKSxcbiAgICAgICAgICAgICAgICBkYXlFbDogdGhpcy5nZXRDZWxsRWwocm93LCBjb2wpLFxuICAgICAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogY29sUG9zaXRpb25zLmxlZnRzW2NvbF0sXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBjb2xQb3NpdGlvbnMucmlnaHRzW2NvbF0sXG4gICAgICAgICAgICAgICAgICAgIHRvcDogcm93UG9zaXRpb25zLnRvcHNbcm93XSxcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tOiByb3dQb3NpdGlvbnMuYm90dG9tc1tyb3ddLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbGF5ZXI6IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXRDZWxsRWwocm93LCBjb2wpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93UmVmcy5jdXJyZW50TWFwW3Jvd10uZ2V0Q2VsbEVscygpW2NvbF07IC8vIFRPRE86IG5vdCBvcHRpbWFsXG4gICAgfVxuICAgIGdldENlbGxSYW5nZShyb3csIGNvbCkge1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnByb3BzLmNlbGxzW3Jvd11bY29sXS5kYXRlO1xuICAgICAgICBsZXQgZW5kID0gYWRkRGF5cyhzdGFydCwgMSk7XG4gICAgICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1NlZ0FsbERheShzZWcpIHtcbiAgICByZXR1cm4gc2VnLmV2ZW50UmFuZ2UuZGVmLmFsbERheTtcbn1cblxuY2xhc3MgVGFibGUgZXh0ZW5kcyBEYXRlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5lbFJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLm5lZWRzU2Nyb2xsUmVzZXQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgZGF5TWF4RXZlbnRSb3dzLCBkYXlNYXhFdmVudHMsIGV4cGFuZFJvd3MgfSA9IHByb3BzO1xuICAgICAgICBsZXQgbGltaXRWaWFCYWxhbmNlZCA9IGRheU1heEV2ZW50cyA9PT0gdHJ1ZSB8fCBkYXlNYXhFdmVudFJvd3MgPT09IHRydWU7XG4gICAgICAgIC8vIGlmIHJvd3MgY2FuJ3QgZXhwYW5kIHRvIGZpbGwgZml4ZWQgaGVpZ2h0LCBjYW4ndCBkbyBiYWxhbmNlZC1oZWlnaHQgZXZlbnQgbGltaXRcbiAgICAgICAgLy8gVE9ETzogYmVzdCBwbGFjZSB0byBub3JtYWxpemUgdGhlc2Ugb3B0aW9ucz9cbiAgICAgICAgaWYgKGxpbWl0VmlhQmFsYW5jZWQgJiYgIWV4cGFuZFJvd3MpIHtcbiAgICAgICAgICAgIGxpbWl0VmlhQmFsYW5jZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGRheU1heEV2ZW50Um93cyA9IG51bGw7XG4gICAgICAgICAgICBkYXlNYXhFdmVudHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgICAgICAgJ2ZjLWRheWdyaWQtYm9keScsXG4gICAgICAgICAgICBsaW1pdFZpYUJhbGFuY2VkID8gJ2ZjLWRheWdyaWQtYm9keS1iYWxhbmNlZCcgOiAnZmMtZGF5Z3JpZC1ib2R5LXVuYmFsYW5jZWQnLFxuICAgICAgICAgICAgZXhwYW5kUm93cyA/ICcnIDogJ2ZjLWRheWdyaWQtYm9keS1uYXR1cmFsJywgLy8gd2lsbCBoZWlnaHQgb2Ygb25lIHJvdyBkZXBlbmQgb24gdGhlIG90aGVycz9cbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiB0aGlzLmVsUmVmLCBjbGFzc05hbWU6IGNsYXNzTmFtZXMuam9pbignICcpLCBzdHlsZToge1xuICAgICAgICAgICAgICAgIC8vIHRoZXNlIHByb3BzIGFyZSBpbXBvcnRhbnQgdG8gZ2l2ZSB0aGlzIHdyYXBwZXIgY29ycmVjdCBkaW1lbnNpb25zIGZvciBpbnRlcmFjdGlvbnNcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBpZiB3ZSBzZXQgaXQgaGVyZSwgY2FuIHdlIGF2b2lkIGdpdmluZyB0byBpbm5lciB0YWJsZXM/XG4gICAgICAgICAgICAgICAgd2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgIG1pbldpZHRoOiBwcm9wcy50YWJsZU1pbldpZHRoLFxuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRhYmxlXCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiwgY2xhc3NOYW1lOiBcImZjLXNjcm9sbGdyaWQtc3luYy10YWJsZVwiLCBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogcHJvcHMuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIG1pbldpZHRoOiBwcm9wcy50YWJsZU1pbldpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGV4cGFuZFJvd3MgPyBwcm9wcy5jbGllbnRIZWlnaHQgOiAnJyxcbiAgICAgICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICAgICAgcHJvcHMuY29sR3JvdXBOb2RlLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0Ym9keVwiLCB7IHJvbGU6IFwicHJlc2VudGF0aW9uXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChUYWJsZVJvd3MsIHsgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBjZWxsczogcHJvcHMuY2VsbHMsIHJlbmRlclJvd0ludHJvOiBwcm9wcy5yZW5kZXJSb3dJbnRybywgc2hvd1dlZWtOdW1iZXJzOiBwcm9wcy5zaG93V2Vla051bWJlcnMsIGNsaWVudFdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0OiBwcm9wcy5jbGllbnRIZWlnaHQsIGJ1c2luZXNzSG91clNlZ3M6IHByb3BzLmJ1c2luZXNzSG91clNlZ3MsIGJnRXZlbnRTZWdzOiBwcm9wcy5iZ0V2ZW50U2VncywgZmdFdmVudFNlZ3M6IHByb3BzLmZnRXZlbnRTZWdzLCBkYXRlU2VsZWN0aW9uU2VnczogcHJvcHMuZGF0ZVNlbGVjdGlvblNlZ3MsIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZXZlbnREcmFnOiBwcm9wcy5ldmVudERyYWcsIGV2ZW50UmVzaXplOiBwcm9wcy5ldmVudFJlc2l6ZSwgZGF5TWF4RXZlbnRzOiBkYXlNYXhFdmVudHMsIGRheU1heEV2ZW50Um93czogZGF5TWF4RXZlbnRSb3dzLCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQsIGlzSGl0Q29tYm9BbGxvd2VkOiBwcm9wcy5pc0hpdENvbWJvQWxsb3dlZCB9KSkpKSk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLnJlcXVlc3RTY3JvbGxSZXNldCgpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgIGlmIChwcmV2UHJvcHMuZGF0ZVByb2ZpbGUgIT09IHRoaXMucHJvcHMuZGF0ZVByb2ZpbGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdFNjcm9sbFJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoU2Nyb2xsUmVzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXF1ZXN0U2Nyb2xsUmVzZXQoKSB7XG4gICAgICAgIHRoaXMubmVlZHNTY3JvbGxSZXNldCA9IHRydWU7XG4gICAgICAgIHRoaXMuZmx1c2hTY3JvbGxSZXNldCgpO1xuICAgIH1cbiAgICBmbHVzaFNjcm9sbFJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5uZWVkc1Njcm9sbFJlc2V0ICYmXG4gICAgICAgICAgICB0aGlzLnByb3BzLmNsaWVudFdpZHRoIC8vIHNpemVzIGNvbXB1dGVkP1xuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YmplY3RFbCA9IGdldFNjcm9sbFN1YmplY3RFbCh0aGlzLmVsUmVmLmN1cnJlbnQsIHRoaXMucHJvcHMuZGF0ZVByb2ZpbGUpO1xuICAgICAgICAgICAgaWYgKHN1YmplY3RFbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbkVsID0gc3ViamVjdEVsLmNsb3Nlc3QoJy5mYy1kYXlncmlkLWJvZHknKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzY3JvbGxFbCA9IG9yaWdpbkVsLmNsb3Nlc3QoJy5mYy1zY3JvbGxlcicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjcm9sbFRvcCA9IHN1YmplY3RFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgLVxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5FbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgICAgICAgICAgICAgc2Nyb2xsRWwuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wID8gKHNjcm9sbFRvcCArIDEpIDogMDsgLy8gb3ZlcmNvbWUgYm9yZGVyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5lZWRzU2Nyb2xsUmVzZXQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFNjcm9sbFN1YmplY3RFbChjb250YWluZXJFbCwgZGF0ZVByb2ZpbGUpIHtcbiAgICBsZXQgZWw7XG4gICAgaWYgKGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQubWF0Y2goL3llYXJ8bW9udGgvKSkge1xuICAgICAgICBlbCA9IGNvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWRhdGU9XCIke2Zvcm1hdElzb01vbnRoU3RyKGRhdGVQcm9maWxlLmN1cnJlbnREYXRlKX0tMDFcIl1gKTtcbiAgICAgICAgLy8gZXZlbiBpZiB2aWV3IGlzIG1vbnRoLWJhc2VkLCBmaXJzdC1vZi1tb250aCBtaWdodCBiZSBoaWRkZW4uLi5cbiAgICB9XG4gICAgaWYgKCFlbCkge1xuICAgICAgICBlbCA9IGNvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWRhdGU9XCIke2Zvcm1hdERheVN0cmluZyhkYXRlUHJvZmlsZS5jdXJyZW50RGF0ZSl9XCJdYCk7XG4gICAgICAgIC8vIGNvdWxkIHN0aWxsIGJlIGhpZGRlbiBpZiBhbiBpbnRlcmlvci12aWV3IGhpZGRlbiBkYXlcbiAgICB9XG4gICAgcmV0dXJuIGVsO1xufVxuXG5jbGFzcyBEYXlUYWJsZVNsaWNlciBleHRlbmRzIFNsaWNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZm9yY2VEYXlJZkxpc3RJdGVtID0gdHJ1ZTtcbiAgICB9XG4gICAgc2xpY2VSYW5nZShkYXRlUmFuZ2UsIGRheVRhYmxlTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIGRheVRhYmxlTW9kZWwuc2xpY2VSYW5nZShkYXRlUmFuZ2UpO1xuICAgIH1cbn1cblxuY2xhc3MgRGF5VGFibGUgZXh0ZW5kcyBEYXRlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zbGljZXIgPSBuZXcgRGF5VGFibGVTbGljZXIoKTtcbiAgICAgICAgdGhpcy50YWJsZVJlZiA9IGNyZWF0ZVJlZigpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVGFibGUsIE9iamVjdC5hc3NpZ24oeyByZWY6IHRoaXMudGFibGVSZWYgfSwgdGhpcy5zbGljZXIuc2xpY2VQcm9wcyhwcm9wcywgcHJvcHMuZGF0ZVByb2ZpbGUsIHByb3BzLm5leHREYXlUaHJlc2hvbGQsIGNvbnRleHQsIHByb3BzLmRheVRhYmxlTW9kZWwpLCB7IGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgY2VsbHM6IHByb3BzLmRheVRhYmxlTW9kZWwuY2VsbHMsIGNvbEdyb3VwTm9kZTogcHJvcHMuY29sR3JvdXBOb2RlLCB0YWJsZU1pbldpZHRoOiBwcm9wcy50YWJsZU1pbldpZHRoLCByZW5kZXJSb3dJbnRybzogcHJvcHMucmVuZGVyUm93SW50cm8sIGRheU1heEV2ZW50czogcHJvcHMuZGF5TWF4RXZlbnRzLCBkYXlNYXhFdmVudFJvd3M6IHByb3BzLmRheU1heEV2ZW50Um93cywgc2hvd1dlZWtOdW1iZXJzOiBwcm9wcy5zaG93V2Vla051bWJlcnMsIGV4cGFuZFJvd3M6IHByb3BzLmV4cGFuZFJvd3MsIGhlYWRlckFsaWduRWxSZWY6IHByb3BzLmhlYWRlckFsaWduRWxSZWYsIGNsaWVudFdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0OiBwcm9wcy5jbGllbnRIZWlnaHQsIGZvclByaW50OiBwcm9wcy5mb3JQcmludCB9KSkpO1xuICAgIH1cbn1cblxuY2xhc3MgRGF5VGFibGVWaWV3IGV4dGVuZHMgVGFibGVWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5idWlsZERheVRhYmxlTW9kZWwgPSBtZW1vaXplKGJ1aWxkRGF5VGFibGVNb2RlbCk7XG4gICAgICAgIHRoaXMuaGVhZGVyUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMudGFibGVSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgLy8gY2FuJ3Qgb3ZlcnJpZGUgYW55IGxpZmVjeWNsZSBtZXRob2RzIGZyb20gcGFyZW50XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgb3B0aW9ucywgZGF0ZVByb2ZpbGVHZW5lcmF0b3IgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBkYXlUYWJsZU1vZGVsID0gdGhpcy5idWlsZERheVRhYmxlTW9kZWwocHJvcHMuZGF0ZVByb2ZpbGUsIGRhdGVQcm9maWxlR2VuZXJhdG9yKTtcbiAgICAgICAgbGV0IGhlYWRlckNvbnRlbnQgPSBvcHRpb25zLmRheUhlYWRlcnMgJiYgKGNyZWF0ZUVsZW1lbnQoRGF5SGVhZGVyLCB7IHJlZjogdGhpcy5oZWFkZXJSZWYsIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgZGF0ZXM6IGRheVRhYmxlTW9kZWwuaGVhZGVyRGF0ZXMsIGRhdGVzUmVwRGlzdGluY3REYXlzOiBkYXlUYWJsZU1vZGVsLnJvd0NudCA9PT0gMSB9KSk7XG4gICAgICAgIGxldCBib2R5Q29udGVudCA9IChjb250ZW50QXJnKSA9PiAoY3JlYXRlRWxlbWVudChEYXlUYWJsZSwgeyByZWY6IHRoaXMudGFibGVSZWYsIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgZGF5VGFibGVNb2RlbDogZGF5VGFibGVNb2RlbCwgYnVzaW5lc3NIb3VyczogcHJvcHMuYnVzaW5lc3NIb3VycywgZGF0ZVNlbGVjdGlvbjogcHJvcHMuZGF0ZVNlbGVjdGlvbiwgZXZlbnRTdG9yZTogcHJvcHMuZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzOiBwcm9wcy5ldmVudFVpQmFzZXMsIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZXZlbnREcmFnOiBwcm9wcy5ldmVudERyYWcsIGV2ZW50UmVzaXplOiBwcm9wcy5ldmVudFJlc2l6ZSwgbmV4dERheVRocmVzaG9sZDogb3B0aW9ucy5uZXh0RGF5VGhyZXNob2xkLCBjb2xHcm91cE5vZGU6IGNvbnRlbnRBcmcudGFibGVDb2xHcm91cE5vZGUsIHRhYmxlTWluV2lkdGg6IGNvbnRlbnRBcmcudGFibGVNaW5XaWR0aCwgZGF5TWF4RXZlbnRzOiBvcHRpb25zLmRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzOiBvcHRpb25zLmRheU1heEV2ZW50Um93cywgc2hvd1dlZWtOdW1iZXJzOiBvcHRpb25zLndlZWtOdW1iZXJzLCBleHBhbmRSb3dzOiAhcHJvcHMuaXNIZWlnaHRBdXRvLCBoZWFkZXJBbGlnbkVsUmVmOiB0aGlzLmhlYWRlckVsUmVmLCBjbGllbnRXaWR0aDogY29udGVudEFyZy5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0OiBjb250ZW50QXJnLmNsaWVudEhlaWdodCwgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50IH0pKTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGF5TWluV2lkdGhcbiAgICAgICAgICAgID8gdGhpcy5yZW5kZXJIU2Nyb2xsTGF5b3V0KGhlYWRlckNvbnRlbnQsIGJvZHlDb250ZW50LCBkYXlUYWJsZU1vZGVsLmNvbENudCwgb3B0aW9ucy5kYXlNaW5XaWR0aClcbiAgICAgICAgICAgIDogdGhpcy5yZW5kZXJTaW1wbGVMYXlvdXQoaGVhZGVyQ29udGVudCwgYm9keUNvbnRlbnQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkRGF5VGFibGVNb2RlbChkYXRlUHJvZmlsZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpIHtcbiAgICBsZXQgZGF5U2VyaWVzID0gbmV3IERheVNlcmllc01vZGVsKGRhdGVQcm9maWxlLnJlbmRlclJhbmdlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcik7XG4gICAgcmV0dXJuIG5ldyBEYXlUYWJsZU1vZGVsKGRheVNlcmllcywgL3llYXJ8bW9udGh8d2Vlay8udGVzdChkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0KSk7XG59XG5cbmNsYXNzIFRhYmxlRGF0ZVByb2ZpbGVHZW5lcmF0b3IgZXh0ZW5kcyBEYXRlUHJvZmlsZUdlbmVyYXRvciB7XG4gICAgLy8gQ29tcHV0ZXMgdGhlIGRhdGUgcmFuZ2UgdGhhdCB3aWxsIGJlIHJlbmRlcmVkXG4gICAgYnVpbGRSZW5kZXJSYW5nZShjdXJyZW50UmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpIHtcbiAgICAgICAgbGV0IHJlbmRlclJhbmdlID0gc3VwZXIuYnVpbGRSZW5kZXJSYW5nZShjdXJyZW50UmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpO1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGJ1aWxkRGF5VGFibGVSZW5kZXJSYW5nZSh7XG4gICAgICAgICAgICBjdXJyZW50UmFuZ2U6IHJlbmRlclJhbmdlLFxuICAgICAgICAgICAgc25hcFRvV2VlazogL14oeWVhcnxtb250aCkkLy50ZXN0KGN1cnJlbnRSYW5nZVVuaXQpLFxuICAgICAgICAgICAgZml4ZWRXZWVrQ291bnQ6IHByb3BzLmZpeGVkV2Vla0NvdW50LFxuICAgICAgICAgICAgZGF0ZUVudjogcHJvcHMuZGF0ZUVudixcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGREYXlUYWJsZVJlbmRlclJhbmdlKHByb3BzKSB7XG4gICAgbGV0IHsgZGF0ZUVudiwgY3VycmVudFJhbmdlIH0gPSBwcm9wcztcbiAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSBjdXJyZW50UmFuZ2U7XG4gICAgbGV0IGVuZE9mV2VlaztcbiAgICAvLyB5ZWFyIGFuZCBtb250aCB2aWV3cyBzaG91bGQgYmUgYWxpZ25lZCB3aXRoIHdlZWtzLiB0aGlzIGlzIGFscmVhZHkgZG9uZSBmb3Igd2Vla1xuICAgIGlmIChwcm9wcy5zbmFwVG9XZWVrKSB7XG4gICAgICAgIHN0YXJ0ID0gZGF0ZUVudi5zdGFydE9mV2VlayhzdGFydCk7XG4gICAgICAgIC8vIG1ha2UgZW5kLW9mLXdlZWsgaWYgbm90IGFscmVhZHlcbiAgICAgICAgZW5kT2ZXZWVrID0gZGF0ZUVudi5zdGFydE9mV2VlayhlbmQpO1xuICAgICAgICBpZiAoZW5kT2ZXZWVrLnZhbHVlT2YoKSAhPT0gZW5kLnZhbHVlT2YoKSkge1xuICAgICAgICAgICAgZW5kID0gYWRkV2Vla3MoZW5kT2ZXZWVrLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBlbnN1cmUgNiB3ZWVrc1xuICAgIGlmIChwcm9wcy5maXhlZFdlZWtDb3VudCkge1xuICAgICAgICAvLyBUT0RPOiBpbnN0ZWFkIG9mIHRoZXNlIGRhdGUtbWF0aCBneW1uYXN0aWNzIChmb3IgbXVsdGltb250aCB2aWV3KSxcbiAgICAgICAgLy8gY29tcHV0ZSBkYXRlcHJvZmlsZXMgb2YgYWxsIG1vbnRocywgdGhlbiB1c2Ugc3RhcnQgb2YgZmlyc3QgYW5kIGVuZCBvZiBsYXN0LlxuICAgICAgICBsZXQgbGFzdE1vbnRoUmVuZGVyU3RhcnQgPSBkYXRlRW52LnN0YXJ0T2ZXZWVrKGRhdGVFbnYuc3RhcnRPZk1vbnRoKGFkZERheXMoY3VycmVudFJhbmdlLmVuZCwgLTEpKSk7XG4gICAgICAgIGxldCByb3dDbnQgPSBNYXRoLmNlaWwoLy8gY291bGQgYmUgcGFydGlhbCB3ZWVrcyBkdWUgdG8gaGlkZGVuRGF5c1xuICAgICAgICBkaWZmV2Vla3MobGFzdE1vbnRoUmVuZGVyU3RhcnQsIGVuZCkpO1xuICAgICAgICBlbmQgPSBhZGRXZWVrcyhlbmQsIDYgLSByb3dDbnQpO1xuICAgIH1cbiAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG59XG5cbnZhciBjc3NfMjQ4eiA9IFwiOnJvb3R7LS1mYy1kYXlncmlkLWV2ZW50LWRvdC13aWR0aDo4cHh9LmZjLWRheWdyaWQtZGF5LWV2ZW50czphZnRlciwuZmMtZGF5Z3JpZC1kYXktZXZlbnRzOmJlZm9yZSwuZmMtZGF5Z3JpZC1kYXktZnJhbWU6YWZ0ZXIsLmZjLWRheWdyaWQtZGF5LWZyYW1lOmJlZm9yZSwuZmMtZGF5Z3JpZC1ldmVudC1oYXJuZXNzOmFmdGVyLC5mYy1kYXlncmlkLWV2ZW50LWhhcm5lc3M6YmVmb3Jle2NsZWFyOmJvdGg7Y29udGVudDpcXFwiXFxcIjtkaXNwbGF5OnRhYmxlfS5mYyAuZmMtZGF5Z3JpZC1ib2R5e3Bvc2l0aW9uOnJlbGF0aXZlO3otaW5kZXg6MX0uZmMgLmZjLWRheWdyaWQtZGF5LmZjLWRheS10b2RheXtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZjLXRvZGF5LWJnLWNvbG9yKX0uZmMgLmZjLWRheWdyaWQtZGF5LWZyYW1le21pbi1oZWlnaHQ6MTAwJTtwb3NpdGlvbjpyZWxhdGl2ZX0uZmMgLmZjLWRheWdyaWQtZGF5LXRvcHtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246cm93LXJldmVyc2V9LmZjIC5mYy1kYXktb3RoZXIgLmZjLWRheWdyaWQtZGF5LXRvcHtvcGFjaXR5Oi4zfS5mYyAuZmMtZGF5Z3JpZC1kYXktbnVtYmVye3BhZGRpbmc6NHB4O3Bvc2l0aW9uOnJlbGF0aXZlO3otaW5kZXg6NH0uZmMgLmZjLWRheWdyaWQtbW9udGgtc3RhcnR7Zm9udC1zaXplOjEuMWVtO2ZvbnQtd2VpZ2h0OjcwMH0uZmMgLmZjLWRheWdyaWQtZGF5LWV2ZW50c3ttYXJnaW4tdG9wOjFweH0uZmMgLmZjLWRheWdyaWQtYm9keS1iYWxhbmNlZCAuZmMtZGF5Z3JpZC1kYXktZXZlbnRze2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowfS5mYyAuZmMtZGF5Z3JpZC1ib2R5LXVuYmFsYW5jZWQgLmZjLWRheWdyaWQtZGF5LWV2ZW50c3ttaW4taGVpZ2h0OjJlbTtwb3NpdGlvbjpyZWxhdGl2ZX0uZmMgLmZjLWRheWdyaWQtYm9keS1uYXR1cmFsIC5mYy1kYXlncmlkLWRheS1ldmVudHN7bWFyZ2luLWJvdHRvbToxZW19LmZjIC5mYy1kYXlncmlkLWV2ZW50LWhhcm5lc3N7cG9zaXRpb246cmVsYXRpdmV9LmZjIC5mYy1kYXlncmlkLWV2ZW50LWhhcm5lc3MtYWJze2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowfS5mYyAuZmMtZGF5Z3JpZC1iZy1oYXJuZXNze2JvdHRvbTowO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowfS5mYyAuZmMtZGF5Z3JpZC1kYXktYmcgLmZjLW5vbi1idXNpbmVzc3t6LWluZGV4OjF9LmZjIC5mYy1kYXlncmlkLWRheS1iZyAuZmMtYmctZXZlbnR7ei1pbmRleDoyfS5mYyAuZmMtZGF5Z3JpZC1kYXktYmcgLmZjLWhpZ2hsaWdodHt6LWluZGV4OjN9LmZjIC5mYy1kYXlncmlkLWV2ZW50e21hcmdpbi10b3A6MXB4O3otaW5kZXg6Nn0uZmMgLmZjLWRheWdyaWQtZXZlbnQuZmMtZXZlbnQtbWlycm9ye3otaW5kZXg6N30uZmMgLmZjLWRheWdyaWQtZGF5LWJvdHRvbXtmb250LXNpemU6Ljg1ZW07bWFyZ2luOjAgMnB4fS5mYyAuZmMtZGF5Z3JpZC1kYXktYm90dG9tOmFmdGVyLC5mYyAuZmMtZGF5Z3JpZC1kYXktYm90dG9tOmJlZm9yZXtjbGVhcjpib3RoO2NvbnRlbnQ6XFxcIlxcXCI7ZGlzcGxheTp0YWJsZX0uZmMgLmZjLWRheWdyaWQtbW9yZS1saW5re2JvcmRlci1yYWRpdXM6M3B4O2N1cnNvcjpwb2ludGVyO2xpbmUtaGVpZ2h0OjE7bWFyZ2luLXRvcDoxcHg7bWF4LXdpZHRoOjEwMCU7b3ZlcmZsb3c6aGlkZGVuO3BhZGRpbmc6MnB4O3Bvc2l0aW9uOnJlbGF0aXZlO3doaXRlLXNwYWNlOm5vd3JhcDt6LWluZGV4OjR9LmZjIC5mYy1kYXlncmlkLW1vcmUtbGluazpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMCwwLDAsLjEpfS5mYyAuZmMtZGF5Z3JpZC13ZWVrLW51bWJlcntiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZjLW5ldXRyYWwtYmctY29sb3IpO2NvbG9yOnZhcigtLWZjLW5ldXRyYWwtdGV4dC1jb2xvcik7bWluLXdpZHRoOjEuNWVtO3BhZGRpbmc6MnB4O3Bvc2l0aW9uOmFic29sdXRlO3RleHQtYWxpZ246Y2VudGVyO3RvcDowO3otaW5kZXg6NX0uZmMgLmZjLW1vcmUtcG9wb3ZlciAuZmMtcG9wb3Zlci1ib2R5e21pbi13aWR0aDoyMjBweDtwYWRkaW5nOjEwcHh9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWRheWdyaWQtZXZlbnQuZmMtZXZlbnQtc3RhcnQsLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWRheWdyaWQtZXZlbnQuZmMtZXZlbnQtZW5ke21hcmdpbi1sZWZ0OjJweH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtZGF5Z3JpZC1ldmVudC5mYy1ldmVudC1lbmQsLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWRheWdyaWQtZXZlbnQuZmMtZXZlbnQtc3RhcnR7bWFyZ2luLXJpZ2h0OjJweH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtZGF5Z3JpZC1tb3JlLWxpbmt7ZmxvYXQ6bGVmdH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtZGF5Z3JpZC13ZWVrLW51bWJlcntib3JkZXItcmFkaXVzOjAgMCAzcHggMDtsZWZ0OjB9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLWRheWdyaWQtbW9yZS1saW5re2Zsb2F0OnJpZ2h0fS5mYy1kaXJlY3Rpb24tcnRsIC5mYy1kYXlncmlkLXdlZWstbnVtYmVye2JvcmRlci1yYWRpdXM6MCAwIDAgM3B4O3JpZ2h0OjB9LmZjLWxpcXVpZC1oYWNrIC5mYy1kYXlncmlkLWRheS1mcmFtZXtwb3NpdGlvbjpzdGF0aWN9LmZjLWRheWdyaWQtZXZlbnR7Ym9yZGVyLXJhZGl1czozcHg7Zm9udC1zaXplOnZhcigtLWZjLXNtYWxsLWZvbnQtc2l6ZSk7cG9zaXRpb246cmVsYXRpdmU7d2hpdGUtc3BhY2U6bm93cmFwfS5mYy1kYXlncmlkLWJsb2NrLWV2ZW50IC5mYy1ldmVudC10aW1le2ZvbnQtd2VpZ2h0OjcwMH0uZmMtZGF5Z3JpZC1ibG9jay1ldmVudCAuZmMtZXZlbnQtdGltZSwuZmMtZGF5Z3JpZC1ibG9jay1ldmVudCAuZmMtZXZlbnQtdGl0bGV7cGFkZGluZzoxcHh9LmZjLWRheWdyaWQtZG90LWV2ZW50e2FsaWduLWl0ZW1zOmNlbnRlcjtkaXNwbGF5OmZsZXg7cGFkZGluZzoycHggMH0uZmMtZGF5Z3JpZC1kb3QtZXZlbnQgLmZjLWV2ZW50LXRpdGxle2ZsZXgtZ3JvdzoxO2ZsZXgtc2hyaW5rOjE7Zm9udC13ZWlnaHQ6NzAwO21pbi13aWR0aDowO292ZXJmbG93OmhpZGRlbn0uZmMtZGF5Z3JpZC1kb3QtZXZlbnQuZmMtZXZlbnQtbWlycm9yLC5mYy1kYXlncmlkLWRvdC1ldmVudDpob3ZlcntiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsLjEpfS5mYy1kYXlncmlkLWRvdC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZDpiZWZvcmV7Ym90dG9tOi0xMHB4O3RvcDotMTBweH0uZmMtZGF5Z3JpZC1ldmVudC1kb3R7Ym9yZGVyOmNhbGModmFyKC0tZmMtZGF5Z3JpZC1ldmVudC1kb3Qtd2lkdGgpLzIpIHNvbGlkIHZhcigtLWZjLWV2ZW50LWJvcmRlci1jb2xvcik7Ym9yZGVyLXJhZGl1czpjYWxjKHZhcigtLWZjLWRheWdyaWQtZXZlbnQtZG90LXdpZHRoKS8yKTtib3gtc2l6aW5nOmNvbnRlbnQtYm94O2hlaWdodDowO21hcmdpbjowIDRweDt3aWR0aDowfS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1kYXlncmlkLWV2ZW50IC5mYy1ldmVudC10aW1le21hcmdpbi1yaWdodDozcHh9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLWRheWdyaWQtZXZlbnQgLmZjLWV2ZW50LXRpbWV7bWFyZ2luLWxlZnQ6M3B4fVwiO1xuaW5qZWN0U3R5bGVzKGNzc18yNDh6KTtcblxuZXhwb3J0IHsgRGF5VGFibGVWaWV3IGFzIERheUdyaWRWaWV3LCBEYXlUYWJsZSwgRGF5VGFibGVTbGljZXIsIFRhYmxlLCBUYWJsZURhdGVQcm9maWxlR2VuZXJhdG9yLCBUYWJsZVJvd3MsIFRhYmxlVmlldywgYnVpbGREYXlUYWJsZU1vZGVsLCBidWlsZERheVRhYmxlUmVuZGVyUmFuZ2UgfTtcbiJdLCJuYW1lcyI6WyJEYXRlQ29tcG9uZW50IiwiZ2V0U3RpY2t5SGVhZGVyRGF0ZXMiLCJWaWV3Q29udGFpbmVyIiwiU2ltcGxlU2Nyb2xsR3JpZCIsImdldFN0aWNreUZvb3RlclNjcm9sbGJhciIsInJlbmRlclNjcm9sbFNoaW0iLCJjcmVhdGVGb3JtYXR0ZXIiLCJCYXNlQ29tcG9uZW50IiwiU3RhbmRhcmRFdmVudCIsImJ1aWxkU2VnVGltZVRleHQiLCJFdmVudENvbnRhaW5lciIsImdldFNlZ0FuY2hvckF0dHJzIiwibWVtb2l6ZSIsIk1vcmVMaW5rQ29udGFpbmVyIiwiZ2V0U2VnTWV0YSIsImdldFVuaXF1ZURvbUlkIiwic2V0UmVmIiwiRGF5Q2VsbENvbnRhaW5lciIsIldlZWtOdW1iZXJDb250YWluZXIiLCJidWlsZE5hdkxpbmtBdHRycyIsImhhc0N1c3RvbURheUNlbGxDb250ZW50IiwiYWRkTXMiLCJpbnRlcnNlY3RSYW5nZXMiLCJhZGREYXlzIiwiU2VnSGllcmFyY2h5IiwiYnVpbGRFbnRyeUtleSIsImludGVyc2VjdFNwYW5zIiwiUmVmTWFwIiwic29ydEV2ZW50U2VncyIsImlzUHJvcHNFcXVhbCIsImJ1aWxkRXZlbnRSYW5nZUtleSIsIkJnRXZlbnQiLCJyZW5kZXJGaWxsIiwiUG9zaXRpb25DYWNoZSIsIk5vd1RpbWVyIiwiZm9ybWF0SXNvTW9udGhTdHIiLCJmb3JtYXREYXlTdHJpbmciLCJTbGljZXIiLCJEYXlIZWFkZXIiLCJEYXlTZXJpZXNNb2RlbCIsIkRheVRhYmxlTW9kZWwiLCJEYXRlUHJvZmlsZUdlbmVyYXRvciIsImFkZFdlZWtzIiwiZGlmZldlZWtzIiwiaW5qZWN0U3R5bGVzIiwiY3JlYXRlUmVmIiwiY3JlYXRlRWxlbWVudCIsIkZyYWdtZW50IiwiVGFibGVWaWV3IiwiY29uc3RydWN0b3IiLCJhcmd1bWVudHMiLCJoZWFkZXJFbFJlZiIsInJlbmRlclNpbXBsZUxheW91dCIsImhlYWRlclJvd0NvbnRlbnQiLCJib2R5Q29udGVudCIsInByb3BzIiwiY29udGV4dCIsInNlY3Rpb25zIiwic3RpY2t5SGVhZGVyRGF0ZXMiLCJvcHRpb25zIiwicHVzaCIsInR5cGUiLCJrZXkiLCJpc1N0aWNreSIsImNodW5rIiwiZWxSZWYiLCJ0YWJsZUNsYXNzTmFtZSIsInJvd0NvbnRlbnQiLCJsaXF1aWQiLCJjb250ZW50IiwiZWxDbGFzc2VzIiwidmlld1NwZWMiLCJpc0hlaWdodEF1dG8iLCJmb3JQcmludCIsImNvbGxhcHNpYmxlV2lkdGgiLCJjb2xzIiwicmVuZGVySFNjcm9sbExheW91dCIsImNvbENudCIsImRheU1pbldpZHRoIiwiU2Nyb2xsR3JpZCIsInBsdWdpbkhvb2tzIiwic2Nyb2xsR3JpZEltcGwiLCJFcnJvciIsInN0aWNreUZvb3RlclNjcm9sbGJhciIsImNodW5rcyIsImNvbEdyb3VwcyIsInNwYW4iLCJtaW5XaWR0aCIsInNwbGl0U2Vnc0J5Um93Iiwic2VncyIsInJvd0NudCIsImJ5Um93IiwiaSIsInNlZyIsInJvdyIsInNwbGl0U2Vnc0J5Rmlyc3RDb2wiLCJieUNvbCIsImZpcnN0Q29sIiwic3BsaXRJbnRlcmFjdGlvbkJ5Um93IiwidWkiLCJhZmZlY3RlZEluc3RhbmNlcyIsImlzRXZlbnQiLCJERUZBVUxUX1RBQkxFX0VWRU5UX1RJTUVfRk9STUFUIiwiaG91ciIsIm1pbnV0ZSIsIm9taXRaZXJvTWludXRlIiwibWVyaWRpZW0iLCJoYXNMaXN0SXRlbURpc3BsYXkiLCJkaXNwbGF5IiwiZXZlbnRSYW5nZSIsImRlZiIsImFsbERheSIsImxhc3RDb2wiLCJpc1N0YXJ0IiwiaXNFbmQiLCJUYWJsZUJsb2NrRXZlbnQiLCJyZW5kZXIiLCJPYmplY3QiLCJhc3NpZ24iLCJkZWZhdWx0VGltZUZvcm1hdCIsImRlZmF1bHREaXNwbGF5RXZlbnRFbmQiLCJkaXNhYmxlUmVzaXppbmciLCJUYWJsZUxpc3RJdGVtRXZlbnQiLCJ0aW1lRm9ybWF0IiwiZXZlbnRUaW1lRm9ybWF0IiwidGltZVRleHQiLCJlbFRhZyIsImVsQXR0cnMiLCJkZWZhdWx0R2VuZXJhdG9yIiwicmVuZGVySW5uZXJDb250ZW50IiwiaXNSZXNpemluZyIsImlzRGF0ZVNlbGVjdGluZyIsInJlbmRlclByb3BzIiwiY2xhc3NOYW1lIiwic3R5bGUiLCJib3JkZXJDb2xvciIsImJhY2tncm91bmRDb2xvciIsImV2ZW50IiwidGl0bGUiLCJUYWJsZUNlbGxNb3JlTGluayIsImNvbXBpbGVTZWdzIiwiYWxsU2VncyIsImludmlzaWJsZVNlZ3MiLCJzaW5nbGVQbGFjZW1lbnRzIiwiZGF0ZVByb2ZpbGUiLCJ0b2RheVJhbmdlIiwiYWxsRGF5RGF0ZSIsIm1vcmVDbnQiLCJoaWRkZW5TZWdzIiwiYWxpZ25tZW50RWxSZWYiLCJhbGlnbkdyaWRUb3AiLCJleHRyYURhdGVTcGFuIiwicG9wb3ZlckNvbnRlbnQiLCJpc0ZvcmNlZEludmlzaWJsZSIsImV2ZW50RHJhZyIsImV2ZW50UmVzaXplIiwibWFwIiwiaW5zdGFuY2VJZCIsImluc3RhbmNlIiwidmlzaWJpbGl0eSIsImlzRHJhZ2dpbmciLCJpc1NlbGVjdGVkIiwiZXZlbnRTZWxlY3Rpb24iLCJwbGFjZW1lbnQiLCJpc1Zpc2libGUiLCJERUZBVUxUX1dFRUtfTlVNX0ZPUk1BVCIsIndlZWsiLCJUYWJsZUNlbGwiLCJyb290RWxSZWYiLCJzdGF0ZSIsImRheU51bWJlcklkIiwiaGFuZGxlUm9vdEVsIiwiZWwiLCJkYXRlRW52IiwiZGF0ZSIsImlzTW9udGhTdGFydCIsInNob3dEYXlOdW1iZXIiLCJzaG91bGREaXNwbGF5TW9udGhTdGFydCIsImN1cnJlbnRSYW5nZSIsImV4dHJhQ2xhc3NOYW1lcyIsImV4dHJhRGF0YUF0dHJzIiwicm9sZSIsInJlbmRlclRvcElubmVyIiwiZXh0cmFSZW5kZXJQcm9wcyIsIklubmVyQ29udGVudCIsInJlZiIsImlubmVyRWxSZWYiLCJtaW5IZWlnaHQiLCJzaG93V2Vla051bWJlciIsImRlZmF1bHRGb3JtYXQiLCJpc0Rpc2FibGVkIiwiZm9yY2VEYXlUb3AiLCJpZCIsInVuZGVmaW5lZCIsImZnQ29udGVudEVsUmVmIiwiZmdDb250ZW50IiwibWFyZ2luVG9wIiwibW9yZU1hcmdpblRvcCIsImJnQ29udGVudCIsImRheU51bWJlclRleHQiLCJzdGFydCIsImN1cnJlbnRTdGFydCIsImVuZCIsImN1cnJlbnRFbmQiLCJjdXJyZW50RW5kSW5jbCIsImN1cnJlbnRGaXJzdFllYXIiLCJnZXRZZWFyIiwiY3VycmVudEZpcnN0TW9udGgiLCJnZXRNb250aCIsImN1cnJlbnRMYXN0WWVhciIsImN1cnJlbnRMYXN0TW9udGgiLCJCb29sZWFuIiwidmFsdWVPZiIsImdldERheSIsImdlbmVyYXRlU2VnS2V5IiwiZ2VuZXJhdGVTZWdVaWQiLCJjb21wdXRlRmdTZWdQbGFjZW1lbnQiLCJkYXlNYXhFdmVudHMiLCJkYXlNYXhFdmVudFJvd3MiLCJzdHJpY3RPcmRlciIsInNlZ0hlaWdodHMiLCJtYXhDb250ZW50SGVpZ2h0IiwiY2VsbHMiLCJoaWVyYXJjaHkiLCJEYXlHcmlkU2VnSGllcmFyY2h5Iiwic2VnRW50cnkiLCJzZWdVaWQiLCJpbmRleCIsImFsbG93UmVzbGljaW5nIiwibWF4Q29vcmQiLCJoaWRkZW5Db25zdW1lcyIsIm1heFN0YWNrQ250Iiwic2VnSW5wdXRzIiwidW5rbm93bkhlaWdodFNlZ3MiLCJsZW5ndGgiLCJldmVudEhlaWdodCIsImhpZGRlbkVudHJpZXMiLCJhZGRTZWdzIiwic2VnUmVjdHMiLCJ0b1JlY3RzIiwic2luZ2xlQ29sUGxhY2VtZW50cyIsIm11bHRpQ29sUGxhY2VtZW50cyIsImxlZnRvdmVyTWFyZ2lucyIsInBsYWNlUmVjdHMiLCJtb3JlQ250cyIsIm1vcmVNYXJnaW5Ub3BzIiwiaXNBYnNvbHV0ZSIsImFic29sdXRlVG9wIiwiY29sIiwicmVzbGljZVNlZyIsImhpZGRlbkVudHJ5IiwiaGlkZGVuU3BhbiIsImFsbFJlY3RzIiwicmVjdHNCeUVhY2hDb2wiLCJncm91cFJlY3RzQnlFYWNoQ29sIiwicmVjdHMiLCJjdXJyZW50SGVpZ2h0IiwiY3VycmVudE1hcmdpblRvcCIsInJlY3QiLCJsZXZlbENvb3JkIiwidGhpY2tuZXNzIiwibXVsdGlQbGFjZW1lbnRzIiwiaXNGaXJzdENvbCIsInNwYW5TdGFydCIsInNwYW5FbmQiLCJvcmlnUmFuZ2UiLCJyYW5nZSIsInNsaWNlZFJhbmdlIiwiZHVyYXRpb25FZGl0YWJsZSIsImZvcmNlSGlkZGVuIiwiZW50cmllc0J5TGV2ZWwiLCJleGNsdWRlSGlkZGVuIiwiZW50cnkiLCJsZXZlbCIsImZpbHRlciIsImhhbmRsZUludmFsaWRJbnNlcnRpb24iLCJpbnNlcnRpb24iLCJ0b3VjaGluZ0VudHJ5IiwidG91Y2hpbmdMZXZlbCIsInRvdWNoaW5nTGF0ZXJhbCIsInRvdWNoaW5nRW50cnlJZCIsImhpZGRlbkVudHJ5SWQiLCJzcGxpdEVudHJ5IiwiVGFibGVSb3ciLCJjZWxsRWxSZWZzIiwiZnJhbWVFbFJlZnMiLCJmZ0VsUmVmcyIsInNlZ0hhcm5lc3NSZWZzIiwiZnJhbWVQb3NpdGlvbnMiLCJoYW5kbGVSZXNpemUiLCJpc0ZvcmNlZCIsInVwZGF0ZVNpemluZyIsImJ1c2luZXNzSG91cnNCeUNvbCIsImJ1c2luZXNzSG91clNlZ3MiLCJiZ0V2ZW50U2Vnc0J5Q29sIiwiYmdFdmVudFNlZ3MiLCJoaWdobGlnaHRTZWdzQnlDb2wiLCJnZXRIaWdobGlnaHRTZWdzIiwibWlycm9yU2Vnc0J5Q29sIiwiZ2V0TWlycm9yU2VncyIsImZnRXZlbnRTZWdzIiwiZXZlbnRPcmRlciIsImV2ZW50T3JkZXJTdHJpY3QiLCJyZW5kZXJJbnRybyIsImNlbGwiLCJub3JtYWxGZ05vZGVzIiwicmVuZGVyRmdTZWdzIiwibWlycm9yRmdOb2RlcyIsImJ1aWxkTWlycm9yUGxhY2VtZW50cyIsInNob3dEYXlOdW1iZXJzIiwic2hvd1dlZWtOdW1iZXJzIiwicmVuZGVyRmlsbFNlZ3MiLCJjZWxsTWluSGVpZ2h0IiwiY29tcG9uZW50RGlkTW91bnQiLCJhZGRSZXNpemVIYW5kbGVyIiwiY29tcG9uZW50RGlkVXBkYXRlIiwicHJldlByb3BzIiwicHJldlN0YXRlIiwiY3VycmVudFByb3BzIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJyZW1vdmVSZXNpemVIYW5kbGVyIiwiZGF0ZVNlbGVjdGlvblNlZ3MiLCJzZWdQbGFjZW1lbnRzIiwiaXNNaXJyb3IiLCJub2RlcyIsImxlZnQiLCJyaWdodCIsImlzUnRsIiwibGVmdHMiLCJyaWdodHMiLCJ0b3AiLCJmaWxsVHlwZSIsImxlZnRSaWdodENzcyIsImlzRXh0ZXJuYWxTaXppbmdDaGFuZ2UiLCJjbGllbnRXaWR0aCIsImZyYW1lRWxzIiwiY3VycmVudE1hcCIsIm9yaWdpbkVsIiwiY3VycmVudCIsIm5ld1Bvc2l0aW9uQ2FjaGUiLCJzaW1pbGFyVG8iLCJzZXRTdGF0ZSIsIm9sZFNlZ0hlaWdodHMiLCJuZXdTZWdIZWlnaHRzIiwicXVlcnlTZWdIZWlnaHRzIiwibGltaXRCeUNvbnRlbnRIZWlnaHQiLCJzYWZlU2V0U3RhdGUiLCJjb21wdXRlTWF4Q29udGVudEhlaWdodCIsInNlZ0VsTWFwIiwiaGVpZ2h0IiwiTWF0aCIsInJvdW5kIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwibWF4IiwiZmlyc3RLZXkiLCJjZWxsRWwiLCJmY0NvbnRhaW5lckVsIiwiYm90dG9tIiwiZ2V0Q2VsbEVscyIsImVsTWFwIiwiYWRkU3RhdGVFcXVhbGl0eSIsIm1pcnJvclNlZ3MiLCJjb2xQbGFjZW1lbnRzIiwidG9wc0J5SW5zdGFuY2VJZCIsImJ1aWxkQWJzb2x1dGVUb3BIYXNoIiwicGxhY2VtZW50cyIsIlRhYmxlUm93cyIsInNwbGl0QnVzaW5lc3NIb3VyU2VncyIsInNwbGl0QmdFdmVudFNlZ3MiLCJzcGxpdEZnRXZlbnRTZWdzIiwic3BsaXREYXRlU2VsZWN0aW9uU2VncyIsInNwbGl0RXZlbnREcmFnIiwic3BsaXRFdmVudFJlc2l6ZSIsInJvd1JlZnMiLCJidXNpbmVzc0hvdXJTZWdzQnlSb3ciLCJiZ0V2ZW50U2Vnc0J5Um93IiwiZmdFdmVudFNlZ3NCeVJvdyIsImRhdGVTZWxlY3Rpb25TZWdzQnlSb3ciLCJldmVudERyYWdCeVJvdyIsImV2ZW50UmVzaXplQnlSb3ciLCJhc3BlY3RSYXRpbyIsInVuaXQiLCJub3dEYXRlIiwidG9JU09TdHJpbmciLCJyZW5kZXJSb3dJbnRybyIsImlzU2VnQWxsRGF5IiwiY2xpZW50SGVpZ2h0IiwicmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCIsInJvb3RFbCIsImZpcnN0Q2VsbEVsIiwiY2xvc2VzdCIsImlzSGl0Q29tYm9BbGxvd2VkIiwidW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50IiwicHJlcGFyZUhpdHMiLCJyb3dQb3NpdGlvbnMiLCJjb2xsZWN0Iiwicm93T2JqIiwiY29sUG9zaXRpb25zIiwicXVlcnlIaXQiLCJwb3NpdGlvbkxlZnQiLCJwb3NpdGlvblRvcCIsImxlZnRUb0luZGV4IiwidG9wVG9JbmRleCIsImRhdGVTcGFuIiwiZ2V0Q2VsbFJhbmdlIiwiZGF5RWwiLCJnZXRDZWxsRWwiLCJ0b3BzIiwiYm90dG9tcyIsImxheWVyIiwiVGFibGUiLCJuZWVkc1Njcm9sbFJlc2V0IiwiZXhwYW5kUm93cyIsImxpbWl0VmlhQmFsYW5jZWQiLCJjbGFzc05hbWVzIiwiam9pbiIsIndpZHRoIiwidGFibGVNaW5XaWR0aCIsImNvbEdyb3VwTm9kZSIsInJlcXVlc3RTY3JvbGxSZXNldCIsImZsdXNoU2Nyb2xsUmVzZXQiLCJzdWJqZWN0RWwiLCJnZXRTY3JvbGxTdWJqZWN0RWwiLCJzY3JvbGxFbCIsInNjcm9sbFRvcCIsImNvbnRhaW5lckVsIiwiY3VycmVudFJhbmdlVW5pdCIsIm1hdGNoIiwicXVlcnlTZWxlY3RvciIsImN1cnJlbnREYXRlIiwiRGF5VGFibGVTbGljZXIiLCJmb3JjZURheUlmTGlzdEl0ZW0iLCJzbGljZVJhbmdlIiwiZGF0ZVJhbmdlIiwiZGF5VGFibGVNb2RlbCIsIkRheVRhYmxlIiwic2xpY2VyIiwidGFibGVSZWYiLCJzbGljZVByb3BzIiwibmV4dERheVRocmVzaG9sZCIsImhlYWRlckFsaWduRWxSZWYiLCJEYXlUYWJsZVZpZXciLCJidWlsZERheVRhYmxlTW9kZWwiLCJoZWFkZXJSZWYiLCJkYXRlUHJvZmlsZUdlbmVyYXRvciIsImhlYWRlckNvbnRlbnQiLCJkYXlIZWFkZXJzIiwiZGF0ZXMiLCJoZWFkZXJEYXRlcyIsImRhdGVzUmVwRGlzdGluY3REYXlzIiwiY29udGVudEFyZyIsImJ1c2luZXNzSG91cnMiLCJkYXRlU2VsZWN0aW9uIiwiZXZlbnRTdG9yZSIsImV2ZW50VWlCYXNlcyIsInRhYmxlQ29sR3JvdXBOb2RlIiwid2Vla051bWJlcnMiLCJkYXlTZXJpZXMiLCJyZW5kZXJSYW5nZSIsInRlc3QiLCJUYWJsZURhdGVQcm9maWxlR2VuZXJhdG9yIiwiYnVpbGRSZW5kZXJSYW5nZSIsImlzUmFuZ2VBbGxEYXkiLCJidWlsZERheVRhYmxlUmVuZGVyUmFuZ2UiLCJzbmFwVG9XZWVrIiwiZml4ZWRXZWVrQ291bnQiLCJlbmRPZldlZWsiLCJzdGFydE9mV2VlayIsImxhc3RNb250aFJlbmRlclN0YXJ0Iiwic3RhcnRPZk1vbnRoIiwiY2VpbCIsImNzc18yNDh6IiwiRGF5R3JpZFZpZXciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@fullcalendar/daygrid/internal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@fullcalendar/interaction/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@fullcalendar/interaction/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Draggable: () => (/* binding */ ExternalDraggable),\n/* harmony export */   ThirdPartyDraggable: () => (/* binding */ ThirdPartyDraggable),\n/* harmony export */   \"default\": () => (/* binding */ index)\n/* harmony export */ });\n/* harmony import */ var _fullcalendar_core_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fullcalendar/core/index.js */ \"(ssr)/./node_modules/@fullcalendar/core/index.js\");\n/* harmony import */ var _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fullcalendar/core/internal.js */ \"(ssr)/./node_modules/@fullcalendar/core/internal-common.js\");\n\n\n_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bI.touchMouseIgnoreWait = 500;\nlet ignoreMouseDepth = 0;\nlet listenerCnt = 0;\nlet isWindowTouchMoveCancelled = false;\n/*\nUses a \"pointer\" abstraction, which monitors UI events for both mouse and touch.\nTracks when the pointer \"drags\" on a certain element, meaning down+move+up.\n\nAlso, tracks if there was touch-scrolling.\nAlso, can prevent touch-scrolling from happening.\nAlso, can fire pointermove events when scrolling happens underneath, even when no real pointer movement.\n\nemits:\n- pointerdown\n- pointermove\n- pointerup\n*/ class PointerDragging {\n    constructor(containerEl){\n        this.subjectEl = null;\n        // options that can be directly assigned by caller\n        this.selector = \"\"; // will cause subjectEl in all emitted events to be this element\n        this.handleSelector = \"\";\n        this.shouldIgnoreMove = false;\n        this.shouldWatchScroll = true; // for simulating pointermove on scroll\n        // internal states\n        this.isDragging = false;\n        this.isTouchDragging = false;\n        this.wasTouchScroll = false;\n        // Mouse\n        // ----------------------------------------------------------------------------------------------------\n        this.handleMouseDown = (ev)=>{\n            if (!this.shouldIgnoreMouse() && isPrimaryMouseButton(ev) && this.tryStart(ev)) {\n                let pev = this.createEventFromMouse(ev, true);\n                this.emitter.trigger(\"pointerdown\", pev);\n                this.initScrollWatch(pev);\n                if (!this.shouldIgnoreMove) {\n                    document.addEventListener(\"mousemove\", this.handleMouseMove);\n                }\n                document.addEventListener(\"mouseup\", this.handleMouseUp);\n            }\n        };\n        this.handleMouseMove = (ev)=>{\n            let pev = this.createEventFromMouse(ev);\n            this.recordCoords(pev);\n            this.emitter.trigger(\"pointermove\", pev);\n        };\n        this.handleMouseUp = (ev)=>{\n            document.removeEventListener(\"mousemove\", this.handleMouseMove);\n            document.removeEventListener(\"mouseup\", this.handleMouseUp);\n            this.emitter.trigger(\"pointerup\", this.createEventFromMouse(ev));\n            this.cleanup(); // call last so that pointerup has access to props\n        };\n        // Touch\n        // ----------------------------------------------------------------------------------------------------\n        this.handleTouchStart = (ev)=>{\n            if (this.tryStart(ev)) {\n                this.isTouchDragging = true;\n                let pev = this.createEventFromTouch(ev, true);\n                this.emitter.trigger(\"pointerdown\", pev);\n                this.initScrollWatch(pev);\n                // unlike mouse, need to attach to target, not document\n                // https://stackoverflow.com/a/45760014\n                let targetEl = ev.target;\n                if (!this.shouldIgnoreMove) {\n                    targetEl.addEventListener(\"touchmove\", this.handleTouchMove);\n                }\n                targetEl.addEventListener(\"touchend\", this.handleTouchEnd);\n                targetEl.addEventListener(\"touchcancel\", this.handleTouchEnd); // treat it as a touch end\n                // attach a handler to get called when ANY scroll action happens on the page.\n                // this was impossible to do with normal on/off because 'scroll' doesn't bubble.\n                // http://stackoverflow.com/a/32954565/96342\n                window.addEventListener(\"scroll\", this.handleTouchScroll, true);\n            }\n        };\n        this.handleTouchMove = (ev)=>{\n            let pev = this.createEventFromTouch(ev);\n            this.recordCoords(pev);\n            this.emitter.trigger(\"pointermove\", pev);\n        };\n        this.handleTouchEnd = (ev)=>{\n            if (this.isDragging) {\n                let targetEl = ev.target;\n                targetEl.removeEventListener(\"touchmove\", this.handleTouchMove);\n                targetEl.removeEventListener(\"touchend\", this.handleTouchEnd);\n                targetEl.removeEventListener(\"touchcancel\", this.handleTouchEnd);\n                window.removeEventListener(\"scroll\", this.handleTouchScroll, true); // useCaptured=true\n                this.emitter.trigger(\"pointerup\", this.createEventFromTouch(ev));\n                this.cleanup(); // call last so that pointerup has access to props\n                this.isTouchDragging = false;\n                startIgnoringMouse();\n            }\n        };\n        this.handleTouchScroll = ()=>{\n            this.wasTouchScroll = true;\n        };\n        this.handleScroll = (ev)=>{\n            if (!this.shouldIgnoreMove) {\n                let pageX = window.scrollX - this.prevScrollX + this.prevPageX;\n                let pageY = window.scrollY - this.prevScrollY + this.prevPageY;\n                this.emitter.trigger(\"pointermove\", {\n                    origEvent: ev,\n                    isTouch: this.isTouchDragging,\n                    subjectEl: this.subjectEl,\n                    pageX,\n                    pageY,\n                    deltaX: pageX - this.origPageX,\n                    deltaY: pageY - this.origPageY\n                });\n            }\n        };\n        this.containerEl = containerEl;\n        this.emitter = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.F();\n        containerEl.addEventListener(\"mousedown\", this.handleMouseDown);\n        containerEl.addEventListener(\"touchstart\", this.handleTouchStart, {\n            passive: true\n        });\n        listenerCreated();\n    }\n    destroy() {\n        this.containerEl.removeEventListener(\"mousedown\", this.handleMouseDown);\n        this.containerEl.removeEventListener(\"touchstart\", this.handleTouchStart, {\n            passive: true\n        });\n        listenerDestroyed();\n    }\n    tryStart(ev) {\n        let subjectEl = this.querySubjectEl(ev);\n        let downEl = ev.target;\n        if (subjectEl && (!this.handleSelector || (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.$)(downEl, this.handleSelector))) {\n            this.subjectEl = subjectEl;\n            this.isDragging = true; // do this first so cancelTouchScroll will work\n            this.wasTouchScroll = false;\n            return true;\n        }\n        return false;\n    }\n    cleanup() {\n        isWindowTouchMoveCancelled = false;\n        this.isDragging = false;\n        this.subjectEl = null;\n        // keep wasTouchScroll around for later access\n        this.destroyScrollWatch();\n    }\n    querySubjectEl(ev) {\n        if (this.selector) {\n            return (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.$)(ev.target, this.selector);\n        }\n        return this.containerEl;\n    }\n    shouldIgnoreMouse() {\n        return ignoreMouseDepth || this.isTouchDragging;\n    }\n    // can be called by user of this class, to cancel touch-based scrolling for the current drag\n    cancelTouchScroll() {\n        if (this.isDragging) {\n            isWindowTouchMoveCancelled = true;\n        }\n    }\n    // Scrolling that simulates pointermoves\n    // ----------------------------------------------------------------------------------------------------\n    initScrollWatch(ev) {\n        if (this.shouldWatchScroll) {\n            this.recordCoords(ev);\n            window.addEventListener(\"scroll\", this.handleScroll, true); // useCapture=true\n        }\n    }\n    recordCoords(ev) {\n        if (this.shouldWatchScroll) {\n            this.prevPageX = ev.pageX;\n            this.prevPageY = ev.pageY;\n            this.prevScrollX = window.scrollX;\n            this.prevScrollY = window.scrollY;\n        }\n    }\n    destroyScrollWatch() {\n        if (this.shouldWatchScroll) {\n            window.removeEventListener(\"scroll\", this.handleScroll, true); // useCaptured=true\n        }\n    }\n    // Event Normalization\n    // ----------------------------------------------------------------------------------------------------\n    createEventFromMouse(ev, isFirst) {\n        let deltaX = 0;\n        let deltaY = 0;\n        // TODO: repeat code\n        if (isFirst) {\n            this.origPageX = ev.pageX;\n            this.origPageY = ev.pageY;\n        } else {\n            deltaX = ev.pageX - this.origPageX;\n            deltaY = ev.pageY - this.origPageY;\n        }\n        return {\n            origEvent: ev,\n            isTouch: false,\n            subjectEl: this.subjectEl,\n            pageX: ev.pageX,\n            pageY: ev.pageY,\n            deltaX,\n            deltaY\n        };\n    }\n    createEventFromTouch(ev, isFirst) {\n        let touches = ev.touches;\n        let pageX;\n        let pageY;\n        let deltaX = 0;\n        let deltaY = 0;\n        // if touch coords available, prefer,\n        // because FF would give bad ev.pageX ev.pageY\n        if (touches && touches.length) {\n            pageX = touches[0].pageX;\n            pageY = touches[0].pageY;\n        } else {\n            pageX = ev.pageX;\n            pageY = ev.pageY;\n        }\n        // TODO: repeat code\n        if (isFirst) {\n            this.origPageX = pageX;\n            this.origPageY = pageY;\n        } else {\n            deltaX = pageX - this.origPageX;\n            deltaY = pageY - this.origPageY;\n        }\n        return {\n            origEvent: ev,\n            isTouch: true,\n            subjectEl: this.subjectEl,\n            pageX,\n            pageY,\n            deltaX,\n            deltaY\n        };\n    }\n}\n// Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)\nfunction isPrimaryMouseButton(ev) {\n    return ev.button === 0 && !ev.ctrlKey;\n}\n// Ignoring fake mouse events generated by touch\n// ----------------------------------------------------------------------------------------------------\nfunction startIgnoringMouse() {\n    ignoreMouseDepth += 1;\n    setTimeout(()=>{\n        ignoreMouseDepth -= 1;\n    }, _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bI.touchMouseIgnoreWait);\n}\n// We want to attach touchmove as early as possible for Safari\n// ----------------------------------------------------------------------------------------------------\nfunction listenerCreated() {\n    listenerCnt += 1;\n    if (listenerCnt === 1) {\n        window.addEventListener(\"touchmove\", onWindowTouchMove, {\n            passive: false\n        });\n    }\n}\nfunction listenerDestroyed() {\n    listenerCnt -= 1;\n    if (!listenerCnt) {\n        window.removeEventListener(\"touchmove\", onWindowTouchMove, {\n            passive: false\n        });\n    }\n}\nfunction onWindowTouchMove(ev) {\n    if (isWindowTouchMoveCancelled) {\n        ev.preventDefault();\n    }\n}\n/*\nAn effect in which an element follows the movement of a pointer across the screen.\nThe moving element is a clone of some other element.\nMust call start + handleMove + stop.\n*/ class ElementMirror {\n    constructor(){\n        this.isVisible = false; // must be explicitly enabled\n        this.sourceEl = null;\n        this.mirrorEl = null;\n        this.sourceElRect = null; // screen coords relative to viewport\n        // options that can be set directly by caller\n        this.parentNode = document.body; // HIGHLY SUGGESTED to set this to sidestep ShadowDOM issues\n        this.zIndex = 9999;\n        this.revertDuration = 0;\n    }\n    start(sourceEl, pageX, pageY) {\n        this.sourceEl = sourceEl;\n        this.sourceElRect = this.sourceEl.getBoundingClientRect();\n        this.origScreenX = pageX - window.scrollX;\n        this.origScreenY = pageY - window.scrollY;\n        this.deltaX = 0;\n        this.deltaY = 0;\n        this.updateElPosition();\n    }\n    handleMove(pageX, pageY) {\n        this.deltaX = pageX - window.scrollX - this.origScreenX;\n        this.deltaY = pageY - window.scrollY - this.origScreenY;\n        this.updateElPosition();\n    }\n    // can be called before start\n    setIsVisible(bool) {\n        if (bool) {\n            if (!this.isVisible) {\n                if (this.mirrorEl) {\n                    this.mirrorEl.style.display = \"\";\n                }\n                this.isVisible = bool; // needs to happen before updateElPosition\n                this.updateElPosition(); // because was not updating the position while invisible\n            }\n        } else if (this.isVisible) {\n            if (this.mirrorEl) {\n                this.mirrorEl.style.display = \"none\";\n            }\n            this.isVisible = bool;\n        }\n    }\n    // always async\n    stop(needsRevertAnimation, callback) {\n        let done = ()=>{\n            this.cleanup();\n            callback();\n        };\n        if (needsRevertAnimation && this.mirrorEl && this.isVisible && this.revertDuration && // if 0, transition won't work\n        (this.deltaX || this.deltaY // if same coords, transition won't work\n        )) {\n            this.doRevertAnimation(done, this.revertDuration);\n        } else {\n            setTimeout(done, 0);\n        }\n    }\n    doRevertAnimation(callback, revertDuration) {\n        let mirrorEl = this.mirrorEl;\n        let finalSourceElRect = this.sourceEl.getBoundingClientRect(); // because autoscrolling might have happened\n        mirrorEl.style.transition = \"top \" + revertDuration + \"ms,\" + \"left \" + revertDuration + \"ms\";\n        (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.aP)(mirrorEl, {\n            left: finalSourceElRect.left,\n            top: finalSourceElRect.top\n        });\n        (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.b2)(mirrorEl, ()=>{\n            mirrorEl.style.transition = \"\";\n            callback();\n        });\n    }\n    cleanup() {\n        if (this.mirrorEl) {\n            (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.aO)(this.mirrorEl);\n            this.mirrorEl = null;\n        }\n        this.sourceEl = null;\n    }\n    updateElPosition() {\n        if (this.sourceEl && this.isVisible) {\n            (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.aP)(this.getMirrorEl(), {\n                left: this.sourceElRect.left + this.deltaX,\n                top: this.sourceElRect.top + this.deltaY\n            });\n        }\n    }\n    getMirrorEl() {\n        let sourceElRect = this.sourceElRect;\n        let mirrorEl = this.mirrorEl;\n        if (!mirrorEl) {\n            mirrorEl = this.mirrorEl = this.sourceEl.cloneNode(true); // cloneChildren=true\n            // we don't want long taps or any mouse interaction causing selection/menus.\n            // would use preventSelection(), but that prevents selectstart, causing problems.\n            mirrorEl.style.userSelect = \"none\";\n            mirrorEl.style.webkitUserSelect = \"none\";\n            mirrorEl.style.pointerEvents = \"none\";\n            mirrorEl.classList.add(\"fc-event-dragging\");\n            (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.aP)(mirrorEl, {\n                position: \"fixed\",\n                zIndex: this.zIndex,\n                visibility: \"\",\n                boxSizing: \"border-box\",\n                width: sourceElRect.right - sourceElRect.left,\n                height: sourceElRect.bottom - sourceElRect.top,\n                right: \"auto\",\n                bottom: \"auto\",\n                margin: 0\n            });\n            this.parentNode.appendChild(mirrorEl);\n        }\n        return mirrorEl;\n    }\n}\n/*\nIs a cache for a given element's scroll information (all the info that ScrollController stores)\nin addition the \"client rectangle\" of the element.. the area within the scrollbars.\n\nThe cache can be in one of two modes:\n- doesListening:false - ignores when the container is scrolled by someone else\n- doesListening:true - watch for scrolling and update the cache\n*/ class ScrollGeomCache extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bb {\n    constructor(scrollController, doesListening){\n        super();\n        this.handleScroll = ()=>{\n            this.scrollTop = this.scrollController.getScrollTop();\n            this.scrollLeft = this.scrollController.getScrollLeft();\n            this.handleScrollChange();\n        };\n        this.scrollController = scrollController;\n        this.doesListening = doesListening;\n        this.scrollTop = this.origScrollTop = scrollController.getScrollTop();\n        this.scrollLeft = this.origScrollLeft = scrollController.getScrollLeft();\n        this.scrollWidth = scrollController.getScrollWidth();\n        this.scrollHeight = scrollController.getScrollHeight();\n        this.clientWidth = scrollController.getClientWidth();\n        this.clientHeight = scrollController.getClientHeight();\n        this.clientRect = this.computeClientRect(); // do last in case it needs cached values\n        if (this.doesListening) {\n            this.getEventTarget().addEventListener(\"scroll\", this.handleScroll);\n        }\n    }\n    destroy() {\n        if (this.doesListening) {\n            this.getEventTarget().removeEventListener(\"scroll\", this.handleScroll);\n        }\n    }\n    getScrollTop() {\n        return this.scrollTop;\n    }\n    getScrollLeft() {\n        return this.scrollLeft;\n    }\n    setScrollTop(top) {\n        this.scrollController.setScrollTop(top);\n        if (!this.doesListening) {\n            // we are not relying on the element to normalize out-of-bounds scroll values\n            // so we need to sanitize ourselves\n            this.scrollTop = Math.max(Math.min(top, this.getMaxScrollTop()), 0);\n            this.handleScrollChange();\n        }\n    }\n    setScrollLeft(top) {\n        this.scrollController.setScrollLeft(top);\n        if (!this.doesListening) {\n            // we are not relying on the element to normalize out-of-bounds scroll values\n            // so we need to sanitize ourselves\n            this.scrollLeft = Math.max(Math.min(top, this.getMaxScrollLeft()), 0);\n            this.handleScrollChange();\n        }\n    }\n    getClientWidth() {\n        return this.clientWidth;\n    }\n    getClientHeight() {\n        return this.clientHeight;\n    }\n    getScrollWidth() {\n        return this.scrollWidth;\n    }\n    getScrollHeight() {\n        return this.scrollHeight;\n    }\n    handleScrollChange() {}\n}\nclass ElementScrollGeomCache extends ScrollGeomCache {\n    constructor(el, doesListening){\n        super(new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bc(el), doesListening);\n    }\n    getEventTarget() {\n        return this.scrollController.el;\n    }\n    computeClientRect() {\n        return (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.b3)(this.scrollController.el);\n    }\n}\nclass WindowScrollGeomCache extends ScrollGeomCache {\n    constructor(doesListening){\n        super(new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bd(), doesListening);\n    }\n    getEventTarget() {\n        return window;\n    }\n    computeClientRect() {\n        return {\n            left: this.scrollLeft,\n            right: this.scrollLeft + this.clientWidth,\n            top: this.scrollTop,\n            bottom: this.scrollTop + this.clientHeight\n        };\n    }\n    // the window is the only scroll object that changes it's rectangle relative\n    // to the document's topleft as it scrolls\n    handleScrollChange() {\n        this.clientRect = this.computeClientRect();\n    }\n}\n// If available we are using native \"performance\" API instead of \"Date\"\n// Read more about it on MDN:\n// https://developer.mozilla.org/en-US/docs/Web/API/Performance\nconst getTime = typeof performance === \"function\" ? performance.now : Date.now;\n/*\nFor a pointer interaction, automatically scrolls certain scroll containers when the pointer\napproaches the edge.\n\nThe caller must call start + handleMove + stop.\n*/ class AutoScroller {\n    constructor(){\n        // options that can be set by caller\n        this.isEnabled = true;\n        this.scrollQuery = [\n            window,\n            \".fc-scroller\"\n        ];\n        this.edgeThreshold = 50; // pixels\n        this.maxVelocity = 300; // pixels per second\n        // internal state\n        this.pointerScreenX = null;\n        this.pointerScreenY = null;\n        this.isAnimating = false;\n        this.scrollCaches = null;\n        // protect against the initial pointerdown being too close to an edge and starting the scroll\n        this.everMovedUp = false;\n        this.everMovedDown = false;\n        this.everMovedLeft = false;\n        this.everMovedRight = false;\n        this.animate = ()=>{\n            if (this.isAnimating) {\n                let edge = this.computeBestEdge(this.pointerScreenX + window.scrollX, this.pointerScreenY + window.scrollY);\n                if (edge) {\n                    let now = getTime();\n                    this.handleSide(edge, (now - this.msSinceRequest) / 1000);\n                    this.requestAnimation(now);\n                } else {\n                    this.isAnimating = false; // will stop animation\n                }\n            }\n        };\n    }\n    start(pageX, pageY, scrollStartEl) {\n        if (this.isEnabled) {\n            this.scrollCaches = this.buildCaches(scrollStartEl);\n            this.pointerScreenX = null;\n            this.pointerScreenY = null;\n            this.everMovedUp = false;\n            this.everMovedDown = false;\n            this.everMovedLeft = false;\n            this.everMovedRight = false;\n            this.handleMove(pageX, pageY);\n        }\n    }\n    handleMove(pageX, pageY) {\n        if (this.isEnabled) {\n            let pointerScreenX = pageX - window.scrollX;\n            let pointerScreenY = pageY - window.scrollY;\n            let yDelta = this.pointerScreenY === null ? 0 : pointerScreenY - this.pointerScreenY;\n            let xDelta = this.pointerScreenX === null ? 0 : pointerScreenX - this.pointerScreenX;\n            if (yDelta < 0) {\n                this.everMovedUp = true;\n            } else if (yDelta > 0) {\n                this.everMovedDown = true;\n            }\n            if (xDelta < 0) {\n                this.everMovedLeft = true;\n            } else if (xDelta > 0) {\n                this.everMovedRight = true;\n            }\n            this.pointerScreenX = pointerScreenX;\n            this.pointerScreenY = pointerScreenY;\n            if (!this.isAnimating) {\n                this.isAnimating = true;\n                this.requestAnimation(getTime());\n            }\n        }\n    }\n    stop() {\n        if (this.isEnabled) {\n            this.isAnimating = false; // will stop animation\n            for (let scrollCache of this.scrollCaches){\n                scrollCache.destroy();\n            }\n            this.scrollCaches = null;\n        }\n    }\n    requestAnimation(now) {\n        this.msSinceRequest = now;\n        requestAnimationFrame(this.animate);\n    }\n    handleSide(edge, seconds) {\n        let { scrollCache } = edge;\n        let { edgeThreshold } = this;\n        let invDistance = edgeThreshold - edge.distance;\n        let velocity = invDistance * invDistance / (edgeThreshold * edgeThreshold) * // quadratic\n        this.maxVelocity * seconds;\n        let sign = 1;\n        switch(edge.name){\n            case \"left\":\n                sign = -1;\n            // falls through\n            case \"right\":\n                scrollCache.setScrollLeft(scrollCache.getScrollLeft() + velocity * sign);\n                break;\n            case \"top\":\n                sign = -1;\n            // falls through\n            case \"bottom\":\n                scrollCache.setScrollTop(scrollCache.getScrollTop() + velocity * sign);\n                break;\n        }\n    }\n    // left/top are relative to document topleft\n    computeBestEdge(left, top) {\n        let { edgeThreshold } = this;\n        let bestSide = null;\n        let scrollCaches = this.scrollCaches || [];\n        for (let scrollCache of scrollCaches){\n            let rect = scrollCache.clientRect;\n            let leftDist = left - rect.left;\n            let rightDist = rect.right - left;\n            let topDist = top - rect.top;\n            let bottomDist = rect.bottom - top;\n            // completely within the rect?\n            if (leftDist >= 0 && rightDist >= 0 && topDist >= 0 && bottomDist >= 0) {\n                if (topDist <= edgeThreshold && this.everMovedUp && scrollCache.canScrollUp() && (!bestSide || bestSide.distance > topDist)) {\n                    bestSide = {\n                        scrollCache,\n                        name: \"top\",\n                        distance: topDist\n                    };\n                }\n                if (bottomDist <= edgeThreshold && this.everMovedDown && scrollCache.canScrollDown() && (!bestSide || bestSide.distance > bottomDist)) {\n                    bestSide = {\n                        scrollCache,\n                        name: \"bottom\",\n                        distance: bottomDist\n                    };\n                }\n                /*\n                TODO: fix broken RTL scrolling. canScrollLeft always returning false\n                https://github.com/fullcalendar/fullcalendar/issues/4837\n                */ if (leftDist <= edgeThreshold && this.everMovedLeft && scrollCache.canScrollLeft() && (!bestSide || bestSide.distance > leftDist)) {\n                    bestSide = {\n                        scrollCache,\n                        name: \"left\",\n                        distance: leftDist\n                    };\n                }\n                if (rightDist <= edgeThreshold && this.everMovedRight && scrollCache.canScrollRight() && (!bestSide || bestSide.distance > rightDist)) {\n                    bestSide = {\n                        scrollCache,\n                        name: \"right\",\n                        distance: rightDist\n                    };\n                }\n            }\n        }\n        return bestSide;\n    }\n    buildCaches(scrollStartEl) {\n        return this.queryScrollEls(scrollStartEl).map((el)=>{\n            if (el === window) {\n                return new WindowScrollGeomCache(false); // false = don't listen to user-generated scrolls\n            }\n            return new ElementScrollGeomCache(el, false); // false = don't listen to user-generated scrolls\n        });\n    }\n    queryScrollEls(scrollStartEl) {\n        let els = [];\n        for (let query of this.scrollQuery){\n            if (typeof query === \"object\") {\n                els.push(query);\n            } else {\n                /*\n                TODO: in the future, always have auto-scroll happen on element where current Hit came from\n                Ticket: https://github.com/fullcalendar/fullcalendar/issues/4593\n                */ els.push(...Array.prototype.slice.call(scrollStartEl.getRootNode().querySelectorAll(query)));\n            }\n        }\n        return els;\n    }\n}\n/*\nMonitors dragging on an element. Has a number of high-level features:\n- minimum distance required before dragging\n- minimum wait time (\"delay\") before dragging\n- a mirror element that follows the pointer\n*/ class FeaturefulElementDragging extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bH {\n    constructor(containerEl, selector){\n        super(containerEl);\n        this.containerEl = containerEl;\n        // options that can be directly set by caller\n        // the caller can also set the PointerDragging's options as well\n        this.delay = null;\n        this.minDistance = 0;\n        this.touchScrollAllowed = true; // prevents drag from starting and blocks scrolling during drag\n        this.mirrorNeedsRevert = false;\n        this.isInteracting = false; // is the user validly moving the pointer? lasts until pointerup\n        this.isDragging = false; // is it INTENTFULLY dragging? lasts until after revert animation\n        this.isDelayEnded = false;\n        this.isDistanceSurpassed = false;\n        this.delayTimeoutId = null;\n        this.onPointerDown = (ev)=>{\n            if (!this.isDragging) {\n                this.isInteracting = true;\n                this.isDelayEnded = false;\n                this.isDistanceSurpassed = false;\n                (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ar)(document.body);\n                (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.at)(document.body);\n                // prevent links from being visited if there's an eventual drag.\n                // also prevents selection in older browsers (maybe?).\n                // not necessary for touch, besides, browser would complain about passiveness.\n                if (!ev.isTouch) {\n                    ev.origEvent.preventDefault();\n                }\n                this.emitter.trigger(\"pointerdown\", ev);\n                if (this.isInteracting && // not destroyed via pointerdown handler\n                !this.pointer.shouldIgnoreMove) {\n                    // actions related to initiating dragstart+dragmove+dragend...\n                    this.mirror.setIsVisible(false); // reset. caller must set-visible\n                    this.mirror.start(ev.subjectEl, ev.pageX, ev.pageY); // must happen on first pointer down\n                    this.startDelay(ev);\n                    if (!this.minDistance) {\n                        this.handleDistanceSurpassed(ev);\n                    }\n                }\n            }\n        };\n        this.onPointerMove = (ev)=>{\n            if (this.isInteracting) {\n                this.emitter.trigger(\"pointermove\", ev);\n                if (!this.isDistanceSurpassed) {\n                    let minDistance = this.minDistance;\n                    let distanceSq; // current distance from the origin, squared\n                    let { deltaX, deltaY } = ev;\n                    distanceSq = deltaX * deltaX + deltaY * deltaY;\n                    if (distanceSq >= minDistance * minDistance) {\n                        this.handleDistanceSurpassed(ev);\n                    }\n                }\n                if (this.isDragging) {\n                    // a real pointer move? (not one simulated by scrolling)\n                    if (ev.origEvent.type !== \"scroll\") {\n                        this.mirror.handleMove(ev.pageX, ev.pageY);\n                        this.autoScroller.handleMove(ev.pageX, ev.pageY);\n                    }\n                    this.emitter.trigger(\"dragmove\", ev);\n                }\n            }\n        };\n        this.onPointerUp = (ev)=>{\n            if (this.isInteracting) {\n                this.isInteracting = false;\n                (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.as)(document.body);\n                (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.au)(document.body);\n                this.emitter.trigger(\"pointerup\", ev); // can potentially set mirrorNeedsRevert\n                if (this.isDragging) {\n                    this.autoScroller.stop();\n                    this.tryStopDrag(ev); // which will stop the mirror\n                }\n                if (this.delayTimeoutId) {\n                    clearTimeout(this.delayTimeoutId);\n                    this.delayTimeoutId = null;\n                }\n            }\n        };\n        let pointer = this.pointer = new PointerDragging(containerEl);\n        pointer.emitter.on(\"pointerdown\", this.onPointerDown);\n        pointer.emitter.on(\"pointermove\", this.onPointerMove);\n        pointer.emitter.on(\"pointerup\", this.onPointerUp);\n        if (selector) {\n            pointer.selector = selector;\n        }\n        this.mirror = new ElementMirror();\n        this.autoScroller = new AutoScroller();\n    }\n    destroy() {\n        this.pointer.destroy();\n        // HACK: simulate a pointer-up to end the current drag\n        // TODO: fire 'dragend' directly and stop interaction. discourage use of pointerup event (b/c might not fire)\n        this.onPointerUp({});\n    }\n    startDelay(ev) {\n        if (typeof this.delay === \"number\") {\n            this.delayTimeoutId = setTimeout(()=>{\n                this.delayTimeoutId = null;\n                this.handleDelayEnd(ev);\n            }, this.delay); // not assignable to number!\n        } else {\n            this.handleDelayEnd(ev);\n        }\n    }\n    handleDelayEnd(ev) {\n        this.isDelayEnded = true;\n        this.tryStartDrag(ev);\n    }\n    handleDistanceSurpassed(ev) {\n        this.isDistanceSurpassed = true;\n        this.tryStartDrag(ev);\n    }\n    tryStartDrag(ev) {\n        if (this.isDelayEnded && this.isDistanceSurpassed) {\n            if (!this.pointer.wasTouchScroll || this.touchScrollAllowed) {\n                this.isDragging = true;\n                this.mirrorNeedsRevert = false;\n                this.autoScroller.start(ev.pageX, ev.pageY, this.containerEl);\n                this.emitter.trigger(\"dragstart\", ev);\n                if (this.touchScrollAllowed === false) {\n                    this.pointer.cancelTouchScroll();\n                }\n            }\n        }\n    }\n    tryStopDrag(ev) {\n        // .stop() is ALWAYS asynchronous, which we NEED because we want all pointerup events\n        // that come from the document to fire beforehand. much more convenient this way.\n        this.mirror.stop(this.mirrorNeedsRevert, this.stopDrag.bind(this, ev));\n    }\n    stopDrag(ev) {\n        this.isDragging = false;\n        this.emitter.trigger(\"dragend\", ev);\n    }\n    // fill in the implementations...\n    setIgnoreMove(bool) {\n        this.pointer.shouldIgnoreMove = bool;\n    }\n    setMirrorIsVisible(bool) {\n        this.mirror.setIsVisible(bool);\n    }\n    setMirrorNeedsRevert(bool) {\n        this.mirrorNeedsRevert = bool;\n    }\n    setAutoScrollEnabled(bool) {\n        this.autoScroller.isEnabled = bool;\n    }\n}\n/*\nWhen this class is instantiated, it records the offset of an element (relative to the document topleft),\nand continues to monitor scrolling, updating the cached coordinates if it needs to.\nDoes not access the DOM after instantiation, so highly performant.\n\nAlso keeps track of all scrolling/overflow:hidden containers that are parents of the given element\nand an determine if a given point is inside the combined clipping rectangle.\n*/ class OffsetTracker {\n    constructor(el){\n        this.el = el;\n        this.origRect = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.b6)(el);\n        // will work fine for divs that have overflow:hidden\n        this.scrollCaches = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.b5)(el).map((scrollEl)=>new ElementScrollGeomCache(scrollEl, true));\n    }\n    destroy() {\n        for (let scrollCache of this.scrollCaches){\n            scrollCache.destroy();\n        }\n    }\n    computeLeft() {\n        let left = this.origRect.left;\n        for (let scrollCache of this.scrollCaches){\n            left += scrollCache.origScrollLeft - scrollCache.getScrollLeft();\n        }\n        return left;\n    }\n    computeTop() {\n        let top = this.origRect.top;\n        for (let scrollCache of this.scrollCaches){\n            top += scrollCache.origScrollTop - scrollCache.getScrollTop();\n        }\n        return top;\n    }\n    isWithinClipping(pageX, pageY) {\n        let point = {\n            left: pageX,\n            top: pageY\n        };\n        for (let scrollCache of this.scrollCaches){\n            if (!isIgnoredClipping(scrollCache.getEventTarget()) && !(0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.aF)(point, scrollCache.clientRect)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n// certain clipping containers should never constrain interactions, like <html> and <body>\n// https://github.com/fullcalendar/fullcalendar/issues/3615\nfunction isIgnoredClipping(node) {\n    let tagName = node.tagName;\n    return tagName === \"HTML\" || tagName === \"BODY\";\n}\n/*\nTracks movement over multiple droppable areas (aka \"hits\")\nthat exist in one or more DateComponents.\nRelies on an existing draggable.\n\nemits:\n- pointerdown\n- dragstart\n- hitchange - fires initially, even if not over a hit\n- pointerup\n- (hitchange - again, to null, if ended over a hit)\n- dragend\n*/ class HitDragging {\n    constructor(dragging, droppableStore){\n        // options that can be set by caller\n        this.useSubjectCenter = false;\n        this.requireInitial = true; // if doesn't start out on a hit, won't emit any events\n        this.disablePointCheck = false;\n        this.initialHit = null;\n        this.movingHit = null;\n        this.finalHit = null; // won't ever be populated if shouldIgnoreMove\n        this.handlePointerDown = (ev)=>{\n            let { dragging } = this;\n            this.initialHit = null;\n            this.movingHit = null;\n            this.finalHit = null;\n            this.prepareHits();\n            this.processFirstCoord(ev);\n            if (this.initialHit || !this.requireInitial) {\n                dragging.setIgnoreMove(false);\n                // TODO: fire this before computing processFirstCoord, so listeners can cancel. this gets fired by almost every handler :(\n                this.emitter.trigger(\"pointerdown\", ev);\n            } else {\n                dragging.setIgnoreMove(true);\n            }\n        };\n        this.handleDragStart = (ev)=>{\n            this.emitter.trigger(\"dragstart\", ev);\n            this.handleMove(ev, true); // force = fire even if initially null\n        };\n        this.handleDragMove = (ev)=>{\n            this.emitter.trigger(\"dragmove\", ev);\n            this.handleMove(ev);\n        };\n        this.handlePointerUp = (ev)=>{\n            this.releaseHits();\n            this.emitter.trigger(\"pointerup\", ev);\n        };\n        this.handleDragEnd = (ev)=>{\n            if (this.movingHit) {\n                this.emitter.trigger(\"hitupdate\", null, true, ev);\n            }\n            this.finalHit = this.movingHit;\n            this.movingHit = null;\n            this.emitter.trigger(\"dragend\", ev);\n        };\n        this.droppableStore = droppableStore;\n        dragging.emitter.on(\"pointerdown\", this.handlePointerDown);\n        dragging.emitter.on(\"dragstart\", this.handleDragStart);\n        dragging.emitter.on(\"dragmove\", this.handleDragMove);\n        dragging.emitter.on(\"pointerup\", this.handlePointerUp);\n        dragging.emitter.on(\"dragend\", this.handleDragEnd);\n        this.dragging = dragging;\n        this.emitter = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.F();\n    }\n    // sets initialHit\n    // sets coordAdjust\n    processFirstCoord(ev) {\n        let origPoint = {\n            left: ev.pageX,\n            top: ev.pageY\n        };\n        let adjustedPoint = origPoint;\n        let subjectEl = ev.subjectEl;\n        let subjectRect;\n        if (subjectEl instanceof HTMLElement) {\n            subjectRect = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.b6)(subjectEl);\n            adjustedPoint = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.aG)(adjustedPoint, subjectRect);\n        }\n        let initialHit = this.initialHit = this.queryHitForOffset(adjustedPoint.left, adjustedPoint.top);\n        if (initialHit) {\n            if (this.useSubjectCenter && subjectRect) {\n                let slicedSubjectRect = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.aE)(subjectRect, initialHit.rect);\n                if (slicedSubjectRect) {\n                    adjustedPoint = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.aH)(slicedSubjectRect);\n                }\n            }\n            this.coordAdjust = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.aI)(adjustedPoint, origPoint);\n        } else {\n            this.coordAdjust = {\n                left: 0,\n                top: 0\n            };\n        }\n    }\n    handleMove(ev, forceHandle) {\n        let hit = this.queryHitForOffset(ev.pageX + this.coordAdjust.left, ev.pageY + this.coordAdjust.top);\n        if (forceHandle || !isHitsEqual(this.movingHit, hit)) {\n            this.movingHit = hit;\n            this.emitter.trigger(\"hitupdate\", hit, false, ev);\n        }\n    }\n    prepareHits() {\n        this.offsetTrackers = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.a)(this.droppableStore, (interactionSettings)=>{\n            interactionSettings.component.prepareHits();\n            return new OffsetTracker(interactionSettings.el);\n        });\n    }\n    releaseHits() {\n        let { offsetTrackers } = this;\n        for(let id in offsetTrackers){\n            offsetTrackers[id].destroy();\n        }\n        this.offsetTrackers = {};\n    }\n    queryHitForOffset(offsetLeft, offsetTop) {\n        let { droppableStore, offsetTrackers } = this;\n        let bestHit = null;\n        for(let id in droppableStore){\n            let component = droppableStore[id].component;\n            let offsetTracker = offsetTrackers[id];\n            if (offsetTracker && // wasn't destroyed mid-drag\n            offsetTracker.isWithinClipping(offsetLeft, offsetTop)) {\n                let originLeft = offsetTracker.computeLeft();\n                let originTop = offsetTracker.computeTop();\n                let positionLeft = offsetLeft - originLeft;\n                let positionTop = offsetTop - originTop;\n                let { origRect } = offsetTracker;\n                let width = origRect.right - origRect.left;\n                let height = origRect.bottom - origRect.top;\n                if (// must be within the element's bounds\n                positionLeft >= 0 && positionLeft < width && positionTop >= 0 && positionTop < height) {\n                    let hit = component.queryHit(positionLeft, positionTop, width, height);\n                    if (hit && // make sure the hit is within activeRange, meaning it's not a dead cell\n                    (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.b9)(hit.dateProfile.activeRange, hit.dateSpan.range) && // Ensure the component we are querying for the hit is accessibly my the pointer\n                    // Prevents obscured calendars (ex: under a modal dialog) from accepting hit\n                    // https://github.com/fullcalendar/fullcalendar/issues/5026\n                    (this.disablePointCheck || offsetTracker.el.contains(offsetTracker.el.getRootNode().elementFromPoint(// add-back origins to get coordinate relative to top-left of window viewport\n                    positionLeft + originLeft - window.scrollX, positionTop + originTop - window.scrollY))) && (!bestHit || hit.layer > bestHit.layer)) {\n                        hit.componentId = id;\n                        hit.context = component.context;\n                        // TODO: better way to re-orient rectangle\n                        hit.rect.left += originLeft;\n                        hit.rect.right += originLeft;\n                        hit.rect.top += originTop;\n                        hit.rect.bottom += originTop;\n                        bestHit = hit;\n                    }\n                }\n            }\n        }\n        return bestHit;\n    }\n}\nfunction isHitsEqual(hit0, hit1) {\n    if (!hit0 && !hit1) {\n        return true;\n    }\n    if (Boolean(hit0) !== Boolean(hit1)) {\n        return false;\n    }\n    return (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bf)(hit0.dateSpan, hit1.dateSpan);\n}\nfunction buildDatePointApiWithContext(dateSpan, context) {\n    let props = {};\n    for (let transform of context.pluginHooks.datePointTransforms){\n        Object.assign(props, transform(dateSpan, context));\n    }\n    Object.assign(props, buildDatePointApi(dateSpan, context.dateEnv));\n    return props;\n}\nfunction buildDatePointApi(span, dateEnv) {\n    return {\n        date: dateEnv.toDate(span.range.start),\n        dateStr: dateEnv.formatIso(span.range.start, {\n            omitTime: span.allDay\n        }),\n        allDay: span.allDay\n    };\n}\n/*\nMonitors when the user clicks on a specific date/time of a component.\nA pointerdown+pointerup on the same \"hit\" constitutes a click.\n*/ class DateClicking extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.Z {\n    constructor(settings){\n        super(settings);\n        this.handlePointerDown = (pev)=>{\n            let { dragging } = this;\n            let downEl = pev.origEvent.target;\n            // do this in pointerdown (not dragend) because DOM might be mutated by the time dragend is fired\n            dragging.setIgnoreMove(!this.component.isValidDateDownEl(downEl));\n        };\n        // won't even fire if moving was ignored\n        this.handleDragEnd = (ev)=>{\n            let { component } = this;\n            let { pointer } = this.dragging;\n            if (!pointer.wasTouchScroll) {\n                let { initialHit, finalHit } = this.hitDragging;\n                if (initialHit && finalHit && isHitsEqual(initialHit, finalHit)) {\n                    let { context } = component;\n                    let arg = Object.assign(Object.assign({}, buildDatePointApiWithContext(initialHit.dateSpan, context)), {\n                        dayEl: initialHit.dayEl,\n                        jsEvent: ev.origEvent,\n                        view: context.viewApi || context.calendarApi.view\n                    });\n                    context.emitter.trigger(\"dateClick\", arg);\n                }\n            }\n        };\n        // we DO want to watch pointer moves because otherwise finalHit won't get populated\n        this.dragging = new FeaturefulElementDragging(settings.el);\n        this.dragging.autoScroller.isEnabled = false;\n        let hitDragging = this.hitDragging = new HitDragging(this.dragging, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bG)(settings));\n        hitDragging.emitter.on(\"pointerdown\", this.handlePointerDown);\n        hitDragging.emitter.on(\"dragend\", this.handleDragEnd);\n    }\n    destroy() {\n        this.dragging.destroy();\n    }\n}\n/*\nTracks when the user selects a portion of time of a component,\nconstituted by a drag over date cells, with a possible delay at the beginning of the drag.\n*/ class DateSelecting extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.Z {\n    constructor(settings){\n        super(settings);\n        this.dragSelection = null;\n        this.handlePointerDown = (ev)=>{\n            let { component, dragging } = this;\n            let { options } = component.context;\n            let canSelect = options.selectable && component.isValidDateDownEl(ev.origEvent.target);\n            // don't bother to watch expensive moves if component won't do selection\n            dragging.setIgnoreMove(!canSelect);\n            // if touch, require user to hold down\n            dragging.delay = ev.isTouch ? getComponentTouchDelay$1(component) : null;\n        };\n        this.handleDragStart = (ev)=>{\n            this.component.context.calendarApi.unselect(ev); // unselect previous selections\n        };\n        this.handleHitUpdate = (hit, isFinal)=>{\n            let { context } = this.component;\n            let dragSelection = null;\n            let isInvalid = false;\n            if (hit) {\n                let initialHit = this.hitDragging.initialHit;\n                let disallowed = hit.componentId === initialHit.componentId && this.isHitComboAllowed && !this.isHitComboAllowed(initialHit, hit);\n                if (!disallowed) {\n                    dragSelection = joinHitsIntoSelection(initialHit, hit, context.pluginHooks.dateSelectionTransformers);\n                }\n                if (!dragSelection || !(0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.b_)(dragSelection, hit.dateProfile, context)) {\n                    isInvalid = true;\n                    dragSelection = null;\n                }\n            }\n            if (dragSelection) {\n                context.dispatch({\n                    type: \"SELECT_DATES\",\n                    selection: dragSelection\n                });\n            } else if (!isFinal) {\n                context.dispatch({\n                    type: \"UNSELECT_DATES\"\n                });\n            }\n            if (!isInvalid) {\n                (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.aw)();\n            } else {\n                (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ax)();\n            }\n            if (!isFinal) {\n                this.dragSelection = dragSelection; // only clear if moved away from all hits while dragging\n            }\n        };\n        this.handlePointerUp = (pev)=>{\n            if (this.dragSelection) {\n                // selection is already rendered, so just need to report selection\n                (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cu)(this.dragSelection, pev, this.component.context);\n                this.dragSelection = null;\n            }\n        };\n        let { component } = settings;\n        let { options } = component.context;\n        let dragging = this.dragging = new FeaturefulElementDragging(settings.el);\n        dragging.touchScrollAllowed = false;\n        dragging.minDistance = options.selectMinDistance || 0;\n        dragging.autoScroller.isEnabled = options.dragScroll;\n        let hitDragging = this.hitDragging = new HitDragging(this.dragging, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bG)(settings));\n        hitDragging.emitter.on(\"pointerdown\", this.handlePointerDown);\n        hitDragging.emitter.on(\"dragstart\", this.handleDragStart);\n        hitDragging.emitter.on(\"hitupdate\", this.handleHitUpdate);\n        hitDragging.emitter.on(\"pointerup\", this.handlePointerUp);\n    }\n    destroy() {\n        this.dragging.destroy();\n    }\n}\nfunction getComponentTouchDelay$1(component) {\n    let { options } = component.context;\n    let delay = options.selectLongPressDelay;\n    if (delay == null) {\n        delay = options.longPressDelay;\n    }\n    return delay;\n}\nfunction joinHitsIntoSelection(hit0, hit1, dateSelectionTransformers) {\n    let dateSpan0 = hit0.dateSpan;\n    let dateSpan1 = hit1.dateSpan;\n    let ms = [\n        dateSpan0.range.start,\n        dateSpan0.range.end,\n        dateSpan1.range.start,\n        dateSpan1.range.end\n    ];\n    ms.sort(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.av);\n    let props = {};\n    for (let transformer of dateSelectionTransformers){\n        let res = transformer(hit0, hit1);\n        if (res === false) {\n            return null;\n        }\n        if (res) {\n            Object.assign(props, res);\n        }\n    }\n    props.range = {\n        start: ms[0],\n        end: ms[3]\n    };\n    props.allDay = dateSpan0.allDay;\n    return props;\n}\nclass EventDragging extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.Z {\n    constructor(settings){\n        super(settings);\n        // internal state\n        this.subjectEl = null;\n        this.subjectSeg = null; // the seg being selected/dragged\n        this.isDragging = false;\n        this.eventRange = null;\n        this.relevantEvents = null; // the events being dragged\n        this.receivingContext = null;\n        this.validMutation = null;\n        this.mutatedRelevantEvents = null;\n        this.handlePointerDown = (ev)=>{\n            let origTarget = ev.origEvent.target;\n            let { component, dragging } = this;\n            let { mirror } = dragging;\n            let { options } = component.context;\n            let initialContext = component.context;\n            this.subjectEl = ev.subjectEl;\n            let subjectSeg = this.subjectSeg = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__._)(ev.subjectEl);\n            let eventRange = this.eventRange = subjectSeg.eventRange;\n            let eventInstanceId = eventRange.instance.instanceId;\n            this.relevantEvents = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.aV)(initialContext.getCurrentData().eventStore, eventInstanceId);\n            dragging.minDistance = ev.isTouch ? 0 : options.eventDragMinDistance;\n            dragging.delay = // only do a touch delay if touch and this event hasn't been selected yet\n            ev.isTouch && eventInstanceId !== component.props.eventSelection ? getComponentTouchDelay(component) : null;\n            if (options.fixedMirrorParent) {\n                mirror.parentNode = options.fixedMirrorParent;\n            } else {\n                mirror.parentNode = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.$)(origTarget, \".fc\");\n            }\n            mirror.revertDuration = options.dragRevertDuration;\n            let isValid = component.isValidSegDownEl(origTarget) && !(0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.$)(origTarget, \".fc-event-resizer\"); // NOT on a resizer\n            dragging.setIgnoreMove(!isValid);\n            // disable dragging for elements that are resizable (ie, selectable)\n            // but are not draggable\n            this.isDragging = isValid && ev.subjectEl.classList.contains(\"fc-event-draggable\");\n        };\n        this.handleDragStart = (ev)=>{\n            let initialContext = this.component.context;\n            let eventRange = this.eventRange;\n            let eventInstanceId = eventRange.instance.instanceId;\n            if (ev.isTouch) {\n                // need to select a different event?\n                if (eventInstanceId !== this.component.props.eventSelection) {\n                    initialContext.dispatch({\n                        type: \"SELECT_EVENT\",\n                        eventInstanceId\n                    });\n                }\n            } else {\n                // if now using mouse, but was previous touch interaction, clear selected event\n                initialContext.dispatch({\n                    type: \"UNSELECT_EVENT\"\n                });\n            }\n            if (this.isDragging) {\n                initialContext.calendarApi.unselect(ev); // unselect *date* selection\n                initialContext.emitter.trigger(\"eventDragStart\", {\n                    el: this.subjectEl,\n                    event: new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.a0(initialContext, eventRange.def, eventRange.instance),\n                    jsEvent: ev.origEvent,\n                    view: initialContext.viewApi\n                });\n            }\n        };\n        this.handleHitUpdate = (hit, isFinal)=>{\n            if (!this.isDragging) {\n                return;\n            }\n            let relevantEvents = this.relevantEvents;\n            let initialHit = this.hitDragging.initialHit;\n            let initialContext = this.component.context;\n            // states based on new hit\n            let receivingContext = null;\n            let mutation = null;\n            let mutatedRelevantEvents = null;\n            let isInvalid = false;\n            let interaction = {\n                affectedEvents: relevantEvents,\n                mutatedEvents: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.I)(),\n                isEvent: true\n            };\n            if (hit) {\n                receivingContext = hit.context;\n                let receivingOptions = receivingContext.options;\n                if (initialContext === receivingContext || receivingOptions.editable && receivingOptions.droppable) {\n                    mutation = computeEventMutation(initialHit, hit, this.eventRange.instance.range.start, receivingContext.getCurrentData().pluginHooks.eventDragMutationMassagers);\n                    if (mutation) {\n                        mutatedRelevantEvents = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bX)(relevantEvents, receivingContext.getCurrentData().eventUiBases, mutation, receivingContext);\n                        interaction.mutatedEvents = mutatedRelevantEvents;\n                        if (!(0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bZ)(interaction, hit.dateProfile, receivingContext)) {\n                            isInvalid = true;\n                            mutation = null;\n                            mutatedRelevantEvents = null;\n                            interaction.mutatedEvents = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.I)();\n                        }\n                    }\n                } else {\n                    receivingContext = null;\n                }\n            }\n            this.displayDrag(receivingContext, interaction);\n            if (!isInvalid) {\n                (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.aw)();\n            } else {\n                (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ax)();\n            }\n            if (!isFinal) {\n                if (initialContext === receivingContext && // TODO: write test for this\n                isHitsEqual(initialHit, hit)) {\n                    mutation = null;\n                }\n                this.dragging.setMirrorNeedsRevert(!mutation);\n                // render the mirror if no already-rendered mirror\n                // TODO: wish we could somehow wait for dispatch to guarantee render\n                this.dragging.setMirrorIsVisible(!hit || !this.subjectEl.getRootNode().querySelector(\".fc-event-mirror\"));\n                // assign states based on new hit\n                this.receivingContext = receivingContext;\n                this.validMutation = mutation;\n                this.mutatedRelevantEvents = mutatedRelevantEvents;\n            }\n        };\n        this.handlePointerUp = ()=>{\n            if (!this.isDragging) {\n                this.cleanup(); // because handleDragEnd won't fire\n            }\n        };\n        this.handleDragEnd = (ev)=>{\n            if (this.isDragging) {\n                let initialContext = this.component.context;\n                let initialView = initialContext.viewApi;\n                let { receivingContext, validMutation } = this;\n                let eventDef = this.eventRange.def;\n                let eventInstance = this.eventRange.instance;\n                let eventApi = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.a0(initialContext, eventDef, eventInstance);\n                let relevantEvents = this.relevantEvents;\n                let mutatedRelevantEvents = this.mutatedRelevantEvents;\n                let { finalHit } = this.hitDragging;\n                this.clearDrag(); // must happen after revert animation\n                initialContext.emitter.trigger(\"eventDragStop\", {\n                    el: this.subjectEl,\n                    event: eventApi,\n                    jsEvent: ev.origEvent,\n                    view: initialView\n                });\n                if (validMutation) {\n                    // dropped within same calendar\n                    if (receivingContext === initialContext) {\n                        let updatedEventApi = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.a0(initialContext, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);\n                        initialContext.dispatch({\n                            type: \"MERGE_EVENTS\",\n                            eventStore: mutatedRelevantEvents\n                        });\n                        let eventChangeArg = {\n                            oldEvent: eventApi,\n                            event: updatedEventApi,\n                            relatedEvents: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.w)(mutatedRelevantEvents, initialContext, eventInstance),\n                            revert () {\n                                initialContext.dispatch({\n                                    type: \"MERGE_EVENTS\",\n                                    eventStore: relevantEvents\n                                });\n                            }\n                        };\n                        let transformed = {};\n                        for (let transformer of initialContext.getCurrentData().pluginHooks.eventDropTransformers){\n                            Object.assign(transformed, transformer(validMutation, initialContext));\n                        }\n                        initialContext.emitter.trigger(\"eventDrop\", Object.assign(Object.assign(Object.assign({}, eventChangeArg), transformed), {\n                            el: ev.subjectEl,\n                            delta: validMutation.datesDelta,\n                            jsEvent: ev.origEvent,\n                            view: initialView\n                        }));\n                        initialContext.emitter.trigger(\"eventChange\", eventChangeArg);\n                    // dropped in different calendar\n                    } else if (receivingContext) {\n                        let eventRemoveArg = {\n                            event: eventApi,\n                            relatedEvents: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.w)(relevantEvents, initialContext, eventInstance),\n                            revert () {\n                                initialContext.dispatch({\n                                    type: \"MERGE_EVENTS\",\n                                    eventStore: relevantEvents\n                                });\n                            }\n                        };\n                        initialContext.emitter.trigger(\"eventLeave\", Object.assign(Object.assign({}, eventRemoveArg), {\n                            draggedEl: ev.subjectEl,\n                            view: initialView\n                        }));\n                        initialContext.dispatch({\n                            type: \"REMOVE_EVENTS\",\n                            eventStore: relevantEvents\n                        });\n                        initialContext.emitter.trigger(\"eventRemove\", eventRemoveArg);\n                        let addedEventDef = mutatedRelevantEvents.defs[eventDef.defId];\n                        let addedEventInstance = mutatedRelevantEvents.instances[eventInstance.instanceId];\n                        let addedEventApi = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.a0(receivingContext, addedEventDef, addedEventInstance);\n                        receivingContext.dispatch({\n                            type: \"MERGE_EVENTS\",\n                            eventStore: mutatedRelevantEvents\n                        });\n                        let eventAddArg = {\n                            event: addedEventApi,\n                            relatedEvents: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.w)(mutatedRelevantEvents, receivingContext, addedEventInstance),\n                            revert () {\n                                receivingContext.dispatch({\n                                    type: \"REMOVE_EVENTS\",\n                                    eventStore: mutatedRelevantEvents\n                                });\n                            }\n                        };\n                        receivingContext.emitter.trigger(\"eventAdd\", eventAddArg);\n                        if (ev.isTouch) {\n                            receivingContext.dispatch({\n                                type: \"SELECT_EVENT\",\n                                eventInstanceId: eventInstance.instanceId\n                            });\n                        }\n                        receivingContext.emitter.trigger(\"drop\", Object.assign(Object.assign({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext)), {\n                            draggedEl: ev.subjectEl,\n                            jsEvent: ev.origEvent,\n                            view: finalHit.context.viewApi\n                        }));\n                        receivingContext.emitter.trigger(\"eventReceive\", Object.assign(Object.assign({}, eventAddArg), {\n                            draggedEl: ev.subjectEl,\n                            view: finalHit.context.viewApi\n                        }));\n                    }\n                } else {\n                    initialContext.emitter.trigger(\"_noEventDrop\");\n                }\n            }\n            this.cleanup();\n        };\n        let { component } = this;\n        let { options } = component.context;\n        let dragging = this.dragging = new FeaturefulElementDragging(settings.el);\n        dragging.pointer.selector = EventDragging.SELECTOR;\n        dragging.touchScrollAllowed = false;\n        dragging.autoScroller.isEnabled = options.dragScroll;\n        let hitDragging = this.hitDragging = new HitDragging(this.dragging, _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.a7);\n        hitDragging.useSubjectCenter = settings.useEventCenter;\n        hitDragging.emitter.on(\"pointerdown\", this.handlePointerDown);\n        hitDragging.emitter.on(\"dragstart\", this.handleDragStart);\n        hitDragging.emitter.on(\"hitupdate\", this.handleHitUpdate);\n        hitDragging.emitter.on(\"pointerup\", this.handlePointerUp);\n        hitDragging.emitter.on(\"dragend\", this.handleDragEnd);\n    }\n    destroy() {\n        this.dragging.destroy();\n    }\n    // render a drag state on the next receivingCalendar\n    displayDrag(nextContext, state) {\n        let initialContext = this.component.context;\n        let prevContext = this.receivingContext;\n        // does the previous calendar need to be cleared?\n        if (prevContext && prevContext !== nextContext) {\n            // does the initial calendar need to be cleared?\n            // if so, don't clear all the way. we still need to to hide the affectedEvents\n            if (prevContext === initialContext) {\n                prevContext.dispatch({\n                    type: \"SET_EVENT_DRAG\",\n                    state: {\n                        affectedEvents: state.affectedEvents,\n                        mutatedEvents: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.I)(),\n                        isEvent: true\n                    }\n                });\n            // completely clear the old calendar if it wasn't the initial\n            } else {\n                prevContext.dispatch({\n                    type: \"UNSET_EVENT_DRAG\"\n                });\n            }\n        }\n        if (nextContext) {\n            nextContext.dispatch({\n                type: \"SET_EVENT_DRAG\",\n                state\n            });\n        }\n    }\n    clearDrag() {\n        let initialCalendar = this.component.context;\n        let { receivingContext } = this;\n        if (receivingContext) {\n            receivingContext.dispatch({\n                type: \"UNSET_EVENT_DRAG\"\n            });\n        }\n        // the initial calendar might have an dummy drag state from displayDrag\n        if (initialCalendar !== receivingContext) {\n            initialCalendar.dispatch({\n                type: \"UNSET_EVENT_DRAG\"\n            });\n        }\n    }\n    cleanup() {\n        this.subjectSeg = null;\n        this.isDragging = false;\n        this.eventRange = null;\n        this.relevantEvents = null;\n        this.receivingContext = null;\n        this.validMutation = null;\n        this.mutatedRelevantEvents = null;\n    }\n}\n// TODO: test this in IE11\n// QUESTION: why do we need it on the resizable???\nEventDragging.SELECTOR = \".fc-event-draggable, .fc-event-resizable\";\nfunction computeEventMutation(hit0, hit1, eventInstanceStart, massagers) {\n    let dateSpan0 = hit0.dateSpan;\n    let dateSpan1 = hit1.dateSpan;\n    let date0 = dateSpan0.range.start;\n    let date1 = dateSpan1.range.start;\n    let standardProps = {};\n    if (dateSpan0.allDay !== dateSpan1.allDay) {\n        standardProps.allDay = dateSpan1.allDay;\n        standardProps.hasEnd = hit1.context.options.allDayMaintainDuration;\n        if (dateSpan1.allDay) {\n            // means date1 is already start-of-day,\n            // but date0 needs to be converted\n            date0 = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.q)(eventInstanceStart);\n        } else {\n            // Moving from allDate->timed\n            // Doesn't matter where on the event the drag began, mutate the event's start-date to date1\n            date0 = eventInstanceStart;\n        }\n    }\n    let delta = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.aA)(date0, date1, hit0.context.dateEnv, hit0.componentId === hit1.componentId ? hit0.largeUnit : null);\n    if (delta.milliseconds) {\n        standardProps.allDay = false;\n    }\n    let mutation = {\n        datesDelta: delta,\n        standardProps\n    };\n    for (let massager of massagers){\n        massager(mutation, hit0, hit1);\n    }\n    return mutation;\n}\nfunction getComponentTouchDelay(component) {\n    let { options } = component.context;\n    let delay = options.eventLongPressDelay;\n    if (delay == null) {\n        delay = options.longPressDelay;\n    }\n    return delay;\n}\nclass EventResizing extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.Z {\n    constructor(settings){\n        super(settings);\n        // internal state\n        this.draggingSegEl = null;\n        this.draggingSeg = null; // TODO: rename to resizingSeg? subjectSeg?\n        this.eventRange = null;\n        this.relevantEvents = null;\n        this.validMutation = null;\n        this.mutatedRelevantEvents = null;\n        this.handlePointerDown = (ev)=>{\n            let { component } = this;\n            let segEl = this.querySegEl(ev);\n            let seg = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__._)(segEl);\n            let eventRange = this.eventRange = seg.eventRange;\n            this.dragging.minDistance = component.context.options.eventDragMinDistance;\n            // if touch, need to be working with a selected event\n            this.dragging.setIgnoreMove(!this.component.isValidSegDownEl(ev.origEvent.target) || ev.isTouch && this.component.props.eventSelection !== eventRange.instance.instanceId);\n        };\n        this.handleDragStart = (ev)=>{\n            let { context } = this.component;\n            let eventRange = this.eventRange;\n            this.relevantEvents = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.aV)(context.getCurrentData().eventStore, this.eventRange.instance.instanceId);\n            let segEl = this.querySegEl(ev);\n            this.draggingSegEl = segEl;\n            this.draggingSeg = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__._)(segEl);\n            context.calendarApi.unselect();\n            context.emitter.trigger(\"eventResizeStart\", {\n                el: segEl,\n                event: new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.a0(context, eventRange.def, eventRange.instance),\n                jsEvent: ev.origEvent,\n                view: context.viewApi\n            });\n        };\n        this.handleHitUpdate = (hit, isFinal, ev)=>{\n            let { context } = this.component;\n            let relevantEvents = this.relevantEvents;\n            let initialHit = this.hitDragging.initialHit;\n            let eventInstance = this.eventRange.instance;\n            let mutation = null;\n            let mutatedRelevantEvents = null;\n            let isInvalid = false;\n            let interaction = {\n                affectedEvents: relevantEvents,\n                mutatedEvents: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.I)(),\n                isEvent: true\n            };\n            if (hit) {\n                let disallowed = hit.componentId === initialHit.componentId && this.isHitComboAllowed && !this.isHitComboAllowed(initialHit, hit);\n                if (!disallowed) {\n                    mutation = computeMutation(initialHit, hit, ev.subjectEl.classList.contains(\"fc-event-resizer-start\"), eventInstance.range);\n                }\n            }\n            if (mutation) {\n                mutatedRelevantEvents = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bX)(relevantEvents, context.getCurrentData().eventUiBases, mutation, context);\n                interaction.mutatedEvents = mutatedRelevantEvents;\n                if (!(0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bZ)(interaction, hit.dateProfile, context)) {\n                    isInvalid = true;\n                    mutation = null;\n                    mutatedRelevantEvents = null;\n                    interaction.mutatedEvents = null;\n                }\n            }\n            if (mutatedRelevantEvents) {\n                context.dispatch({\n                    type: \"SET_EVENT_RESIZE\",\n                    state: interaction\n                });\n            } else {\n                context.dispatch({\n                    type: \"UNSET_EVENT_RESIZE\"\n                });\n            }\n            if (!isInvalid) {\n                (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.aw)();\n            } else {\n                (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ax)();\n            }\n            if (!isFinal) {\n                if (mutation && isHitsEqual(initialHit, hit)) {\n                    mutation = null;\n                }\n                this.validMutation = mutation;\n                this.mutatedRelevantEvents = mutatedRelevantEvents;\n            }\n        };\n        this.handleDragEnd = (ev)=>{\n            let { context } = this.component;\n            let eventDef = this.eventRange.def;\n            let eventInstance = this.eventRange.instance;\n            let eventApi = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.a0(context, eventDef, eventInstance);\n            let relevantEvents = this.relevantEvents;\n            let mutatedRelevantEvents = this.mutatedRelevantEvents;\n            context.emitter.trigger(\"eventResizeStop\", {\n                el: this.draggingSegEl,\n                event: eventApi,\n                jsEvent: ev.origEvent,\n                view: context.viewApi\n            });\n            if (this.validMutation) {\n                let updatedEventApi = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.a0(context, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);\n                context.dispatch({\n                    type: \"MERGE_EVENTS\",\n                    eventStore: mutatedRelevantEvents\n                });\n                let eventChangeArg = {\n                    oldEvent: eventApi,\n                    event: updatedEventApi,\n                    relatedEvents: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.w)(mutatedRelevantEvents, context, eventInstance),\n                    revert () {\n                        context.dispatch({\n                            type: \"MERGE_EVENTS\",\n                            eventStore: relevantEvents\n                        });\n                    }\n                };\n                context.emitter.trigger(\"eventResize\", Object.assign(Object.assign({}, eventChangeArg), {\n                    el: this.draggingSegEl,\n                    startDelta: this.validMutation.startDelta || (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.d)(0),\n                    endDelta: this.validMutation.endDelta || (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.d)(0),\n                    jsEvent: ev.origEvent,\n                    view: context.viewApi\n                }));\n                context.emitter.trigger(\"eventChange\", eventChangeArg);\n            } else {\n                context.emitter.trigger(\"_noEventResize\");\n            }\n            // reset all internal state\n            this.draggingSeg = null;\n            this.relevantEvents = null;\n            this.validMutation = null;\n        // okay to keep eventInstance around. useful to set it in handlePointerDown\n        };\n        let { component } = settings;\n        let dragging = this.dragging = new FeaturefulElementDragging(settings.el);\n        dragging.pointer.selector = \".fc-event-resizer\";\n        dragging.touchScrollAllowed = false;\n        dragging.autoScroller.isEnabled = component.context.options.dragScroll;\n        let hitDragging = this.hitDragging = new HitDragging(this.dragging, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bG)(settings));\n        hitDragging.emitter.on(\"pointerdown\", this.handlePointerDown);\n        hitDragging.emitter.on(\"dragstart\", this.handleDragStart);\n        hitDragging.emitter.on(\"hitupdate\", this.handleHitUpdate);\n        hitDragging.emitter.on(\"dragend\", this.handleDragEnd);\n    }\n    destroy() {\n        this.dragging.destroy();\n    }\n    querySegEl(ev) {\n        return (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.$)(ev.subjectEl, \".fc-event\");\n    }\n}\nfunction computeMutation(hit0, hit1, isFromStart, instanceRange) {\n    let dateEnv = hit0.context.dateEnv;\n    let date0 = hit0.dateSpan.range.start;\n    let date1 = hit1.dateSpan.range.start;\n    let delta = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.aA)(date0, date1, dateEnv, hit0.largeUnit);\n    if (isFromStart) {\n        if (dateEnv.add(instanceRange.start, delta) < instanceRange.end) {\n            return {\n                startDelta: delta\n            };\n        }\n    } else if (dateEnv.add(instanceRange.end, delta) > instanceRange.start) {\n        return {\n            endDelta: delta\n        };\n    }\n    return null;\n}\nclass UnselectAuto {\n    constructor(context){\n        this.context = context;\n        this.isRecentPointerDateSelect = false; // wish we could use a selector to detect date selection, but uses hit system\n        this.matchesCancel = false;\n        this.matchesEvent = false;\n        this.onSelect = (selectInfo)=>{\n            if (selectInfo.jsEvent) {\n                this.isRecentPointerDateSelect = true;\n            }\n        };\n        this.onDocumentPointerDown = (pev)=>{\n            let unselectCancel = this.context.options.unselectCancel;\n            let downEl = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.aR)(pev.origEvent);\n            this.matchesCancel = !!(0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.$)(downEl, unselectCancel);\n            this.matchesEvent = !!(0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.$)(downEl, EventDragging.SELECTOR); // interaction started on an event?\n        };\n        this.onDocumentPointerUp = (pev)=>{\n            let { context } = this;\n            let { documentPointer } = this;\n            let calendarState = context.getCurrentData();\n            // touch-scrolling should never unfocus any type of selection\n            if (!documentPointer.wasTouchScroll) {\n                if (calendarState.dateSelection && // an existing date selection?\n                !this.isRecentPointerDateSelect // a new pointer-initiated date selection since last onDocumentPointerUp?\n                ) {\n                    let unselectAuto = context.options.unselectAuto;\n                    if (unselectAuto && (!unselectAuto || !this.matchesCancel)) {\n                        context.calendarApi.unselect(pev);\n                    }\n                }\n                if (calendarState.eventSelection && // an existing event selected?\n                !this.matchesEvent // interaction DIDN'T start on an event\n                ) {\n                    context.dispatch({\n                        type: \"UNSELECT_EVENT\"\n                    });\n                }\n            }\n            this.isRecentPointerDateSelect = false;\n        };\n        let documentPointer = this.documentPointer = new PointerDragging(document);\n        documentPointer.shouldIgnoreMove = true;\n        documentPointer.shouldWatchScroll = false;\n        documentPointer.emitter.on(\"pointerdown\", this.onDocumentPointerDown);\n        documentPointer.emitter.on(\"pointerup\", this.onDocumentPointerUp);\n        /*\n        TODO: better way to know about whether there was a selection with the pointer\n        */ context.emitter.on(\"select\", this.onSelect);\n    }\n    destroy() {\n        this.context.emitter.off(\"select\", this.onSelect);\n        this.documentPointer.destroy();\n    }\n}\nconst OPTION_REFINERS = {\n    fixedMirrorParent: _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.n\n};\nconst LISTENER_REFINERS = {\n    dateClick: _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.n,\n    eventDragStart: _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.n,\n    eventDragStop: _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.n,\n    eventDrop: _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.n,\n    eventResizeStart: _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.n,\n    eventResizeStop: _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.n,\n    eventResize: _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.n,\n    drop: _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.n,\n    eventReceive: _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.n,\n    eventLeave: _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.n\n};\n/*\nGiven an already instantiated draggable object for one-or-more elements,\nInterprets any dragging as an attempt to drag an events that lives outside\nof a calendar onto a calendar.\n*/ class ExternalElementDragging {\n    constructor(dragging, suppliedDragMeta){\n        this.receivingContext = null;\n        this.droppableEvent = null; // will exist for all drags, even if create:false\n        this.suppliedDragMeta = null;\n        this.dragMeta = null;\n        this.handleDragStart = (ev)=>{\n            this.dragMeta = this.buildDragMeta(ev.subjectEl);\n        };\n        this.handleHitUpdate = (hit, isFinal, ev)=>{\n            let { dragging } = this.hitDragging;\n            let receivingContext = null;\n            let droppableEvent = null;\n            let isInvalid = false;\n            let interaction = {\n                affectedEvents: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.I)(),\n                mutatedEvents: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.I)(),\n                isEvent: this.dragMeta.create\n            };\n            if (hit) {\n                receivingContext = hit.context;\n                if (this.canDropElOnCalendar(ev.subjectEl, receivingContext)) {\n                    droppableEvent = computeEventForDateSpan(hit.dateSpan, this.dragMeta, receivingContext);\n                    interaction.mutatedEvents = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.aW)(droppableEvent);\n                    isInvalid = !(0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bZ)(interaction, hit.dateProfile, receivingContext);\n                    if (isInvalid) {\n                        interaction.mutatedEvents = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.I)();\n                        droppableEvent = null;\n                    }\n                }\n            }\n            this.displayDrag(receivingContext, interaction);\n            // show mirror if no already-rendered mirror element OR if we are shutting down the mirror (?)\n            // TODO: wish we could somehow wait for dispatch to guarantee render\n            dragging.setMirrorIsVisible(isFinal || !droppableEvent || !document.querySelector(\".fc-event-mirror\"));\n            if (!isInvalid) {\n                (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.aw)();\n            } else {\n                (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ax)();\n            }\n            if (!isFinal) {\n                dragging.setMirrorNeedsRevert(!droppableEvent);\n                this.receivingContext = receivingContext;\n                this.droppableEvent = droppableEvent;\n            }\n        };\n        this.handleDragEnd = (pev)=>{\n            let { receivingContext, droppableEvent } = this;\n            this.clearDrag();\n            if (receivingContext && droppableEvent) {\n                let finalHit = this.hitDragging.finalHit;\n                let finalView = finalHit.context.viewApi;\n                let dragMeta = this.dragMeta;\n                receivingContext.emitter.trigger(\"drop\", Object.assign(Object.assign({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext)), {\n                    draggedEl: pev.subjectEl,\n                    jsEvent: pev.origEvent,\n                    view: finalView\n                }));\n                if (dragMeta.create) {\n                    let addingEvents = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.aW)(droppableEvent);\n                    receivingContext.dispatch({\n                        type: \"MERGE_EVENTS\",\n                        eventStore: addingEvents\n                    });\n                    if (pev.isTouch) {\n                        receivingContext.dispatch({\n                            type: \"SELECT_EVENT\",\n                            eventInstanceId: droppableEvent.instance.instanceId\n                        });\n                    }\n                    // signal that an external event landed\n                    receivingContext.emitter.trigger(\"eventReceive\", {\n                        event: new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.a0(receivingContext, droppableEvent.def, droppableEvent.instance),\n                        relatedEvents: [],\n                        revert () {\n                            receivingContext.dispatch({\n                                type: \"REMOVE_EVENTS\",\n                                eventStore: addingEvents\n                            });\n                        },\n                        draggedEl: pev.subjectEl,\n                        view: finalView\n                    });\n                }\n            }\n            this.receivingContext = null;\n            this.droppableEvent = null;\n        };\n        let hitDragging = this.hitDragging = new HitDragging(dragging, _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.a7);\n        hitDragging.requireInitial = false; // will start outside of a component\n        hitDragging.emitter.on(\"dragstart\", this.handleDragStart);\n        hitDragging.emitter.on(\"hitupdate\", this.handleHitUpdate);\n        hitDragging.emitter.on(\"dragend\", this.handleDragEnd);\n        this.suppliedDragMeta = suppliedDragMeta;\n    }\n    buildDragMeta(subjectEl) {\n        if (typeof this.suppliedDragMeta === \"object\") {\n            return (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bJ)(this.suppliedDragMeta);\n        }\n        if (typeof this.suppliedDragMeta === \"function\") {\n            return (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bJ)(this.suppliedDragMeta(subjectEl));\n        }\n        return getDragMetaFromEl(subjectEl);\n    }\n    displayDrag(nextContext, state) {\n        let prevContext = this.receivingContext;\n        if (prevContext && prevContext !== nextContext) {\n            prevContext.dispatch({\n                type: \"UNSET_EVENT_DRAG\"\n            });\n        }\n        if (nextContext) {\n            nextContext.dispatch({\n                type: \"SET_EVENT_DRAG\",\n                state\n            });\n        }\n    }\n    clearDrag() {\n        if (this.receivingContext) {\n            this.receivingContext.dispatch({\n                type: \"UNSET_EVENT_DRAG\"\n            });\n        }\n    }\n    canDropElOnCalendar(el, receivingContext) {\n        let dropAccept = receivingContext.options.dropAccept;\n        if (typeof dropAccept === \"function\") {\n            return dropAccept.call(receivingContext.calendarApi, el);\n        }\n        if (typeof dropAccept === \"string\" && dropAccept) {\n            return Boolean((0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.aQ)(el, dropAccept));\n        }\n        return true;\n    }\n}\n// Utils for computing event store from the DragMeta\n// ----------------------------------------------------------------------------------------------------\nfunction computeEventForDateSpan(dateSpan, dragMeta, context) {\n    let defProps = Object.assign({}, dragMeta.leftoverProps);\n    for (let transform of context.pluginHooks.externalDefTransforms){\n        Object.assign(defProps, transform(dateSpan, dragMeta));\n    }\n    let { refined, extra } = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.al)(defProps, context);\n    let def = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ak)(refined, extra, dragMeta.sourceId, dateSpan.allDay, context.options.forceEventDuration || Boolean(dragMeta.duration), context);\n    let start = dateSpan.range.start;\n    // only rely on time info if drop zone is all-day,\n    // otherwise, we already know the time\n    if (dateSpan.allDay && dragMeta.startTime) {\n        start = context.dateEnv.add(start, dragMeta.startTime);\n    }\n    let end = dragMeta.duration ? context.dateEnv.add(start, dragMeta.duration) : (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cv)(dateSpan.allDay, start, context);\n    let instance = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.aj)(def.defId, {\n        start,\n        end\n    });\n    return {\n        def,\n        instance\n    };\n}\n// Utils for extracting data from element\n// ----------------------------------------------------------------------------------------------------\nfunction getDragMetaFromEl(el) {\n    let str = getEmbeddedElData(el, \"event\");\n    let obj = str ? JSON.parse(str) : {\n        create: false\n    }; // if no embedded data, assume no event creation\n    return (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bJ)(obj);\n}\n_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bI.dataAttrPrefix = \"\";\nfunction getEmbeddedElData(el, name) {\n    let prefix = _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bI.dataAttrPrefix;\n    let prefixedName = (prefix ? prefix + \"-\" : \"\") + name;\n    return el.getAttribute(\"data-\" + prefixedName) || \"\";\n}\n/*\nMakes an element (that is *external* to any calendar) draggable.\nCan pass in data that determines how an event will be created when dropped onto a calendar.\nLeverages FullCalendar's internal drag-n-drop functionality WITHOUT a third-party drag system.\n*/ class ExternalDraggable {\n    constructor(el, settings = {}){\n        this.handlePointerDown = (ev)=>{\n            let { dragging } = this;\n            let { minDistance, longPressDelay } = this.settings;\n            dragging.minDistance = minDistance != null ? minDistance : ev.isTouch ? 0 : _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.e.eventDragMinDistance;\n            dragging.delay = ev.isTouch ? longPressDelay != null ? longPressDelay : _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.e.longPressDelay : 0;\n        };\n        this.handleDragStart = (ev)=>{\n            if (ev.isTouch && this.dragging.delay && ev.subjectEl.classList.contains(\"fc-event\")) {\n                this.dragging.mirror.getMirrorEl().classList.add(\"fc-event-selected\");\n            }\n        };\n        this.settings = settings;\n        let dragging = this.dragging = new FeaturefulElementDragging(el);\n        dragging.touchScrollAllowed = false;\n        if (settings.itemSelector != null) {\n            dragging.pointer.selector = settings.itemSelector;\n        }\n        if (settings.appendTo != null) {\n            dragging.mirror.parentNode = settings.appendTo; // TODO: write tests\n        }\n        dragging.emitter.on(\"pointerdown\", this.handlePointerDown);\n        dragging.emitter.on(\"dragstart\", this.handleDragStart);\n        new ExternalElementDragging(dragging, settings.eventData); // eslint-disable-line no-new\n    }\n    destroy() {\n        this.dragging.destroy();\n    }\n}\n/*\nDetects when a *THIRD-PARTY* drag-n-drop system interacts with elements.\nThe third-party system is responsible for drawing the visuals effects of the drag.\nThis class simply monitors for pointer movements and fires events.\nIt also has the ability to hide the moving element (the \"mirror\") during the drag.\n*/ class InferredElementDragging extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bH {\n    constructor(containerEl){\n        super(containerEl);\n        this.shouldIgnoreMove = false;\n        this.mirrorSelector = \"\";\n        this.currentMirrorEl = null;\n        this.handlePointerDown = (ev)=>{\n            this.emitter.trigger(\"pointerdown\", ev);\n            if (!this.shouldIgnoreMove) {\n                // fire dragstart right away. does not support delay or min-distance\n                this.emitter.trigger(\"dragstart\", ev);\n            }\n        };\n        this.handlePointerMove = (ev)=>{\n            if (!this.shouldIgnoreMove) {\n                this.emitter.trigger(\"dragmove\", ev);\n            }\n        };\n        this.handlePointerUp = (ev)=>{\n            this.emitter.trigger(\"pointerup\", ev);\n            if (!this.shouldIgnoreMove) {\n                // fire dragend right away. does not support a revert animation\n                this.emitter.trigger(\"dragend\", ev);\n            }\n        };\n        let pointer = this.pointer = new PointerDragging(containerEl);\n        pointer.emitter.on(\"pointerdown\", this.handlePointerDown);\n        pointer.emitter.on(\"pointermove\", this.handlePointerMove);\n        pointer.emitter.on(\"pointerup\", this.handlePointerUp);\n    }\n    destroy() {\n        this.pointer.destroy();\n    }\n    setIgnoreMove(bool) {\n        this.shouldIgnoreMove = bool;\n    }\n    setMirrorIsVisible(bool) {\n        if (bool) {\n            // restore a previously hidden element.\n            // use the reference in case the selector class has already been removed.\n            if (this.currentMirrorEl) {\n                this.currentMirrorEl.style.visibility = \"\";\n                this.currentMirrorEl = null;\n            }\n        } else {\n            let mirrorEl = this.mirrorSelector ? document.querySelector(this.mirrorSelector) : null;\n            if (mirrorEl) {\n                this.currentMirrorEl = mirrorEl;\n                mirrorEl.style.visibility = \"hidden\";\n            }\n        }\n    }\n}\n/*\nBridges third-party drag-n-drop systems with FullCalendar.\nMust be instantiated and destroyed by caller.\n*/ class ThirdPartyDraggable {\n    constructor(containerOrSettings, settings){\n        let containerEl = document;\n        if (// wish we could just test instanceof EventTarget, but doesn't work in IE11\n        containerOrSettings === document || containerOrSettings instanceof Element) {\n            containerEl = containerOrSettings;\n            settings = settings || {};\n        } else {\n            settings = containerOrSettings || {};\n        }\n        let dragging = this.dragging = new InferredElementDragging(containerEl);\n        if (typeof settings.itemSelector === \"string\") {\n            dragging.pointer.selector = settings.itemSelector;\n        } else if (containerEl === document) {\n            dragging.pointer.selector = \"[data-event]\";\n        }\n        if (typeof settings.mirrorSelector === \"string\") {\n            dragging.mirrorSelector = settings.mirrorSelector;\n        }\n        let externalDragging = new ExternalElementDragging(dragging, settings.eventData);\n        // The hit-detection system requires that the dnd-mirror-element be pointer-events:none,\n        // but this can't be guaranteed for third-party draggables, so disable\n        externalDragging.hitDragging.disablePointCheck = true;\n    }\n    destroy() {\n        this.dragging.destroy();\n    }\n}\nvar index = (0,_fullcalendar_core_index_js__WEBPACK_IMPORTED_MODULE_1__.createPlugin)({\n    name: \"@fullcalendar/interaction\",\n    componentInteractions: [\n        DateClicking,\n        DateSelecting,\n        EventDragging,\n        EventResizing\n    ],\n    calendarInteractions: [\n        UnselectAuto\n    ],\n    elementDraggingImpl: FeaturefulElementDragging,\n    optionRefiners: OPTION_REFINERS,\n    listenerRefiners: LISTENER_REFINERS\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9pbnRlcmFjdGlvbi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEyRDtBQUM4M0I7QUFFejdCQyw4REFBTUEsQ0FBQ3FELG9CQUFvQixHQUFHO0FBQzlCLElBQUlDLG1CQUFtQjtBQUN2QixJQUFJQyxjQUFjO0FBQ2xCLElBQUlDLDZCQUE2QjtBQUNqQzs7Ozs7Ozs7Ozs7O0FBWUEsR0FDQSxNQUFNQztJQUNGQyxZQUFZQyxXQUFXLENBQUU7UUFDckIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFDakIsa0RBQWtEO1FBQ2xELElBQUksQ0FBQ0MsUUFBUSxHQUFHLElBQUksZ0VBQWdFO1FBQ3BGLElBQUksQ0FBQ0MsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUc7UUFDeEIsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRyxNQUFNLHVDQUF1QztRQUN0RSxrQkFBa0I7UUFDbEIsSUFBSSxDQUFDQyxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDQyxlQUFlLEdBQUc7UUFDdkIsSUFBSSxDQUFDQyxjQUFjLEdBQUc7UUFDdEIsUUFBUTtRQUNSLHVHQUF1RztRQUN2RyxJQUFJLENBQUNDLGVBQWUsR0FBRyxDQUFDQztZQUNwQixJQUFJLENBQUMsSUFBSSxDQUFDQyxpQkFBaUIsTUFDdkJDLHFCQUFxQkYsT0FDckIsSUFBSSxDQUFDRyxRQUFRLENBQUNILEtBQUs7Z0JBQ25CLElBQUlJLE1BQU0sSUFBSSxDQUFDQyxvQkFBb0IsQ0FBQ0wsSUFBSTtnQkFDeEMsSUFBSSxDQUFDTSxPQUFPLENBQUNDLE9BQU8sQ0FBQyxlQUFlSDtnQkFDcEMsSUFBSSxDQUFDSSxlQUFlLENBQUNKO2dCQUNyQixJQUFJLENBQUMsSUFBSSxDQUFDVixnQkFBZ0IsRUFBRTtvQkFDeEJlLFNBQVNDLGdCQUFnQixDQUFDLGFBQWEsSUFBSSxDQUFDQyxlQUFlO2dCQUMvRDtnQkFDQUYsU0FBU0MsZ0JBQWdCLENB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dGUsZ0JBQWdCbUIsVUFBVTtZQUMvQjJOLFNBQVMvQixPQUFPLENBQUM3TSxRQUFRLEdBQUc7UUFDaEM7UUFDQSxJQUFJLE9BQU9nVCxTQUFTd0wsY0FBYyxLQUFLLFVBQVU7WUFDN0M1UCxTQUFTNFAsY0FBYyxHQUFHeEwsU0FBU3dMLGNBQWM7UUFDckQ7UUFDQSxJQUFJTSxtQkFBbUIsSUFBSXpDLHdCQUF3QnpOLFVBQVVvRSxTQUFTc0wsU0FBUztRQUMvRSx3RkFBd0Y7UUFDeEYsc0VBQXNFO1FBQ3RFUSxpQkFBaUI1TCxXQUFXLENBQUNsRSxpQkFBaUIsR0FBRztJQUNyRDtJQUNBOUwsVUFBVTtRQUNOLElBQUksQ0FBQzBMLFFBQVEsQ0FBQzFMLE9BQU87SUFDekI7QUFDSjtBQUVBLElBQUk2YixRQUFRN2lCLHlFQUFZQSxDQUFDO0lBQ3JCMk8sTUFBTTtJQUNObVUsdUJBQXVCO1FBQUNqTTtRQUFjVTtRQUFlMkI7UUFBZTRFO0tBQWM7SUFDbEZpRixzQkFBc0I7UUFBQ3RFO0tBQWE7SUFDcEN1RSxxQkFBcUIvUztJQUNyQmdULGdCQUFnQjFEO0lBQ2hCMkQsa0JBQWtCMUQ7QUFDdEI7QUFFaUYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWhhc3BvcnQtbWFuYWdlbWVudC8uL25vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2ludGVyYWN0aW9uL2luZGV4LmpzP2QyZDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlUGx1Z2luIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb3JlL2luZGV4LmpzJztcbmltcG9ydCB7IGNvbmZpZywgRW1pdHRlciwgZWxlbWVudENsb3Nlc3QsIGFwcGx5U3R5bGUsIHdoZW5UcmFuc2l0aW9uRG9uZSwgcmVtb3ZlRWxlbWVudCwgU2Nyb2xsQ29udHJvbGxlciwgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIsIGNvbXB1dGVJbm5lclJlY3QsIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIsIEVsZW1lbnREcmFnZ2luZywgcHJldmVudFNlbGVjdGlvbiwgcHJldmVudENvbnRleHRNZW51LCBhbGxvd1NlbGVjdGlvbiwgYWxsb3dDb250ZXh0TWVudSwgY29tcHV0ZVJlY3QsIGdldENsaXBwaW5nUGFyZW50cywgcG9pbnRJbnNpZGVSZWN0LCBjb25zdHJhaW5Qb2ludCwgaW50ZXJzZWN0UmVjdHMsIGdldFJlY3RDZW50ZXIsIGRpZmZQb2ludHMsIG1hcEhhc2gsIHJhbmdlQ29udGFpbnNSYW5nZSwgaXNEYXRlU3BhbnNFcXVhbCwgSW50ZXJhY3Rpb24sIGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlLCBpc0RhdGVTZWxlY3Rpb25WYWxpZCwgZW5hYmxlQ3Vyc29yLCBkaXNhYmxlQ3Vyc29yLCB0cmlnZ2VyRGF0ZVNlbGVjdCwgY29tcGFyZU51bWJlcnMsIGdldEVsU2VnLCBnZXRSZWxldmFudEV2ZW50cywgRXZlbnRJbXBsLCBjcmVhdGVFbXB0eUV2ZW50U3RvcmUsIGFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUsIGlzSW50ZXJhY3Rpb25WYWxpZCwgYnVpbGRFdmVudEFwaXMsIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSwgc3RhcnRPZkRheSwgZGlmZkRhdGVzLCBjcmVhdGVEdXJhdGlvbiwgZ2V0RXZlbnRUYXJnZXRWaWFSb290LCBpZGVudGl0eSwgZXZlbnRUdXBsZVRvU3RvcmUsIHBhcnNlRHJhZ01ldGEsIGVsZW1lbnRNYXRjaGVzLCByZWZpbmVFdmVudERlZiwgcGFyc2VFdmVudERlZiwgZ2V0RGVmYXVsdEV2ZW50RW5kLCBjcmVhdGVFdmVudEluc3RhbmNlLCBCQVNFX09QVElPTl9ERUZBVUxUUyB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZS9pbnRlcm5hbC5qcyc7XG5cbmNvbmZpZy50b3VjaE1vdXNlSWdub3JlV2FpdCA9IDUwMDtcbmxldCBpZ25vcmVNb3VzZURlcHRoID0gMDtcbmxldCBsaXN0ZW5lckNudCA9IDA7XG5sZXQgaXNXaW5kb3dUb3VjaE1vdmVDYW5jZWxsZWQgPSBmYWxzZTtcbi8qXG5Vc2VzIGEgXCJwb2ludGVyXCIgYWJzdHJhY3Rpb24sIHdoaWNoIG1vbml0b3JzIFVJIGV2ZW50cyBmb3IgYm90aCBtb3VzZSBhbmQgdG91Y2guXG5UcmFja3Mgd2hlbiB0aGUgcG9pbnRlciBcImRyYWdzXCIgb24gYSBjZXJ0YWluIGVsZW1lbnQsIG1lYW5pbmcgZG93bittb3ZlK3VwLlxuXG5BbHNvLCB0cmFja3MgaWYgdGhlcmUgd2FzIHRvdWNoLXNjcm9sbGluZy5cbkFsc28sIGNhbiBwcmV2ZW50IHRvdWNoLXNjcm9sbGluZyBmcm9tIGhhcHBlbmluZy5cbkFsc28sIGNhbiBmaXJlIHBvaW50ZXJtb3ZlIGV2ZW50cyB3aGVuIHNjcm9sbGluZyBoYXBwZW5zIHVuZGVybmVhdGgsIGV2ZW4gd2hlbiBubyByZWFsIHBvaW50ZXIgbW92ZW1lbnQuXG5cbmVtaXRzOlxuLSBwb2ludGVyZG93blxuLSBwb2ludGVybW92ZVxuLSBwb2ludGVydXBcbiovXG5jbGFzcyBQb2ludGVyRHJhZ2dpbmcge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lckVsKSB7XG4gICAgICAgIHRoaXMuc3ViamVjdEVsID0gbnVsbDtcbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IGNhbiBiZSBkaXJlY3RseSBhc3NpZ25lZCBieSBjYWxsZXJcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9ICcnOyAvLyB3aWxsIGNhdXNlIHN1YmplY3RFbCBpbiBhbGwgZW1pdHRlZCBldmVudHMgdG8gYmUgdGhpcyBlbGVtZW50XG4gICAgICAgIHRoaXMuaGFuZGxlU2VsZWN0b3IgPSAnJztcbiAgICAgICAgdGhpcy5zaG91bGRJZ25vcmVNb3ZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2hvdWxkV2F0Y2hTY3JvbGwgPSB0cnVlOyAvLyBmb3Igc2ltdWxhdGluZyBwb2ludGVybW92ZSBvbiBzY3JvbGxcbiAgICAgICAgLy8gaW50ZXJuYWwgc3RhdGVzXG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzVG91Y2hEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLndhc1RvdWNoU2Nyb2xsID0gZmFsc2U7XG4gICAgICAgIC8vIE1vdXNlXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgdGhpcy5oYW5kbGVNb3VzZURvd24gPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3VzZSgpICYmXG4gICAgICAgICAgICAgICAgaXNQcmltYXJ5TW91c2VCdXR0b24oZXYpICYmXG4gICAgICAgICAgICAgICAgdGhpcy50cnlTdGFydChldikpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGV2ID0gdGhpcy5jcmVhdGVFdmVudEZyb21Nb3VzZShldiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJkb3duJywgcGV2KTtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRTY3JvbGxXYXRjaChwZXYpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlTW91c2VNb3ZlID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBsZXQgcGV2ID0gdGhpcy5jcmVhdGVFdmVudEZyb21Nb3VzZShldik7XG4gICAgICAgICAgICB0aGlzLnJlY29yZENvb3JkcyhwZXYpO1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJtb3ZlJywgcGV2KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVNb3VzZVVwID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLmhhbmRsZU1vdXNlTW92ZSk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVydXAnLCB0aGlzLmNyZWF0ZUV2ZW50RnJvbU1vdXNlKGV2KSk7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXAoKTsgLy8gY2FsbCBsYXN0IHNvIHRoYXQgcG9pbnRlcnVwIGhhcyBhY2Nlc3MgdG8gcHJvcHNcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVG91Y2hcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB0aGlzLmhhbmRsZVRvdWNoU3RhcnQgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyeVN0YXJ0KGV2KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNUb3VjaERyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsZXQgcGV2ID0gdGhpcy5jcmVhdGVFdmVudEZyb21Ub3VjaChldiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJkb3duJywgcGV2KTtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRTY3JvbGxXYXRjaChwZXYpO1xuICAgICAgICAgICAgICAgIC8vIHVubGlrZSBtb3VzZSwgbmVlZCB0byBhdHRhY2ggdG8gdGFyZ2V0LCBub3QgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDU3NjAwMTRcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0RWwgPSBldi50YXJnZXQ7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNob3VsZElnbm9yZU1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVUb3VjaE1vdmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YXJnZXRFbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlVG91Y2hFbmQpO1xuICAgICAgICAgICAgICAgIHRhcmdldEVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5oYW5kbGVUb3VjaEVuZCk7IC8vIHRyZWF0IGl0IGFzIGEgdG91Y2ggZW5kXG4gICAgICAgICAgICAgICAgLy8gYXR0YWNoIGEgaGFuZGxlciB0byBnZXQgY2FsbGVkIHdoZW4gQU5ZIHNjcm9sbCBhY3Rpb24gaGFwcGVucyBvbiB0aGUgcGFnZS5cbiAgICAgICAgICAgICAgICAvLyB0aGlzIHdhcyBpbXBvc3NpYmxlIHRvIGRvIHdpdGggbm9ybWFsIG9uL29mZiBiZWNhdXNlICdzY3JvbGwnIGRvZXNuJ3QgYnViYmxlLlxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMyOTU0NTY1Lzk2MzQyXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlVG91Y2hTY3JvbGwsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVRvdWNoTW92ZSA9IChldikgPT4ge1xuICAgICAgICAgICAgbGV0IHBldiA9IHRoaXMuY3JlYXRlRXZlbnRGcm9tVG91Y2goZXYpO1xuICAgICAgICAgICAgdGhpcy5yZWNvcmRDb29yZHMocGV2KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVybW92ZScsIHBldik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG91Y2hFbmQgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcpIHsgLy8gZG9uZSB0byBndWFyZCBhZ2FpbnN0IHRvdWNoZW5kIGZvbGxvd2VkIGJ5IHRvdWNoY2FuY2VsXG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldEVsID0gZXYudGFyZ2V0O1xuICAgICAgICAgICAgICAgIHRhcmdldEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuaGFuZGxlVG91Y2hNb3ZlKTtcbiAgICAgICAgICAgICAgICB0YXJnZXRFbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlVG91Y2hFbmQpO1xuICAgICAgICAgICAgICAgIHRhcmdldEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5oYW5kbGVUb3VjaEVuZCk7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlVG91Y2hTY3JvbGwsIHRydWUpOyAvLyB1c2VDYXB0dXJlZD10cnVlXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJ1cCcsIHRoaXMuY3JlYXRlRXZlbnRGcm9tVG91Y2goZXYpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFudXAoKTsgLy8gY2FsbCBsYXN0IHNvIHRoYXQgcG9pbnRlcnVwIGhhcyBhY2Nlc3MgdG8gcHJvcHNcbiAgICAgICAgICAgICAgICB0aGlzLmlzVG91Y2hEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN0YXJ0SWdub3JpbmdNb3VzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVRvdWNoU2Nyb2xsID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy53YXNUb3VjaFNjcm9sbCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2hvdWxkSWdub3JlTW92ZSkge1xuICAgICAgICAgICAgICAgIGxldCBwYWdlWCA9ICh3aW5kb3cuc2Nyb2xsWCAtIHRoaXMucHJldlNjcm9sbFgpICsgdGhpcy5wcmV2UGFnZVg7XG4gICAgICAgICAgICAgICAgbGV0IHBhZ2VZID0gKHdpbmRvdy5zY3JvbGxZIC0gdGhpcy5wcmV2U2Nyb2xsWSkgKyB0aGlzLnByZXZQYWdlWTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcm1vdmUnLCB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdFdmVudDogZXYsXG4gICAgICAgICAgICAgICAgICAgIGlzVG91Y2g6IHRoaXMuaXNUb3VjaERyYWdnaW5nLFxuICAgICAgICAgICAgICAgICAgICBzdWJqZWN0RWw6IHRoaXMuc3ViamVjdEVsLFxuICAgICAgICAgICAgICAgICAgICBwYWdlWCxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVksXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhWDogcGFnZVggLSB0aGlzLm9yaWdQYWdlWCxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFZOiBwYWdlWSAtIHRoaXMub3JpZ1BhZ2VZLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbnRhaW5lckVsID0gY29udGFpbmVyRWw7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG4gICAgICAgIGNvbnRhaW5lckVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlTW91c2VEb3duKTtcbiAgICAgICAgY29udGFpbmVyRWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuaGFuZGxlVG91Y2hTdGFydCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICBsaXN0ZW5lckNyZWF0ZWQoKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXJFbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZU1vdXNlRG93bik7XG4gICAgICAgIHRoaXMuY29udGFpbmVyRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuaGFuZGxlVG91Y2hTdGFydCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICBsaXN0ZW5lckRlc3Ryb3llZCgpO1xuICAgIH1cbiAgICB0cnlTdGFydChldikge1xuICAgICAgICBsZXQgc3ViamVjdEVsID0gdGhpcy5xdWVyeVN1YmplY3RFbChldik7XG4gICAgICAgIGxldCBkb3duRWwgPSBldi50YXJnZXQ7XG4gICAgICAgIGlmIChzdWJqZWN0RWwgJiZcbiAgICAgICAgICAgICghdGhpcy5oYW5kbGVTZWxlY3RvciB8fCBlbGVtZW50Q2xvc2VzdChkb3duRWwsIHRoaXMuaGFuZGxlU2VsZWN0b3IpKSkge1xuICAgICAgICAgICAgdGhpcy5zdWJqZWN0RWwgPSBzdWJqZWN0RWw7XG4gICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlOyAvLyBkbyB0aGlzIGZpcnN0IHNvIGNhbmNlbFRvdWNoU2Nyb2xsIHdpbGwgd29ya1xuICAgICAgICAgICAgdGhpcy53YXNUb3VjaFNjcm9sbCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjbGVhbnVwKCkge1xuICAgICAgICBpc1dpbmRvd1RvdWNoTW92ZUNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdWJqZWN0RWwgPSBudWxsO1xuICAgICAgICAvLyBrZWVwIHdhc1RvdWNoU2Nyb2xsIGFyb3VuZCBmb3IgbGF0ZXIgYWNjZXNzXG4gICAgICAgIHRoaXMuZGVzdHJveVNjcm9sbFdhdGNoKCk7XG4gICAgfVxuICAgIHF1ZXJ5U3ViamVjdEVsKGV2KSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudENsb3Nlc3QoZXYudGFyZ2V0LCB0aGlzLnNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXJFbDtcbiAgICB9XG4gICAgc2hvdWxkSWdub3JlTW91c2UoKSB7XG4gICAgICAgIHJldHVybiBpZ25vcmVNb3VzZURlcHRoIHx8IHRoaXMuaXNUb3VjaERyYWdnaW5nO1xuICAgIH1cbiAgICAvLyBjYW4gYmUgY2FsbGVkIGJ5IHVzZXIgb2YgdGhpcyBjbGFzcywgdG8gY2FuY2VsIHRvdWNoLWJhc2VkIHNjcm9sbGluZyBmb3IgdGhlIGN1cnJlbnQgZHJhZ1xuICAgIGNhbmNlbFRvdWNoU2Nyb2xsKCkge1xuICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICBpc1dpbmRvd1RvdWNoTW92ZUNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU2Nyb2xsaW5nIHRoYXQgc2ltdWxhdGVzIHBvaW50ZXJtb3Zlc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBpbml0U2Nyb2xsV2F0Y2goZXYpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkV2F0Y2hTY3JvbGwpIHtcbiAgICAgICAgICAgIHRoaXMucmVjb3JkQ29vcmRzKGV2KTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmhhbmRsZVNjcm9sbCwgdHJ1ZSk7IC8vIHVzZUNhcHR1cmU9dHJ1ZVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlY29yZENvb3Jkcyhldikge1xuICAgICAgICBpZiAodGhpcy5zaG91bGRXYXRjaFNjcm9sbCkge1xuICAgICAgICAgICAgdGhpcy5wcmV2UGFnZVggPSBldi5wYWdlWDtcbiAgICAgICAgICAgIHRoaXMucHJldlBhZ2VZID0gZXYucGFnZVk7XG4gICAgICAgICAgICB0aGlzLnByZXZTY3JvbGxYID0gd2luZG93LnNjcm9sbFg7XG4gICAgICAgICAgICB0aGlzLnByZXZTY3JvbGxZID0gd2luZG93LnNjcm9sbFk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveVNjcm9sbFdhdGNoKCkge1xuICAgICAgICBpZiAodGhpcy5zaG91bGRXYXRjaFNjcm9sbCkge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsLCB0cnVlKTsgLy8gdXNlQ2FwdHVyZWQ9dHJ1ZVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEV2ZW50IE5vcm1hbGl6YXRpb25cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgY3JlYXRlRXZlbnRGcm9tTW91c2UoZXYsIGlzRmlyc3QpIHtcbiAgICAgICAgbGV0IGRlbHRhWCA9IDA7XG4gICAgICAgIGxldCBkZWx0YVkgPSAwO1xuICAgICAgICAvLyBUT0RPOiByZXBlYXQgY29kZVxuICAgICAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgICAgICAgdGhpcy5vcmlnUGFnZVggPSBldi5wYWdlWDtcbiAgICAgICAgICAgIHRoaXMub3JpZ1BhZ2VZID0gZXYucGFnZVk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWx0YVggPSBldi5wYWdlWCAtIHRoaXMub3JpZ1BhZ2VYO1xuICAgICAgICAgICAgZGVsdGFZID0gZXYucGFnZVkgLSB0aGlzLm9yaWdQYWdlWTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3JpZ0V2ZW50OiBldixcbiAgICAgICAgICAgIGlzVG91Y2g6IGZhbHNlLFxuICAgICAgICAgICAgc3ViamVjdEVsOiB0aGlzLnN1YmplY3RFbCxcbiAgICAgICAgICAgIHBhZ2VYOiBldi5wYWdlWCxcbiAgICAgICAgICAgIHBhZ2VZOiBldi5wYWdlWSxcbiAgICAgICAgICAgIGRlbHRhWCxcbiAgICAgICAgICAgIGRlbHRhWSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY3JlYXRlRXZlbnRGcm9tVG91Y2goZXYsIGlzRmlyc3QpIHtcbiAgICAgICAgbGV0IHRvdWNoZXMgPSBldi50b3VjaGVzO1xuICAgICAgICBsZXQgcGFnZVg7XG4gICAgICAgIGxldCBwYWdlWTtcbiAgICAgICAgbGV0IGRlbHRhWCA9IDA7XG4gICAgICAgIGxldCBkZWx0YVkgPSAwO1xuICAgICAgICAvLyBpZiB0b3VjaCBjb29yZHMgYXZhaWxhYmxlLCBwcmVmZXIsXG4gICAgICAgIC8vIGJlY2F1c2UgRkYgd291bGQgZ2l2ZSBiYWQgZXYucGFnZVggZXYucGFnZVlcbiAgICAgICAgaWYgKHRvdWNoZXMgJiYgdG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBhZ2VYID0gdG91Y2hlc1swXS5wYWdlWDtcbiAgICAgICAgICAgIHBhZ2VZID0gdG91Y2hlc1swXS5wYWdlWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhZ2VYID0gZXYucGFnZVg7XG4gICAgICAgICAgICBwYWdlWSA9IGV2LnBhZ2VZO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHJlcGVhdCBjb2RlXG4gICAgICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgICAgICB0aGlzLm9yaWdQYWdlWCA9IHBhZ2VYO1xuICAgICAgICAgICAgdGhpcy5vcmlnUGFnZVkgPSBwYWdlWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbHRhWCA9IHBhZ2VYIC0gdGhpcy5vcmlnUGFnZVg7XG4gICAgICAgICAgICBkZWx0YVkgPSBwYWdlWSAtIHRoaXMub3JpZ1BhZ2VZO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcmlnRXZlbnQ6IGV2LFxuICAgICAgICAgICAgaXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIHN1YmplY3RFbDogdGhpcy5zdWJqZWN0RWwsXG4gICAgICAgICAgICBwYWdlWCxcbiAgICAgICAgICAgIHBhZ2VZLFxuICAgICAgICAgICAgZGVsdGFYLFxuICAgICAgICAgICAgZGVsdGFZLFxuICAgICAgICB9O1xuICAgIH1cbn1cbi8vIFJldHVybnMgYSBib29sZWFuIHdoZXRoZXIgdGhpcyB3YXMgYSBsZWZ0IG1vdXNlIGNsaWNrIGFuZCBubyBjdHJsIGtleSAod2hpY2ggbWVhbnMgcmlnaHQgY2xpY2sgb24gTWFjKVxuZnVuY3Rpb24gaXNQcmltYXJ5TW91c2VCdXR0b24oZXYpIHtcbiAgICByZXR1cm4gZXYuYnV0dG9uID09PSAwICYmICFldi5jdHJsS2V5O1xufVxuLy8gSWdub3JpbmcgZmFrZSBtb3VzZSBldmVudHMgZ2VuZXJhdGVkIGJ5IHRvdWNoXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBzdGFydElnbm9yaW5nTW91c2UoKSB7XG4gICAgaWdub3JlTW91c2VEZXB0aCArPSAxO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZ25vcmVNb3VzZURlcHRoIC09IDE7XG4gICAgfSwgY29uZmlnLnRvdWNoTW91c2VJZ25vcmVXYWl0KTtcbn1cbi8vIFdlIHdhbnQgdG8gYXR0YWNoIHRvdWNobW92ZSBhcyBlYXJseSBhcyBwb3NzaWJsZSBmb3IgU2FmYXJpXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBsaXN0ZW5lckNyZWF0ZWQoKSB7XG4gICAgbGlzdGVuZXJDbnQgKz0gMTtcbiAgICBpZiAobGlzdGVuZXJDbnQgPT09IDEpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uV2luZG93VG91Y2hNb3ZlLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxpc3RlbmVyRGVzdHJveWVkKCkge1xuICAgIGxpc3RlbmVyQ250IC09IDE7XG4gICAgaWYgKCFsaXN0ZW5lckNudCkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25XaW5kb3dUb3VjaE1vdmUsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gb25XaW5kb3dUb3VjaE1vdmUoZXYpIHtcbiAgICBpZiAoaXNXaW5kb3dUb3VjaE1vdmVDYW5jZWxsZWQpIHtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG59XG5cbi8qXG5BbiBlZmZlY3QgaW4gd2hpY2ggYW4gZWxlbWVudCBmb2xsb3dzIHRoZSBtb3ZlbWVudCBvZiBhIHBvaW50ZXIgYWNyb3NzIHRoZSBzY3JlZW4uXG5UaGUgbW92aW5nIGVsZW1lbnQgaXMgYSBjbG9uZSBvZiBzb21lIG90aGVyIGVsZW1lbnQuXG5NdXN0IGNhbGwgc3RhcnQgKyBoYW5kbGVNb3ZlICsgc3RvcC5cbiovXG5jbGFzcyBFbGVtZW50TWlycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pc1Zpc2libGUgPSBmYWxzZTsgLy8gbXVzdCBiZSBleHBsaWNpdGx5IGVuYWJsZWRcbiAgICAgICAgdGhpcy5zb3VyY2VFbCA9IG51bGw7XG4gICAgICAgIHRoaXMubWlycm9yRWwgPSBudWxsO1xuICAgICAgICB0aGlzLnNvdXJjZUVsUmVjdCA9IG51bGw7IC8vIHNjcmVlbiBjb29yZHMgcmVsYXRpdmUgdG8gdmlld3BvcnRcbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IGNhbiBiZSBzZXQgZGlyZWN0bHkgYnkgY2FsbGVyXG4gICAgICAgIHRoaXMucGFyZW50Tm9kZSA9IGRvY3VtZW50LmJvZHk7IC8vIEhJR0hMWSBTVUdHRVNURUQgdG8gc2V0IHRoaXMgdG8gc2lkZXN0ZXAgU2hhZG93RE9NIGlzc3Vlc1xuICAgICAgICB0aGlzLnpJbmRleCA9IDk5OTk7XG4gICAgICAgIHRoaXMucmV2ZXJ0RHVyYXRpb24gPSAwO1xuICAgIH1cbiAgICBzdGFydChzb3VyY2VFbCwgcGFnZVgsIHBhZ2VZKSB7XG4gICAgICAgIHRoaXMuc291cmNlRWwgPSBzb3VyY2VFbDtcbiAgICAgICAgdGhpcy5zb3VyY2VFbFJlY3QgPSB0aGlzLnNvdXJjZUVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLm9yaWdTY3JlZW5YID0gcGFnZVggLSB3aW5kb3cuc2Nyb2xsWDtcbiAgICAgICAgdGhpcy5vcmlnU2NyZWVuWSA9IHBhZ2VZIC0gd2luZG93LnNjcm9sbFk7XG4gICAgICAgIHRoaXMuZGVsdGFYID0gMDtcbiAgICAgICAgdGhpcy5kZWx0YVkgPSAwO1xuICAgICAgICB0aGlzLnVwZGF0ZUVsUG9zaXRpb24oKTtcbiAgICB9XG4gICAgaGFuZGxlTW92ZShwYWdlWCwgcGFnZVkpIHtcbiAgICAgICAgdGhpcy5kZWx0YVggPSAocGFnZVggLSB3aW5kb3cuc2Nyb2xsWCkgLSB0aGlzLm9yaWdTY3JlZW5YO1xuICAgICAgICB0aGlzLmRlbHRhWSA9IChwYWdlWSAtIHdpbmRvdy5zY3JvbGxZKSAtIHRoaXMub3JpZ1NjcmVlblk7XG4gICAgICAgIHRoaXMudXBkYXRlRWxQb3NpdGlvbigpO1xuICAgIH1cbiAgICAvLyBjYW4gYmUgY2FsbGVkIGJlZm9yZSBzdGFydFxuICAgIHNldElzVmlzaWJsZShib29sKSB7XG4gICAgICAgIGlmIChib29sKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWlycm9yRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taXJyb3JFbC5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaXNWaXNpYmxlID0gYm9vbDsgLy8gbmVlZHMgdG8gaGFwcGVuIGJlZm9yZSB1cGRhdGVFbFBvc2l0aW9uXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVFbFBvc2l0aW9uKCk7IC8vIGJlY2F1c2Ugd2FzIG5vdCB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgaW52aXNpYmxlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc1Zpc2libGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1pcnJvckVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5taXJyb3JFbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pc1Zpc2libGUgPSBib29sO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFsd2F5cyBhc3luY1xuICAgIHN0b3AobmVlZHNSZXZlcnRBbmltYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgICAgIGxldCBkb25lID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAobmVlZHNSZXZlcnRBbmltYXRpb24gJiZcbiAgICAgICAgICAgIHRoaXMubWlycm9yRWwgJiZcbiAgICAgICAgICAgIHRoaXMuaXNWaXNpYmxlICYmXG4gICAgICAgICAgICB0aGlzLnJldmVydER1cmF0aW9uICYmIC8vIGlmIDAsIHRyYW5zaXRpb24gd29uJ3Qgd29ya1xuICAgICAgICAgICAgKHRoaXMuZGVsdGFYIHx8IHRoaXMuZGVsdGFZKSAvLyBpZiBzYW1lIGNvb3JkcywgdHJhbnNpdGlvbiB3b24ndCB3b3JrXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5kb1JldmVydEFuaW1hdGlvbihkb25lLCB0aGlzLnJldmVydER1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZG9uZSwgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZG9SZXZlcnRBbmltYXRpb24oY2FsbGJhY2ssIHJldmVydER1cmF0aW9uKSB7XG4gICAgICAgIGxldCBtaXJyb3JFbCA9IHRoaXMubWlycm9yRWw7XG4gICAgICAgIGxldCBmaW5hbFNvdXJjZUVsUmVjdCA9IHRoaXMuc291cmNlRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIGJlY2F1c2UgYXV0b3Njcm9sbGluZyBtaWdodCBoYXZlIGhhcHBlbmVkXG4gICAgICAgIG1pcnJvckVsLnN0eWxlLnRyYW5zaXRpb24gPVxuICAgICAgICAgICAgJ3RvcCAnICsgcmV2ZXJ0RHVyYXRpb24gKyAnbXMsJyArXG4gICAgICAgICAgICAgICAgJ2xlZnQgJyArIHJldmVydER1cmF0aW9uICsgJ21zJztcbiAgICAgICAgYXBwbHlTdHlsZShtaXJyb3JFbCwge1xuICAgICAgICAgICAgbGVmdDogZmluYWxTb3VyY2VFbFJlY3QubGVmdCxcbiAgICAgICAgICAgIHRvcDogZmluYWxTb3VyY2VFbFJlY3QudG9wLFxuICAgICAgICB9KTtcbiAgICAgICAgd2hlblRyYW5zaXRpb25Eb25lKG1pcnJvckVsLCAoKSA9PiB7XG4gICAgICAgICAgICBtaXJyb3JFbC5zdHlsZS50cmFuc2l0aW9uID0gJyc7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xlYW51cCgpIHtcbiAgICAgICAgaWYgKHRoaXMubWlycm9yRWwpIHtcbiAgICAgICAgICAgIHJlbW92ZUVsZW1lbnQodGhpcy5taXJyb3JFbCk7XG4gICAgICAgICAgICB0aGlzLm1pcnJvckVsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvdXJjZUVsID0gbnVsbDtcbiAgICB9XG4gICAgdXBkYXRlRWxQb3NpdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc291cmNlRWwgJiYgdGhpcy5pc1Zpc2libGUpIHtcbiAgICAgICAgICAgIGFwcGx5U3R5bGUodGhpcy5nZXRNaXJyb3JFbCgpLCB7XG4gICAgICAgICAgICAgICAgbGVmdDogdGhpcy5zb3VyY2VFbFJlY3QubGVmdCArIHRoaXMuZGVsdGFYLFxuICAgICAgICAgICAgICAgIHRvcDogdGhpcy5zb3VyY2VFbFJlY3QudG9wICsgdGhpcy5kZWx0YVksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRNaXJyb3JFbCgpIHtcbiAgICAgICAgbGV0IHNvdXJjZUVsUmVjdCA9IHRoaXMuc291cmNlRWxSZWN0O1xuICAgICAgICBsZXQgbWlycm9yRWwgPSB0aGlzLm1pcnJvckVsO1xuICAgICAgICBpZiAoIW1pcnJvckVsKSB7XG4gICAgICAgICAgICBtaXJyb3JFbCA9IHRoaXMubWlycm9yRWwgPSB0aGlzLnNvdXJjZUVsLmNsb25lTm9kZSh0cnVlKTsgLy8gY2xvbmVDaGlsZHJlbj10cnVlXG4gICAgICAgICAgICAvLyB3ZSBkb24ndCB3YW50IGxvbmcgdGFwcyBvciBhbnkgbW91c2UgaW50ZXJhY3Rpb24gY2F1c2luZyBzZWxlY3Rpb24vbWVudXMuXG4gICAgICAgICAgICAvLyB3b3VsZCB1c2UgcHJldmVudFNlbGVjdGlvbigpLCBidXQgdGhhdCBwcmV2ZW50cyBzZWxlY3RzdGFydCwgY2F1c2luZyBwcm9ibGVtcy5cbiAgICAgICAgICAgIG1pcnJvckVsLnN0eWxlLnVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgICAgICAgICBtaXJyb3JFbC5zdHlsZS53ZWJraXRVc2VyU2VsZWN0ID0gJ25vbmUnO1xuICAgICAgICAgICAgbWlycm9yRWwuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgICAgIG1pcnJvckVsLmNsYXNzTGlzdC5hZGQoJ2ZjLWV2ZW50LWRyYWdnaW5nJyk7XG4gICAgICAgICAgICBhcHBseVN0eWxlKG1pcnJvckVsLCB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAgICAgICAgICAgekluZGV4OiB0aGlzLnpJbmRleCxcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiAnJyxcbiAgICAgICAgICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgICAgICAgICAgICB3aWR0aDogc291cmNlRWxSZWN0LnJpZ2h0IC0gc291cmNlRWxSZWN0LmxlZnQsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBzb3VyY2VFbFJlY3QuYm90dG9tIC0gc291cmNlRWxSZWN0LnRvcCxcbiAgICAgICAgICAgICAgICByaWdodDogJ2F1dG8nLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogJ2F1dG8nLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlLmFwcGVuZENoaWxkKG1pcnJvckVsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWlycm9yRWw7XG4gICAgfVxufVxuXG4vKlxuSXMgYSBjYWNoZSBmb3IgYSBnaXZlbiBlbGVtZW50J3Mgc2Nyb2xsIGluZm9ybWF0aW9uIChhbGwgdGhlIGluZm8gdGhhdCBTY3JvbGxDb250cm9sbGVyIHN0b3JlcylcbmluIGFkZGl0aW9uIHRoZSBcImNsaWVudCByZWN0YW5nbGVcIiBvZiB0aGUgZWxlbWVudC4uIHRoZSBhcmVhIHdpdGhpbiB0aGUgc2Nyb2xsYmFycy5cblxuVGhlIGNhY2hlIGNhbiBiZSBpbiBvbmUgb2YgdHdvIG1vZGVzOlxuLSBkb2VzTGlzdGVuaW5nOmZhbHNlIC0gaWdub3JlcyB3aGVuIHRoZSBjb250YWluZXIgaXMgc2Nyb2xsZWQgYnkgc29tZW9uZSBlbHNlXG4tIGRvZXNMaXN0ZW5pbmc6dHJ1ZSAtIHdhdGNoIGZvciBzY3JvbGxpbmcgYW5kIHVwZGF0ZSB0aGUgY2FjaGVcbiovXG5jbGFzcyBTY3JvbGxHZW9tQ2FjaGUgZXh0ZW5kcyBTY3JvbGxDb250cm9sbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzY3JvbGxDb250cm9sbGVyLCBkb2VzTGlzdGVuaW5nKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb3AgPSB0aGlzLnNjcm9sbENvbnRyb2xsZXIuZ2V0U2Nyb2xsVG9wKCk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbExlZnQgPSB0aGlzLnNjcm9sbENvbnRyb2xsZXIuZ2V0U2Nyb2xsTGVmdCgpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGxDaGFuZ2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zY3JvbGxDb250cm9sbGVyID0gc2Nyb2xsQ29udHJvbGxlcjtcbiAgICAgICAgdGhpcy5kb2VzTGlzdGVuaW5nID0gZG9lc0xpc3RlbmluZztcbiAgICAgICAgdGhpcy5zY3JvbGxUb3AgPSB0aGlzLm9yaWdTY3JvbGxUb3AgPSBzY3JvbGxDb250cm9sbGVyLmdldFNjcm9sbFRvcCgpO1xuICAgICAgICB0aGlzLnNjcm9sbExlZnQgPSB0aGlzLm9yaWdTY3JvbGxMZWZ0ID0gc2Nyb2xsQ29udHJvbGxlci5nZXRTY3JvbGxMZWZ0KCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsV2lkdGggPSBzY3JvbGxDb250cm9sbGVyLmdldFNjcm9sbFdpZHRoKCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsSGVpZ2h0ID0gc2Nyb2xsQ29udHJvbGxlci5nZXRTY3JvbGxIZWlnaHQoKTtcbiAgICAgICAgdGhpcy5jbGllbnRXaWR0aCA9IHNjcm9sbENvbnRyb2xsZXIuZ2V0Q2xpZW50V2lkdGgoKTtcbiAgICAgICAgdGhpcy5jbGllbnRIZWlnaHQgPSBzY3JvbGxDb250cm9sbGVyLmdldENsaWVudEhlaWdodCgpO1xuICAgICAgICB0aGlzLmNsaWVudFJlY3QgPSB0aGlzLmNvbXB1dGVDbGllbnRSZWN0KCk7IC8vIGRvIGxhc3QgaW4gY2FzZSBpdCBuZWVkcyBjYWNoZWQgdmFsdWVzXG4gICAgICAgIGlmICh0aGlzLmRvZXNMaXN0ZW5pbmcpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0RXZlbnRUYXJnZXQoKS5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmhhbmRsZVNjcm9sbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9lc0xpc3RlbmluZykge1xuICAgICAgICAgICAgdGhpcy5nZXRFdmVudFRhcmdldCgpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRTY3JvbGxUb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbFRvcDtcbiAgICB9XG4gICAgZ2V0U2Nyb2xsTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsTGVmdDtcbiAgICB9XG4gICAgc2V0U2Nyb2xsVG9wKHRvcCkge1xuICAgICAgICB0aGlzLnNjcm9sbENvbnRyb2xsZXIuc2V0U2Nyb2xsVG9wKHRvcCk7XG4gICAgICAgIGlmICghdGhpcy5kb2VzTGlzdGVuaW5nKSB7XG4gICAgICAgICAgICAvLyB3ZSBhcmUgbm90IHJlbHlpbmcgb24gdGhlIGVsZW1lbnQgdG8gbm9ybWFsaXplIG91dC1vZi1ib3VuZHMgc2Nyb2xsIHZhbHVlc1xuICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBzYW5pdGl6ZSBvdXJzZWx2ZXNcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9wID0gTWF0aC5tYXgoTWF0aC5taW4odG9wLCB0aGlzLmdldE1heFNjcm9sbFRvcCgpKSwgMCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbENoYW5nZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFNjcm9sbExlZnQodG9wKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsQ29udHJvbGxlci5zZXRTY3JvbGxMZWZ0KHRvcCk7XG4gICAgICAgIGlmICghdGhpcy5kb2VzTGlzdGVuaW5nKSB7XG4gICAgICAgICAgICAvLyB3ZSBhcmUgbm90IHJlbHlpbmcgb24gdGhlIGVsZW1lbnQgdG8gbm9ybWFsaXplIG91dC1vZi1ib3VuZHMgc2Nyb2xsIHZhbHVlc1xuICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBzYW5pdGl6ZSBvdXJzZWx2ZXNcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsTGVmdCA9IE1hdGgubWF4KE1hdGgubWluKHRvcCwgdGhpcy5nZXRNYXhTY3JvbGxMZWZ0KCkpLCAwKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q2xpZW50V2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudFdpZHRoO1xuICAgIH1cbiAgICBnZXRDbGllbnRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudEhlaWdodDtcbiAgICB9XG4gICAgZ2V0U2Nyb2xsV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbFdpZHRoO1xuICAgIH1cbiAgICBnZXRTY3JvbGxIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbEhlaWdodDtcbiAgICB9XG4gICAgaGFuZGxlU2Nyb2xsQ2hhbmdlKCkge1xuICAgIH1cbn1cblxuY2xhc3MgRWxlbWVudFNjcm9sbEdlb21DYWNoZSBleHRlbmRzIFNjcm9sbEdlb21DYWNoZSB7XG4gICAgY29uc3RydWN0b3IoZWwsIGRvZXNMaXN0ZW5pbmcpIHtcbiAgICAgICAgc3VwZXIobmV3IEVsZW1lbnRTY3JvbGxDb250cm9sbGVyKGVsKSwgZG9lc0xpc3RlbmluZyk7XG4gICAgfVxuICAgIGdldEV2ZW50VGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxDb250cm9sbGVyLmVsO1xuICAgIH1cbiAgICBjb21wdXRlQ2xpZW50UmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIGNvbXB1dGVJbm5lclJlY3QodGhpcy5zY3JvbGxDb250cm9sbGVyLmVsKTtcbiAgICB9XG59XG5cbmNsYXNzIFdpbmRvd1Njcm9sbEdlb21DYWNoZSBleHRlbmRzIFNjcm9sbEdlb21DYWNoZSB7XG4gICAgY29uc3RydWN0b3IoZG9lc0xpc3RlbmluZykge1xuICAgICAgICBzdXBlcihuZXcgV2luZG93U2Nyb2xsQ29udHJvbGxlcigpLCBkb2VzTGlzdGVuaW5nKTtcbiAgICB9XG4gICAgZ2V0RXZlbnRUYXJnZXQoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgfVxuICAgIGNvbXB1dGVDbGllbnRSZWN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogdGhpcy5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgcmlnaHQ6IHRoaXMuc2Nyb2xsTGVmdCArIHRoaXMuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICB0b3A6IHRoaXMuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgYm90dG9tOiB0aGlzLnNjcm9sbFRvcCArIHRoaXMuY2xpZW50SGVpZ2h0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyB0aGUgd2luZG93IGlzIHRoZSBvbmx5IHNjcm9sbCBvYmplY3QgdGhhdCBjaGFuZ2VzIGl0J3MgcmVjdGFuZ2xlIHJlbGF0aXZlXG4gICAgLy8gdG8gdGhlIGRvY3VtZW50J3MgdG9wbGVmdCBhcyBpdCBzY3JvbGxzXG4gICAgaGFuZGxlU2Nyb2xsQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLmNsaWVudFJlY3QgPSB0aGlzLmNvbXB1dGVDbGllbnRSZWN0KCk7XG4gICAgfVxufVxuXG4vLyBJZiBhdmFpbGFibGUgd2UgYXJlIHVzaW5nIG5hdGl2ZSBcInBlcmZvcm1hbmNlXCIgQVBJIGluc3RlYWQgb2YgXCJEYXRlXCJcbi8vIFJlYWQgbW9yZSBhYm91dCBpdCBvbiBNRE46XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUGVyZm9ybWFuY2VcbmNvbnN0IGdldFRpbWUgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICdmdW5jdGlvbicgPyBwZXJmb3JtYW5jZS5ub3cgOiBEYXRlLm5vdztcbi8qXG5Gb3IgYSBwb2ludGVyIGludGVyYWN0aW9uLCBhdXRvbWF0aWNhbGx5IHNjcm9sbHMgY2VydGFpbiBzY3JvbGwgY29udGFpbmVycyB3aGVuIHRoZSBwb2ludGVyXG5hcHByb2FjaGVzIHRoZSBlZGdlLlxuXG5UaGUgY2FsbGVyIG11c3QgY2FsbCBzdGFydCArIGhhbmRsZU1vdmUgKyBzdG9wLlxuKi9cbmNsYXNzIEF1dG9TY3JvbGxlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCBjYW4gYmUgc2V0IGJ5IGNhbGxlclxuICAgICAgICB0aGlzLmlzRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc2Nyb2xsUXVlcnkgPSBbd2luZG93LCAnLmZjLXNjcm9sbGVyJ107XG4gICAgICAgIHRoaXMuZWRnZVRocmVzaG9sZCA9IDUwOyAvLyBwaXhlbHNcbiAgICAgICAgdGhpcy5tYXhWZWxvY2l0eSA9IDMwMDsgLy8gcGl4ZWxzIHBlciBzZWNvbmRcbiAgICAgICAgLy8gaW50ZXJuYWwgc3RhdGVcbiAgICAgICAgdGhpcy5wb2ludGVyU2NyZWVuWCA9IG51bGw7XG4gICAgICAgIHRoaXMucG9pbnRlclNjcmVlblkgPSBudWxsO1xuICAgICAgICB0aGlzLmlzQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2Nyb2xsQ2FjaGVzID0gbnVsbDtcbiAgICAgICAgLy8gcHJvdGVjdCBhZ2FpbnN0IHRoZSBpbml0aWFsIHBvaW50ZXJkb3duIGJlaW5nIHRvbyBjbG9zZSB0byBhbiBlZGdlIGFuZCBzdGFydGluZyB0aGUgc2Nyb2xsXG4gICAgICAgIHRoaXMuZXZlck1vdmVkVXAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ldmVyTW92ZWREb3duID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXZlck1vdmVkTGVmdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmV2ZXJNb3ZlZFJpZ2h0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYW5pbWF0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQW5pbWF0aW5nKSB7IC8vIHdhc24ndCBjYW5jZWxsZWQgYmV0d2VlbiBhbmltYXRpb24gY2FsbHNcbiAgICAgICAgICAgICAgICBsZXQgZWRnZSA9IHRoaXMuY29tcHV0ZUJlc3RFZGdlKHRoaXMucG9pbnRlclNjcmVlblggKyB3aW5kb3cuc2Nyb2xsWCwgdGhpcy5wb2ludGVyU2NyZWVuWSArIHdpbmRvdy5zY3JvbGxZKTtcbiAgICAgICAgICAgICAgICBpZiAoZWRnZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbm93ID0gZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNpZGUoZWRnZSwgKG5vdyAtIHRoaXMubXNTaW5jZVJlcXVlc3QpIC8gMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbihub3cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0FuaW1hdGluZyA9IGZhbHNlOyAvLyB3aWxsIHN0b3AgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGFydChwYWdlWCwgcGFnZVksIHNjcm9sbFN0YXJ0RWwpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbENhY2hlcyA9IHRoaXMuYnVpbGRDYWNoZXMoc2Nyb2xsU3RhcnRFbCk7XG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJTY3JlZW5YID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucG9pbnRlclNjcmVlblkgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWRVcCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWREb3duID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmV2ZXJNb3ZlZExlZnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZXZlck1vdmVkUmlnaHQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW92ZShwYWdlWCwgcGFnZVkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZU1vdmUocGFnZVgsIHBhZ2VZKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW5hYmxlZCkge1xuICAgICAgICAgICAgbGV0IHBvaW50ZXJTY3JlZW5YID0gcGFnZVggLSB3aW5kb3cuc2Nyb2xsWDtcbiAgICAgICAgICAgIGxldCBwb2ludGVyU2NyZWVuWSA9IHBhZ2VZIC0gd2luZG93LnNjcm9sbFk7XG4gICAgICAgICAgICBsZXQgeURlbHRhID0gdGhpcy5wb2ludGVyU2NyZWVuWSA9PT0gbnVsbCA/IDAgOiBwb2ludGVyU2NyZWVuWSAtIHRoaXMucG9pbnRlclNjcmVlblk7XG4gICAgICAgICAgICBsZXQgeERlbHRhID0gdGhpcy5wb2ludGVyU2NyZWVuWCA9PT0gbnVsbCA/IDAgOiBwb2ludGVyU2NyZWVuWCAtIHRoaXMucG9pbnRlclNjcmVlblg7XG4gICAgICAgICAgICBpZiAoeURlbHRhIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlck1vdmVkVXAgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoeURlbHRhID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlck1vdmVkRG93biA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeERlbHRhIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlck1vdmVkTGVmdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh4RGVsdGEgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWRSaWdodCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJTY3JlZW5YID0gcG9pbnRlclNjcmVlblg7XG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJTY3JlZW5ZID0gcG9pbnRlclNjcmVlblk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNBbmltYXRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzQW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RBbmltYXRpb24oZ2V0VGltZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAodGhpcy5pc0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNBbmltYXRpbmcgPSBmYWxzZTsgLy8gd2lsbCBzdG9wIGFuaW1hdGlvblxuICAgICAgICAgICAgZm9yIChsZXQgc2Nyb2xsQ2FjaGUgb2YgdGhpcy5zY3JvbGxDYWNoZXMpIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxDYWNoZS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNjcm9sbENhY2hlcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVxdWVzdEFuaW1hdGlvbihub3cpIHtcbiAgICAgICAgdGhpcy5tc1NpbmNlUmVxdWVzdCA9IG5vdztcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0ZSk7XG4gICAgfVxuICAgIGhhbmRsZVNpZGUoZWRnZSwgc2Vjb25kcykge1xuICAgICAgICBsZXQgeyBzY3JvbGxDYWNoZSB9ID0gZWRnZTtcbiAgICAgICAgbGV0IHsgZWRnZVRocmVzaG9sZCB9ID0gdGhpcztcbiAgICAgICAgbGV0IGludkRpc3RhbmNlID0gZWRnZVRocmVzaG9sZCAtIGVkZ2UuZGlzdGFuY2U7XG4gICAgICAgIGxldCB2ZWxvY2l0eSA9IC8vIHRoZSBjbG9zZXIgdG8gdGhlIGVkZ2UsIHRoZSBmYXN0ZXIgd2Ugc2Nyb2xsXG4gICAgICAgICAoKGludkRpc3RhbmNlICogaW52RGlzdGFuY2UpIC8gKGVkZ2VUaHJlc2hvbGQgKiBlZGdlVGhyZXNob2xkKSkgKiAvLyBxdWFkcmF0aWNcbiAgICAgICAgICAgIHRoaXMubWF4VmVsb2NpdHkgKiBzZWNvbmRzO1xuICAgICAgICBsZXQgc2lnbiA9IDE7XG4gICAgICAgIHN3aXRjaCAoZWRnZS5uYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICBzaWduID0gLTE7XG4gICAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgc2Nyb2xsQ2FjaGUuc2V0U2Nyb2xsTGVmdChzY3JvbGxDYWNoZS5nZXRTY3JvbGxMZWZ0KCkgKyB2ZWxvY2l0eSAqIHNpZ24pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICBzaWduID0gLTE7XG4gICAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgIHNjcm9sbENhY2hlLnNldFNjcm9sbFRvcChzY3JvbGxDYWNoZS5nZXRTY3JvbGxUb3AoKSArIHZlbG9jaXR5ICogc2lnbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gbGVmdC90b3AgYXJlIHJlbGF0aXZlIHRvIGRvY3VtZW50IHRvcGxlZnRcbiAgICBjb21wdXRlQmVzdEVkZ2UobGVmdCwgdG9wKSB7XG4gICAgICAgIGxldCB7IGVkZ2VUaHJlc2hvbGQgfSA9IHRoaXM7XG4gICAgICAgIGxldCBiZXN0U2lkZSA9IG51bGw7XG4gICAgICAgIGxldCBzY3JvbGxDYWNoZXMgPSB0aGlzLnNjcm9sbENhY2hlcyB8fCBbXTtcbiAgICAgICAgZm9yIChsZXQgc2Nyb2xsQ2FjaGUgb2Ygc2Nyb2xsQ2FjaGVzKSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IHNjcm9sbENhY2hlLmNsaWVudFJlY3Q7XG4gICAgICAgICAgICBsZXQgbGVmdERpc3QgPSBsZWZ0IC0gcmVjdC5sZWZ0O1xuICAgICAgICAgICAgbGV0IHJpZ2h0RGlzdCA9IHJlY3QucmlnaHQgLSBsZWZ0O1xuICAgICAgICAgICAgbGV0IHRvcERpc3QgPSB0b3AgLSByZWN0LnRvcDtcbiAgICAgICAgICAgIGxldCBib3R0b21EaXN0ID0gcmVjdC5ib3R0b20gLSB0b3A7XG4gICAgICAgICAgICAvLyBjb21wbGV0ZWx5IHdpdGhpbiB0aGUgcmVjdD9cbiAgICAgICAgICAgIGlmIChsZWZ0RGlzdCA+PSAwICYmIHJpZ2h0RGlzdCA+PSAwICYmIHRvcERpc3QgPj0gMCAmJiBib3R0b21EaXN0ID49IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodG9wRGlzdCA8PSBlZGdlVGhyZXNob2xkICYmIHRoaXMuZXZlck1vdmVkVXAgJiYgc2Nyb2xsQ2FjaGUuY2FuU2Nyb2xsVXAoKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIWJlc3RTaWRlIHx8IGJlc3RTaWRlLmRpc3RhbmNlID4gdG9wRGlzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdFNpZGUgPSB7IHNjcm9sbENhY2hlLCBuYW1lOiAndG9wJywgZGlzdGFuY2U6IHRvcERpc3QgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJvdHRvbURpc3QgPD0gZWRnZVRocmVzaG9sZCAmJiB0aGlzLmV2ZXJNb3ZlZERvd24gJiYgc2Nyb2xsQ2FjaGUuY2FuU2Nyb2xsRG93bigpICYmXG4gICAgICAgICAgICAgICAgICAgICghYmVzdFNpZGUgfHwgYmVzdFNpZGUuZGlzdGFuY2UgPiBib3R0b21EaXN0KSkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0U2lkZSA9IHsgc2Nyb2xsQ2FjaGUsIG5hbWU6ICdib3R0b20nLCBkaXN0YW5jZTogYm90dG9tRGlzdCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgIFRPRE86IGZpeCBicm9rZW4gUlRMIHNjcm9sbGluZy4gY2FuU2Nyb2xsTGVmdCBhbHdheXMgcmV0dXJuaW5nIGZhbHNlXG4gICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2Z1bGxjYWxlbmRhci9mdWxsY2FsZW5kYXIvaXNzdWVzLzQ4MzdcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0RGlzdCA8PSBlZGdlVGhyZXNob2xkICYmIHRoaXMuZXZlck1vdmVkTGVmdCAmJiBzY3JvbGxDYWNoZS5jYW5TY3JvbGxMZWZ0KCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFiZXN0U2lkZSB8fCBiZXN0U2lkZS5kaXN0YW5jZSA+IGxlZnREaXN0KSkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0U2lkZSA9IHsgc2Nyb2xsQ2FjaGUsIG5hbWU6ICdsZWZ0JywgZGlzdGFuY2U6IGxlZnREaXN0IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyaWdodERpc3QgPD0gZWRnZVRocmVzaG9sZCAmJiB0aGlzLmV2ZXJNb3ZlZFJpZ2h0ICYmIHNjcm9sbENhY2hlLmNhblNjcm9sbFJpZ2h0KCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFiZXN0U2lkZSB8fCBiZXN0U2lkZS5kaXN0YW5jZSA+IHJpZ2h0RGlzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdFNpZGUgPSB7IHNjcm9sbENhY2hlLCBuYW1lOiAncmlnaHQnLCBkaXN0YW5jZTogcmlnaHREaXN0IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiZXN0U2lkZTtcbiAgICB9XG4gICAgYnVpbGRDYWNoZXMoc2Nyb2xsU3RhcnRFbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeVNjcm9sbEVscyhzY3JvbGxTdGFydEVsKS5tYXAoKGVsKSA9PiB7XG4gICAgICAgICAgICBpZiAoZWwgPT09IHdpbmRvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgV2luZG93U2Nyb2xsR2VvbUNhY2hlKGZhbHNlKTsgLy8gZmFsc2UgPSBkb24ndCBsaXN0ZW4gdG8gdXNlci1nZW5lcmF0ZWQgc2Nyb2xsc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50U2Nyb2xsR2VvbUNhY2hlKGVsLCBmYWxzZSk7IC8vIGZhbHNlID0gZG9uJ3QgbGlzdGVuIHRvIHVzZXItZ2VuZXJhdGVkIHNjcm9sbHNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHF1ZXJ5U2Nyb2xsRWxzKHNjcm9sbFN0YXJ0RWwpIHtcbiAgICAgICAgbGV0IGVscyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBxdWVyeSBvZiB0aGlzLnNjcm9sbFF1ZXJ5KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGVscy5wdXNoKHF1ZXJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgVE9ETzogaW4gdGhlIGZ1dHVyZSwgYWx3YXlzIGhhdmUgYXV0by1zY3JvbGwgaGFwcGVuIG9uIGVsZW1lbnQgd2hlcmUgY3VycmVudCBIaXQgY2FtZSBmcm9tXG4gICAgICAgICAgICAgICAgVGlja2V0OiBodHRwczovL2dpdGh1Yi5jb20vZnVsbGNhbGVuZGFyL2Z1bGxjYWxlbmRhci9pc3N1ZXMvNDU5M1xuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZWxzLnB1c2goLi4uQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoc2Nyb2xsU3RhcnRFbC5nZXRSb290Tm9kZSgpLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVscztcbiAgICB9XG59XG5cbi8qXG5Nb25pdG9ycyBkcmFnZ2luZyBvbiBhbiBlbGVtZW50LiBIYXMgYSBudW1iZXIgb2YgaGlnaC1sZXZlbCBmZWF0dXJlczpcbi0gbWluaW11bSBkaXN0YW5jZSByZXF1aXJlZCBiZWZvcmUgZHJhZ2dpbmdcbi0gbWluaW11bSB3YWl0IHRpbWUgKFwiZGVsYXlcIikgYmVmb3JlIGRyYWdnaW5nXG4tIGEgbWlycm9yIGVsZW1lbnQgdGhhdCBmb2xsb3dzIHRoZSBwb2ludGVyXG4qL1xuY2xhc3MgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyBleHRlbmRzIEVsZW1lbnREcmFnZ2luZyB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyRWwsIHNlbGVjdG9yKSB7XG4gICAgICAgIHN1cGVyKGNvbnRhaW5lckVsKTtcbiAgICAgICAgdGhpcy5jb250YWluZXJFbCA9IGNvbnRhaW5lckVsO1xuICAgICAgICAvLyBvcHRpb25zIHRoYXQgY2FuIGJlIGRpcmVjdGx5IHNldCBieSBjYWxsZXJcbiAgICAgICAgLy8gdGhlIGNhbGxlciBjYW4gYWxzbyBzZXQgdGhlIFBvaW50ZXJEcmFnZ2luZydzIG9wdGlvbnMgYXMgd2VsbFxuICAgICAgICB0aGlzLmRlbGF5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5taW5EaXN0YW5jZSA9IDA7XG4gICAgICAgIHRoaXMudG91Y2hTY3JvbGxBbGxvd2VkID0gdHJ1ZTsgLy8gcHJldmVudHMgZHJhZyBmcm9tIHN0YXJ0aW5nIGFuZCBibG9ja3Mgc2Nyb2xsaW5nIGR1cmluZyBkcmFnXG4gICAgICAgIHRoaXMubWlycm9yTmVlZHNSZXZlcnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0ludGVyYWN0aW5nID0gZmFsc2U7IC8vIGlzIHRoZSB1c2VyIHZhbGlkbHkgbW92aW5nIHRoZSBwb2ludGVyPyBsYXN0cyB1bnRpbCBwb2ludGVydXBcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7IC8vIGlzIGl0IElOVEVOVEZVTExZIGRyYWdnaW5nPyBsYXN0cyB1bnRpbCBhZnRlciByZXZlcnQgYW5pbWF0aW9uXG4gICAgICAgIHRoaXMuaXNEZWxheUVuZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlbGF5VGltZW91dElkID0gbnVsbDtcbiAgICAgICAgdGhpcy5vblBvaW50ZXJEb3duID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZykgeyAvLyBzbyBuZXcgZHJhZyBkb2Vzbid0IGhhcHBlbiB3aGlsZSByZXZlcnQgYW5pbWF0aW9uIGlzIGdvaW5nXG4gICAgICAgICAgICAgICAgdGhpcy5pc0ludGVyYWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmlzRGVsYXlFbmRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHByZXZlbnRTZWxlY3Rpb24oZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICAgICAgICAgcHJldmVudENvbnRleHRNZW51KGRvY3VtZW50LmJvZHkpO1xuICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgbGlua3MgZnJvbSBiZWluZyB2aXNpdGVkIGlmIHRoZXJlJ3MgYW4gZXZlbnR1YWwgZHJhZy5cbiAgICAgICAgICAgICAgICAvLyBhbHNvIHByZXZlbnRzIHNlbGVjdGlvbiBpbiBvbGRlciBicm93c2VycyAobWF5YmU/KS5cbiAgICAgICAgICAgICAgICAvLyBub3QgbmVjZXNzYXJ5IGZvciB0b3VjaCwgYmVzaWRlcywgYnJvd3NlciB3b3VsZCBjb21wbGFpbiBhYm91dCBwYXNzaXZlbmVzcy5cbiAgICAgICAgICAgICAgICBpZiAoIWV2LmlzVG91Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgZXYub3JpZ0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVyZG93bicsIGV2KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0ludGVyYWN0aW5nICYmIC8vIG5vdCBkZXN0cm95ZWQgdmlhIHBvaW50ZXJkb3duIGhhbmRsZXJcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMucG9pbnRlci5zaG91bGRJZ25vcmVNb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFjdGlvbnMgcmVsYXRlZCB0byBpbml0aWF0aW5nIGRyYWdzdGFydCtkcmFnbW92ZStkcmFnZW5kLi4uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWlycm9yLnNldElzVmlzaWJsZShmYWxzZSk7IC8vIHJlc2V0LiBjYWxsZXIgbXVzdCBzZXQtdmlzaWJsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1pcnJvci5zdGFydChldi5zdWJqZWN0RWwsIGV2LnBhZ2VYLCBldi5wYWdlWSk7IC8vIG11c3QgaGFwcGVuIG9uIGZpcnN0IHBvaW50ZXIgZG93blxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0RGVsYXkoZXYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWluRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzdGFuY2VTdXJwYXNzZWQoZXYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uUG9pbnRlck1vdmUgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW50ZXJhY3RpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcm1vdmUnLCBldik7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzRGlzdGFuY2VTdXJwYXNzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1pbkRpc3RhbmNlID0gdGhpcy5taW5EaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRpc3RhbmNlU3E7IC8vIGN1cnJlbnQgZGlzdGFuY2UgZnJvbSB0aGUgb3JpZ2luLCBzcXVhcmVkXG4gICAgICAgICAgICAgICAgICAgIGxldCB7IGRlbHRhWCwgZGVsdGFZIH0gPSBldjtcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2VTcSA9IGRlbHRhWCAqIGRlbHRhWCArIGRlbHRhWSAqIGRlbHRhWTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlU3EgPj0gbWluRGlzdGFuY2UgKiBtaW5EaXN0YW5jZSkgeyAvLyB1c2UgcHl0aGFnb3JlYW4gdGhlb3JlbVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXN0YW5jZVN1cnBhc3NlZChldik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xuICAgICAgICAgICAgICAgICAgICAvLyBhIHJlYWwgcG9pbnRlciBtb3ZlPyAobm90IG9uZSBzaW11bGF0ZWQgYnkgc2Nyb2xsaW5nKVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXYub3JpZ0V2ZW50LnR5cGUgIT09ICdzY3JvbGwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1pcnJvci5oYW5kbGVNb3ZlKGV2LnBhZ2VYLCBldi5wYWdlWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dG9TY3JvbGxlci5oYW5kbGVNb3ZlKGV2LnBhZ2VYLCBldi5wYWdlWSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdtb3ZlJywgZXYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblBvaW50ZXJVcCA9IChldikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNJbnRlcmFjdGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNJbnRlcmFjdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGFsbG93U2VsZWN0aW9uKGRvY3VtZW50LmJvZHkpO1xuICAgICAgICAgICAgICAgIGFsbG93Q29udGV4dE1lbnUoZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJ1cCcsIGV2KTsgLy8gY2FuIHBvdGVudGlhbGx5IHNldCBtaXJyb3JOZWVkc1JldmVydFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRvU2Nyb2xsZXIuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyeVN0b3BEcmFnKGV2KTsgLy8gd2hpY2ggd2lsbCBzdG9wIHRoZSBtaXJyb3JcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVsYXlUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVsYXlUaW1lb3V0SWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGF5VGltZW91dElkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxldCBwb2ludGVyID0gdGhpcy5wb2ludGVyID0gbmV3IFBvaW50ZXJEcmFnZ2luZyhjb250YWluZXJFbCk7XG4gICAgICAgIHBvaW50ZXIuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLm9uUG9pbnRlckRvd24pO1xuICAgICAgICBwb2ludGVyLmVtaXR0ZXIub24oJ3BvaW50ZXJtb3ZlJywgdGhpcy5vblBvaW50ZXJNb3ZlKTtcbiAgICAgICAgcG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVydXAnLCB0aGlzLm9uUG9pbnRlclVwKTtcbiAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICBwb2ludGVyLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5taXJyb3IgPSBuZXcgRWxlbWVudE1pcnJvcigpO1xuICAgICAgICB0aGlzLmF1dG9TY3JvbGxlciA9IG5ldyBBdXRvU2Nyb2xsZXIoKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5wb2ludGVyLmRlc3Ryb3koKTtcbiAgICAgICAgLy8gSEFDSzogc2ltdWxhdGUgYSBwb2ludGVyLXVwIHRvIGVuZCB0aGUgY3VycmVudCBkcmFnXG4gICAgICAgIC8vIFRPRE86IGZpcmUgJ2RyYWdlbmQnIGRpcmVjdGx5IGFuZCBzdG9wIGludGVyYWN0aW9uLiBkaXNjb3VyYWdlIHVzZSBvZiBwb2ludGVydXAgZXZlbnQgKGIvYyBtaWdodCBub3QgZmlyZSlcbiAgICAgICAgdGhpcy5vblBvaW50ZXJVcCh7fSk7XG4gICAgfVxuICAgIHN0YXJ0RGVsYXkoZXYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRlbGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5kZWxheVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsYXlUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRGVsYXlFbmQoZXYpO1xuICAgICAgICAgICAgfSwgdGhpcy5kZWxheSk7IC8vIG5vdCBhc3NpZ25hYmxlIHRvIG51bWJlciFcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGVsYXlFbmQoZXYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZURlbGF5RW5kKGV2KSB7XG4gICAgICAgIHRoaXMuaXNEZWxheUVuZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50cnlTdGFydERyYWcoZXYpO1xuICAgIH1cbiAgICBoYW5kbGVEaXN0YW5jZVN1cnBhc3NlZChldikge1xuICAgICAgICB0aGlzLmlzRGlzdGFuY2VTdXJwYXNzZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnRyeVN0YXJ0RHJhZyhldik7XG4gICAgfVxuICAgIHRyeVN0YXJ0RHJhZyhldikge1xuICAgICAgICBpZiAodGhpcy5pc0RlbGF5RW5kZWQgJiYgdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucG9pbnRlci53YXNUb3VjaFNjcm9sbCB8fCB0aGlzLnRvdWNoU2Nyb2xsQWxsb3dlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5taXJyb3JOZWVkc1JldmVydCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuYXV0b1Njcm9sbGVyLnN0YXJ0KGV2LnBhZ2VYLCBldi5wYWdlWSwgdGhpcy5jb250YWluZXJFbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdzdGFydCcsIGV2KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50b3VjaFNjcm9sbEFsbG93ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlci5jYW5jZWxUb3VjaFNjcm9sbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0cnlTdG9wRHJhZyhldikge1xuICAgICAgICAvLyAuc3RvcCgpIGlzIEFMV0FZUyBhc3luY2hyb25vdXMsIHdoaWNoIHdlIE5FRUQgYmVjYXVzZSB3ZSB3YW50IGFsbCBwb2ludGVydXAgZXZlbnRzXG4gICAgICAgIC8vIHRoYXQgY29tZSBmcm9tIHRoZSBkb2N1bWVudCB0byBmaXJlIGJlZm9yZWhhbmQuIG11Y2ggbW9yZSBjb252ZW5pZW50IHRoaXMgd2F5LlxuICAgICAgICB0aGlzLm1pcnJvci5zdG9wKHRoaXMubWlycm9yTmVlZHNSZXZlcnQsIHRoaXMuc3RvcERyYWcuYmluZCh0aGlzLCBldikpO1xuICAgIH1cbiAgICBzdG9wRHJhZyhldikge1xuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdlbmQnLCBldik7XG4gICAgfVxuICAgIC8vIGZpbGwgaW4gdGhlIGltcGxlbWVudGF0aW9ucy4uLlxuICAgIHNldElnbm9yZU1vdmUoYm9vbCkge1xuICAgICAgICB0aGlzLnBvaW50ZXIuc2hvdWxkSWdub3JlTW92ZSA9IGJvb2w7XG4gICAgfVxuICAgIHNldE1pcnJvcklzVmlzaWJsZShib29sKSB7XG4gICAgICAgIHRoaXMubWlycm9yLnNldElzVmlzaWJsZShib29sKTtcbiAgICB9XG4gICAgc2V0TWlycm9yTmVlZHNSZXZlcnQoYm9vbCkge1xuICAgICAgICB0aGlzLm1pcnJvck5lZWRzUmV2ZXJ0ID0gYm9vbDtcbiAgICB9XG4gICAgc2V0QXV0b1Njcm9sbEVuYWJsZWQoYm9vbCkge1xuICAgICAgICB0aGlzLmF1dG9TY3JvbGxlci5pc0VuYWJsZWQgPSBib29sO1xuICAgIH1cbn1cblxuLypcbldoZW4gdGhpcyBjbGFzcyBpcyBpbnN0YW50aWF0ZWQsIGl0IHJlY29yZHMgdGhlIG9mZnNldCBvZiBhbiBlbGVtZW50IChyZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQgdG9wbGVmdCksXG5hbmQgY29udGludWVzIHRvIG1vbml0b3Igc2Nyb2xsaW5nLCB1cGRhdGluZyB0aGUgY2FjaGVkIGNvb3JkaW5hdGVzIGlmIGl0IG5lZWRzIHRvLlxuRG9lcyBub3QgYWNjZXNzIHRoZSBET00gYWZ0ZXIgaW5zdGFudGlhdGlvbiwgc28gaGlnaGx5IHBlcmZvcm1hbnQuXG5cbkFsc28ga2VlcHMgdHJhY2sgb2YgYWxsIHNjcm9sbGluZy9vdmVyZmxvdzpoaWRkZW4gY29udGFpbmVycyB0aGF0IGFyZSBwYXJlbnRzIG9mIHRoZSBnaXZlbiBlbGVtZW50XG5hbmQgYW4gZGV0ZXJtaW5lIGlmIGEgZ2l2ZW4gcG9pbnQgaXMgaW5zaWRlIHRoZSBjb21iaW5lZCBjbGlwcGluZyByZWN0YW5nbGUuXG4qL1xuY2xhc3MgT2Zmc2V0VHJhY2tlciB7XG4gICAgY29uc3RydWN0b3IoZWwpIHtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLm9yaWdSZWN0ID0gY29tcHV0ZVJlY3QoZWwpO1xuICAgICAgICAvLyB3aWxsIHdvcmsgZmluZSBmb3IgZGl2cyB0aGF0IGhhdmUgb3ZlcmZsb3c6aGlkZGVuXG4gICAgICAgIHRoaXMuc2Nyb2xsQ2FjaGVzID0gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsKS5tYXAoKHNjcm9sbEVsKSA9PiBuZXcgRWxlbWVudFNjcm9sbEdlb21DYWNoZShzY3JvbGxFbCwgdHJ1ZSkpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBmb3IgKGxldCBzY3JvbGxDYWNoZSBvZiB0aGlzLnNjcm9sbENhY2hlcykge1xuICAgICAgICAgICAgc2Nyb2xsQ2FjaGUuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXB1dGVMZWZ0KCkge1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMub3JpZ1JlY3QubGVmdDtcbiAgICAgICAgZm9yIChsZXQgc2Nyb2xsQ2FjaGUgb2YgdGhpcy5zY3JvbGxDYWNoZXMpIHtcbiAgICAgICAgICAgIGxlZnQgKz0gc2Nyb2xsQ2FjaGUub3JpZ1Njcm9sbExlZnQgLSBzY3JvbGxDYWNoZS5nZXRTY3JvbGxMZWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgfVxuICAgIGNvbXB1dGVUb3AoKSB7XG4gICAgICAgIGxldCB0b3AgPSB0aGlzLm9yaWdSZWN0LnRvcDtcbiAgICAgICAgZm9yIChsZXQgc2Nyb2xsQ2FjaGUgb2YgdGhpcy5zY3JvbGxDYWNoZXMpIHtcbiAgICAgICAgICAgIHRvcCArPSBzY3JvbGxDYWNoZS5vcmlnU2Nyb2xsVG9wIC0gc2Nyb2xsQ2FjaGUuZ2V0U2Nyb2xsVG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvcDtcbiAgICB9XG4gICAgaXNXaXRoaW5DbGlwcGluZyhwYWdlWCwgcGFnZVkpIHtcbiAgICAgICAgbGV0IHBvaW50ID0geyBsZWZ0OiBwYWdlWCwgdG9wOiBwYWdlWSB9O1xuICAgICAgICBmb3IgKGxldCBzY3JvbGxDYWNoZSBvZiB0aGlzLnNjcm9sbENhY2hlcykge1xuICAgICAgICAgICAgaWYgKCFpc0lnbm9yZWRDbGlwcGluZyhzY3JvbGxDYWNoZS5nZXRFdmVudFRhcmdldCgpKSAmJlxuICAgICAgICAgICAgICAgICFwb2ludEluc2lkZVJlY3QocG9pbnQsIHNjcm9sbENhY2hlLmNsaWVudFJlY3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbi8vIGNlcnRhaW4gY2xpcHBpbmcgY29udGFpbmVycyBzaG91bGQgbmV2ZXIgY29uc3RyYWluIGludGVyYWN0aW9ucywgbGlrZSA8aHRtbD4gYW5kIDxib2R5PlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Z1bGxjYWxlbmRhci9mdWxsY2FsZW5kYXIvaXNzdWVzLzM2MTVcbmZ1bmN0aW9uIGlzSWdub3JlZENsaXBwaW5nKG5vZGUpIHtcbiAgICBsZXQgdGFnTmFtZSA9IG5vZGUudGFnTmFtZTtcbiAgICByZXR1cm4gdGFnTmFtZSA9PT0gJ0hUTUwnIHx8IHRhZ05hbWUgPT09ICdCT0RZJztcbn1cblxuLypcblRyYWNrcyBtb3ZlbWVudCBvdmVyIG11bHRpcGxlIGRyb3BwYWJsZSBhcmVhcyAoYWthIFwiaGl0c1wiKVxudGhhdCBleGlzdCBpbiBvbmUgb3IgbW9yZSBEYXRlQ29tcG9uZW50cy5cblJlbGllcyBvbiBhbiBleGlzdGluZyBkcmFnZ2FibGUuXG5cbmVtaXRzOlxuLSBwb2ludGVyZG93blxuLSBkcmFnc3RhcnRcbi0gaGl0Y2hhbmdlIC0gZmlyZXMgaW5pdGlhbGx5LCBldmVuIGlmIG5vdCBvdmVyIGEgaGl0XG4tIHBvaW50ZXJ1cFxuLSAoaGl0Y2hhbmdlIC0gYWdhaW4sIHRvIG51bGwsIGlmIGVuZGVkIG92ZXIgYSBoaXQpXG4tIGRyYWdlbmRcbiovXG5jbGFzcyBIaXREcmFnZ2luZyB7XG4gICAgY29uc3RydWN0b3IoZHJhZ2dpbmcsIGRyb3BwYWJsZVN0b3JlKSB7XG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCBjYW4gYmUgc2V0IGJ5IGNhbGxlclxuICAgICAgICB0aGlzLnVzZVN1YmplY3RDZW50ZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZXF1aXJlSW5pdGlhbCA9IHRydWU7IC8vIGlmIGRvZXNuJ3Qgc3RhcnQgb3V0IG9uIGEgaGl0LCB3b24ndCBlbWl0IGFueSBldmVudHNcbiAgICAgICAgdGhpcy5kaXNhYmxlUG9pbnRDaGVjayA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluaXRpYWxIaXQgPSBudWxsO1xuICAgICAgICB0aGlzLm1vdmluZ0hpdCA9IG51bGw7XG4gICAgICAgIHRoaXMuZmluYWxIaXQgPSBudWxsOyAvLyB3b24ndCBldmVyIGJlIHBvcHVsYXRlZCBpZiBzaG91bGRJZ25vcmVNb3ZlXG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlckRvd24gPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGxldCB7IGRyYWdnaW5nIH0gPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsSGl0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubW92aW5nSGl0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZmluYWxIaXQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5wcmVwYXJlSGl0cygpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzRmlyc3RDb29yZChldik7XG4gICAgICAgICAgICBpZiAodGhpcy5pbml0aWFsSGl0IHx8ICF0aGlzLnJlcXVpcmVJbml0aWFsKSB7XG4gICAgICAgICAgICAgICAgZHJhZ2dpbmcuc2V0SWdub3JlTW92ZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogZmlyZSB0aGlzIGJlZm9yZSBjb21wdXRpbmcgcHJvY2Vzc0ZpcnN0Q29vcmQsIHNvIGxpc3RlbmVycyBjYW4gY2FuY2VsLiB0aGlzIGdldHMgZmlyZWQgYnkgYWxtb3N0IGV2ZXJ5IGhhbmRsZXIgOihcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcmRvd24nLCBldik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkcmFnZ2luZy5zZXRJZ25vcmVNb3ZlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZURyYWdTdGFydCA9IChldikgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdzdGFydCcsIGV2KTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW92ZShldiwgdHJ1ZSk7IC8vIGZvcmNlID0gZmlyZSBldmVuIGlmIGluaXRpYWxseSBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ01vdmUgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnbW92ZScsIGV2KTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW92ZShldik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlclVwID0gKGV2KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbGVhc2VIaXRzKCk7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcnVwJywgZXYpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZURyYWdFbmQgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1vdmluZ0hpdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdoaXR1cGRhdGUnLCBudWxsLCB0cnVlLCBldik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZpbmFsSGl0ID0gdGhpcy5tb3ZpbmdIaXQ7XG4gICAgICAgICAgICB0aGlzLm1vdmluZ0hpdCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignZHJhZ2VuZCcsIGV2KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kcm9wcGFibGVTdG9yZSA9IGRyb3BwYWJsZVN0b3JlO1xuICAgICAgICBkcmFnZ2luZy5lbWl0dGVyLm9uKCdwb2ludGVyZG93bicsIHRoaXMuaGFuZGxlUG9pbnRlckRvd24pO1xuICAgICAgICBkcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnc3RhcnQnLCB0aGlzLmhhbmRsZURyYWdTdGFydCk7XG4gICAgICAgIGRyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdtb3ZlJywgdGhpcy5oYW5kbGVEcmFnTW92ZSk7XG4gICAgICAgIGRyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJ1cCcsIHRoaXMuaGFuZGxlUG9pbnRlclVwKTtcbiAgICAgICAgZHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ2VuZCcsIHRoaXMuaGFuZGxlRHJhZ0VuZCk7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBkcmFnZ2luZztcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgLy8gc2V0cyBpbml0aWFsSGl0XG4gICAgLy8gc2V0cyBjb29yZEFkanVzdFxuICAgIHByb2Nlc3NGaXJzdENvb3JkKGV2KSB7XG4gICAgICAgIGxldCBvcmlnUG9pbnQgPSB7IGxlZnQ6IGV2LnBhZ2VYLCB0b3A6IGV2LnBhZ2VZIH07XG4gICAgICAgIGxldCBhZGp1c3RlZFBvaW50ID0gb3JpZ1BvaW50O1xuICAgICAgICBsZXQgc3ViamVjdEVsID0gZXYuc3ViamVjdEVsO1xuICAgICAgICBsZXQgc3ViamVjdFJlY3Q7XG4gICAgICAgIGlmIChzdWJqZWN0RWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgeyAvLyBpLmUuIG5vdCBhIERvY3VtZW50L1NoYWRvd1Jvb3RcbiAgICAgICAgICAgIHN1YmplY3RSZWN0ID0gY29tcHV0ZVJlY3Qoc3ViamVjdEVsKTtcbiAgICAgICAgICAgIGFkanVzdGVkUG9pbnQgPSBjb25zdHJhaW5Qb2ludChhZGp1c3RlZFBvaW50LCBzdWJqZWN0UmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluaXRpYWxIaXQgPSB0aGlzLmluaXRpYWxIaXQgPSB0aGlzLnF1ZXJ5SGl0Rm9yT2Zmc2V0KGFkanVzdGVkUG9pbnQubGVmdCwgYWRqdXN0ZWRQb2ludC50b3ApO1xuICAgICAgICBpZiAoaW5pdGlhbEhpdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudXNlU3ViamVjdENlbnRlciAmJiBzdWJqZWN0UmVjdCkge1xuICAgICAgICAgICAgICAgIGxldCBzbGljZWRTdWJqZWN0UmVjdCA9IGludGVyc2VjdFJlY3RzKHN1YmplY3RSZWN0LCBpbml0aWFsSGl0LnJlY3QpO1xuICAgICAgICAgICAgICAgIGlmIChzbGljZWRTdWJqZWN0UmVjdCkge1xuICAgICAgICAgICAgICAgICAgICBhZGp1c3RlZFBvaW50ID0gZ2V0UmVjdENlbnRlcihzbGljZWRTdWJqZWN0UmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb29yZEFkanVzdCA9IGRpZmZQb2ludHMoYWRqdXN0ZWRQb2ludCwgb3JpZ1BvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29vcmRBZGp1c3QgPSB7IGxlZnQ6IDAsIHRvcDogMCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZU1vdmUoZXYsIGZvcmNlSGFuZGxlKSB7XG4gICAgICAgIGxldCBoaXQgPSB0aGlzLnF1ZXJ5SGl0Rm9yT2Zmc2V0KGV2LnBhZ2VYICsgdGhpcy5jb29yZEFkanVzdC5sZWZ0LCBldi5wYWdlWSArIHRoaXMuY29vcmRBZGp1c3QudG9wKTtcbiAgICAgICAgaWYgKGZvcmNlSGFuZGxlIHx8ICFpc0hpdHNFcXVhbCh0aGlzLm1vdmluZ0hpdCwgaGl0KSkge1xuICAgICAgICAgICAgdGhpcy5tb3ZpbmdIaXQgPSBoaXQ7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignaGl0dXBkYXRlJywgaGl0LCBmYWxzZSwgZXYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByZXBhcmVIaXRzKCkge1xuICAgICAgICB0aGlzLm9mZnNldFRyYWNrZXJzID0gbWFwSGFzaCh0aGlzLmRyb3BwYWJsZVN0b3JlLCAoaW50ZXJhY3Rpb25TZXR0aW5ncykgPT4ge1xuICAgICAgICAgICAgaW50ZXJhY3Rpb25TZXR0aW5ncy5jb21wb25lbnQucHJlcGFyZUhpdHMoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgT2Zmc2V0VHJhY2tlcihpbnRlcmFjdGlvblNldHRpbmdzLmVsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbGVhc2VIaXRzKCkge1xuICAgICAgICBsZXQgeyBvZmZzZXRUcmFja2VycyB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaWQgaW4gb2Zmc2V0VHJhY2tlcnMpIHtcbiAgICAgICAgICAgIG9mZnNldFRyYWNrZXJzW2lkXS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vZmZzZXRUcmFja2VycyA9IHt9O1xuICAgIH1cbiAgICBxdWVyeUhpdEZvck9mZnNldChvZmZzZXRMZWZ0LCBvZmZzZXRUb3ApIHtcbiAgICAgICAgbGV0IHsgZHJvcHBhYmxlU3RvcmUsIG9mZnNldFRyYWNrZXJzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgYmVzdEhpdCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGlkIGluIGRyb3BwYWJsZVN0b3JlKSB7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50ID0gZHJvcHBhYmxlU3RvcmVbaWRdLmNvbXBvbmVudDtcbiAgICAgICAgICAgIGxldCBvZmZzZXRUcmFja2VyID0gb2Zmc2V0VHJhY2tlcnNbaWRdO1xuICAgICAgICAgICAgaWYgKG9mZnNldFRyYWNrZXIgJiYgLy8gd2Fzbid0IGRlc3Ryb3llZCBtaWQtZHJhZ1xuICAgICAgICAgICAgICAgIG9mZnNldFRyYWNrZXIuaXNXaXRoaW5DbGlwcGluZyhvZmZzZXRMZWZ0LCBvZmZzZXRUb3ApKSB7XG4gICAgICAgICAgICAgICAgbGV0IG9yaWdpbkxlZnQgPSBvZmZzZXRUcmFja2VyLmNvbXB1dGVMZWZ0KCk7XG4gICAgICAgICAgICAgICAgbGV0IG9yaWdpblRvcCA9IG9mZnNldFRyYWNrZXIuY29tcHV0ZVRvcCgpO1xuICAgICAgICAgICAgICAgIGxldCBwb3NpdGlvbkxlZnQgPSBvZmZzZXRMZWZ0IC0gb3JpZ2luTGVmdDtcbiAgICAgICAgICAgICAgICBsZXQgcG9zaXRpb25Ub3AgPSBvZmZzZXRUb3AgLSBvcmlnaW5Ub3A7XG4gICAgICAgICAgICAgICAgbGV0IHsgb3JpZ1JlY3QgfSA9IG9mZnNldFRyYWNrZXI7XG4gICAgICAgICAgICAgICAgbGV0IHdpZHRoID0gb3JpZ1JlY3QucmlnaHQgLSBvcmlnUmVjdC5sZWZ0O1xuICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSBvcmlnUmVjdC5ib3R0b20gLSBvcmlnUmVjdC50b3A7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIC8vIG11c3QgYmUgd2l0aGluIHRoZSBlbGVtZW50J3MgYm91bmRzXG4gICAgICAgICAgICAgICAgcG9zaXRpb25MZWZ0ID49IDAgJiYgcG9zaXRpb25MZWZ0IDwgd2lkdGggJiZcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25Ub3AgPj0gMCAmJiBwb3NpdGlvblRvcCA8IGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaGl0ID0gY29tcG9uZW50LnF1ZXJ5SGl0KHBvc2l0aW9uTGVmdCwgcG9zaXRpb25Ub3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGl0ICYmIChcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBoaXQgaXMgd2l0aGluIGFjdGl2ZVJhbmdlLCBtZWFuaW5nIGl0J3Mgbm90IGEgZGVhZCBjZWxsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlQ29udGFpbnNSYW5nZShoaXQuZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGhpdC5kYXRlU3Bhbi5yYW5nZSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhlIGNvbXBvbmVudCB3ZSBhcmUgcXVlcnlpbmcgZm9yIHRoZSBoaXQgaXMgYWNjZXNzaWJseSBteSB0aGUgcG9pbnRlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudHMgb2JzY3VyZWQgY2FsZW5kYXJzIChleDogdW5kZXIgYSBtb2RhbCBkaWFsb2cpIGZyb20gYWNjZXB0aW5nIGhpdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Z1bGxjYWxlbmRhci9mdWxsY2FsZW5kYXIvaXNzdWVzLzUwMjZcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmRpc2FibGVQb2ludENoZWNrIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0VHJhY2tlci5lbC5jb250YWlucyhvZmZzZXRUcmFja2VyLmVsLmdldFJvb3ROb2RlKCkuZWxlbWVudEZyb21Qb2ludChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQtYmFjayBvcmlnaW5zIHRvIGdldCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRvcC1sZWZ0IG9mIHdpbmRvdyB2aWV3cG9ydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uTGVmdCArIG9yaWdpbkxlZnQgLSB3aW5kb3cuc2Nyb2xsWCwgcG9zaXRpb25Ub3AgKyBvcmlnaW5Ub3AgLSB3aW5kb3cuc2Nyb2xsWSkpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCFiZXN0SGl0IHx8IGhpdC5sYXllciA+IGJlc3RIaXQubGF5ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaXQuY29tcG9uZW50SWQgPSBpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdC5jb250ZXh0ID0gY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBiZXR0ZXIgd2F5IHRvIHJlLW9yaWVudCByZWN0YW5nbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdC5yZWN0LmxlZnQgKz0gb3JpZ2luTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdC5yZWN0LnJpZ2h0ICs9IG9yaWdpbkxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaXQucmVjdC50b3AgKz0gb3JpZ2luVG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGl0LnJlY3QuYm90dG9tICs9IG9yaWdpblRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RIaXQgPSBoaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJlc3RIaXQ7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNIaXRzRXF1YWwoaGl0MCwgaGl0MSkge1xuICAgIGlmICghaGl0MCAmJiAhaGl0MSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKEJvb2xlYW4oaGl0MCkgIT09IEJvb2xlYW4oaGl0MSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaXNEYXRlU3BhbnNFcXVhbChoaXQwLmRhdGVTcGFuLCBoaXQxLmRhdGVTcGFuKTtcbn1cblxuZnVuY3Rpb24gYnVpbGREYXRlUG9pbnRBcGlXaXRoQ29udGV4dChkYXRlU3BhbiwgY29udGV4dCkge1xuICAgIGxldCBwcm9wcyA9IHt9O1xuICAgIGZvciAobGV0IHRyYW5zZm9ybSBvZiBjb250ZXh0LnBsdWdpbkhvb2tzLmRhdGVQb2ludFRyYW5zZm9ybXMpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihwcm9wcywgdHJhbnNmb3JtKGRhdGVTcGFuLCBjb250ZXh0KSk7XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24ocHJvcHMsIGJ1aWxkRGF0ZVBvaW50QXBpKGRhdGVTcGFuLCBjb250ZXh0LmRhdGVFbnYpKTtcbiAgICByZXR1cm4gcHJvcHM7XG59XG5mdW5jdGlvbiBidWlsZERhdGVQb2ludEFwaShzcGFuLCBkYXRlRW52KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0ZTogZGF0ZUVudi50b0RhdGUoc3Bhbi5yYW5nZS5zdGFydCksXG4gICAgICAgIGRhdGVTdHI6IGRhdGVFbnYuZm9ybWF0SXNvKHNwYW4ucmFuZ2Uuc3RhcnQsIHsgb21pdFRpbWU6IHNwYW4uYWxsRGF5IH0pLFxuICAgICAgICBhbGxEYXk6IHNwYW4uYWxsRGF5LFxuICAgIH07XG59XG5cbi8qXG5Nb25pdG9ycyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiBhIHNwZWNpZmljIGRhdGUvdGltZSBvZiBhIGNvbXBvbmVudC5cbkEgcG9pbnRlcmRvd24rcG9pbnRlcnVwIG9uIHRoZSBzYW1lIFwiaGl0XCIgY29uc3RpdHV0ZXMgYSBjbGljay5cbiovXG5jbGFzcyBEYXRlQ2xpY2tpbmcgZXh0ZW5kcyBJbnRlcmFjdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICAgICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJEb3duID0gKHBldikgPT4ge1xuICAgICAgICAgICAgbGV0IHsgZHJhZ2dpbmcgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgZG93bkVsID0gcGV2Lm9yaWdFdmVudC50YXJnZXQ7XG4gICAgICAgICAgICAvLyBkbyB0aGlzIGluIHBvaW50ZXJkb3duIChub3QgZHJhZ2VuZCkgYmVjYXVzZSBET00gbWlnaHQgYmUgbXV0YXRlZCBieSB0aGUgdGltZSBkcmFnZW5kIGlzIGZpcmVkXG4gICAgICAgICAgICBkcmFnZ2luZy5zZXRJZ25vcmVNb3ZlKCF0aGlzLmNvbXBvbmVudC5pc1ZhbGlkRGF0ZURvd25FbChkb3duRWwpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gd29uJ3QgZXZlbiBmaXJlIGlmIG1vdmluZyB3YXMgaWdub3JlZFxuICAgICAgICB0aGlzLmhhbmRsZURyYWdFbmQgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGxldCB7IGNvbXBvbmVudCB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCB7IHBvaW50ZXIgfSA9IHRoaXMuZHJhZ2dpbmc7XG4gICAgICAgICAgICBpZiAoIXBvaW50ZXIud2FzVG91Y2hTY3JvbGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBpbml0aWFsSGl0LCBmaW5hbEhpdCB9ID0gdGhpcy5oaXREcmFnZ2luZztcbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbEhpdCAmJiBmaW5hbEhpdCAmJiBpc0hpdHNFcXVhbChpbml0aWFsSGl0LCBmaW5hbEhpdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgY29udGV4dCB9ID0gY29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICBsZXQgYXJnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZERhdGVQb2ludEFwaVdpdGhDb250ZXh0KGluaXRpYWxIaXQuZGF0ZVNwYW4sIGNvbnRleHQpKSwgeyBkYXlFbDogaW5pdGlhbEhpdC5kYXlFbCwganNFdmVudDogZXYub3JpZ0V2ZW50LCB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfHwgY29udGV4dC5jYWxlbmRhckFwaS52aWV3IH0pO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZGF0ZUNsaWNrJywgYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIHdlIERPIHdhbnQgdG8gd2F0Y2ggcG9pbnRlciBtb3ZlcyBiZWNhdXNlIG90aGVyd2lzZSBmaW5hbEhpdCB3b24ndCBnZXQgcG9wdWxhdGVkXG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBuZXcgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyhzZXR0aW5ncy5lbCk7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcuYXV0b1Njcm9sbGVyLmlzRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgaGl0RHJhZ2dpbmcgPSB0aGlzLmhpdERyYWdnaW5nID0gbmV3IEhpdERyYWdnaW5nKHRoaXMuZHJhZ2dpbmcsIGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlKHNldHRpbmdzKSk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJkb3duJywgdGhpcy5oYW5kbGVQb2ludGVyRG93bik7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdlbmQnLCB0aGlzLmhhbmRsZURyYWdFbmQpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nLmRlc3Ryb3koKTtcbiAgICB9XG59XG5cbi8qXG5UcmFja3Mgd2hlbiB0aGUgdXNlciBzZWxlY3RzIGEgcG9ydGlvbiBvZiB0aW1lIG9mIGEgY29tcG9uZW50LFxuY29uc3RpdHV0ZWQgYnkgYSBkcmFnIG92ZXIgZGF0ZSBjZWxscywgd2l0aCBhIHBvc3NpYmxlIGRlbGF5IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRyYWcuXG4qL1xuY2xhc3MgRGF0ZVNlbGVjdGluZyBleHRlbmRzIEludGVyYWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgICAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgICAgIHRoaXMuZHJhZ1NlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlckRvd24gPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGxldCB7IGNvbXBvbmVudCwgZHJhZ2dpbmcgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgICAgIGxldCBjYW5TZWxlY3QgPSBvcHRpb25zLnNlbGVjdGFibGUgJiZcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuaXNWYWxpZERhdGVEb3duRWwoZXYub3JpZ0V2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICAvLyBkb24ndCBib3RoZXIgdG8gd2F0Y2ggZXhwZW5zaXZlIG1vdmVzIGlmIGNvbXBvbmVudCB3b24ndCBkbyBzZWxlY3Rpb25cbiAgICAgICAgICAgIGRyYWdnaW5nLnNldElnbm9yZU1vdmUoIWNhblNlbGVjdCk7XG4gICAgICAgICAgICAvLyBpZiB0b3VjaCwgcmVxdWlyZSB1c2VyIHRvIGhvbGQgZG93blxuICAgICAgICAgICAgZHJhZ2dpbmcuZGVsYXkgPSBldi5pc1RvdWNoID8gZ2V0Q29tcG9uZW50VG91Y2hEZWxheSQxKGNvbXBvbmVudCkgOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZURyYWdTdGFydCA9IChldikgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQuY29udGV4dC5jYWxlbmRhckFwaS51bnNlbGVjdChldik7IC8vIHVuc2VsZWN0IHByZXZpb3VzIHNlbGVjdGlvbnNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVIaXRVcGRhdGUgPSAoaGl0LCBpc0ZpbmFsKSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSB0aGlzLmNvbXBvbmVudDtcbiAgICAgICAgICAgIGxldCBkcmFnU2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBpc0ludmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChoaXQpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5pdGlhbEhpdCA9IHRoaXMuaGl0RHJhZ2dpbmcuaW5pdGlhbEhpdDtcbiAgICAgICAgICAgICAgICBsZXQgZGlzYWxsb3dlZCA9IGhpdC5jb21wb25lbnRJZCA9PT0gaW5pdGlhbEhpdC5jb21wb25lbnRJZFxuICAgICAgICAgICAgICAgICAgICAmJiB0aGlzLmlzSGl0Q29tYm9BbGxvd2VkXG4gICAgICAgICAgICAgICAgICAgICYmICF0aGlzLmlzSGl0Q29tYm9BbGxvd2VkKGluaXRpYWxIaXQsIGhpdCk7XG4gICAgICAgICAgICAgICAgaWYgKCFkaXNhbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdTZWxlY3Rpb24gPSBqb2luSGl0c0ludG9TZWxlY3Rpb24oaW5pdGlhbEhpdCwgaGl0LCBjb250ZXh0LnBsdWdpbkhvb2tzLmRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWRyYWdTZWxlY3Rpb24gfHwgIWlzRGF0ZVNlbGVjdGlvblZhbGlkKGRyYWdTZWxlY3Rpb24sIGhpdC5kYXRlUHJvZmlsZSwgY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNJbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ1NlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRyYWdTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1NFTEVDVF9EQVRFUycsIHNlbGVjdGlvbjogZHJhZ1NlbGVjdGlvbiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc0ZpbmFsKSB7IC8vIG9ubHkgdW5zZWxlY3QgaWYgbW92ZWQgYXdheSB3aGlsZSBkcmFnZ2luZ1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRUxFQ1RfREFURVMnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0ludmFsaWQpIHtcbiAgICAgICAgICAgICAgICBlbmFibGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpc2FibGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNGaW5hbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1NlbGVjdGlvbiA9IGRyYWdTZWxlY3Rpb247IC8vIG9ubHkgY2xlYXIgaWYgbW92ZWQgYXdheSBmcm9tIGFsbCBoaXRzIHdoaWxlIGRyYWdnaW5nXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlclVwID0gKHBldikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuZHJhZ1NlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIHNlbGVjdGlvbiBpcyBhbHJlYWR5IHJlbmRlcmVkLCBzbyBqdXN0IG5lZWQgdG8gcmVwb3J0IHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIHRyaWdnZXJEYXRlU2VsZWN0KHRoaXMuZHJhZ1NlbGVjdGlvbiwgcGV2LCB0aGlzLmNvbXBvbmVudC5jb250ZXh0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgeyBjb21wb25lbnQgfSA9IHNldHRpbmdzO1xuICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgbGV0IGRyYWdnaW5nID0gdGhpcy5kcmFnZ2luZyA9IG5ldyBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nKHNldHRpbmdzLmVsKTtcbiAgICAgICAgZHJhZ2dpbmcudG91Y2hTY3JvbGxBbGxvd2VkID0gZmFsc2U7XG4gICAgICAgIGRyYWdnaW5nLm1pbkRpc3RhbmNlID0gb3B0aW9ucy5zZWxlY3RNaW5EaXN0YW5jZSB8fCAwO1xuICAgICAgICBkcmFnZ2luZy5hdXRvU2Nyb2xsZXIuaXNFbmFibGVkID0gb3B0aW9ucy5kcmFnU2Nyb2xsO1xuICAgICAgICBsZXQgaGl0RHJhZ2dpbmcgPSB0aGlzLmhpdERyYWdnaW5nID0gbmV3IEhpdERyYWdnaW5nKHRoaXMuZHJhZ2dpbmcsIGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlKHNldHRpbmdzKSk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJkb3duJywgdGhpcy5oYW5kbGVQb2ludGVyRG93bik7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdzdGFydCcsIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0KTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignaGl0dXBkYXRlJywgdGhpcy5oYW5kbGVIaXRVcGRhdGUpO1xuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdwb2ludGVydXAnLCB0aGlzLmhhbmRsZVBvaW50ZXJVcCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldENvbXBvbmVudFRvdWNoRGVsYXkkMShjb21wb25lbnQpIHtcbiAgICBsZXQgeyBvcHRpb25zIH0gPSBjb21wb25lbnQuY29udGV4dDtcbiAgICBsZXQgZGVsYXkgPSBvcHRpb25zLnNlbGVjdExvbmdQcmVzc0RlbGF5O1xuICAgIGlmIChkZWxheSA9PSBudWxsKSB7XG4gICAgICAgIGRlbGF5ID0gb3B0aW9ucy5sb25nUHJlc3NEZWxheTtcbiAgICB9XG4gICAgcmV0dXJuIGRlbGF5O1xufVxuZnVuY3Rpb24gam9pbkhpdHNJbnRvU2VsZWN0aW9uKGhpdDAsIGhpdDEsIGRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMpIHtcbiAgICBsZXQgZGF0ZVNwYW4wID0gaGl0MC5kYXRlU3BhbjtcbiAgICBsZXQgZGF0ZVNwYW4xID0gaGl0MS5kYXRlU3BhbjtcbiAgICBsZXQgbXMgPSBbXG4gICAgICAgIGRhdGVTcGFuMC5yYW5nZS5zdGFydCxcbiAgICAgICAgZGF0ZVNwYW4wLnJhbmdlLmVuZCxcbiAgICAgICAgZGF0ZVNwYW4xLnJhbmdlLnN0YXJ0LFxuICAgICAgICBkYXRlU3BhbjEucmFuZ2UuZW5kLFxuICAgIF07XG4gICAgbXMuc29ydChjb21wYXJlTnVtYmVycyk7XG4gICAgbGV0IHByb3BzID0ge307XG4gICAgZm9yIChsZXQgdHJhbnNmb3JtZXIgb2YgZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycykge1xuICAgICAgICBsZXQgcmVzID0gdHJhbnNmb3JtZXIoaGl0MCwgaGl0MSk7XG4gICAgICAgIGlmIChyZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHByb3BzLCByZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb3BzLnJhbmdlID0geyBzdGFydDogbXNbMF0sIGVuZDogbXNbM10gfTtcbiAgICBwcm9wcy5hbGxEYXkgPSBkYXRlU3BhbjAuYWxsRGF5O1xuICAgIHJldHVybiBwcm9wcztcbn1cblxuY2xhc3MgRXZlbnREcmFnZ2luZyBleHRlbmRzIEludGVyYWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgICAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgICAgIC8vIGludGVybmFsIHN0YXRlXG4gICAgICAgIHRoaXMuc3ViamVjdEVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdWJqZWN0U2VnID0gbnVsbDsgLy8gdGhlIHNlZyBiZWluZyBzZWxlY3RlZC9kcmFnZ2VkXG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmV2ZW50UmFuZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLnJlbGV2YW50RXZlbnRzID0gbnVsbDsgLy8gdGhlIGV2ZW50cyBiZWluZyBkcmFnZ2VkXG4gICAgICAgIHRoaXMucmVjZWl2aW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMudmFsaWRNdXRhdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyRG93biA9IChldikgPT4ge1xuICAgICAgICAgICAgbGV0IG9yaWdUYXJnZXQgPSBldi5vcmlnRXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgbGV0IHsgY29tcG9uZW50LCBkcmFnZ2luZyB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCB7IG1pcnJvciB9ID0gZHJhZ2dpbmc7XG4gICAgICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgICAgIGxldCBpbml0aWFsQ29udGV4dCA9IGNvbXBvbmVudC5jb250ZXh0O1xuICAgICAgICAgICAgdGhpcy5zdWJqZWN0RWwgPSBldi5zdWJqZWN0RWw7XG4gICAgICAgICAgICBsZXQgc3ViamVjdFNlZyA9IHRoaXMuc3ViamVjdFNlZyA9IGdldEVsU2VnKGV2LnN1YmplY3RFbCk7XG4gICAgICAgICAgICBsZXQgZXZlbnRSYW5nZSA9IHRoaXMuZXZlbnRSYW5nZSA9IHN1YmplY3RTZWcuZXZlbnRSYW5nZTtcbiAgICAgICAgICAgIGxldCBldmVudEluc3RhbmNlSWQgPSBldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQ7XG4gICAgICAgICAgICB0aGlzLnJlbGV2YW50RXZlbnRzID0gZ2V0UmVsZXZhbnRFdmVudHMoaW5pdGlhbENvbnRleHQuZ2V0Q3VycmVudERhdGEoKS5ldmVudFN0b3JlLCBldmVudEluc3RhbmNlSWQpO1xuICAgICAgICAgICAgZHJhZ2dpbmcubWluRGlzdGFuY2UgPSBldi5pc1RvdWNoID8gMCA6IG9wdGlvbnMuZXZlbnREcmFnTWluRGlzdGFuY2U7XG4gICAgICAgICAgICBkcmFnZ2luZy5kZWxheSA9XG4gICAgICAgICAgICAgICAgLy8gb25seSBkbyBhIHRvdWNoIGRlbGF5IGlmIHRvdWNoIGFuZCB0aGlzIGV2ZW50IGhhc24ndCBiZWVuIHNlbGVjdGVkIHlldFxuICAgICAgICAgICAgICAgIChldi5pc1RvdWNoICYmIGV2ZW50SW5zdGFuY2VJZCAhPT0gY29tcG9uZW50LnByb3BzLmV2ZW50U2VsZWN0aW9uKSA/XG4gICAgICAgICAgICAgICAgICAgIGdldENvbXBvbmVudFRvdWNoRGVsYXkoY29tcG9uZW50KSA6XG4gICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5maXhlZE1pcnJvclBhcmVudCkge1xuICAgICAgICAgICAgICAgIG1pcnJvci5wYXJlbnROb2RlID0gb3B0aW9ucy5maXhlZE1pcnJvclBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1pcnJvci5wYXJlbnROb2RlID0gZWxlbWVudENsb3Nlc3Qob3JpZ1RhcmdldCwgJy5mYycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWlycm9yLnJldmVydER1cmF0aW9uID0gb3B0aW9ucy5kcmFnUmV2ZXJ0RHVyYXRpb247XG4gICAgICAgICAgICBsZXQgaXNWYWxpZCA9IGNvbXBvbmVudC5pc1ZhbGlkU2VnRG93bkVsKG9yaWdUYXJnZXQpICYmXG4gICAgICAgICAgICAgICAgIWVsZW1lbnRDbG9zZXN0KG9yaWdUYXJnZXQsICcuZmMtZXZlbnQtcmVzaXplcicpOyAvLyBOT1Qgb24gYSByZXNpemVyXG4gICAgICAgICAgICBkcmFnZ2luZy5zZXRJZ25vcmVNb3ZlKCFpc1ZhbGlkKTtcbiAgICAgICAgICAgIC8vIGRpc2FibGUgZHJhZ2dpbmcgZm9yIGVsZW1lbnRzIHRoYXQgYXJlIHJlc2l6YWJsZSAoaWUsIHNlbGVjdGFibGUpXG4gICAgICAgICAgICAvLyBidXQgYXJlIG5vdCBkcmFnZ2FibGVcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGlzVmFsaWQgJiZcbiAgICAgICAgICAgICAgICBldi5zdWJqZWN0RWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdmYy1ldmVudC1kcmFnZ2FibGUnKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEcmFnU3RhcnQgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGxldCBpbml0aWFsQ29udGV4dCA9IHRoaXMuY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgICAgICBsZXQgZXZlbnRSYW5nZSA9IHRoaXMuZXZlbnRSYW5nZTtcbiAgICAgICAgICAgIGxldCBldmVudEluc3RhbmNlSWQgPSBldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQ7XG4gICAgICAgICAgICBpZiAoZXYuaXNUb3VjaCkge1xuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gc2VsZWN0IGEgZGlmZmVyZW50IGV2ZW50P1xuICAgICAgICAgICAgICAgIGlmIChldmVudEluc3RhbmNlSWQgIT09IHRoaXMuY29tcG9uZW50LnByb3BzLmV2ZW50U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1NFTEVDVF9FVkVOVCcsIGV2ZW50SW5zdGFuY2VJZCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBub3cgdXNpbmcgbW91c2UsIGJ1dCB3YXMgcHJldmlvdXMgdG91Y2ggaW50ZXJhY3Rpb24sIGNsZWFyIHNlbGVjdGVkIGV2ZW50XG4gICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRUxFQ1RfRVZFTlQnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmNhbGVuZGFyQXBpLnVuc2VsZWN0KGV2KTsgLy8gdW5zZWxlY3QgKmRhdGUqIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnREcmFnU3RhcnQnLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsOiB0aGlzLnN1YmplY3RFbCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEltcGwoaW5pdGlhbENvbnRleHQsIGV2ZW50UmFuZ2UuZGVmLCBldmVudFJhbmdlLmluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAganNFdmVudDogZXYub3JpZ0V2ZW50LFxuICAgICAgICAgICAgICAgICAgICB2aWV3OiBpbml0aWFsQ29udGV4dC52aWV3QXBpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUhpdFVwZGF0ZSA9IChoaXQsIGlzRmluYWwpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlbGV2YW50RXZlbnRzID0gdGhpcy5yZWxldmFudEV2ZW50cztcbiAgICAgICAgICAgIGxldCBpbml0aWFsSGl0ID0gdGhpcy5oaXREcmFnZ2luZy5pbml0aWFsSGl0O1xuICAgICAgICAgICAgbGV0IGluaXRpYWxDb250ZXh0ID0gdGhpcy5jb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgICAgIC8vIHN0YXRlcyBiYXNlZCBvbiBuZXcgaGl0XG4gICAgICAgICAgICBsZXQgcmVjZWl2aW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICBsZXQgbXV0YXRpb24gPSBudWxsO1xuICAgICAgICAgICAgbGV0IG11dGF0ZWRSZWxldmFudEV2ZW50cyA9IG51bGw7XG4gICAgICAgICAgICBsZXQgaXNJbnZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgaW50ZXJhY3Rpb24gPSB7XG4gICAgICAgICAgICAgICAgYWZmZWN0ZWRFdmVudHM6IHJlbGV2YW50RXZlbnRzLFxuICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudHM6IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpLFxuICAgICAgICAgICAgICAgIGlzRXZlbnQ6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGhpdCkge1xuICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQgPSBoaXQuY29udGV4dDtcbiAgICAgICAgICAgICAgICBsZXQgcmVjZWl2aW5nT3B0aW9ucyA9IHJlY2VpdmluZ0NvbnRleHQub3B0aW9ucztcbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbENvbnRleHQgPT09IHJlY2VpdmluZ0NvbnRleHQgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlY2VpdmluZ09wdGlvbnMuZWRpdGFibGUgJiYgcmVjZWl2aW5nT3B0aW9ucy5kcm9wcGFibGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG11dGF0aW9uID0gY29tcHV0ZUV2ZW50TXV0YXRpb24oaW5pdGlhbEhpdCwgaGl0LCB0aGlzLmV2ZW50UmFuZ2UuaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIHJlY2VpdmluZ0NvbnRleHQuZ2V0Q3VycmVudERhdGEoKS5wbHVnaW5Ib29rcy5ldmVudERyYWdNdXRhdGlvbk1hc3NhZ2Vycyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtdXRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZShyZWxldmFudEV2ZW50cywgcmVjZWl2aW5nQ29udGV4dC5nZXRDdXJyZW50RGF0YSgpLmV2ZW50VWlCYXNlcywgbXV0YXRpb24sIHJlY2VpdmluZ0NvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cyA9IG11dGF0ZWRSZWxldmFudEV2ZW50cztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNJbnRlcmFjdGlvblZhbGlkKGludGVyYWN0aW9uLCBoaXQuZGF0ZVByb2ZpbGUsIHJlY2VpdmluZ0NvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNJbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGlzcGxheURyYWcocmVjZWl2aW5nQ29udGV4dCwgaW50ZXJhY3Rpb24pO1xuICAgICAgICAgICAgaWYgKCFpc0ludmFsaWQpIHtcbiAgICAgICAgICAgICAgICBlbmFibGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpc2FibGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNGaW5hbCkge1xuICAgICAgICAgICAgICAgIGlmIChpbml0aWFsQ29udGV4dCA9PT0gcmVjZWl2aW5nQ29udGV4dCAmJiAvLyBUT0RPOiB3cml0ZSB0ZXN0IGZvciB0aGlzXG4gICAgICAgICAgICAgICAgICAgIGlzSGl0c0VxdWFsKGluaXRpYWxIaXQsIGhpdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nLnNldE1pcnJvck5lZWRzUmV2ZXJ0KCFtdXRhdGlvbik7XG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyIHRoZSBtaXJyb3IgaWYgbm8gYWxyZWFkeS1yZW5kZXJlZCBtaXJyb3JcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB3aXNoIHdlIGNvdWxkIHNvbWVob3cgd2FpdCBmb3IgZGlzcGF0Y2ggdG8gZ3VhcmFudGVlIHJlbmRlclxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcuc2V0TWlycm9ySXNWaXNpYmxlKCFoaXQgfHwgIXRoaXMuc3ViamVjdEVsLmdldFJvb3ROb2RlKCkucXVlcnlTZWxlY3RvcignLmZjLWV2ZW50LW1pcnJvcicpKTtcbiAgICAgICAgICAgICAgICAvLyBhc3NpZ24gc3RhdGVzIGJhc2VkIG9uIG5ldyBoaXRcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2VpdmluZ0NvbnRleHQgPSByZWNlaXZpbmdDb250ZXh0O1xuICAgICAgICAgICAgICAgIHRoaXMudmFsaWRNdXRhdGlvbiA9IG11dGF0aW9uO1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbXV0YXRlZFJlbGV2YW50RXZlbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJVcCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhbnVwKCk7IC8vIGJlY2F1c2UgaGFuZGxlRHJhZ0VuZCB3b24ndCBmaXJlXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ0VuZCA9IChldikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIGxldCBpbml0aWFsQ29udGV4dCA9IHRoaXMuY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgICAgICAgICAgbGV0IGluaXRpYWxWaWV3ID0gaW5pdGlhbENvbnRleHQudmlld0FwaTtcbiAgICAgICAgICAgICAgICBsZXQgeyByZWNlaXZpbmdDb250ZXh0LCB2YWxpZE11dGF0aW9uIH0gPSB0aGlzO1xuICAgICAgICAgICAgICAgIGxldCBldmVudERlZiA9IHRoaXMuZXZlbnRSYW5nZS5kZWY7XG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50SW5zdGFuY2UgPSB0aGlzLmV2ZW50UmFuZ2UuaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50QXBpID0gbmV3IEV2ZW50SW1wbChpbml0aWFsQ29udGV4dCwgZXZlbnREZWYsIGV2ZW50SW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIGxldCByZWxldmFudEV2ZW50cyA9IHRoaXMucmVsZXZhbnRFdmVudHM7XG4gICAgICAgICAgICAgICAgbGV0IG11dGF0ZWRSZWxldmFudEV2ZW50cyA9IHRoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzO1xuICAgICAgICAgICAgICAgIGxldCB7IGZpbmFsSGl0IH0gPSB0aGlzLmhpdERyYWdnaW5nO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJEcmFnKCk7IC8vIG11c3QgaGFwcGVuIGFmdGVyIHJldmVydCBhbmltYXRpb25cbiAgICAgICAgICAgICAgICBpbml0aWFsQ29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50RHJhZ1N0b3AnLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsOiB0aGlzLnN1YmplY3RFbCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50QXBpLFxuICAgICAgICAgICAgICAgICAgICBqc0V2ZW50OiBldi5vcmlnRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIHZpZXc6IGluaXRpYWxWaWV3LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh2YWxpZE11dGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRyb3BwZWQgd2l0aGluIHNhbWUgY2FsZW5kYXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpdmluZ0NvbnRleHQgPT09IGluaXRpYWxDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdXBkYXRlZEV2ZW50QXBpID0gbmV3IEV2ZW50SW1wbChpbml0aWFsQ29udGV4dCwgbXV0YXRlZFJlbGV2YW50RXZlbnRzLmRlZnNbZXZlbnREZWYuZGVmSWRdLCBldmVudEluc3RhbmNlID8gbXV0YXRlZFJlbGV2YW50RXZlbnRzLmluc3RhbmNlc1tldmVudEluc3RhbmNlLmluc3RhbmNlSWRdIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogbXV0YXRlZFJlbGV2YW50RXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXZlbnRDaGFuZ2VBcmcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkRXZlbnQ6IGV2ZW50QXBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiB1cGRhdGVkRXZlbnRBcGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogYnVpbGRFdmVudEFwaXMobXV0YXRlZFJlbGV2YW50RXZlbnRzLCBpbml0aWFsQ29udGV4dCwgZXZlbnRJbnN0YW5jZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IHJlbGV2YW50RXZlbnRzLCAvLyB0aGUgcHJlLWNoYW5nZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRyYW5zZm9ybWVkID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0cmFuc2Zvcm1lciBvZiBpbml0aWFsQ29udGV4dC5nZXRDdXJyZW50RGF0YSgpLnBsdWdpbkhvb2tzLmV2ZW50RHJvcFRyYW5zZm9ybWVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHJhbnNmb3JtZWQsIHRyYW5zZm9ybWVyKHZhbGlkTXV0YXRpb24sIGluaXRpYWxDb250ZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50RHJvcCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldmVudENoYW5nZUFyZyksIHRyYW5zZm9ybWVkKSwgeyBlbDogZXYuc3ViamVjdEVsLCBkZWx0YTogdmFsaWRNdXRhdGlvbi5kYXRlc0RlbHRhLCBqc0V2ZW50OiBldi5vcmlnRXZlbnQsIHZpZXc6IGluaXRpYWxWaWV3IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRDaGFuZ2UnLCBldmVudENoYW5nZUFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkcm9wcGVkIGluIGRpZmZlcmVudCBjYWxlbmRhclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlY2VpdmluZ0NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBldmVudFJlbW92ZUFyZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZXZlbnRBcGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogYnVpbGRFdmVudEFwaXMocmVsZXZhbnRFdmVudHMsIGluaXRpYWxDb250ZXh0LCBldmVudEluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogcmVsZXZhbnRFdmVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudExlYXZlJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldmVudFJlbW92ZUFyZyksIHsgZHJhZ2dlZEVsOiBldi5zdWJqZWN0RWwsIHZpZXc6IGluaXRpYWxWaWV3IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogcmVsZXZhbnRFdmVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRSZW1vdmUnLCBldmVudFJlbW92ZUFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYWRkZWRFdmVudERlZiA9IG11dGF0ZWRSZWxldmFudEV2ZW50cy5kZWZzW2V2ZW50RGVmLmRlZklkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhZGRlZEV2ZW50SW5zdGFuY2UgPSBtdXRhdGVkUmVsZXZhbnRFdmVudHMuaW5zdGFuY2VzW2V2ZW50SW5zdGFuY2UuaW5zdGFuY2VJZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYWRkZWRFdmVudEFwaSA9IG5ldyBFdmVudEltcGwocmVjZWl2aW5nQ29udGV4dCwgYWRkZWRFdmVudERlZiwgYWRkZWRFdmVudEluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IG11dGF0ZWRSZWxldmFudEV2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGV2ZW50QWRkQXJnID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBhZGRlZEV2ZW50QXBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0ZWRFdmVudHM6IGJ1aWxkRXZlbnRBcGlzKG11dGF0ZWRSZWxldmFudEV2ZW50cywgcmVjZWl2aW5nQ29udGV4dCwgYWRkZWRFdmVudEluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogbXV0YXRlZFJlbGV2YW50RXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudEFkZCcsIGV2ZW50QWRkQXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldi5pc1RvdWNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTRUxFQ1RfRVZFTlQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudEluc3RhbmNlSWQ6IGV2ZW50SW5zdGFuY2UuaW5zdGFuY2VJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdkcm9wJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZERhdGVQb2ludEFwaVdpdGhDb250ZXh0KGZpbmFsSGl0LmRhdGVTcGFuLCByZWNlaXZpbmdDb250ZXh0KSksIHsgZHJhZ2dlZEVsOiBldi5zdWJqZWN0RWwsIGpzRXZlbnQ6IGV2Lm9yaWdFdmVudCwgdmlldzogZmluYWxIaXQuY29udGV4dC52aWV3QXBpIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudFJlY2VpdmUnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50QWRkQXJnKSwgeyBkcmFnZ2VkRWw6IGV2LnN1YmplY3RFbCwgdmlldzogZmluYWxIaXQuY29udGV4dC52aWV3QXBpIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdfbm9FdmVudERyb3AnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHsgY29tcG9uZW50IH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgbGV0IGRyYWdnaW5nID0gdGhpcy5kcmFnZ2luZyA9IG5ldyBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nKHNldHRpbmdzLmVsKTtcbiAgICAgICAgZHJhZ2dpbmcucG9pbnRlci5zZWxlY3RvciA9IEV2ZW50RHJhZ2dpbmcuU0VMRUNUT1I7XG4gICAgICAgIGRyYWdnaW5nLnRvdWNoU2Nyb2xsQWxsb3dlZCA9IGZhbHNlO1xuICAgICAgICBkcmFnZ2luZy5hdXRvU2Nyb2xsZXIuaXNFbmFibGVkID0gb3B0aW9ucy5kcmFnU2Nyb2xsO1xuICAgICAgICBsZXQgaGl0RHJhZ2dpbmcgPSB0aGlzLmhpdERyYWdnaW5nID0gbmV3IEhpdERyYWdnaW5nKHRoaXMuZHJhZ2dpbmcsIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSk7XG4gICAgICAgIGhpdERyYWdnaW5nLnVzZVN1YmplY3RDZW50ZXIgPSBzZXR0aW5ncy51c2VFdmVudENlbnRlcjtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLmhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ3N0YXJ0JywgdGhpcy5oYW5kbGVEcmFnU3RhcnQpO1xuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdoaXR1cGRhdGUnLCB0aGlzLmhhbmRsZUhpdFVwZGF0ZSk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJ1cCcsIHRoaXMuaGFuZGxlUG9pbnRlclVwKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ2VuZCcsIHRoaXMuaGFuZGxlRHJhZ0VuZCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpO1xuICAgIH1cbiAgICAvLyByZW5kZXIgYSBkcmFnIHN0YXRlIG9uIHRoZSBuZXh0IHJlY2VpdmluZ0NhbGVuZGFyXG4gICAgZGlzcGxheURyYWcobmV4dENvbnRleHQsIHN0YXRlKSB7XG4gICAgICAgIGxldCBpbml0aWFsQ29udGV4dCA9IHRoaXMuY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgIGxldCBwcmV2Q29udGV4dCA9IHRoaXMucmVjZWl2aW5nQ29udGV4dDtcbiAgICAgICAgLy8gZG9lcyB0aGUgcHJldmlvdXMgY2FsZW5kYXIgbmVlZCB0byBiZSBjbGVhcmVkP1xuICAgICAgICBpZiAocHJldkNvbnRleHQgJiYgcHJldkNvbnRleHQgIT09IG5leHRDb250ZXh0KSB7XG4gICAgICAgICAgICAvLyBkb2VzIHRoZSBpbml0aWFsIGNhbGVuZGFyIG5lZWQgdG8gYmUgY2xlYXJlZD9cbiAgICAgICAgICAgIC8vIGlmIHNvLCBkb24ndCBjbGVhciBhbGwgdGhlIHdheS4gd2Ugc3RpbGwgbmVlZCB0byB0byBoaWRlIHRoZSBhZmZlY3RlZEV2ZW50c1xuICAgICAgICAgICAgaWYgKHByZXZDb250ZXh0ID09PSBpbml0aWFsQ29udGV4dCkge1xuICAgICAgICAgICAgICAgIHByZXZDb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1NFVF9FVkVOVF9EUkFHJyxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiBzdGF0ZS5hZmZlY3RlZEV2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudHM6IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBjb21wbGV0ZWx5IGNsZWFyIHRoZSBvbGQgY2FsZW5kYXIgaWYgaXQgd2Fzbid0IHRoZSBpbml0aWFsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmV2Q29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFVF9FVkVOVF9EUkFHJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dENvbnRleHQpIHtcbiAgICAgICAgICAgIG5leHRDb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1NFVF9FVkVOVF9EUkFHJywgc3RhdGUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXJEcmFnKCkge1xuICAgICAgICBsZXQgaW5pdGlhbENhbGVuZGFyID0gdGhpcy5jb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgbGV0IHsgcmVjZWl2aW5nQ29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgaWYgKHJlY2VpdmluZ0NvbnRleHQpIHtcbiAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRVRfRVZFTlRfRFJBRycgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIGluaXRpYWwgY2FsZW5kYXIgbWlnaHQgaGF2ZSBhbiBkdW1teSBkcmFnIHN0YXRlIGZyb20gZGlzcGxheURyYWdcbiAgICAgICAgaWYgKGluaXRpYWxDYWxlbmRhciAhPT0gcmVjZWl2aW5nQ29udGV4dCkge1xuICAgICAgICAgICAgaW5pdGlhbENhbGVuZGFyLmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VUX0VWRU5UX0RSQUcnIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFudXAoKSB7XG4gICAgICAgIHRoaXMuc3ViamVjdFNlZyA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmV2ZW50UmFuZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLnJlbGV2YW50RXZlbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWNlaXZpbmdDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy52YWxpZE11dGF0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5tdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBudWxsO1xuICAgIH1cbn1cbi8vIFRPRE86IHRlc3QgdGhpcyBpbiBJRTExXG4vLyBRVUVTVElPTjogd2h5IGRvIHdlIG5lZWQgaXQgb24gdGhlIHJlc2l6YWJsZT8/P1xuRXZlbnREcmFnZ2luZy5TRUxFQ1RPUiA9ICcuZmMtZXZlbnQtZHJhZ2dhYmxlLCAuZmMtZXZlbnQtcmVzaXphYmxlJztcbmZ1bmN0aW9uIGNvbXB1dGVFdmVudE11dGF0aW9uKGhpdDAsIGhpdDEsIGV2ZW50SW5zdGFuY2VTdGFydCwgbWFzc2FnZXJzKSB7XG4gICAgbGV0IGRhdGVTcGFuMCA9IGhpdDAuZGF0ZVNwYW47XG4gICAgbGV0IGRhdGVTcGFuMSA9IGhpdDEuZGF0ZVNwYW47XG4gICAgbGV0IGRhdGUwID0gZGF0ZVNwYW4wLnJhbmdlLnN0YXJ0O1xuICAgIGxldCBkYXRlMSA9IGRhdGVTcGFuMS5yYW5nZS5zdGFydDtcbiAgICBsZXQgc3RhbmRhcmRQcm9wcyA9IHt9O1xuICAgIGlmIChkYXRlU3BhbjAuYWxsRGF5ICE9PSBkYXRlU3BhbjEuYWxsRGF5KSB7XG4gICAgICAgIHN0YW5kYXJkUHJvcHMuYWxsRGF5ID0gZGF0ZVNwYW4xLmFsbERheTtcbiAgICAgICAgc3RhbmRhcmRQcm9wcy5oYXNFbmQgPSBoaXQxLmNvbnRleHQub3B0aW9ucy5hbGxEYXlNYWludGFpbkR1cmF0aW9uO1xuICAgICAgICBpZiAoZGF0ZVNwYW4xLmFsbERheSkge1xuICAgICAgICAgICAgLy8gbWVhbnMgZGF0ZTEgaXMgYWxyZWFkeSBzdGFydC1vZi1kYXksXG4gICAgICAgICAgICAvLyBidXQgZGF0ZTAgbmVlZHMgdG8gYmUgY29udmVydGVkXG4gICAgICAgICAgICBkYXRlMCA9IHN0YXJ0T2ZEYXkoZXZlbnRJbnN0YW5jZVN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE1vdmluZyBmcm9tIGFsbERhdGUtPnRpbWVkXG4gICAgICAgICAgICAvLyBEb2Vzbid0IG1hdHRlciB3aGVyZSBvbiB0aGUgZXZlbnQgdGhlIGRyYWcgYmVnYW4sIG11dGF0ZSB0aGUgZXZlbnQncyBzdGFydC1kYXRlIHRvIGRhdGUxXG4gICAgICAgICAgICBkYXRlMCA9IGV2ZW50SW5zdGFuY2VTdGFydDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgZGVsdGEgPSBkaWZmRGF0ZXMoZGF0ZTAsIGRhdGUxLCBoaXQwLmNvbnRleHQuZGF0ZUVudiwgaGl0MC5jb21wb25lbnRJZCA9PT0gaGl0MS5jb21wb25lbnRJZCA/XG4gICAgICAgIGhpdDAubGFyZ2VVbml0IDpcbiAgICAgICAgbnVsbCk7XG4gICAgaWYgKGRlbHRhLm1pbGxpc2Vjb25kcykgeyAvLyBoYXMgaG91cnMvbWludXRlcy9zZWNvbmRzXG4gICAgICAgIHN0YW5kYXJkUHJvcHMuYWxsRGF5ID0gZmFsc2U7XG4gICAgfVxuICAgIGxldCBtdXRhdGlvbiA9IHtcbiAgICAgICAgZGF0ZXNEZWx0YTogZGVsdGEsXG4gICAgICAgIHN0YW5kYXJkUHJvcHMsXG4gICAgfTtcbiAgICBmb3IgKGxldCBtYXNzYWdlciBvZiBtYXNzYWdlcnMpIHtcbiAgICAgICAgbWFzc2FnZXIobXV0YXRpb24sIGhpdDAsIGhpdDEpO1xuICAgIH1cbiAgICByZXR1cm4gbXV0YXRpb247XG59XG5mdW5jdGlvbiBnZXRDb21wb25lbnRUb3VjaERlbGF5KGNvbXBvbmVudCkge1xuICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbXBvbmVudC5jb250ZXh0O1xuICAgIGxldCBkZWxheSA9IG9wdGlvbnMuZXZlbnRMb25nUHJlc3NEZWxheTtcbiAgICBpZiAoZGVsYXkgPT0gbnVsbCkge1xuICAgICAgICBkZWxheSA9IG9wdGlvbnMubG9uZ1ByZXNzRGVsYXk7XG4gICAgfVxuICAgIHJldHVybiBkZWxheTtcbn1cblxuY2xhc3MgRXZlbnRSZXNpemluZyBleHRlbmRzIEludGVyYWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgICAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgICAgIC8vIGludGVybmFsIHN0YXRlXG4gICAgICAgIHRoaXMuZHJhZ2dpbmdTZWdFbCA9IG51bGw7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmdTZWcgPSBudWxsOyAvLyBUT0RPOiByZW5hbWUgdG8gcmVzaXppbmdTZWc/IHN1YmplY3RTZWc/XG4gICAgICAgIHRoaXMuZXZlbnRSYW5nZSA9IG51bGw7XG4gICAgICAgIHRoaXMucmVsZXZhbnRFdmVudHMgPSBudWxsO1xuICAgICAgICB0aGlzLnZhbGlkTXV0YXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLm11dGF0ZWRSZWxldmFudEV2ZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlckRvd24gPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGxldCB7IGNvbXBvbmVudCB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCBzZWdFbCA9IHRoaXMucXVlcnlTZWdFbChldik7XG4gICAgICAgICAgICBsZXQgc2VnID0gZ2V0RWxTZWcoc2VnRWwpO1xuICAgICAgICAgICAgbGV0IGV2ZW50UmFuZ2UgPSB0aGlzLmV2ZW50UmFuZ2UgPSBzZWcuZXZlbnRSYW5nZTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcubWluRGlzdGFuY2UgPSBjb21wb25lbnQuY29udGV4dC5vcHRpb25zLmV2ZW50RHJhZ01pbkRpc3RhbmNlO1xuICAgICAgICAgICAgLy8gaWYgdG91Y2gsIG5lZWQgdG8gYmUgd29ya2luZyB3aXRoIGEgc2VsZWN0ZWQgZXZlbnRcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcuc2V0SWdub3JlTW92ZSghdGhpcy5jb21wb25lbnQuaXNWYWxpZFNlZ0Rvd25FbChldi5vcmlnRXZlbnQudGFyZ2V0KSB8fFxuICAgICAgICAgICAgICAgIChldi5pc1RvdWNoICYmIHRoaXMuY29tcG9uZW50LnByb3BzLmV2ZW50U2VsZWN0aW9uICE9PSBldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEcmFnU3RhcnQgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGxldCB7IGNvbnRleHQgfSA9IHRoaXMuY29tcG9uZW50O1xuICAgICAgICAgICAgbGV0IGV2ZW50UmFuZ2UgPSB0aGlzLmV2ZW50UmFuZ2U7XG4gICAgICAgICAgICB0aGlzLnJlbGV2YW50RXZlbnRzID0gZ2V0UmVsZXZhbnRFdmVudHMoY29udGV4dC5nZXRDdXJyZW50RGF0YSgpLmV2ZW50U3RvcmUsIHRoaXMuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkKTtcbiAgICAgICAgICAgIGxldCBzZWdFbCA9IHRoaXMucXVlcnlTZWdFbChldik7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nU2VnRWwgPSBzZWdFbDtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdTZWcgPSBnZXRFbFNlZyhzZWdFbCk7XG4gICAgICAgICAgICBjb250ZXh0LmNhbGVuZGFyQXBpLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRSZXNpemVTdGFydCcsIHtcbiAgICAgICAgICAgICAgICBlbDogc2VnRWwsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEltcGwoY29udGV4dCwgZXZlbnRSYW5nZS5kZWYsIGV2ZW50UmFuZ2UuaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2Lm9yaWdFdmVudCxcbiAgICAgICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVIaXRVcGRhdGUgPSAoaGl0LCBpc0ZpbmFsLCBldikgPT4ge1xuICAgICAgICAgICAgbGV0IHsgY29udGV4dCB9ID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICAgICAgICBsZXQgcmVsZXZhbnRFdmVudHMgPSB0aGlzLnJlbGV2YW50RXZlbnRzO1xuICAgICAgICAgICAgbGV0IGluaXRpYWxIaXQgPSB0aGlzLmhpdERyYWdnaW5nLmluaXRpYWxIaXQ7XG4gICAgICAgICAgICBsZXQgZXZlbnRJbnN0YW5jZSA9IHRoaXMuZXZlbnRSYW5nZS5pbnN0YW5jZTtcbiAgICAgICAgICAgIGxldCBtdXRhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICBsZXQgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBpc0ludmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogcmVsZXZhbnRFdmVudHMsXG4gICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXG4gICAgICAgICAgICAgICAgaXNFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaGl0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGRpc2FsbG93ZWQgPSBoaXQuY29tcG9uZW50SWQgPT09IGluaXRpYWxIaXQuY29tcG9uZW50SWRcbiAgICAgICAgICAgICAgICAgICAgJiYgdGhpcy5pc0hpdENvbWJvQWxsb3dlZFxuICAgICAgICAgICAgICAgICAgICAmJiAhdGhpcy5pc0hpdENvbWJvQWxsb3dlZChpbml0aWFsSGl0LCBoaXQpO1xuICAgICAgICAgICAgICAgIGlmICghZGlzYWxsb3dlZCkge1xuICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbiA9IGNvbXB1dGVNdXRhdGlvbihpbml0aWFsSGl0LCBoaXQsIGV2LnN1YmplY3RFbC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZjLWV2ZW50LXJlc2l6ZXItc3RhcnQnKSwgZXZlbnRJbnN0YW5jZS5yYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG11dGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZShyZWxldmFudEV2ZW50cywgY29udGV4dC5nZXRDdXJyZW50RGF0YSgpLmV2ZW50VWlCYXNlcywgbXV0YXRpb24sIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMgPSBtdXRhdGVkUmVsZXZhbnRFdmVudHM7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0ludGVyYWN0aW9uVmFsaWQoaW50ZXJhY3Rpb24sIGhpdC5kYXRlUHJvZmlsZSwgY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNJbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobXV0YXRlZFJlbGV2YW50RXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTRVRfRVZFTlRfUkVTSVpFJyxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IGludGVyYWN0aW9uLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFVF9FVkVOVF9SRVNJWkUnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0ludmFsaWQpIHtcbiAgICAgICAgICAgICAgICBlbmFibGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpc2FibGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNGaW5hbCkge1xuICAgICAgICAgICAgICAgIGlmIChtdXRhdGlvbiAmJiBpc0hpdHNFcXVhbChpbml0aWFsSGl0LCBoaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG11dGF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy52YWxpZE11dGF0aW9uID0gbXV0YXRpb247XG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBtdXRhdGVkUmVsZXZhbnRFdmVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ0VuZCA9IChldikgPT4ge1xuICAgICAgICAgICAgbGV0IHsgY29udGV4dCB9ID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICAgICAgICBsZXQgZXZlbnREZWYgPSB0aGlzLmV2ZW50UmFuZ2UuZGVmO1xuICAgICAgICAgICAgbGV0IGV2ZW50SW5zdGFuY2UgPSB0aGlzLmV2ZW50UmFuZ2UuaW5zdGFuY2U7XG4gICAgICAgICAgICBsZXQgZXZlbnRBcGkgPSBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIGV2ZW50RGVmLCBldmVudEluc3RhbmNlKTtcbiAgICAgICAgICAgIGxldCByZWxldmFudEV2ZW50cyA9IHRoaXMucmVsZXZhbnRFdmVudHM7XG4gICAgICAgICAgICBsZXQgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gdGhpcy5tdXRhdGVkUmVsZXZhbnRFdmVudHM7XG4gICAgICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRSZXNpemVTdG9wJywge1xuICAgICAgICAgICAgICAgIGVsOiB0aGlzLmRyYWdnaW5nU2VnRWwsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50QXBpLFxuICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2Lm9yaWdFdmVudCxcbiAgICAgICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbGlkTXV0YXRpb24pIHtcbiAgICAgICAgICAgICAgICBsZXQgdXBkYXRlZEV2ZW50QXBpID0gbmV3IEV2ZW50SW1wbChjb250ZXh0LCBtdXRhdGVkUmVsZXZhbnRFdmVudHMuZGVmc1tldmVudERlZi5kZWZJZF0sIGV2ZW50SW5zdGFuY2UgPyBtdXRhdGVkUmVsZXZhbnRFdmVudHMuaW5zdGFuY2VzW2V2ZW50SW5zdGFuY2UuaW5zdGFuY2VJZF0gOiBudWxsKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IG11dGF0ZWRSZWxldmFudEV2ZW50cyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsZXQgZXZlbnRDaGFuZ2VBcmcgPSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZEV2ZW50OiBldmVudEFwaSxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IHVwZGF0ZWRFdmVudEFwaSxcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogYnVpbGRFdmVudEFwaXMobXV0YXRlZFJlbGV2YW50RXZlbnRzLCBjb250ZXh0LCBldmVudEluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogcmVsZXZhbnRFdmVudHMsIC8vIHRoZSBwcmUtY2hhbmdlIGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRSZXNpemUnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50Q2hhbmdlQXJnKSwgeyBlbDogdGhpcy5kcmFnZ2luZ1NlZ0VsLCBzdGFydERlbHRhOiB0aGlzLnZhbGlkTXV0YXRpb24uc3RhcnREZWx0YSB8fCBjcmVhdGVEdXJhdGlvbigwKSwgZW5kRGVsdGE6IHRoaXMudmFsaWRNdXRhdGlvbi5lbmREZWx0YSB8fCBjcmVhdGVEdXJhdGlvbigwKSwganNFdmVudDogZXYub3JpZ0V2ZW50LCB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfSkpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudENoYW5nZScsIGV2ZW50Q2hhbmdlQXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdfbm9FdmVudFJlc2l6ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVzZXQgYWxsIGludGVybmFsIHN0YXRlXG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nU2VnID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucmVsZXZhbnRFdmVudHMgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy52YWxpZE11dGF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIC8vIG9rYXkgdG8ga2VlcCBldmVudEluc3RhbmNlIGFyb3VuZC4gdXNlZnVsIHRvIHNldCBpdCBpbiBoYW5kbGVQb2ludGVyRG93blxuICAgICAgICB9O1xuICAgICAgICBsZXQgeyBjb21wb25lbnQgfSA9IHNldHRpbmdzO1xuICAgICAgICBsZXQgZHJhZ2dpbmcgPSB0aGlzLmRyYWdnaW5nID0gbmV3IEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcoc2V0dGluZ3MuZWwpO1xuICAgICAgICBkcmFnZ2luZy5wb2ludGVyLnNlbGVjdG9yID0gJy5mYy1ldmVudC1yZXNpemVyJztcbiAgICAgICAgZHJhZ2dpbmcudG91Y2hTY3JvbGxBbGxvd2VkID0gZmFsc2U7XG4gICAgICAgIGRyYWdnaW5nLmF1dG9TY3JvbGxlci5pc0VuYWJsZWQgPSBjb21wb25lbnQuY29udGV4dC5vcHRpb25zLmRyYWdTY3JvbGw7XG4gICAgICAgIGxldCBoaXREcmFnZ2luZyA9IHRoaXMuaGl0RHJhZ2dpbmcgPSBuZXcgSGl0RHJhZ2dpbmcodGhpcy5kcmFnZ2luZywgaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUoc2V0dGluZ3MpKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLmhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ3N0YXJ0JywgdGhpcy5oYW5kbGVEcmFnU3RhcnQpO1xuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdoaXR1cGRhdGUnLCB0aGlzLmhhbmRsZUhpdFVwZGF0ZSk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdlbmQnLCB0aGlzLmhhbmRsZURyYWdFbmQpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgcXVlcnlTZWdFbChldikge1xuICAgICAgICByZXR1cm4gZWxlbWVudENsb3Nlc3QoZXYuc3ViamVjdEVsLCAnLmZjLWV2ZW50Jyk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZU11dGF0aW9uKGhpdDAsIGhpdDEsIGlzRnJvbVN0YXJ0LCBpbnN0YW5jZVJhbmdlKSB7XG4gICAgbGV0IGRhdGVFbnYgPSBoaXQwLmNvbnRleHQuZGF0ZUVudjtcbiAgICBsZXQgZGF0ZTAgPSBoaXQwLmRhdGVTcGFuLnJhbmdlLnN0YXJ0O1xuICAgIGxldCBkYXRlMSA9IGhpdDEuZGF0ZVNwYW4ucmFuZ2Uuc3RhcnQ7XG4gICAgbGV0IGRlbHRhID0gZGlmZkRhdGVzKGRhdGUwLCBkYXRlMSwgZGF0ZUVudiwgaGl0MC5sYXJnZVVuaXQpO1xuICAgIGlmIChpc0Zyb21TdGFydCkge1xuICAgICAgICBpZiAoZGF0ZUVudi5hZGQoaW5zdGFuY2VSYW5nZS5zdGFydCwgZGVsdGEpIDwgaW5zdGFuY2VSYW5nZS5lbmQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0RGVsdGE6IGRlbHRhIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0ZUVudi5hZGQoaW5zdGFuY2VSYW5nZS5lbmQsIGRlbHRhKSA+IGluc3RhbmNlUmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIHsgZW5kRGVsdGE6IGRlbHRhIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5jbGFzcyBVbnNlbGVjdEF1dG8ge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5pc1JlY2VudFBvaW50ZXJEYXRlU2VsZWN0ID0gZmFsc2U7IC8vIHdpc2ggd2UgY291bGQgdXNlIGEgc2VsZWN0b3IgdG8gZGV0ZWN0IGRhdGUgc2VsZWN0aW9uLCBidXQgdXNlcyBoaXQgc3lzdGVtXG4gICAgICAgIHRoaXMubWF0Y2hlc0NhbmNlbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1hdGNoZXNFdmVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uU2VsZWN0ID0gKHNlbGVjdEluZm8pID0+IHtcbiAgICAgICAgICAgIGlmIChzZWxlY3RJbmZvLmpzRXZlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzUmVjZW50UG9pbnRlckRhdGVTZWxlY3QgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uRG9jdW1lbnRQb2ludGVyRG93biA9IChwZXYpID0+IHtcbiAgICAgICAgICAgIGxldCB1bnNlbGVjdENhbmNlbCA9IHRoaXMuY29udGV4dC5vcHRpb25zLnVuc2VsZWN0Q2FuY2VsO1xuICAgICAgICAgICAgbGV0IGRvd25FbCA9IGdldEV2ZW50VGFyZ2V0VmlhUm9vdChwZXYub3JpZ0V2ZW50KTtcbiAgICAgICAgICAgIHRoaXMubWF0Y2hlc0NhbmNlbCA9ICEhZWxlbWVudENsb3Nlc3QoZG93bkVsLCB1bnNlbGVjdENhbmNlbCk7XG4gICAgICAgICAgICB0aGlzLm1hdGNoZXNFdmVudCA9ICEhZWxlbWVudENsb3Nlc3QoZG93bkVsLCBFdmVudERyYWdnaW5nLlNFTEVDVE9SKTsgLy8gaW50ZXJhY3Rpb24gc3RhcnRlZCBvbiBhbiBldmVudD9cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkRvY3VtZW50UG9pbnRlclVwID0gKHBldikgPT4ge1xuICAgICAgICAgICAgbGV0IHsgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCB7IGRvY3VtZW50UG9pbnRlciB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCBjYWxlbmRhclN0YXRlID0gY29udGV4dC5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICAgICAgLy8gdG91Y2gtc2Nyb2xsaW5nIHNob3VsZCBuZXZlciB1bmZvY3VzIGFueSB0eXBlIG9mIHNlbGVjdGlvblxuICAgICAgICAgICAgaWYgKCFkb2N1bWVudFBvaW50ZXIud2FzVG91Y2hTY3JvbGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsZW5kYXJTdGF0ZS5kYXRlU2VsZWN0aW9uICYmIC8vIGFuIGV4aXN0aW5nIGRhdGUgc2VsZWN0aW9uP1xuICAgICAgICAgICAgICAgICAgICAhdGhpcy5pc1JlY2VudFBvaW50ZXJEYXRlU2VsZWN0IC8vIGEgbmV3IHBvaW50ZXItaW5pdGlhdGVkIGRhdGUgc2VsZWN0aW9uIHNpbmNlIGxhc3Qgb25Eb2N1bWVudFBvaW50ZXJVcD9cbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVuc2VsZWN0QXV0byA9IGNvbnRleHQub3B0aW9ucy51bnNlbGVjdEF1dG87XG4gICAgICAgICAgICAgICAgICAgIGlmICh1bnNlbGVjdEF1dG8gJiYgKCF1bnNlbGVjdEF1dG8gfHwgIXRoaXMubWF0Y2hlc0NhbmNlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY2FsZW5kYXJBcGkudW5zZWxlY3QocGV2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2FsZW5kYXJTdGF0ZS5ldmVudFNlbGVjdGlvbiAmJiAvLyBhbiBleGlzdGluZyBldmVudCBzZWxlY3RlZD9cbiAgICAgICAgICAgICAgICAgICAgIXRoaXMubWF0Y2hlc0V2ZW50IC8vIGludGVyYWN0aW9uIERJRE4nVCBzdGFydCBvbiBhbiBldmVudFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VMRUNUX0VWRU5UJyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzUmVjZW50UG9pbnRlckRhdGVTZWxlY3QgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGRvY3VtZW50UG9pbnRlciA9IHRoaXMuZG9jdW1lbnRQb2ludGVyID0gbmV3IFBvaW50ZXJEcmFnZ2luZyhkb2N1bWVudCk7XG4gICAgICAgIGRvY3VtZW50UG9pbnRlci5zaG91bGRJZ25vcmVNb3ZlID0gdHJ1ZTtcbiAgICAgICAgZG9jdW1lbnRQb2ludGVyLnNob3VsZFdhdGNoU2Nyb2xsID0gZmFsc2U7XG4gICAgICAgIGRvY3VtZW50UG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVyZG93bicsIHRoaXMub25Eb2N1bWVudFBvaW50ZXJEb3duKTtcbiAgICAgICAgZG9jdW1lbnRQb2ludGVyLmVtaXR0ZXIub24oJ3BvaW50ZXJ1cCcsIHRoaXMub25Eb2N1bWVudFBvaW50ZXJVcCk7XG4gICAgICAgIC8qXG4gICAgICAgIFRPRE86IGJldHRlciB3YXkgdG8ga25vdyBhYm91dCB3aGV0aGVyIHRoZXJlIHdhcyBhIHNlbGVjdGlvbiB3aXRoIHRoZSBwb2ludGVyXG4gICAgICAgICovXG4gICAgICAgIGNvbnRleHQuZW1pdHRlci5vbignc2VsZWN0JywgdGhpcy5vblNlbGVjdCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5lbWl0dGVyLm9mZignc2VsZWN0JywgdGhpcy5vblNlbGVjdCk7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRQb2ludGVyLmRlc3Ryb3koKTtcbiAgICB9XG59XG5cbmNvbnN0IE9QVElPTl9SRUZJTkVSUyA9IHtcbiAgICBmaXhlZE1pcnJvclBhcmVudDogaWRlbnRpdHksXG59O1xuY29uc3QgTElTVEVORVJfUkVGSU5FUlMgPSB7XG4gICAgZGF0ZUNsaWNrOiBpZGVudGl0eSxcbiAgICBldmVudERyYWdTdGFydDogaWRlbnRpdHksXG4gICAgZXZlbnREcmFnU3RvcDogaWRlbnRpdHksXG4gICAgZXZlbnREcm9wOiBpZGVudGl0eSxcbiAgICBldmVudFJlc2l6ZVN0YXJ0OiBpZGVudGl0eSxcbiAgICBldmVudFJlc2l6ZVN0b3A6IGlkZW50aXR5LFxuICAgIGV2ZW50UmVzaXplOiBpZGVudGl0eSxcbiAgICBkcm9wOiBpZGVudGl0eSxcbiAgICBldmVudFJlY2VpdmU6IGlkZW50aXR5LFxuICAgIGV2ZW50TGVhdmU6IGlkZW50aXR5LFxufTtcblxuLypcbkdpdmVuIGFuIGFscmVhZHkgaW5zdGFudGlhdGVkIGRyYWdnYWJsZSBvYmplY3QgZm9yIG9uZS1vci1tb3JlIGVsZW1lbnRzLFxuSW50ZXJwcmV0cyBhbnkgZHJhZ2dpbmcgYXMgYW4gYXR0ZW1wdCB0byBkcmFnIGFuIGV2ZW50cyB0aGF0IGxpdmVzIG91dHNpZGVcbm9mIGEgY2FsZW5kYXIgb250byBhIGNhbGVuZGFyLlxuKi9cbmNsYXNzIEV4dGVybmFsRWxlbWVudERyYWdnaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihkcmFnZ2luZywgc3VwcGxpZWREcmFnTWV0YSkge1xuICAgICAgICB0aGlzLnJlY2VpdmluZ0NvbnRleHQgPSBudWxsO1xuICAgICAgICB0aGlzLmRyb3BwYWJsZUV2ZW50ID0gbnVsbDsgLy8gd2lsbCBleGlzdCBmb3IgYWxsIGRyYWdzLCBldmVuIGlmIGNyZWF0ZTpmYWxzZVxuICAgICAgICB0aGlzLnN1cHBsaWVkRHJhZ01ldGEgPSBudWxsO1xuICAgICAgICB0aGlzLmRyYWdNZXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYW5kbGVEcmFnU3RhcnQgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ01ldGEgPSB0aGlzLmJ1aWxkRHJhZ01ldGEoZXYuc3ViamVjdEVsKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVIaXRVcGRhdGUgPSAoaGl0LCBpc0ZpbmFsLCBldikgPT4ge1xuICAgICAgICAgICAgbGV0IHsgZHJhZ2dpbmcgfSA9IHRoaXMuaGl0RHJhZ2dpbmc7XG4gICAgICAgICAgICBsZXQgcmVjZWl2aW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICBsZXQgZHJvcHBhYmxlRXZlbnQgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGlzSW52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGludGVyYWN0aW9uID0ge1xuICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcbiAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRzOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcbiAgICAgICAgICAgICAgICBpc0V2ZW50OiB0aGlzLmRyYWdNZXRhLmNyZWF0ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaGl0KSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dCA9IGhpdC5jb250ZXh0O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbkRyb3BFbE9uQ2FsZW5kYXIoZXYuc3ViamVjdEVsLCByZWNlaXZpbmdDb250ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBkcm9wcGFibGVFdmVudCA9IGNvbXB1dGVFdmVudEZvckRhdGVTcGFuKGhpdC5kYXRlU3BhbiwgdGhpcy5kcmFnTWV0YSwgcmVjZWl2aW5nQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMgPSBldmVudFR1cGxlVG9TdG9yZShkcm9wcGFibGVFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlzSW52YWxpZCA9ICFpc0ludGVyYWN0aW9uVmFsaWQoaW50ZXJhY3Rpb24sIGhpdC5kYXRlUHJvZmlsZSwgcmVjZWl2aW5nQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0ludmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyb3BwYWJsZUV2ZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGlzcGxheURyYWcocmVjZWl2aW5nQ29udGV4dCwgaW50ZXJhY3Rpb24pO1xuICAgICAgICAgICAgLy8gc2hvdyBtaXJyb3IgaWYgbm8gYWxyZWFkeS1yZW5kZXJlZCBtaXJyb3IgZWxlbWVudCBPUiBpZiB3ZSBhcmUgc2h1dHRpbmcgZG93biB0aGUgbWlycm9yICg/KVxuICAgICAgICAgICAgLy8gVE9ETzogd2lzaCB3ZSBjb3VsZCBzb21laG93IHdhaXQgZm9yIGRpc3BhdGNoIHRvIGd1YXJhbnRlZSByZW5kZXJcbiAgICAgICAgICAgIGRyYWdnaW5nLnNldE1pcnJvcklzVmlzaWJsZShpc0ZpbmFsIHx8ICFkcm9wcGFibGVFdmVudCB8fCAhZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmZjLWV2ZW50LW1pcnJvcicpKTtcbiAgICAgICAgICAgIGlmICghaXNJbnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgZW5hYmxlQ3Vyc29yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXNhYmxlQ3Vyc29yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzRmluYWwpIHtcbiAgICAgICAgICAgICAgICBkcmFnZ2luZy5zZXRNaXJyb3JOZWVkc1JldmVydCghZHJvcHBhYmxlRXZlbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVjZWl2aW5nQ29udGV4dCA9IHJlY2VpdmluZ0NvbnRleHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5kcm9wcGFibGVFdmVudCA9IGRyb3BwYWJsZUV2ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZURyYWdFbmQgPSAocGV2KSA9PiB7XG4gICAgICAgICAgICBsZXQgeyByZWNlaXZpbmdDb250ZXh0LCBkcm9wcGFibGVFdmVudCB9ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuY2xlYXJEcmFnKCk7XG4gICAgICAgICAgICBpZiAocmVjZWl2aW5nQ29udGV4dCAmJiBkcm9wcGFibGVFdmVudCkge1xuICAgICAgICAgICAgICAgIGxldCBmaW5hbEhpdCA9IHRoaXMuaGl0RHJhZ2dpbmcuZmluYWxIaXQ7XG4gICAgICAgICAgICAgICAgbGV0IGZpbmFsVmlldyA9IGZpbmFsSGl0LmNvbnRleHQudmlld0FwaTtcbiAgICAgICAgICAgICAgICBsZXQgZHJhZ01ldGEgPSB0aGlzLmRyYWdNZXRhO1xuICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdkcm9wJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZERhdGVQb2ludEFwaVdpdGhDb250ZXh0KGZpbmFsSGl0LmRhdGVTcGFuLCByZWNlaXZpbmdDb250ZXh0KSksIHsgZHJhZ2dlZEVsOiBwZXYuc3ViamVjdEVsLCBqc0V2ZW50OiBwZXYub3JpZ0V2ZW50LCB2aWV3OiBmaW5hbFZpZXcgfSkpO1xuICAgICAgICAgICAgICAgIGlmIChkcmFnTWV0YS5jcmVhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFkZGluZ0V2ZW50cyA9IGV2ZW50VHVwbGVUb1N0b3JlKGRyb3BwYWJsZUV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IGFkZGluZ0V2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwZXYuaXNUb3VjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1NFTEVDVF9FVkVOVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRJbnN0YW5jZUlkOiBkcm9wcGFibGVFdmVudC5pbnN0YW5jZS5pbnN0YW5jZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gc2lnbmFsIHRoYXQgYW4gZXh0ZXJuYWwgZXZlbnQgbGFuZGVkXG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudFJlY2VpdmUnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50SW1wbChyZWNlaXZpbmdDb250ZXh0LCBkcm9wcGFibGVFdmVudC5kZWYsIGRyb3BwYWJsZUV2ZW50Lmluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0ZWRFdmVudHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IGFkZGluZ0V2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnZ2VkRWw6IHBldi5zdWJqZWN0RWwsXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3OiBmaW5hbFZpZXcsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVjZWl2aW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmRyb3BwYWJsZUV2ZW50ID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGhpdERyYWdnaW5nID0gdGhpcy5oaXREcmFnZ2luZyA9IG5ldyBIaXREcmFnZ2luZyhkcmFnZ2luZywgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcucmVxdWlyZUluaXRpYWwgPSBmYWxzZTsgLy8gd2lsbCBzdGFydCBvdXRzaWRlIG9mIGEgY29tcG9uZW50XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdzdGFydCcsIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0KTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignaGl0dXBkYXRlJywgdGhpcy5oYW5kbGVIaXRVcGRhdGUpO1xuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnZW5kJywgdGhpcy5oYW5kbGVEcmFnRW5kKTtcbiAgICAgICAgdGhpcy5zdXBwbGllZERyYWdNZXRhID0gc3VwcGxpZWREcmFnTWV0YTtcbiAgICB9XG4gICAgYnVpbGREcmFnTWV0YShzdWJqZWN0RWwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnN1cHBsaWVkRHJhZ01ldGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VEcmFnTWV0YSh0aGlzLnN1cHBsaWVkRHJhZ01ldGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5zdXBwbGllZERyYWdNZXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VEcmFnTWV0YSh0aGlzLnN1cHBsaWVkRHJhZ01ldGEoc3ViamVjdEVsKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldERyYWdNZXRhRnJvbUVsKHN1YmplY3RFbCk7XG4gICAgfVxuICAgIGRpc3BsYXlEcmFnKG5leHRDb250ZXh0LCBzdGF0ZSkge1xuICAgICAgICBsZXQgcHJldkNvbnRleHQgPSB0aGlzLnJlY2VpdmluZ0NvbnRleHQ7XG4gICAgICAgIGlmIChwcmV2Q29udGV4dCAmJiBwcmV2Q29udGV4dCAhPT0gbmV4dENvbnRleHQpIHtcbiAgICAgICAgICAgIHByZXZDb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VUX0VWRU5UX0RSQUcnIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0Q29udGV4dCkge1xuICAgICAgICAgICAgbmV4dENvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnU0VUX0VWRU5UX0RSQUcnLCBzdGF0ZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhckRyYWcoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlY2VpdmluZ0NvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMucmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFVF9FVkVOVF9EUkFHJyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYW5Ecm9wRWxPbkNhbGVuZGFyKGVsLCByZWNlaXZpbmdDb250ZXh0KSB7XG4gICAgICAgIGxldCBkcm9wQWNjZXB0ID0gcmVjZWl2aW5nQ29udGV4dC5vcHRpb25zLmRyb3BBY2NlcHQ7XG4gICAgICAgIGlmICh0eXBlb2YgZHJvcEFjY2VwdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGRyb3BBY2NlcHQuY2FsbChyZWNlaXZpbmdDb250ZXh0LmNhbGVuZGFyQXBpLCBlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkcm9wQWNjZXB0ID09PSAnc3RyaW5nJyAmJiBkcm9wQWNjZXB0KSB7XG4gICAgICAgICAgICByZXR1cm4gQm9vbGVhbihlbGVtZW50TWF0Y2hlcyhlbCwgZHJvcEFjY2VwdCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbi8vIFV0aWxzIGZvciBjb21wdXRpbmcgZXZlbnQgc3RvcmUgZnJvbSB0aGUgRHJhZ01ldGFcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGNvbXB1dGVFdmVudEZvckRhdGVTcGFuKGRhdGVTcGFuLCBkcmFnTWV0YSwgY29udGV4dCkge1xuICAgIGxldCBkZWZQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIGRyYWdNZXRhLmxlZnRvdmVyUHJvcHMpO1xuICAgIGZvciAobGV0IHRyYW5zZm9ybSBvZiBjb250ZXh0LnBsdWdpbkhvb2tzLmV4dGVybmFsRGVmVHJhbnNmb3Jtcykge1xuICAgICAgICBPYmplY3QuYXNzaWduKGRlZlByb3BzLCB0cmFuc2Zvcm0oZGF0ZVNwYW4sIGRyYWdNZXRhKSk7XG4gICAgfVxuICAgIGxldCB7IHJlZmluZWQsIGV4dHJhIH0gPSByZWZpbmVFdmVudERlZihkZWZQcm9wcywgY29udGV4dCk7XG4gICAgbGV0IGRlZiA9IHBhcnNlRXZlbnREZWYocmVmaW5lZCwgZXh0cmEsIGRyYWdNZXRhLnNvdXJjZUlkLCBkYXRlU3Bhbi5hbGxEYXksIGNvbnRleHQub3B0aW9ucy5mb3JjZUV2ZW50RHVyYXRpb24gfHwgQm9vbGVhbihkcmFnTWV0YS5kdXJhdGlvbiksIC8vIGhhc0VuZFxuICAgIGNvbnRleHQpO1xuICAgIGxldCBzdGFydCA9IGRhdGVTcGFuLnJhbmdlLnN0YXJ0O1xuICAgIC8vIG9ubHkgcmVseSBvbiB0aW1lIGluZm8gaWYgZHJvcCB6b25lIGlzIGFsbC1kYXksXG4gICAgLy8gb3RoZXJ3aXNlLCB3ZSBhbHJlYWR5IGtub3cgdGhlIHRpbWVcbiAgICBpZiAoZGF0ZVNwYW4uYWxsRGF5ICYmIGRyYWdNZXRhLnN0YXJ0VGltZSkge1xuICAgICAgICBzdGFydCA9IGNvbnRleHQuZGF0ZUVudi5hZGQoc3RhcnQsIGRyYWdNZXRhLnN0YXJ0VGltZSk7XG4gICAgfVxuICAgIGxldCBlbmQgPSBkcmFnTWV0YS5kdXJhdGlvbiA/XG4gICAgICAgIGNvbnRleHQuZGF0ZUVudi5hZGQoc3RhcnQsIGRyYWdNZXRhLmR1cmF0aW9uKSA6XG4gICAgICAgIGdldERlZmF1bHRFdmVudEVuZChkYXRlU3Bhbi5hbGxEYXksIHN0YXJ0LCBjb250ZXh0KTtcbiAgICBsZXQgaW5zdGFuY2UgPSBjcmVhdGVFdmVudEluc3RhbmNlKGRlZi5kZWZJZCwgeyBzdGFydCwgZW5kIH0pO1xuICAgIHJldHVybiB7IGRlZiwgaW5zdGFuY2UgfTtcbn1cbi8vIFV0aWxzIGZvciBleHRyYWN0aW5nIGRhdGEgZnJvbSBlbGVtZW50XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBnZXREcmFnTWV0YUZyb21FbChlbCkge1xuICAgIGxldCBzdHIgPSBnZXRFbWJlZGRlZEVsRGF0YShlbCwgJ2V2ZW50Jyk7XG4gICAgbGV0IG9iaiA9IHN0ciA/XG4gICAgICAgIEpTT04ucGFyc2Uoc3RyKSA6XG4gICAgICAgIHsgY3JlYXRlOiBmYWxzZSB9OyAvLyBpZiBubyBlbWJlZGRlZCBkYXRhLCBhc3N1bWUgbm8gZXZlbnQgY3JlYXRpb25cbiAgICByZXR1cm4gcGFyc2VEcmFnTWV0YShvYmopO1xufVxuY29uZmlnLmRhdGFBdHRyUHJlZml4ID0gJyc7XG5mdW5jdGlvbiBnZXRFbWJlZGRlZEVsRGF0YShlbCwgbmFtZSkge1xuICAgIGxldCBwcmVmaXggPSBjb25maWcuZGF0YUF0dHJQcmVmaXg7XG4gICAgbGV0IHByZWZpeGVkTmFtZSA9IChwcmVmaXggPyBwcmVmaXggKyAnLScgOiAnJykgKyBuYW1lO1xuICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtJyArIHByZWZpeGVkTmFtZSkgfHwgJyc7XG59XG5cbi8qXG5NYWtlcyBhbiBlbGVtZW50ICh0aGF0IGlzICpleHRlcm5hbCogdG8gYW55IGNhbGVuZGFyKSBkcmFnZ2FibGUuXG5DYW4gcGFzcyBpbiBkYXRhIHRoYXQgZGV0ZXJtaW5lcyBob3cgYW4gZXZlbnQgd2lsbCBiZSBjcmVhdGVkIHdoZW4gZHJvcHBlZCBvbnRvIGEgY2FsZW5kYXIuXG5MZXZlcmFnZXMgRnVsbENhbGVuZGFyJ3MgaW50ZXJuYWwgZHJhZy1uLWRyb3AgZnVuY3Rpb25hbGl0eSBXSVRIT1VUIGEgdGhpcmQtcGFydHkgZHJhZyBzeXN0ZW0uXG4qL1xuY2xhc3MgRXh0ZXJuYWxEcmFnZ2FibGUge1xuICAgIGNvbnN0cnVjdG9yKGVsLCBzZXR0aW5ncyA9IHt9KSB7XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlckRvd24gPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGxldCB7IGRyYWdnaW5nIH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IHsgbWluRGlzdGFuY2UsIGxvbmdQcmVzc0RlbGF5IH0gPSB0aGlzLnNldHRpbmdzO1xuICAgICAgICAgICAgZHJhZ2dpbmcubWluRGlzdGFuY2UgPVxuICAgICAgICAgICAgICAgIG1pbkRpc3RhbmNlICE9IG51bGwgP1xuICAgICAgICAgICAgICAgICAgICBtaW5EaXN0YW5jZSA6XG4gICAgICAgICAgICAgICAgICAgIChldi5pc1RvdWNoID8gMCA6IEJBU0VfT1BUSU9OX0RFRkFVTFRTLmV2ZW50RHJhZ01pbkRpc3RhbmNlKTtcbiAgICAgICAgICAgIGRyYWdnaW5nLmRlbGF5ID1cbiAgICAgICAgICAgICAgICBldi5pc1RvdWNoID8gLy8gVE9ETzogZXZlbnR1YWxseSByZWFkIGV2ZW50TG9uZ1ByZXNzRGVsYXkgaW5zdGVhZCB2dnZcbiAgICAgICAgICAgICAgICAgICAgKGxvbmdQcmVzc0RlbGF5ICE9IG51bGwgPyBsb25nUHJlc3NEZWxheSA6IEJBU0VfT1BUSU9OX0RFRkFVTFRTLmxvbmdQcmVzc0RlbGF5KSA6XG4gICAgICAgICAgICAgICAgICAgIDA7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0ID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXYuaXNUb3VjaCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVsYXkgJiZcbiAgICAgICAgICAgICAgICBldi5zdWJqZWN0RWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdmYy1ldmVudCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZy5taXJyb3IuZ2V0TWlycm9yRWwoKS5jbGFzc0xpc3QuYWRkKCdmYy1ldmVudC1zZWxlY3RlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgICAgIGxldCBkcmFnZ2luZyA9IHRoaXMuZHJhZ2dpbmcgPSBuZXcgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyhlbCk7XG4gICAgICAgIGRyYWdnaW5nLnRvdWNoU2Nyb2xsQWxsb3dlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoc2V0dGluZ3MuaXRlbVNlbGVjdG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRyYWdnaW5nLnBvaW50ZXIuc2VsZWN0b3IgPSBzZXR0aW5ncy5pdGVtU2VsZWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldHRpbmdzLmFwcGVuZFRvICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRyYWdnaW5nLm1pcnJvci5wYXJlbnROb2RlID0gc2V0dGluZ3MuYXBwZW5kVG87IC8vIFRPRE86IHdyaXRlIHRlc3RzXG4gICAgICAgIH1cbiAgICAgICAgZHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLmhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgICAgZHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ3N0YXJ0JywgdGhpcy5oYW5kbGVEcmFnU3RhcnQpO1xuICAgICAgICBuZXcgRXh0ZXJuYWxFbGVtZW50RHJhZ2dpbmcoZHJhZ2dpbmcsIHNldHRpbmdzLmV2ZW50RGF0YSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpO1xuICAgIH1cbn1cblxuLypcbkRldGVjdHMgd2hlbiBhICpUSElSRC1QQVJUWSogZHJhZy1uLWRyb3Agc3lzdGVtIGludGVyYWN0cyB3aXRoIGVsZW1lbnRzLlxuVGhlIHRoaXJkLXBhcnR5IHN5c3RlbSBpcyByZXNwb25zaWJsZSBmb3IgZHJhd2luZyB0aGUgdmlzdWFscyBlZmZlY3RzIG9mIHRoZSBkcmFnLlxuVGhpcyBjbGFzcyBzaW1wbHkgbW9uaXRvcnMgZm9yIHBvaW50ZXIgbW92ZW1lbnRzIGFuZCBmaXJlcyBldmVudHMuXG5JdCBhbHNvIGhhcyB0aGUgYWJpbGl0eSB0byBoaWRlIHRoZSBtb3ZpbmcgZWxlbWVudCAodGhlIFwibWlycm9yXCIpIGR1cmluZyB0aGUgZHJhZy5cbiovXG5jbGFzcyBJbmZlcnJlZEVsZW1lbnREcmFnZ2luZyBleHRlbmRzIEVsZW1lbnREcmFnZ2luZyB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyRWwpIHtcbiAgICAgICAgc3VwZXIoY29udGFpbmVyRWwpO1xuICAgICAgICB0aGlzLnNob3VsZElnbm9yZU1vdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5taXJyb3JTZWxlY3RvciA9ICcnO1xuICAgICAgICB0aGlzLmN1cnJlbnRNaXJyb3JFbCA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlckRvd24gPSAoZXYpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVyZG93bicsIGV2KTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3ZlKSB7XG4gICAgICAgICAgICAgICAgLy8gZmlyZSBkcmFnc3RhcnQgcmlnaHQgYXdheS4gZG9lcyBub3Qgc3VwcG9ydCBkZWxheSBvciBtaW4tZGlzdGFuY2VcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignZHJhZ3N0YXJ0JywgZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJNb3ZlID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2hvdWxkSWdub3JlTW92ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnbW92ZScsIGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyVXAgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVydXAnLCBldik7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2hvdWxkSWdub3JlTW92ZSkge1xuICAgICAgICAgICAgICAgIC8vIGZpcmUgZHJhZ2VuZCByaWdodCBhd2F5LiBkb2VzIG5vdCBzdXBwb3J0IGEgcmV2ZXJ0IGFuaW1hdGlvblxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnZW5kJywgZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgcG9pbnRlciA9IHRoaXMucG9pbnRlciA9IG5ldyBQb2ludGVyRHJhZ2dpbmcoY29udGFpbmVyRWwpO1xuICAgICAgICBwb2ludGVyLmVtaXR0ZXIub24oJ3BvaW50ZXJkb3duJywgdGhpcy5oYW5kbGVQb2ludGVyRG93bik7XG4gICAgICAgIHBvaW50ZXIuZW1pdHRlci5vbigncG9pbnRlcm1vdmUnLCB0aGlzLmhhbmRsZVBvaW50ZXJNb3ZlKTtcbiAgICAgICAgcG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVydXAnLCB0aGlzLmhhbmRsZVBvaW50ZXJVcCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucG9pbnRlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIHNldElnbm9yZU1vdmUoYm9vbCkge1xuICAgICAgICB0aGlzLnNob3VsZElnbm9yZU1vdmUgPSBib29sO1xuICAgIH1cbiAgICBzZXRNaXJyb3JJc1Zpc2libGUoYm9vbCkge1xuICAgICAgICBpZiAoYm9vbCkge1xuICAgICAgICAgICAgLy8gcmVzdG9yZSBhIHByZXZpb3VzbHkgaGlkZGVuIGVsZW1lbnQuXG4gICAgICAgICAgICAvLyB1c2UgdGhlIHJlZmVyZW5jZSBpbiBjYXNlIHRoZSBzZWxlY3RvciBjbGFzcyBoYXMgYWxyZWFkeSBiZWVuIHJlbW92ZWQuXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50TWlycm9yRWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRNaXJyb3JFbC5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TWlycm9yRWwgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1pcnJvckVsID0gdGhpcy5taXJyb3JTZWxlY3RvclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHNvbWVob3cgcXVlcnkgRnVsbENhbGVuZGFycyBXSVRISU4gc2hhZG93LXJvb3RzXG4gICAgICAgICAgICAgICAgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMubWlycm9yU2VsZWN0b3IpXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgaWYgKG1pcnJvckVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TWlycm9yRWwgPSBtaXJyb3JFbDtcbiAgICAgICAgICAgICAgICBtaXJyb3JFbC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qXG5CcmlkZ2VzIHRoaXJkLXBhcnR5IGRyYWctbi1kcm9wIHN5c3RlbXMgd2l0aCBGdWxsQ2FsZW5kYXIuXG5NdXN0IGJlIGluc3RhbnRpYXRlZCBhbmQgZGVzdHJveWVkIGJ5IGNhbGxlci5cbiovXG5jbGFzcyBUaGlyZFBhcnR5RHJhZ2dhYmxlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXJPclNldHRpbmdzLCBzZXR0aW5ncykge1xuICAgICAgICBsZXQgY29udGFpbmVyRWwgPSBkb2N1bWVudDtcbiAgICAgICAgaWYgKFxuICAgICAgICAvLyB3aXNoIHdlIGNvdWxkIGp1c3QgdGVzdCBpbnN0YW5jZW9mIEV2ZW50VGFyZ2V0LCBidXQgZG9lc24ndCB3b3JrIGluIElFMTFcbiAgICAgICAgY29udGFpbmVyT3JTZXR0aW5ncyA9PT0gZG9jdW1lbnQgfHxcbiAgICAgICAgICAgIGNvbnRhaW5lck9yU2V0dGluZ3MgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICBjb250YWluZXJFbCA9IGNvbnRhaW5lck9yU2V0dGluZ3M7XG4gICAgICAgICAgICBzZXR0aW5ncyA9IHNldHRpbmdzIHx8IHt9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0dGluZ3MgPSAoY29udGFpbmVyT3JTZXR0aW5ncyB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRyYWdnaW5nID0gdGhpcy5kcmFnZ2luZyA9IG5ldyBJbmZlcnJlZEVsZW1lbnREcmFnZ2luZyhjb250YWluZXJFbCk7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MuaXRlbVNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZHJhZ2dpbmcucG9pbnRlci5zZWxlY3RvciA9IHNldHRpbmdzLml0ZW1TZWxlY3RvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250YWluZXJFbCA9PT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIGRyYWdnaW5nLnBvaW50ZXIuc2VsZWN0b3IgPSAnW2RhdGEtZXZlbnRdJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLm1pcnJvclNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZHJhZ2dpbmcubWlycm9yU2VsZWN0b3IgPSBzZXR0aW5ncy5taXJyb3JTZWxlY3RvcjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZXh0ZXJuYWxEcmFnZ2luZyA9IG5ldyBFeHRlcm5hbEVsZW1lbnREcmFnZ2luZyhkcmFnZ2luZywgc2V0dGluZ3MuZXZlbnREYXRhKTtcbiAgICAgICAgLy8gVGhlIGhpdC1kZXRlY3Rpb24gc3lzdGVtIHJlcXVpcmVzIHRoYXQgdGhlIGRuZC1taXJyb3ItZWxlbWVudCBiZSBwb2ludGVyLWV2ZW50czpub25lLFxuICAgICAgICAvLyBidXQgdGhpcyBjYW4ndCBiZSBndWFyYW50ZWVkIGZvciB0aGlyZC1wYXJ0eSBkcmFnZ2FibGVzLCBzbyBkaXNhYmxlXG4gICAgICAgIGV4dGVybmFsRHJhZ2dpbmcuaGl0RHJhZ2dpbmcuZGlzYWJsZVBvaW50Q2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nLmRlc3Ryb3koKTtcbiAgICB9XG59XG5cbnZhciBpbmRleCA9IGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogJ0BmdWxsY2FsZW5kYXIvaW50ZXJhY3Rpb24nLFxuICAgIGNvbXBvbmVudEludGVyYWN0aW9uczogW0RhdGVDbGlja2luZywgRGF0ZVNlbGVjdGluZywgRXZlbnREcmFnZ2luZywgRXZlbnRSZXNpemluZ10sXG4gICAgY2FsZW5kYXJJbnRlcmFjdGlvbnM6IFtVbnNlbGVjdEF1dG9dLFxuICAgIGVsZW1lbnREcmFnZ2luZ0ltcGw6IEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcsXG4gICAgb3B0aW9uUmVmaW5lcnM6IE9QVElPTl9SRUZJTkVSUyxcbiAgICBsaXN0ZW5lclJlZmluZXJzOiBMSVNURU5FUl9SRUZJTkVSUyxcbn0pO1xuXG5leHBvcnQgeyBFeHRlcm5hbERyYWdnYWJsZSBhcyBEcmFnZ2FibGUsIFRoaXJkUGFydHlEcmFnZ2FibGUsIGluZGV4IGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6WyJjcmVhdGVQbHVnaW4iLCJjb25maWciLCJFbWl0dGVyIiwiZWxlbWVudENsb3Nlc3QiLCJhcHBseVN0eWxlIiwid2hlblRyYW5zaXRpb25Eb25lIiwicmVtb3ZlRWxlbWVudCIsIlNjcm9sbENvbnRyb2xsZXIiLCJFbGVtZW50U2Nyb2xsQ29udHJvbGxlciIsImNvbXB1dGVJbm5lclJlY3QiLCJXaW5kb3dTY3JvbGxDb250cm9sbGVyIiwiRWxlbWVudERyYWdnaW5nIiwicHJldmVudFNlbGVjdGlvbiIsInByZXZlbnRDb250ZXh0TWVudSIsImFsbG93U2VsZWN0aW9uIiwiYWxsb3dDb250ZXh0TWVudSIsImNvbXB1dGVSZWN0IiwiZ2V0Q2xpcHBpbmdQYXJlbnRzIiwicG9pbnRJbnNpZGVSZWN0IiwiY29uc3RyYWluUG9pbnQiLCJpbnRlcnNlY3RSZWN0cyIsImdldFJlY3RDZW50ZXIiLCJkaWZmUG9pbnRzIiwibWFwSGFzaCIsInJhbmdlQ29udGFpbnNSYW5nZSIsImlzRGF0ZVNwYW5zRXF1YWwiLCJJbnRlcmFjdGlvbiIsImludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlIiwiaXNEYXRlU2VsZWN0aW9uVmFsaWQiLCJlbmFibGVDdXJzb3IiLCJkaXNhYmxlQ3Vyc29yIiwidHJpZ2dlckRhdGVTZWxlY3QiLCJjb21wYXJlTnVtYmVycyIsImdldEVsU2VnIiwiZ2V0UmVsZXZhbnRFdmVudHMiLCJFdmVudEltcGwiLCJjcmVhdGVFbXB0eUV2ZW50U3RvcmUiLCJhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlIiwiaXNJbnRlcmFjdGlvblZhbGlkIiwiYnVpbGRFdmVudEFwaXMiLCJpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUiLCJzdGFydE9mRGF5IiwiZGlmZkRhdGVzIiwiY3JlYXRlRHVyYXRpb24iLCJnZXRFdmVudFRhcmdldFZpYVJvb3QiLCJpZGVudGl0eSIsImV2ZW50VHVwbGVUb1N0b3JlIiwicGFyc2VEcmFnTWV0YSIsImVsZW1lbnRNYXRjaGVzIiwicmVmaW5lRXZlbnREZWYiLCJwYXJzZUV2ZW50RGVmIiwiZ2V0RGVmYXVsdEV2ZW50RW5kIiwiY3JlYXRlRXZlbnRJbnN0YW5jZSIsIkJBU0VfT1BUSU9OX0RFRkFVTFRTIiwidG91Y2hNb3VzZUlnbm9yZVdhaXQiLCJpZ25vcmVNb3VzZURlcHRoIiwibGlzdGVuZXJDbnQiLCJpc1dpbmRvd1RvdWNoTW92ZUNhbmNlbGxlZCIsIlBvaW50ZXJEcmFnZ2luZyIsImNvbnN0cnVjdG9yIiwiY29udGFpbmVyRWwiLCJzdWJqZWN0RWwiLCJzZWxlY3RvciIsImhhbmRsZVNlbGVjdG9yIiwic2hvdWxkSWdub3JlTW92ZSIsInNob3VsZFdhdGNoU2Nyb2xsIiwiaXNEcmFnZ2luZyIsImlzVG91Y2hEcmFnZ2luZyIsIndhc1RvdWNoU2Nyb2xsIiwiaGFuZGxlTW91c2VEb3duIiwiZXYiLCJzaG91bGRJZ25vcmVNb3VzZSIsImlzUHJpbWFyeU1vdXNlQnV0dG9uIiwidHJ5U3RhcnQiLCJwZXYiLCJjcmVhdGVFdmVudEZyb21Nb3VzZSIsImVtaXR0ZXIiLCJ0cmlnZ2VyIiwiaW5pdFNjcm9sbFdhdGNoIiwiZG9jdW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwiaGFuZGxlTW91c2VNb3ZlIiwiaGFuZGxlTW91c2VVcCIsInJlY29yZENvb3JkcyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjbGVhbnVwIiwiaGFuZGxlVG91Y2hTdGFydCIsImNyZWF0ZUV2ZW50RnJvbVRvdWNoIiwidGFyZ2V0RWwiLCJ0YXJnZXQiLCJoYW5kbGVUb3VjaE1vdmUiLCJoYW5kbGVUb3VjaEVuZCIsIndpbmRvdyIsImhhbmRsZVRvdWNoU2Nyb2xsIiwic3RhcnRJZ25vcmluZ01vdXNlIiwiaGFuZGxlU2Nyb2xsIiwicGFnZVgiLCJzY3JvbGxYIiwicHJldlNjcm9sbFgiLCJwcmV2UGFnZVgiLCJwYWdlWSIsInNjcm9sbFkiLCJwcmV2U2Nyb2xsWSIsInByZXZQYWdlWSIsIm9yaWdFdmVudCIsImlzVG91Y2giLCJkZWx0YVgiLCJvcmlnUGFnZVgiLCJkZWx0YVkiLCJvcmlnUGFnZVkiLCJwYXNzaXZlIiwibGlzdGVuZXJDcmVhdGVkIiwiZGVzdHJveSIsImxpc3RlbmVyRGVzdHJveWVkIiwicXVlcnlTdWJqZWN0RWwiLCJkb3duRWwiLCJkZXN0cm95U2Nyb2xsV2F0Y2giLCJjYW5jZWxUb3VjaFNjcm9sbCIsImlzRmlyc3QiLCJ0b3VjaGVzIiwibGVuZ3RoIiwiYnV0dG9uIiwiY3RybEtleSIsInNldFRpbWVvdXQiLCJvbldpbmRvd1RvdWNoTW92ZSIsInByZXZlbnREZWZhdWx0IiwiRWxlbWVudE1pcnJvciIsImlzVmlzaWJsZSIsInNvdXJjZUVsIiwibWlycm9yRWwiLCJzb3VyY2VFbFJlY3QiLCJwYXJlbnROb2RlIiwiYm9keSIsInpJbmRleCIsInJldmVydER1cmF0aW9uIiwic3RhcnQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJvcmlnU2NyZWVuWCIsIm9yaWdTY3JlZW5ZIiwidXBkYXRlRWxQb3NpdGlvbiIsImhhbmRsZU1vdmUiLCJzZXRJc1Zpc2libGUiLCJib29sIiwic3R5bGUiLCJkaXNwbGF5Iiwic3RvcCIsIm5lZWRzUmV2ZXJ0QW5pbWF0aW9uIiwiY2FsbGJhY2siLCJkb25lIiwiZG9SZXZlcnRBbmltYXRpb24iLCJmaW5hbFNvdXJjZUVsUmVjdCIsInRyYW5zaXRpb24iLCJsZWZ0IiwidG9wIiwiZ2V0TWlycm9yRWwiLCJjbG9uZU5vZGUiLCJ1c2VyU2VsZWN0Iiwid2Via2l0VXNlclNlbGVjdCIsInBvaW50ZXJFdmVudHMiLCJjbGFzc0xpc3QiLCJhZGQiLCJwb3NpdGlvbiIsInZpc2liaWxpdHkiLCJib3hTaXppbmciLCJ3aWR0aCIsInJpZ2h0IiwiaGVpZ2h0IiwiYm90dG9tIiwibWFyZ2luIiwiYXBwZW5kQ2hpbGQiLCJTY3JvbGxHZW9tQ2FjaGUiLCJzY3JvbGxDb250cm9sbGVyIiwiZG9lc0xpc3RlbmluZyIsInNjcm9sbFRvcCIsImdldFNjcm9sbFRvcCIsInNjcm9sbExlZnQiLCJnZXRTY3JvbGxMZWZ0IiwiaGFuZGxlU2Nyb2xsQ2hhbmdlIiwib3JpZ1Njcm9sbFRvcCIsIm9yaWdTY3JvbGxMZWZ0Iiwic2Nyb2xsV2lkdGgiLCJnZXRTY3JvbGxXaWR0aCIsInNjcm9sbEhlaWdodCIsImdldFNjcm9sbEhlaWdodCIsImNsaWVudFdpZHRoIiwiZ2V0Q2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJnZXRDbGllbnRIZWlnaHQiLCJjbGllbnRSZWN0IiwiY29tcHV0ZUNsaWVudFJlY3QiLCJnZXRFdmVudFRhcmdldCIsInNldFNjcm9sbFRvcCIsIk1hdGgiLCJtYXgiLCJtaW4iLCJnZXRNYXhTY3JvbGxUb3AiLCJzZXRTY3JvbGxMZWZ0IiwiZ2V0TWF4U2Nyb2xsTGVmdCIsIkVsZW1lbnRTY3JvbGxHZW9tQ2FjaGUiLCJlbCIsIldpbmRvd1Njcm9sbEdlb21DYWNoZSIsImdldFRpbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsIkRhdGUiLCJBdXRvU2Nyb2xsZXIiLCJpc0VuYWJsZWQiLCJzY3JvbGxRdWVyeSIsImVkZ2VUaHJlc2hvbGQiLCJtYXhWZWxvY2l0eSIsInBvaW50ZXJTY3JlZW5YIiwicG9pbnRlclNjcmVlblkiLCJpc0FuaW1hdGluZyIsInNjcm9sbENhY2hlcyIsImV2ZXJNb3ZlZFVwIiwiZXZlck1vdmVkRG93biIsImV2ZXJNb3ZlZExlZnQiLCJldmVyTW92ZWRSaWdodCIsImFuaW1hdGUiLCJlZGdlIiwiY29tcHV0ZUJlc3RFZGdlIiwiaGFuZGxlU2lkZSIsIm1zU2luY2VSZXF1ZXN0IiwicmVxdWVzdEFuaW1hdGlvbiIsInNjcm9sbFN0YXJ0RWwiLCJidWlsZENhY2hlcyIsInlEZWx0YSIsInhEZWx0YSIsInNjcm9sbENhY2hlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic2Vjb25kcyIsImludkRpc3RhbmNlIiwiZGlzdGFuY2UiLCJ2ZWxvY2l0eSIsInNpZ24iLCJuYW1lIiwiYmVzdFNpZGUiLCJyZWN0IiwibGVmdERpc3QiLCJyaWdodERpc3QiLCJ0b3BEaXN0IiwiYm90dG9tRGlzdCIsImNhblNjcm9sbFVwIiwiY2FuU2Nyb2xsRG93biIsImNhblNjcm9sbExlZnQiLCJjYW5TY3JvbGxSaWdodCIsInF1ZXJ5U2Nyb2xsRWxzIiwibWFwIiwiZWxzIiwicXVlcnkiLCJwdXNoIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJnZXRSb290Tm9kZSIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nIiwiZGVsYXkiLCJtaW5EaXN0YW5jZSIsInRvdWNoU2Nyb2xsQWxsb3dlZCIsIm1pcnJvck5lZWRzUmV2ZXJ0IiwiaXNJbnRlcmFjdGluZyIsImlzRGVsYXlFbmRlZCIsImlzRGlzdGFuY2VTdXJwYXNzZWQiLCJkZWxheVRpbWVvdXRJZCIsIm9uUG9pbnRlckRvd24iLCJwb2ludGVyIiwibWlycm9yIiwic3RhcnREZWxheSIsImhhbmRsZURpc3RhbmNlU3VycGFzc2VkIiwib25Qb2ludGVyTW92ZSIsImRpc3RhbmNlU3EiLCJ0eXBlIiwiYXV0b1Njcm9sbGVyIiwib25Qb2ludGVyVXAiLCJ0cnlTdG9wRHJhZyIsImNsZWFyVGltZW91dCIsIm9uIiwiaGFuZGxlRGVsYXlFbmQiLCJ0cnlTdGFydERyYWciLCJzdG9wRHJhZyIsImJpbmQiLCJzZXRJZ25vcmVNb3ZlIiwic2V0TWlycm9ySXNWaXNpYmxlIiwic2V0TWlycm9yTmVlZHNSZXZlcnQiLCJzZXRBdXRvU2Nyb2xsRW5hYmxlZCIsIk9mZnNldFRyYWNrZXIiLCJvcmlnUmVjdCIsInNjcm9sbEVsIiwiY29tcHV0ZUxlZnQiLCJjb21wdXRlVG9wIiwiaXNXaXRoaW5DbGlwcGluZyIsInBvaW50IiwiaXNJZ25vcmVkQ2xpcHBpbmciLCJub2RlIiwidGFnTmFtZSIsIkhpdERyYWdnaW5nIiwiZHJhZ2dpbmciLCJkcm9wcGFibGVTdG9yZSIsInVzZVN1YmplY3RDZW50ZXIiLCJyZXF1aXJlSW5pdGlhbCIsImRpc2FibGVQb2ludENoZWNrIiwiaW5pdGlhbEhpdCIsIm1vdmluZ0hpdCIsImZpbmFsSGl0IiwiaGFuZGxlUG9pbnRlckRvd24iLCJwcmVwYXJlSGl0cyIsInByb2Nlc3NGaXJzdENvb3JkIiwiaGFuZGxlRHJhZ1N0YXJ0IiwiaGFuZGxlRHJhZ01vdmUiLCJoYW5kbGVQb2ludGVyVXAiLCJyZWxlYXNlSGl0cyIsImhhbmRsZURyYWdFbmQiLCJvcmlnUG9pbnQiLCJhZGp1c3RlZFBvaW50Iiwic3ViamVjdFJlY3QiLCJIVE1MRWxlbWVudCIsInF1ZXJ5SGl0Rm9yT2Zmc2V0Iiwic2xpY2VkU3ViamVjdFJlY3QiLCJjb29yZEFkanVzdCIsImZvcmNlSGFuZGxlIiwiaGl0IiwiaXNIaXRzRXF1YWwiLCJvZmZzZXRUcmFja2VycyIsImludGVyYWN0aW9uU2V0dGluZ3MiLCJjb21wb25lbnQiLCJpZCIsIm9mZnNldExlZnQiLCJvZmZzZXRUb3AiLCJiZXN0SGl0Iiwib2Zmc2V0VHJhY2tlciIsIm9yaWdpbkxlZnQiLCJvcmlnaW5Ub3AiLCJwb3NpdGlvbkxlZnQiLCJwb3NpdGlvblRvcCIsInF1ZXJ5SGl0IiwiZGF0ZVByb2ZpbGUiLCJhY3RpdmVSYW5nZSIsImRhdGVTcGFuIiwicmFuZ2UiLCJjb250YWlucyIsImVsZW1lbnRGcm9tUG9pbnQiLCJsYXllciIsImNvbXBvbmVudElkIiwiY29udGV4dCIsImhpdDAiLCJoaXQxIiwiQm9vbGVhbiIsImJ1aWxkRGF0ZVBvaW50QXBpV2l0aENvbnRleHQiLCJwcm9wcyIsInRyYW5zZm9ybSIsInBsdWdpbkhvb2tzIiwiZGF0ZVBvaW50VHJhbnNmb3JtcyIsIk9iamVjdCIsImFzc2lnbiIsImJ1aWxkRGF0ZVBvaW50QXBpIiwiZGF0ZUVudiIsInNwYW4iLCJkYXRlIiwidG9EYXRlIiwiZGF0ZVN0ciIsImZvcm1hdElzbyIsIm9taXRUaW1lIiwiYWxsRGF5IiwiRGF0ZUNsaWNraW5nIiwic2V0dGluZ3MiLCJpc1ZhbGlkRGF0ZURvd25FbCIsImhpdERyYWdnaW5nIiwiYXJnIiwiZGF5RWwiLCJqc0V2ZW50IiwidmlldyIsInZpZXdBcGkiLCJjYWxlbmRhckFwaSIsIkRhdGVTZWxlY3RpbmciLCJkcmFnU2VsZWN0aW9uIiwib3B0aW9ucyIsImNhblNlbGVjdCIsInNlbGVjdGFibGUiLCJnZXRDb21wb25lbnRUb3VjaERlbGF5JDEiLCJ1bnNlbGVjdCIsImhhbmRsZUhpdFVwZGF0ZSIsImlzRmluYWwiLCJpc0ludmFsaWQiLCJkaXNhbGxvd2VkIiwiaXNIaXRDb21ib0FsbG93ZWQiLCJqb2luSGl0c0ludG9TZWxlY3Rpb24iLCJkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzIiwiZGlzcGF0Y2giLCJzZWxlY3Rpb24iLCJzZWxlY3RNaW5EaXN0YW5jZSIsImRyYWdTY3JvbGwiLCJzZWxlY3RMb25nUHJlc3NEZWxheSIsImxvbmdQcmVzc0RlbGF5IiwiZGF0ZVNwYW4wIiwiZGF0ZVNwYW4xIiwibXMiLCJlbmQiLCJzb3J0IiwidHJhbnNmb3JtZXIiLCJyZXMiLCJFdmVudERyYWdnaW5nIiwic3ViamVjdFNlZyIsImV2ZW50UmFuZ2UiLCJyZWxldmFudEV2ZW50cyIsInJlY2VpdmluZ0NvbnRleHQiLCJ2YWxpZE11dGF0aW9uIiwibXV0YXRlZFJlbGV2YW50RXZlbnRzIiwib3JpZ1RhcmdldCIsImluaXRpYWxDb250ZXh0IiwiZXZlbnRJbnN0YW5jZUlkIiwiaW5zdGFuY2UiLCJpbnN0YW5jZUlkIiwiZ2V0Q3VycmVudERhdGEiLCJldmVudFN0b3JlIiwiZXZlbnREcmFnTWluRGlzdGFuY2UiLCJldmVudFNlbGVjdGlvbiIsImdldENvbXBvbmVudFRvdWNoRGVsYXkiLCJmaXhlZE1pcnJvclBhcmVudCIsImRyYWdSZXZlcnREdXJhdGlvbiIsImlzVmFsaWQiLCJpc1ZhbGlkU2VnRG93bkVsIiwiZXZlbnQiLCJkZWYiLCJtdXRhdGlvbiIsImludGVyYWN0aW9uIiwiYWZmZWN0ZWRFdmVudHMiLCJtdXRhdGVkRXZlbnRzIiwiaXNFdmVudCIsInJlY2VpdmluZ09wdGlvbnMiLCJlZGl0YWJsZSIsImRyb3BwYWJsZSIsImNvbXB1dGVFdmVudE11dGF0aW9uIiwiZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnMiLCJldmVudFVpQmFzZXMiLCJkaXNwbGF5RHJhZyIsInF1ZXJ5U2VsZWN0b3IiLCJpbml0aWFsVmlldyIsImV2ZW50RGVmIiwiZXZlbnRJbnN0YW5jZSIsImV2ZW50QXBpIiwiY2xlYXJEcmFnIiwidXBkYXRlZEV2ZW50QXBpIiwiZGVmcyIsImRlZklkIiwiaW5zdGFuY2VzIiwiZXZlbnRDaGFuZ2VBcmciLCJvbGRFdmVudCIsInJlbGF0ZWRFdmVudHMiLCJyZXZlcnQiLCJ0cmFuc2Zvcm1lZCIsImV2ZW50RHJvcFRyYW5zZm9ybWVycyIsImRlbHRhIiwiZGF0ZXNEZWx0YSIsImV2ZW50UmVtb3ZlQXJnIiwiZHJhZ2dlZEVsIiwiYWRkZWRFdmVudERlZiIsImFkZGVkRXZlbnRJbnN0YW5jZSIsImFkZGVkRXZlbnRBcGkiLCJldmVudEFkZEFyZyIsIlNFTEVDVE9SIiwidXNlRXZlbnRDZW50ZXIiLCJuZXh0Q29udGV4dCIsInN0YXRlIiwicHJldkNvbnRleHQiLCJpbml0aWFsQ2FsZW5kYXIiLCJldmVudEluc3RhbmNlU3RhcnQiLCJtYXNzYWdlcnMiLCJkYXRlMCIsImRhdGUxIiwic3RhbmRhcmRQcm9wcyIsImhhc0VuZCIsImFsbERheU1haW50YWluRHVyYXRpb24iLCJsYXJnZVVuaXQiLCJtaWxsaXNlY29uZHMiLCJtYXNzYWdlciIsImV2ZW50TG9uZ1ByZXNzRGVsYXkiLCJFdmVudFJlc2l6aW5nIiwiZHJhZ2dpbmdTZWdFbCIsImRyYWdnaW5nU2VnIiwic2VnRWwiLCJxdWVyeVNlZ0VsIiwic2VnIiwiY29tcHV0ZU11dGF0aW9uIiwic3RhcnREZWx0YSIsImVuZERlbHRhIiwiaXNGcm9tU3RhcnQiLCJpbnN0YW5jZVJhbmdlIiwiVW5zZWxlY3RBdXRvIiwiaXNSZWNlbnRQb2ludGVyRGF0ZVNlbGVjdCIsIm1hdGNoZXNDYW5jZWwiLCJtYXRjaGVzRXZlbnQiLCJvblNlbGVjdCIsInNlbGVjdEluZm8iLCJvbkRvY3VtZW50UG9pbnRlckRvd24iLCJ1bnNlbGVjdENhbmNlbCIsIm9uRG9jdW1lbnRQb2ludGVyVXAiLCJkb2N1bWVudFBvaW50ZXIiLCJjYWxlbmRhclN0YXRlIiwiZGF0ZVNlbGVjdGlvbiIsInVuc2VsZWN0QXV0byIsIm9mZiIsIk9QVElPTl9SRUZJTkVSUyIsIkxJU1RFTkVSX1JFRklORVJTIiwiZGF0ZUNsaWNrIiwiZXZlbnREcmFnU3RhcnQiLCJldmVudERyYWdTdG9wIiwiZXZlbnREcm9wIiwiZXZlbnRSZXNpemVTdGFydCIsImV2ZW50UmVzaXplU3RvcCIsImV2ZW50UmVzaXplIiwiZHJvcCIsImV2ZW50UmVjZWl2ZSIsImV2ZW50TGVhdmUiLCJFeHRlcm5hbEVsZW1lbnREcmFnZ2luZyIsInN1cHBsaWVkRHJhZ01ldGEiLCJkcm9wcGFibGVFdmVudCIsImRyYWdNZXRhIiwiYnVpbGREcmFnTWV0YSIsImNyZWF0ZSIsImNhbkRyb3BFbE9uQ2FsZW5kYXIiLCJjb21wdXRlRXZlbnRGb3JEYXRlU3BhbiIsImZpbmFsVmlldyIsImFkZGluZ0V2ZW50cyIsImdldERyYWdNZXRhRnJvbUVsIiwiZHJvcEFjY2VwdCIsImRlZlByb3BzIiwibGVmdG92ZXJQcm9wcyIsImV4dGVybmFsRGVmVHJhbnNmb3JtcyIsInJlZmluZWQiLCJleHRyYSIsInNvdXJjZUlkIiwiZm9yY2VFdmVudER1cmF0aW9uIiwiZHVyYXRpb24iLCJzdGFydFRpbWUiLCJzdHIiLCJnZXRFbWJlZGRlZEVsRGF0YSIsIm9iaiIsIkpTT04iLCJwYXJzZSIsImRhdGFBdHRyUHJlZml4IiwicHJlZml4IiwicHJlZml4ZWROYW1lIiwiZ2V0QXR0cmlidXRlIiwiRXh0ZXJuYWxEcmFnZ2FibGUiLCJpdGVtU2VsZWN0b3IiLCJhcHBlbmRUbyIsImV2ZW50RGF0YSIsIkluZmVycmVkRWxlbWVudERyYWdnaW5nIiwibWlycm9yU2VsZWN0b3IiLCJjdXJyZW50TWlycm9yRWwiLCJoYW5kbGVQb2ludGVyTW92ZSIsIlRoaXJkUGFydHlEcmFnZ2FibGUiLCJjb250YWluZXJPclNldHRpbmdzIiwiRWxlbWVudCIsImV4dGVybmFsRHJhZ2dpbmciLCJpbmRleCIsImNvbXBvbmVudEludGVyYWN0aW9ucyIsImNhbGVuZGFySW50ZXJhY3Rpb25zIiwiZWxlbWVudERyYWdnaW5nSW1wbCIsIm9wdGlvblJlZmluZXJzIiwibGlzdGVuZXJSZWZpbmVycyIsIkRyYWdnYWJsZSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@fullcalendar/interaction/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@fullcalendar/react/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@fullcalendar/react/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ FullCalendar)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var _fullcalendar_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fullcalendar/core */ \"(ssr)/./node_modules/@fullcalendar/core/index.js\");\n/* harmony import */ var _fullcalendar_core_internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fullcalendar/core/internal */ \"(ssr)/./node_modules/@fullcalendar/core/internal-common.js\");\n\n\n\n\nconst reactMajorVersion = parseInt(String(react__WEBPACK_IMPORTED_MODULE_0__.version).split(\".\")[0]);\nconst syncRenderingByDefault = reactMajorVersion < 18;\nclass FullCalendar extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(){\n        super(...arguments);\n        this.elRef = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)();\n        this.isUpdating = false;\n        this.isUnmounting = false;\n        this.state = {\n            customRenderingMap: new Map()\n        };\n        this.requestResize = ()=>{\n            if (!this.isUnmounting) {\n                this.cancelResize();\n                this.resizeId = requestAnimationFrame(()=>{\n                    this.doResize();\n                });\n            }\n        };\n    }\n    render() {\n        const customRenderingNodes = [];\n        for (const customRendering of this.state.customRenderingMap.values()){\n            customRenderingNodes.push(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CustomRenderingComponent, {\n                key: customRendering.id,\n                customRendering: customRendering\n            }));\n        }\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            ref: this.elRef\n        }, customRenderingNodes);\n    }\n    componentDidMount() {\n        // reset b/c react strict-mode calls componentWillUnmount/componentDidMount\n        this.isUnmounting = false;\n        const customRenderingStore = new _fullcalendar_core_internal__WEBPACK_IMPORTED_MODULE_2__.cy();\n        this.handleCustomRendering = customRenderingStore.handle.bind(customRenderingStore);\n        this.calendar = new _fullcalendar_core__WEBPACK_IMPORTED_MODULE_3__.Calendar(this.elRef.current, Object.assign(Object.assign({}, this.props), {\n            handleCustomRendering: this.handleCustomRendering\n        }));\n        this.calendar.render();\n        // attaching with .on() will cause this to fire AFTER internal preact rendering did flushSync\n        this.calendar.on(\"_beforeprint\", ()=>{\n            (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(()=>{\n            // our `customRenderingMap` state will be flushed at this point\n            });\n        });\n        let lastRequestTimestamp;\n        customRenderingStore.subscribe((customRenderingMap)=>{\n            const requestTimestamp = Date.now();\n            const isMounting = !lastRequestTimestamp;\n            const runFunc = // don't call flushSync if React version already does sync rendering by default\n            // guards against fatal errors:\n            // https://github.com/fullcalendar/fullcalendar/issues/7448\n            syncRenderingByDefault || //\n            isMounting || this.isUpdating || this.isUnmounting || requestTimestamp - lastRequestTimestamp < 100 // rerendering frequently\n             ? runNow // either sync rendering (first-time or React 16/17) or async (React 18)\n             : react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync; // guaranteed sync rendering\n            runFunc(()=>{\n                this.setState({\n                    customRenderingMap\n                }, ()=>{\n                    lastRequestTimestamp = requestTimestamp;\n                    if (isMounting) {\n                        this.doResize();\n                    } else {\n                        this.requestResize();\n                    }\n                });\n            });\n        });\n    }\n    componentDidUpdate() {\n        this.isUpdating = true;\n        this.calendar.resetOptions(Object.assign(Object.assign({}, this.props), {\n            handleCustomRendering: this.handleCustomRendering\n        }));\n        this.isUpdating = false;\n    }\n    componentWillUnmount() {\n        this.isUnmounting = true;\n        this.cancelResize();\n        this.calendar.destroy();\n    }\n    doResize() {\n        this.calendar.updateSize();\n    }\n    cancelResize() {\n        if (this.resizeId !== undefined) {\n            cancelAnimationFrame(this.resizeId);\n            this.resizeId = undefined;\n        }\n    }\n    getApi() {\n        return this.calendar;\n    }\n}\nFullCalendar.act = runNow; // DEPRECATED. Not leveraged anymore\nclass CustomRenderingComponent extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n    render() {\n        const { customRendering } = this.props;\n        const { generatorMeta } = customRendering;\n        const vnode = typeof generatorMeta === \"function\" ? generatorMeta(customRendering.renderProps) : generatorMeta;\n        return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(vnode, customRendering.containerEl);\n    }\n}\n// Util\n// -------------------------------------------------------------------------------------------------\nfunction runNow(f) {\n    f();\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9yZWFjdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW1FO0FBQ2Y7QUFDTDtBQUNxQjtBQUNwRSxNQUFNUSxvQkFBb0JDLFNBQVNDLE9BQU9WLDBDQUFhLEVBQUVZLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtBQUN0RSxNQUFNQyx5QkFBeUJMLG9CQUFvQjtBQUNwQyxNQUFNTSxxQkFBcUJiLDRDQUFTQTtJQUMvQ2MsYUFBYztRQUNWLEtBQUssSUFBSUM7UUFDVCxJQUFJLENBQUNDLEtBQUssaUJBQUdmLGdEQUFTQTtRQUN0QixJQUFJLENBQUNnQixVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDQyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDQyxLQUFLLEdBQUc7WUFDVEMsb0JBQW9CLElBQUlDO1FBQzVCO1FBQ0EsSUFBSSxDQUFDQyxhQUFhLEdBQUc7WUFDakIsSUFBSSxDQUFDLElBQUksQ0FBQ0osWUFBWSxFQUFFO2dCQUNwQixJQUFJLENBQUNLLFlBQVk7Z0JBQ2pCLElBQUksQ0FBQ0MsUUFBUSxHQUFHQyxzQkFBc0I7b0JBQ2xDLElBQUksQ0FBQ0MsUUFBUTtnQkFDakI7WUFDSjtRQUNKO0lBQ0o7SUFDQUMsU0FBUztRQUNMLE1BQU1DLHVCQUF1QixFQUFFO1FBQy9CLEtBQUssTUFBTUMsbUJBQW1CLElBQUksQ0FBQ1YsS0FBSyxDQUFDQyxrQkFBa0IsQ0FBQ1UsTUFBTSxHQUFJO1lBQ2xFRixxQkFBcUJHLElBQUksZUFBQ2hDLGdEQUFtQixDQUFDa0MsMEJBQTBCO2dCQUFFQyxLQUFLTCxnQkFBZ0JNLEVBQUU7Z0JBQUVOLGlCQUFpQkE7WUFBZ0I7UUFDeEk7UUFDQSxxQkFBUTlCLGdEQUFtQixDQUFDLE9BQU87WUFBRXFDLEtBQUssSUFBSSxDQUFDcEIsS0FBSztRQUFDLEdBQUdZO0lBQzVEO0lBQ0FTLG9CQUFvQjtRQUNoQiwyRUFBMkU7UUFDM0UsSUFBSSxDQUFD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InNvdXJjZXMiOlsid2VicGFjazovL3JlaGFzcG9ydC1tYW5hZ2VtZW50Ly4vbm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvcmVhY3QvZGlzdC9pbmRleC5qcz9kN2I5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIGNyZWF0ZVJlZiwgUHVyZUNvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCwgZmx1c2hTeW5jIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCB7IENhbGVuZGFyLCB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZSc7XG5pbXBvcnQgeyBDdXN0b21SZW5kZXJpbmdTdG9yZSwgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUvaW50ZXJuYWwnO1xuY29uc3QgcmVhY3RNYWpvclZlcnNpb24gPSBwYXJzZUludChTdHJpbmcoUmVhY3QudmVyc2lvbikuc3BsaXQoJy4nKVswXSk7XG5jb25zdCBzeW5jUmVuZGVyaW5nQnlEZWZhdWx0ID0gcmVhY3RNYWpvclZlcnNpb24gPCAxODtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZ1bGxDYWxlbmRhciBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZWxSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy5pc1VwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNVbm1vdW50aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBjdXN0b21SZW5kZXJpbmdNYXA6IG5ldyBNYXAoKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlcXVlc3RSZXNpemUgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNVbm1vdW50aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxSZXNpemUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb1Jlc2l6ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IGN1c3RvbVJlbmRlcmluZ05vZGVzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgY3VzdG9tUmVuZGVyaW5nIG9mIHRoaXMuc3RhdGUuY3VzdG9tUmVuZGVyaW5nTWFwLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBjdXN0b21SZW5kZXJpbmdOb2Rlcy5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ3VzdG9tUmVuZGVyaW5nQ29tcG9uZW50LCB7IGtleTogY3VzdG9tUmVuZGVyaW5nLmlkLCBjdXN0b21SZW5kZXJpbmc6IGN1c3RvbVJlbmRlcmluZyB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiB0aGlzLmVsUmVmIH0sIGN1c3RvbVJlbmRlcmluZ05vZGVzKSk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICAvLyByZXNldCBiL2MgcmVhY3Qgc3RyaWN0LW1vZGUgY2FsbHMgY29tcG9uZW50V2lsbFVubW91bnQvY29tcG9uZW50RGlkTW91bnRcbiAgICAgICAgdGhpcy5pc1VubW91bnRpbmcgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY3VzdG9tUmVuZGVyaW5nU3RvcmUgPSBuZXcgQ3VzdG9tUmVuZGVyaW5nU3RvcmUoKTtcbiAgICAgICAgdGhpcy5oYW5kbGVDdXN0b21SZW5kZXJpbmcgPSBjdXN0b21SZW5kZXJpbmdTdG9yZS5oYW5kbGUuYmluZChjdXN0b21SZW5kZXJpbmdTdG9yZSk7XG4gICAgICAgIHRoaXMuY2FsZW5kYXIgPSBuZXcgQ2FsZW5kYXIodGhpcy5lbFJlZi5jdXJyZW50LCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMpLCB7IGhhbmRsZUN1c3RvbVJlbmRlcmluZzogdGhpcy5oYW5kbGVDdXN0b21SZW5kZXJpbmcgfSkpO1xuICAgICAgICB0aGlzLmNhbGVuZGFyLnJlbmRlcigpO1xuICAgICAgICAvLyBhdHRhY2hpbmcgd2l0aCAub24oKSB3aWxsIGNhdXNlIHRoaXMgdG8gZmlyZSBBRlRFUiBpbnRlcm5hbCBwcmVhY3QgcmVuZGVyaW5nIGRpZCBmbHVzaFN5bmNcbiAgICAgICAgdGhpcy5jYWxlbmRhci5vbignX2JlZm9yZXByaW50JywgKCkgPT4ge1xuICAgICAgICAgICAgZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBvdXIgYGN1c3RvbVJlbmRlcmluZ01hcGAgc3RhdGUgd2lsbCBiZSBmbHVzaGVkIGF0IHRoaXMgcG9pbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGxhc3RSZXF1ZXN0VGltZXN0YW1wO1xuICAgICAgICBjdXN0b21SZW5kZXJpbmdTdG9yZS5zdWJzY3JpYmUoKGN1c3RvbVJlbmRlcmluZ01hcCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdFRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBjb25zdCBpc01vdW50aW5nID0gIWxhc3RSZXF1ZXN0VGltZXN0YW1wO1xuICAgICAgICAgICAgY29uc3QgcnVuRnVuYyA9IChcbiAgICAgICAgICAgIC8vIGRvbid0IGNhbGwgZmx1c2hTeW5jIGlmIFJlYWN0IHZlcnNpb24gYWxyZWFkeSBkb2VzIHN5bmMgcmVuZGVyaW5nIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIC8vIGd1YXJkcyBhZ2FpbnN0IGZhdGFsIGVycm9yczpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mdWxsY2FsZW5kYXIvZnVsbGNhbGVuZGFyL2lzc3Vlcy83NDQ4XG4gICAgICAgICAgICBzeW5jUmVuZGVyaW5nQnlEZWZhdWx0IHx8XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBpc01vdW50aW5nIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5pc1VwZGF0aW5nIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5pc1VubW91bnRpbmcgfHxcbiAgICAgICAgICAgICAgICAocmVxdWVzdFRpbWVzdGFtcCAtIGxhc3RSZXF1ZXN0VGltZXN0YW1wKSA8IDEwMCAvLyByZXJlbmRlcmluZyBmcmVxdWVudGx5XG4gICAgICAgICAgICApID8gcnVuTm93IC8vIGVpdGhlciBzeW5jIHJlbmRlcmluZyAoZmlyc3QtdGltZSBvciBSZWFjdCAxNi8xNykgb3IgYXN5bmMgKFJlYWN0IDE4KVxuICAgICAgICAgICAgICAgIDogZmx1c2hTeW5jOyAvLyBndWFyYW50ZWVkIHN5bmMgcmVuZGVyaW5nXG4gICAgICAgICAgICBydW5GdW5jKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgY3VzdG9tUmVuZGVyaW5nTWFwIH0sICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFJlcXVlc3RUaW1lc3RhbXAgPSByZXF1ZXN0VGltZXN0YW1wO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNNb3VudGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb1Jlc2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0UmVzaXplKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICB0aGlzLmlzVXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmNhbGVuZGFyLnJlc2V0T3B0aW9ucyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMpLCB7IGhhbmRsZUN1c3RvbVJlbmRlcmluZzogdGhpcy5oYW5kbGVDdXN0b21SZW5kZXJpbmcgfSkpO1xuICAgICAgICB0aGlzLmlzVXBkYXRpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHRoaXMuaXNVbm1vdW50aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jYW5jZWxSZXNpemUoKTtcbiAgICAgICAgdGhpcy5jYWxlbmRhci5kZXN0cm95KCk7XG4gICAgfVxuICAgIGRvUmVzaXplKCkge1xuICAgICAgICB0aGlzLmNhbGVuZGFyLnVwZGF0ZVNpemUoKTtcbiAgICB9XG4gICAgY2FuY2VsUmVzaXplKCkge1xuICAgICAgICBpZiAodGhpcy5yZXNpemVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJlc2l6ZUlkKTtcbiAgICAgICAgICAgIHRoaXMucmVzaXplSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0QXBpKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhcjtcbiAgICB9XG59XG5GdWxsQ2FsZW5kYXIuYWN0ID0gcnVuTm93OyAvLyBERVBSRUNBVEVELiBOb3QgbGV2ZXJhZ2VkIGFueW1vcmVcbmNsYXNzIEN1c3RvbVJlbmRlcmluZ0NvbXBvbmVudCBleHRlbmRzIFB1cmVDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBjdXN0b21SZW5kZXJpbmcgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgZ2VuZXJhdG9yTWV0YSB9ID0gY3VzdG9tUmVuZGVyaW5nO1xuICAgICAgICBjb25zdCB2bm9kZSA9IHR5cGVvZiBnZW5lcmF0b3JNZXRhID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgIGdlbmVyYXRvck1ldGEoY3VzdG9tUmVuZGVyaW5nLnJlbmRlclByb3BzKSA6XG4gICAgICAgICAgICBnZW5lcmF0b3JNZXRhO1xuICAgICAgICByZXR1cm4gY3JlYXRlUG9ydGFsKHZub2RlLCBjdXN0b21SZW5kZXJpbmcuY29udGFpbmVyRWwpO1xuICAgIH1cbn1cbi8vIFV0aWxcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIHJ1bk5vdyhmKSB7XG4gICAgZigpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIlJlYWN0IiwiQ29tcG9uZW50IiwiY3JlYXRlUmVmIiwiUHVyZUNvbXBvbmVudCIsImNyZWF0ZVBvcnRhbCIsImZsdXNoU3luYyIsIkNhbGVuZGFyIiwiQ3VzdG9tUmVuZGVyaW5nU3RvcmUiLCJyZWFjdE1ham9yVmVyc2lvbiIsInBhcnNlSW50IiwiU3RyaW5nIiwidmVyc2lvbiIsInNwbGl0Iiwic3luY1JlbmRlcmluZ0J5RGVmYXVsdCIsIkZ1bGxDYWxlbmRhciIsImNvbnN0cnVjdG9yIiwiYXJndW1lbnRzIiwiZWxSZWYiLCJpc1VwZGF0aW5nIiwiaXNVbm1vdW50aW5nIiwic3RhdGUiLCJjdXN0b21SZW5kZXJpbmdNYXAiLCJNYXAiLCJyZXF1ZXN0UmVzaXplIiwiY2FuY2VsUmVzaXplIiwicmVzaXplSWQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJkb1Jlc2l6ZSIsInJlbmRlciIsImN1c3RvbVJlbmRlcmluZ05vZGVzIiwiY3VzdG9tUmVuZGVyaW5nIiwidmFsdWVzIiwicHVzaCIsImNyZWF0ZUVsZW1lbnQiLCJDdXN0b21SZW5kZXJpbmdDb21wb25lbnQiLCJrZXkiLCJpZCIsInJlZiIsImNvbXBvbmVudERpZE1vdW50IiwiY3VzdG9tUmVuZGVyaW5nU3RvcmUiLCJoYW5kbGVDdXN0b21SZW5kZXJpbmciLCJoYW5kbGUiLCJiaW5kIiwiY2FsZW5kYXIiLCJjdXJyZW50IiwiT2JqZWN0IiwiYXNzaWduIiwicHJvcHMiLCJvbiIsImxhc3RSZXF1ZXN0VGltZXN0YW1wIiwic3Vic2NyaWJlIiwicmVxdWVzdFRpbWVzdGFtcCIsIkRhdGUiLCJub3ciLCJpc01vdW50aW5nIiwicnVuRnVuYyIsInJ1bk5vdyIsInNldFN0YXRlIiwiY29tcG9uZW50RGlkVXBkYXRlIiwicmVzZXRPcHRpb25zIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJkZXN0cm95IiwidXBkYXRlU2l6ZSIsInVuZGVmaW5lZCIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiZ2V0QXBpIiwiYWN0IiwiZ2VuZXJhdG9yTWV0YSIsInZub2RlIiwicmVuZGVyUHJvcHMiLCJjb250YWluZXJFbCIsImYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@fullcalendar/react/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@fullcalendar/timegrid/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@fullcalendar/timegrid/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ index)\n/* harmony export */ });\n/* harmony import */ var _fullcalendar_core_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fullcalendar/core/index.js */ \"(ssr)/./node_modules/@fullcalendar/core/index.js\");\n/* harmony import */ var _internal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal.js */ \"(ssr)/./node_modules/@fullcalendar/timegrid/internal.js\");\n\n\n\n\n\nconst OPTION_REFINERS = {\n    allDaySlot: Boolean\n};\nvar index = (0,_fullcalendar_core_index_js__WEBPACK_IMPORTED_MODULE_0__.createPlugin)({\n    name: \"@fullcalendar/timegrid\",\n    initialView: \"timeGridWeek\",\n    optionRefiners: OPTION_REFINERS,\n    views: {\n        timeGrid: {\n            component: _internal_js__WEBPACK_IMPORTED_MODULE_1__.DayTimeColsView,\n            usesMinMaxTime: true,\n            allDaySlot: true,\n            slotDuration: \"00:30:00\",\n            slotEventOverlap: true\n        },\n        timeGridDay: {\n            type: \"timeGrid\",\n            duration: {\n                days: 1\n            }\n        },\n        timeGridWeek: {\n            type: \"timeGrid\",\n            duration: {\n                weeks: 1\n            }\n        }\n    }\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci90aW1lZ3JpZC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMkQ7QUFDWDtBQUNSO0FBQ0Y7QUFDSztBQUUzQyxNQUFNRSxrQkFBa0I7SUFDcEJDLFlBQVlDO0FBQ2hCO0FBRUEsSUFBSUMsUUFBUUwseUVBQVlBLENBQUM7SUFDckJNLE1BQU07SUFDTkMsYUFBYTtJQUNiQyxnQkFBZ0JOO0lBQ2hCTyxPQUFPO1FBQ0hDLFVBQVU7WUFDTkMsV0FBV1YseURBQWVBO1lBQzFCVyxnQkFBZ0I7WUFDaEJULFlBQVk7WUFDWlUsY0FBYztZQUNkQyxrQkFBa0I7UUFDdEI7UUFDQUMsYUFBYTtZQUNUQyxNQUFNO1lBQ05DLFVBQVU7Z0JBQUVDLE1BQU07WUFBRTtRQUN4QjtRQUNBQyxjQUFjO1lBQ1ZILE1BQU07WUFDTkMsVUFBVTtnQkFBRUcsT0FBTztZQUFFO1FBQ3pCO0lBQ0o7QUFDSjtBQUU0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlaGFzcG9ydC1tYW5hZ2VtZW50Ly4vbm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvdGltZWdyaWQvaW5kZXguanM/YWY3MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVQbHVnaW4gfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUvaW5kZXguanMnO1xuaW1wb3J0IHsgRGF5VGltZUNvbHNWaWV3IH0gZnJvbSAnLi9pbnRlcm5hbC5qcyc7XG5pbXBvcnQgJ0BmdWxsY2FsZW5kYXIvY29yZS9pbnRlcm5hbC5qcyc7XG5pbXBvcnQgJ0BmdWxsY2FsZW5kYXIvY29yZS9wcmVhY3QuanMnO1xuaW1wb3J0ICdAZnVsbGNhbGVuZGFyL2RheWdyaWQvaW50ZXJuYWwuanMnO1xuXG5jb25zdCBPUFRJT05fUkVGSU5FUlMgPSB7XG4gICAgYWxsRGF5U2xvdDogQm9vbGVhbixcbn07XG5cbnZhciBpbmRleCA9IGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogJ0BmdWxsY2FsZW5kYXIvdGltZWdyaWQnLFxuICAgIGluaXRpYWxWaWV3OiAndGltZUdyaWRXZWVrJyxcbiAgICBvcHRpb25SZWZpbmVyczogT1BUSU9OX1JFRklORVJTLFxuICAgIHZpZXdzOiB7XG4gICAgICAgIHRpbWVHcmlkOiB7XG4gICAgICAgICAgICBjb21wb25lbnQ6IERheVRpbWVDb2xzVmlldyxcbiAgICAgICAgICAgIHVzZXNNaW5NYXhUaW1lOiB0cnVlLFxuICAgICAgICAgICAgYWxsRGF5U2xvdDogdHJ1ZSxcbiAgICAgICAgICAgIHNsb3REdXJhdGlvbjogJzAwOjMwOjAwJyxcbiAgICAgICAgICAgIHNsb3RFdmVudE92ZXJsYXA6IHRydWUsIC8vIGEgYmFkIG5hbWUuIGNvbmZ1c2VkIHdpdGggb3ZlcmxhcC9jb25zdHJhaW50IHN5c3RlbVxuICAgICAgICB9LFxuICAgICAgICB0aW1lR3JpZERheToge1xuICAgICAgICAgICAgdHlwZTogJ3RpbWVHcmlkJyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB7IGRheXM6IDEgfSxcbiAgICAgICAgfSxcbiAgICAgICAgdGltZUdyaWRXZWVrOiB7XG4gICAgICAgICAgICB0eXBlOiAndGltZUdyaWQnLFxuICAgICAgICAgICAgZHVyYXRpb246IHsgd2Vla3M6IDEgfSxcbiAgICAgICAgfSxcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IGluZGV4IGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6WyJjcmVhdGVQbHVnaW4iLCJEYXlUaW1lQ29sc1ZpZXciLCJPUFRJT05fUkVGSU5FUlMiLCJhbGxEYXlTbG90IiwiQm9vbGVhbiIsImluZGV4IiwibmFtZSIsImluaXRpYWxWaWV3Iiwib3B0aW9uUmVmaW5lcnMiLCJ2aWV3cyIsInRpbWVHcmlkIiwiY29tcG9uZW50IiwidXNlc01pbk1heFRpbWUiLCJzbG90RHVyYXRpb24iLCJzbG90RXZlbnRPdmVybGFwIiwidGltZUdyaWREYXkiLCJ0eXBlIiwiZHVyYXRpb24iLCJkYXlzIiwidGltZUdyaWRXZWVrIiwid2Vla3MiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@fullcalendar/timegrid/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@fullcalendar/timegrid/internal.js":
/*!*********************************************************!*\
  !*** ./node_modules/@fullcalendar/timegrid/internal.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DayTimeCols: () => (/* binding */ DayTimeCols),\n/* harmony export */   DayTimeColsSlicer: () => (/* binding */ DayTimeColsSlicer),\n/* harmony export */   DayTimeColsView: () => (/* binding */ DayTimeColsView),\n/* harmony export */   TimeCols: () => (/* binding */ TimeCols),\n/* harmony export */   TimeColsSlatsCoords: () => (/* binding */ TimeColsSlatsCoords),\n/* harmony export */   TimeColsView: () => (/* binding */ TimeColsView),\n/* harmony export */   buildDayRanges: () => (/* binding */ buildDayRanges),\n/* harmony export */   buildSlatMetas: () => (/* binding */ buildSlatMetas),\n/* harmony export */   buildTimeColsModel: () => (/* binding */ buildTimeColsModel)\n/* harmony export */ });\n/* harmony import */ var _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fullcalendar/core/internal.js */ \"(ssr)/./node_modules/@fullcalendar/core/internal-common.js\");\n/* harmony import */ var _fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fullcalendar/core/preact.js */ \"(ssr)/./node_modules/preact/dist/preact.mjs\");\n/* harmony import */ var _fullcalendar_daygrid_internal_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fullcalendar/daygrid/internal.js */ \"(ssr)/./node_modules/@fullcalendar/daygrid/internal.js\");\n\n\n\nclass AllDaySplitter extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.aY {\n    getKeyInfo() {\n        return {\n            allDay: {},\n            timed: {}\n        };\n    }\n    getKeysForDateSpan(dateSpan) {\n        if (dateSpan.allDay) {\n            return [\n                \"allDay\"\n            ];\n        }\n        return [\n            \"timed\"\n        ];\n    }\n    getKeysForEventDef(eventDef) {\n        if (!eventDef.allDay) {\n            return [\n                \"timed\"\n            ];\n        }\n        if ((0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bP)(eventDef)) {\n            return [\n                \"timed\",\n                \"allDay\"\n            ];\n        }\n        return [\n            \"allDay\"\n        ];\n    }\n}\nconst DEFAULT_SLAT_LABEL_FORMAT = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.x)({\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    omitZeroMinute: true,\n    meridiem: \"short\"\n});\nfunction TimeColsAxisCell(props) {\n    let classNames = [\n        \"fc-timegrid-slot\",\n        \"fc-timegrid-slot-label\",\n        props.isLabeled ? \"fc-scrollgrid-shrink\" : \"fc-timegrid-slot-minor\"\n    ];\n    return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.V.Consumer, null, (context)=>{\n        if (!props.isLabeled) {\n            return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"td\", {\n                className: classNames.join(\" \"),\n                \"data-time\": props.isoTimeStr\n            });\n        }\n        let { dateEnv, options, viewApi } = context;\n        let labelFormat = options.slotLabelFormat == null ? DEFAULT_SLAT_LABEL_FORMAT : Array.isArray(options.slotLabelFormat) ? (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.x)(options.slotLabelFormat[0]) : (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.x)(options.slotLabelFormat);\n        let renderProps = {\n            level: 0,\n            time: props.time,\n            date: dateEnv.toDate(props.date),\n            view: viewApi,\n            text: dateEnv.format(props.date, labelFormat)\n        };\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.C, {\n            elTag: \"td\",\n            elClasses: classNames,\n            elAttrs: {\n                \"data-time\": props.isoTimeStr\n            },\n            renderProps: renderProps,\n            generatorName: \"slotLabelContent\",\n            customGenerator: options.slotLabelContent,\n            defaultGenerator: renderInnerContent,\n            classNameGenerator: options.slotLabelClassNames,\n            didMount: options.slotLabelDidMount,\n            willUnmount: options.slotLabelWillUnmount\n        }, (InnerContent)=>(0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-timegrid-slot-label-frame fc-scrollgrid-shrink-frame\"\n            }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(InnerContent, {\n                elTag: \"div\",\n                elClasses: [\n                    \"fc-timegrid-slot-label-cushion\",\n                    \"fc-scrollgrid-shrink-cushion\"\n                ]\n            })));\n    });\n}\nfunction renderInnerContent(props) {\n    return props.text;\n}\nclass TimeBodyAxis extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    render() {\n        return this.props.slatMetas.map((slatMeta)=>(0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", {\n                key: slatMeta.key\n            }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TimeColsAxisCell, Object.assign({}, slatMeta))));\n    }\n}\nconst DEFAULT_WEEK_NUM_FORMAT = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.x)({\n    week: \"short\"\n});\nconst AUTO_ALL_DAY_MAX_EVENT_ROWS = 5;\nclass TimeColsView extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.be {\n    constructor(){\n        super(...arguments);\n        this.allDaySplitter = new AllDaySplitter(); // for use by subclasses\n        this.headerElRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        this.rootElRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        this.scrollerElRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        this.state = {\n            slatCoords: null\n        };\n        this.handleScrollTopRequest = (scrollTop)=>{\n            let scrollerEl = this.scrollerElRef.current;\n            if (scrollerEl) {\n                scrollerEl.scrollTop = scrollTop;\n            }\n        };\n        /* Header Render Methods\n        ------------------------------------------------------------------------------------------------------------------*/ this.renderHeadAxis = (rowKey, frameHeight = \"\")=>{\n            let { options } = this.context;\n            let { dateProfile } = this.props;\n            let range = dateProfile.renderRange;\n            let dayCnt = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bl)(range.start, range.end);\n            // only do in day views (to avoid doing in week views that dont need it)\n            let navLinkAttrs = dayCnt === 1 ? (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.b0)(this.context, range.start, \"week\") : {};\n            if (options.weekNumbers && rowKey === \"day\") {\n                return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cq, {\n                    elTag: \"th\",\n                    elClasses: [\n                        \"fc-timegrid-axis\",\n                        \"fc-scrollgrid-shrink\"\n                    ],\n                    elAttrs: {\n                        \"aria-hidden\": true\n                    },\n                    date: range.start,\n                    defaultFormat: DEFAULT_WEEK_NUM_FORMAT\n                }, (InnerContent)=>(0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                        className: [\n                            \"fc-timegrid-axis-frame\",\n                            \"fc-scrollgrid-shrink-frame\",\n                            \"fc-timegrid-axis-frame-liquid\"\n                        ].join(\" \"),\n                        style: {\n                            height: frameHeight\n                        }\n                    }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(InnerContent, {\n                        elTag: \"a\",\n                        elClasses: [\n                            \"fc-timegrid-axis-cushion\",\n                            \"fc-scrollgrid-shrink-cushion\",\n                            \"fc-scrollgrid-sync-inner\"\n                        ],\n                        elAttrs: navLinkAttrs\n                    })));\n            }\n            return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"th\", {\n                \"aria-hidden\": true,\n                className: \"fc-timegrid-axis\"\n            }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-timegrid-axis-frame\",\n                style: {\n                    height: frameHeight\n                }\n            }));\n        };\n        /* Table Component Render Methods\n        ------------------------------------------------------------------------------------------------------------------*/ // only a one-way height sync. we don't send the axis inner-content height to the DayGrid,\n        // but DayGrid still needs to have classNames on inner elements in order to measure.\n        this.renderTableRowAxis = (rowHeight)=>{\n            let { options, viewApi } = this.context;\n            let renderProps = {\n                text: options.allDayText,\n                view: viewApi\n            };\n            return(// TODO: make reusable hook. used in list view too\n            (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.C, {\n                elTag: \"td\",\n                elClasses: [\n                    \"fc-timegrid-axis\",\n                    \"fc-scrollgrid-shrink\"\n                ],\n                elAttrs: {\n                    \"aria-hidden\": true\n                },\n                renderProps: renderProps,\n                generatorName: \"allDayContent\",\n                customGenerator: options.allDayContent,\n                defaultGenerator: renderAllDayInner,\n                classNameGenerator: options.allDayClassNames,\n                didMount: options.allDayDidMount,\n                willUnmount: options.allDayWillUnmount\n            }, (InnerContent)=>(0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                    className: [\n                        \"fc-timegrid-axis-frame\",\n                        \"fc-scrollgrid-shrink-frame\",\n                        rowHeight == null ? \" fc-timegrid-axis-frame-liquid\" : \"\"\n                    ].join(\" \"),\n                    style: {\n                        height: rowHeight\n                    }\n                }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(InnerContent, {\n                    elTag: \"span\",\n                    elClasses: [\n                        \"fc-timegrid-axis-cushion\",\n                        \"fc-scrollgrid-shrink-cushion\",\n                        \"fc-scrollgrid-sync-inner\"\n                    ]\n                }))));\n        };\n        this.handleSlatCoords = (slatCoords)=>{\n            this.setState({\n                slatCoords\n            });\n        };\n    }\n    // rendering\n    // ----------------------------------------------------------------------------------------------------\n    renderSimpleLayout(headerRowContent, allDayContent, timeContent) {\n        let { context, props } = this;\n        let sections = [];\n        let stickyHeaderDates = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cc)(context.options);\n        if (headerRowContent) {\n            sections.push({\n                type: \"header\",\n                key: \"header\",\n                isSticky: stickyHeaderDates,\n                chunk: {\n                    elRef: this.headerElRef,\n                    tableClassName: \"fc-col-header\",\n                    rowContent: headerRowContent\n                }\n            });\n        }\n        if (allDayContent) {\n            sections.push({\n                type: \"body\",\n                key: \"all-day\",\n                chunk: {\n                    content: allDayContent\n                }\n            });\n            sections.push({\n                type: \"body\",\n                key: \"all-day-divider\",\n                outerContent: (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", {\n                    role: \"presentation\",\n                    className: \"fc-scrollgrid-section\"\n                }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"td\", {\n                    className: \"fc-timegrid-divider \" + context.theme.getClass(\"tableCellShaded\")\n                }))\n            });\n        }\n        sections.push({\n            type: \"body\",\n            key: \"body\",\n            liquid: true,\n            expandRows: Boolean(context.options.expandRows),\n            chunk: {\n                scrollerElRef: this.scrollerElRef,\n                content: timeContent\n            }\n        });\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ct, {\n            elRef: this.rootElRef,\n            elClasses: [\n                \"fc-timegrid\"\n            ],\n            viewSpec: context.viewSpec\n        }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.b$, {\n            liquid: !props.isHeightAuto && !props.forPrint,\n            collapsibleWidth: props.forPrint,\n            cols: [\n                {\n                    width: \"shrink\"\n                }\n            ],\n            sections: sections\n        }));\n    }\n    renderHScrollLayout(headerRowContent, allDayContent, timeContent, colCnt, dayMinWidth, slatMetas, slatCoords) {\n        let ScrollGrid = this.context.pluginHooks.scrollGridImpl;\n        if (!ScrollGrid) {\n            throw new Error(\"No ScrollGrid implementation\");\n        }\n        let { context, props } = this;\n        let stickyHeaderDates = !props.forPrint && (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cc)(context.options);\n        let stickyFooterScrollbar = !props.forPrint && (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cb)(context.options);\n        let sections = [];\n        if (headerRowContent) {\n            sections.push({\n                type: \"header\",\n                key: \"header\",\n                isSticky: stickyHeaderDates,\n                syncRowHeights: true,\n                chunks: [\n                    {\n                        key: \"axis\",\n                        rowContent: (arg)=>(0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", {\n                                role: \"presentation\"\n                            }, this.renderHeadAxis(\"day\", arg.rowSyncHeights[0]))\n                    },\n                    {\n                        key: \"cols\",\n                        elRef: this.headerElRef,\n                        tableClassName: \"fc-col-header\",\n                        rowContent: headerRowContent\n                    }\n                ]\n            });\n        }\n        if (allDayContent) {\n            sections.push({\n                type: \"body\",\n                key: \"all-day\",\n                syncRowHeights: true,\n                chunks: [\n                    {\n                        key: \"axis\",\n                        rowContent: (contentArg)=>(0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", {\n                                role: \"presentation\"\n                            }, this.renderTableRowAxis(contentArg.rowSyncHeights[0]))\n                    },\n                    {\n                        key: \"cols\",\n                        content: allDayContent\n                    }\n                ]\n            });\n            sections.push({\n                key: \"all-day-divider\",\n                type: \"body\",\n                outerContent: (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", {\n                    role: \"presentation\",\n                    className: \"fc-scrollgrid-section\"\n                }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"td\", {\n                    colSpan: 2,\n                    className: \"fc-timegrid-divider \" + context.theme.getClass(\"tableCellShaded\")\n                }))\n            });\n        }\n        let isNowIndicator = context.options.nowIndicator;\n        sections.push({\n            type: \"body\",\n            key: \"body\",\n            liquid: true,\n            expandRows: Boolean(context.options.expandRows),\n            chunks: [\n                {\n                    key: \"axis\",\n                    content: (arg)=>// TODO: make this now-indicator arrow more DRY with TimeColsContent\n                        (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                            className: \"fc-timegrid-axis-chunk\"\n                        }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"table\", {\n                            \"aria-hidden\": true,\n                            style: {\n                                height: arg.expandRows ? arg.clientHeight : \"\"\n                            }\n                        }, arg.tableColGroupNode, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tbody\", null, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TimeBodyAxis, {\n                            slatMetas: slatMetas\n                        }))), (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                            className: \"fc-timegrid-now-indicator-container\"\n                        }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ch, {\n                            unit: isNowIndicator ? \"minute\" : \"day\" /* hacky */ \n                        }, (nowDate)=>{\n                            let nowIndicatorTop = isNowIndicator && slatCoords && slatCoords.safeComputeTop(nowDate); // might return void\n                            if (typeof nowIndicatorTop === \"number\") {\n                                return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ck, {\n                                    elClasses: [\n                                        \"fc-timegrid-now-indicator-arrow\"\n                                    ],\n                                    elStyle: {\n                                        top: nowIndicatorTop\n                                    },\n                                    isAxis: true,\n                                    date: nowDate\n                                });\n                            }\n                            return null;\n                        })))\n                },\n                {\n                    key: \"cols\",\n                    scrollerElRef: this.scrollerElRef,\n                    content: timeContent\n                }\n            ]\n        });\n        if (stickyFooterScrollbar) {\n            sections.push({\n                key: \"footer\",\n                type: \"footer\",\n                isSticky: true,\n                chunks: [\n                    {\n                        key: \"axis\",\n                        content: _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ca\n                    },\n                    {\n                        key: \"cols\",\n                        content: _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ca\n                    }\n                ]\n            });\n        }\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ct, {\n            elRef: this.rootElRef,\n            elClasses: [\n                \"fc-timegrid\"\n            ],\n            viewSpec: context.viewSpec\n        }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ScrollGrid, {\n            liquid: !props.isHeightAuto && !props.forPrint,\n            forPrint: props.forPrint,\n            collapsibleWidth: false,\n            colGroups: [\n                {\n                    width: \"shrink\",\n                    cols: [\n                        {\n                            width: \"shrink\"\n                        }\n                    ]\n                },\n                {\n                    cols: [\n                        {\n                            span: colCnt,\n                            minWidth: dayMinWidth\n                        }\n                    ]\n                }\n            ],\n            sections: sections\n        }));\n    }\n    /* Dimensions\n    ------------------------------------------------------------------------------------------------------------------*/ getAllDayMaxEventProps() {\n        let { dayMaxEvents, dayMaxEventRows } = this.context.options;\n        if (dayMaxEvents === true || dayMaxEventRows === true) {\n            dayMaxEvents = undefined;\n            dayMaxEventRows = AUTO_ALL_DAY_MAX_EVENT_ROWS; // make sure \"auto\" goes to a real number\n        }\n        return {\n            dayMaxEvents,\n            dayMaxEventRows\n        };\n    }\n}\nfunction renderAllDayInner(renderProps) {\n    return renderProps.text;\n}\nclass TimeColsSlatsCoords {\n    constructor(positions, dateProfile, slotDuration){\n        this.positions = positions;\n        this.dateProfile = dateProfile;\n        this.slotDuration = slotDuration;\n    }\n    safeComputeTop(date) {\n        let { dateProfile } = this;\n        if ((0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.H)(dateProfile.currentRange, date)) {\n            let startOfDayDate = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.q)(date);\n            let timeMs = date.valueOf() - startOfDayDate.valueOf();\n            if (timeMs >= (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bs)(dateProfile.slotMinTime) && timeMs < (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bs)(dateProfile.slotMaxTime)) {\n                return this.computeTimeTop((0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.d)(timeMs));\n            }\n        }\n        return null;\n    }\n    // Computes the top coordinate, relative to the bounds of the grid, of the given date.\n    // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.\n    computeDateTop(when, startOfDayDate) {\n        if (!startOfDayDate) {\n            startOfDayDate = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.q)(when);\n        }\n        return this.computeTimeTop((0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.d)(when.valueOf() - startOfDayDate.valueOf()));\n    }\n    // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).\n    // This is a makeshify way to compute the time-top. Assumes all slatMetas dates are uniform.\n    // Eventually allow computation with arbirary slat dates.\n    computeTimeTop(duration) {\n        let { positions, dateProfile } = this;\n        let len = positions.els.length;\n        // floating-point value of # of slots covered\n        let slatCoverage = (duration.milliseconds - (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bs)(dateProfile.slotMinTime)) / (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bs)(this.slotDuration);\n        let slatIndex;\n        let slatRemainder;\n        // compute a floating-point number for how many slats should be progressed through.\n        // from 0 to number of slats (inclusive)\n        // constrained because slotMinTime/slotMaxTime might be customized.\n        slatCoverage = Math.max(0, slatCoverage);\n        slatCoverage = Math.min(len, slatCoverage);\n        // an integer index of the furthest whole slat\n        // from 0 to number slats (*exclusive*, so len-1)\n        slatIndex = Math.floor(slatCoverage);\n        slatIndex = Math.min(slatIndex, len - 1);\n        // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.\n        // could be 1.0 if slatCoverage is covering *all* the slots\n        slatRemainder = slatCoverage - slatIndex;\n        return positions.tops[slatIndex] + positions.getHeight(slatIndex) * slatRemainder;\n    }\n}\nclass TimeColsSlatsBody extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    render() {\n        let { props, context } = this;\n        let { options } = context;\n        let { slatElRefs } = props;\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tbody\", null, props.slatMetas.map((slatMeta, i)=>{\n            let renderProps = {\n                time: slatMeta.time,\n                date: context.dateEnv.toDate(slatMeta.date),\n                view: context.viewApi\n            };\n            return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", {\n                key: slatMeta.key,\n                ref: slatElRefs.createRef(slatMeta.key)\n            }, props.axis && (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TimeColsAxisCell, Object.assign({}, slatMeta)), (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.C, {\n                elTag: \"td\",\n                elClasses: [\n                    \"fc-timegrid-slot\",\n                    \"fc-timegrid-slot-lane\",\n                    !slatMeta.isLabeled && \"fc-timegrid-slot-minor\"\n                ],\n                elAttrs: {\n                    \"data-time\": slatMeta.isoTimeStr\n                },\n                renderProps: renderProps,\n                generatorName: \"slotLaneContent\",\n                customGenerator: options.slotLaneContent,\n                classNameGenerator: options.slotLaneClassNames,\n                didMount: options.slotLaneDidMount,\n                willUnmount: options.slotLaneWillUnmount\n            }));\n        }));\n    }\n}\n/*\nfor the horizontal \"slats\" that run width-wise. Has a time axis on a side. Depends on RTL.\n*/ class TimeColsSlats extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    constructor(){\n        super(...arguments);\n        this.rootElRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        this.slatElRefs = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cf();\n    }\n    render() {\n        let { props, context } = this;\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            ref: this.rootElRef,\n            className: \"fc-timegrid-slots\"\n        }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"table\", {\n            \"aria-hidden\": true,\n            className: context.theme.getClass(\"table\"),\n            style: {\n                minWidth: props.tableMinWidth,\n                width: props.clientWidth,\n                height: props.minHeight\n            }\n        }, props.tableColGroupNode /* relies on there only being a single <col> for the axis */ , (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TimeColsSlatsBody, {\n            slatElRefs: this.slatElRefs,\n            axis: props.axis,\n            slatMetas: props.slatMetas\n        })));\n    }\n    componentDidMount() {\n        this.updateSizing();\n    }\n    componentDidUpdate() {\n        this.updateSizing();\n    }\n    componentWillUnmount() {\n        if (this.props.onCoords) {\n            this.props.onCoords(null);\n        }\n    }\n    updateSizing() {\n        let { context, props } = this;\n        if (props.onCoords && props.clientWidth !== null // means sizing has stabilized\n        ) {\n            let rootEl = this.rootElRef.current;\n            if (rootEl.offsetHeight) {\n                props.onCoords(new TimeColsSlatsCoords(new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ba(this.rootElRef.current, collectSlatEls(this.slatElRefs.currentMap, props.slatMetas), false, true), this.props.dateProfile, context.options.slotDuration));\n            }\n        }\n    }\n}\nfunction collectSlatEls(elMap, slatMetas) {\n    return slatMetas.map((slatMeta)=>elMap[slatMeta.key]);\n}\nfunction splitSegsByCol(segs, colCnt) {\n    let segsByCol = [];\n    let i;\n    for(i = 0; i < colCnt; i += 1){\n        segsByCol.push([]);\n    }\n    if (segs) {\n        for(i = 0; i < segs.length; i += 1){\n            segsByCol[segs[i].col].push(segs[i]);\n        }\n    }\n    return segsByCol;\n}\nfunction splitInteractionByCol(ui, colCnt) {\n    let byRow = [];\n    if (!ui) {\n        for(let i = 0; i < colCnt; i += 1){\n            byRow[i] = null;\n        }\n    } else {\n        for(let i = 0; i < colCnt; i += 1){\n            byRow[i] = {\n                affectedInstances: ui.affectedInstances,\n                isEvent: ui.isEvent,\n                segs: []\n            };\n        }\n        for (let seg of ui.segs){\n            byRow[seg.col].segs.push(seg);\n        }\n    }\n    return byRow;\n}\nclass TimeColMoreLink extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    render() {\n        let { props } = this;\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cr, {\n            elClasses: [\n                \"fc-timegrid-more-link\"\n            ],\n            elStyle: {\n                top: props.top,\n                bottom: props.bottom\n            },\n            allDayDate: null,\n            moreCnt: props.hiddenSegs.length,\n            allSegs: props.hiddenSegs,\n            hiddenSegs: props.hiddenSegs,\n            extraDateSpan: props.extraDateSpan,\n            dateProfile: props.dateProfile,\n            todayRange: props.todayRange,\n            popoverContent: ()=>renderPlainFgSegs(props.hiddenSegs, props),\n            defaultGenerator: renderMoreLinkInner,\n            forceTimed: true\n        }, (InnerContent)=>(0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(InnerContent, {\n                elTag: \"div\",\n                elClasses: [\n                    \"fc-timegrid-more-link-inner\",\n                    \"fc-sticky\"\n                ]\n            }));\n    }\n}\nfunction renderMoreLinkInner(props) {\n    return props.shortText;\n}\n// segInputs assumed sorted\nfunction buildPositioning(segInputs, strictOrder, maxStackCnt) {\n    let hierarchy = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bA();\n    if (strictOrder != null) {\n        hierarchy.strictOrder = strictOrder;\n    }\n    if (maxStackCnt != null) {\n        hierarchy.maxStackCnt = maxStackCnt;\n    }\n    let hiddenEntries = hierarchy.addSegs(segInputs);\n    let hiddenGroups = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bE)(hiddenEntries);\n    let web = buildWeb(hierarchy);\n    web = stretchWeb(web, 1); // all levelCoords/thickness will have 0.0-1.0\n    let segRects = webToRects(web);\n    return {\n        segRects,\n        hiddenGroups\n    };\n}\nfunction buildWeb(hierarchy) {\n    const { entriesByLevel } = hierarchy;\n    const buildNode = cacheable((level, lateral)=>level + \":\" + lateral, (level, lateral)=>{\n        let siblingRange = findNextLevelSegs(hierarchy, level, lateral);\n        let nextLevelRes = buildNodes(siblingRange, buildNode);\n        let entry = entriesByLevel[level][lateral];\n        return [\n            Object.assign(Object.assign({}, entry), {\n                nextLevelNodes: nextLevelRes[0]\n            }),\n            entry.thickness + nextLevelRes[1]\n        ];\n    });\n    return buildNodes(entriesByLevel.length ? {\n        level: 0,\n        lateralStart: 0,\n        lateralEnd: entriesByLevel[0].length\n    } : null, buildNode)[0];\n}\nfunction buildNodes(siblingRange, buildNode) {\n    if (!siblingRange) {\n        return [\n            [],\n            0\n        ];\n    }\n    let { level, lateralStart, lateralEnd } = siblingRange;\n    let lateral = lateralStart;\n    let pairs = [];\n    while(lateral < lateralEnd){\n        pairs.push(buildNode(level, lateral));\n        lateral += 1;\n    }\n    pairs.sort(cmpDescPressures);\n    return [\n        pairs.map(extractNode),\n        pairs[0][1]\n    ];\n}\nfunction cmpDescPressures(a, b) {\n    return b[1] - a[1];\n}\nfunction extractNode(a) {\n    return a[0];\n}\nfunction findNextLevelSegs(hierarchy, subjectLevel, subjectLateral) {\n    let { levelCoords, entriesByLevel } = hierarchy;\n    let subjectEntry = entriesByLevel[subjectLevel][subjectLateral];\n    let afterSubject = levelCoords[subjectLevel] + subjectEntry.thickness;\n    let levelCnt = levelCoords.length;\n    let level = subjectLevel;\n    // skip past levels that are too high up\n    for(; level < levelCnt && levelCoords[level] < afterSubject; level += 1); // do nothing\n    for(; level < levelCnt; level += 1){\n        let entries = entriesByLevel[level];\n        let entry;\n        let searchIndex = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bD)(entries, subjectEntry.span.start, _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bC);\n        let lateralStart = searchIndex[0] + searchIndex[1]; // if exact match (which doesn't collide), go to next one\n        let lateralEnd = lateralStart;\n        while((entry = entries[lateralEnd]) && // but not past the whole seg list\n        entry.span.start < subjectEntry.span.end){\n            lateralEnd += 1;\n        }\n        if (lateralStart < lateralEnd) {\n            return {\n                level,\n                lateralStart,\n                lateralEnd\n            };\n        }\n    }\n    return null;\n}\nfunction stretchWeb(topLevelNodes, totalThickness) {\n    const stretchNode = cacheable((node, startCoord, prevThickness)=>(0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bB)(node), (node, startCoord, prevThickness)=>{\n        let { nextLevelNodes, thickness } = node;\n        let allThickness = thickness + prevThickness;\n        let thicknessFraction = thickness / allThickness;\n        let endCoord;\n        let newChildren = [];\n        if (!nextLevelNodes.length) {\n            endCoord = totalThickness;\n        } else {\n            for (let childNode of nextLevelNodes){\n                if (endCoord === undefined) {\n                    let res = stretchNode(childNode, startCoord, allThickness);\n                    endCoord = res[0];\n                    newChildren.push(res[1]);\n                } else {\n                    let res = stretchNode(childNode, endCoord, 0);\n                    newChildren.push(res[1]);\n                }\n            }\n        }\n        let newThickness = (endCoord - startCoord) * thicknessFraction;\n        return [\n            endCoord - newThickness,\n            Object.assign(Object.assign({}, node), {\n                thickness: newThickness,\n                nextLevelNodes: newChildren\n            })\n        ];\n    });\n    return topLevelNodes.map((node)=>stretchNode(node, 0, 0)[1]);\n}\n// not sorted in any particular order\nfunction webToRects(topLevelNodes) {\n    let rects = [];\n    const processNode = cacheable((node, levelCoord, stackDepth)=>(0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bB)(node), (node, levelCoord, stackDepth)=>{\n        let rect = Object.assign(Object.assign({}, node), {\n            levelCoord,\n            stackDepth,\n            stackForward: 0\n        });\n        rects.push(rect);\n        return rect.stackForward = processNodes(node.nextLevelNodes, levelCoord + node.thickness, stackDepth + 1) + 1;\n    });\n    function processNodes(nodes, levelCoord, stackDepth) {\n        let stackForward = 0;\n        for (let node of nodes){\n            stackForward = Math.max(processNode(node, levelCoord, stackDepth), stackForward);\n        }\n        return stackForward;\n    }\n    processNodes(topLevelNodes, 0, 0);\n    return rects; // TODO: sort rects by levelCoord to be consistent with toRects?\n}\n// TODO: move to general util\nfunction cacheable(keyFunc, workFunc) {\n    const cache = {};\n    return (...args)=>{\n        let key = keyFunc(...args);\n        return key in cache ? cache[key] : cache[key] = workFunc(...args);\n    };\n}\nfunction computeSegVCoords(segs, colDate, slatCoords = null, eventMinHeight = 0) {\n    let vcoords = [];\n    if (slatCoords) {\n        for(let i = 0; i < segs.length; i += 1){\n            let seg = segs[i];\n            let spanStart = slatCoords.computeDateTop(seg.start, colDate);\n            let spanEnd = Math.max(spanStart + (eventMinHeight || 0), slatCoords.computeDateTop(seg.end, colDate));\n            vcoords.push({\n                start: Math.round(spanStart),\n                end: Math.round(spanEnd)\n            });\n        }\n    }\n    return vcoords;\n}\nfunction computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack) {\n    let segInputs = [];\n    let dumbSegs = []; // segs without coords\n    for(let i = 0; i < segs.length; i += 1){\n        let vcoords = segVCoords[i];\n        if (vcoords) {\n            segInputs.push({\n                index: i,\n                thickness: 1,\n                span: vcoords\n            });\n        } else {\n            dumbSegs.push(segs[i]);\n        }\n    }\n    let { segRects, hiddenGroups } = buildPositioning(segInputs, eventOrderStrict, eventMaxStack);\n    let segPlacements = [];\n    for (let segRect of segRects){\n        segPlacements.push({\n            seg: segs[segRect.index],\n            rect: segRect\n        });\n    }\n    for (let dumbSeg of dumbSegs){\n        segPlacements.push({\n            seg: dumbSeg,\n            rect: null\n        });\n    }\n    return {\n        segPlacements,\n        hiddenGroups\n    };\n}\nconst DEFAULT_TIME_FORMAT = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.x)({\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    meridiem: false\n});\nclass TimeColEvent extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    render() {\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cj, Object.assign({}, this.props, {\n            elClasses: [\n                \"fc-timegrid-event\",\n                \"fc-v-event\",\n                this.props.isShort && \"fc-timegrid-event-short\"\n            ],\n            defaultTimeFormat: DEFAULT_TIME_FORMAT\n        }));\n    }\n}\nclass TimeCol extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    constructor(){\n        super(...arguments);\n        this.sortEventSegs = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bR);\n    }\n    // TODO: memoize event-placement?\n    render() {\n        let { props, context } = this;\n        let { options } = context;\n        let isSelectMirror = options.selectMirror;\n        let mirrorSegs = props.eventDrag && props.eventDrag.segs || props.eventResize && props.eventResize.segs || isSelectMirror && props.dateSelectionSegs || [];\n        let interactionAffectedInstances = props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {};\n        let sortedFgSegs = this.sortEventSegs(props.fgEventSegs, options.eventOrder);\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cl, {\n            elTag: \"td\",\n            elRef: props.elRef,\n            elClasses: [\n                \"fc-timegrid-col\",\n                ...props.extraClassNames || []\n            ],\n            elAttrs: Object.assign({\n                role: \"gridcell\"\n            }, props.extraDataAttrs),\n            date: props.date,\n            dateProfile: props.dateProfile,\n            todayRange: props.todayRange,\n            extraRenderProps: props.extraRenderProps\n        }, (InnerContent)=>(0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-timegrid-col-frame\"\n            }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-timegrid-col-bg\"\n            }, this.renderFillSegs(props.businessHourSegs, \"non-business\"), this.renderFillSegs(props.bgEventSegs, \"bg-event\"), this.renderFillSegs(props.dateSelectionSegs, \"highlight\")), (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-timegrid-col-events\"\n            }, this.renderFgSegs(sortedFgSegs, interactionAffectedInstances, false, false, false)), (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-timegrid-col-events\"\n            }, this.renderFgSegs(mirrorSegs, {}, Boolean(props.eventDrag), Boolean(props.eventResize), Boolean(isSelectMirror), \"mirror\")), (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-timegrid-now-indicator-container\"\n            }, this.renderNowIndicator(props.nowIndicatorSegs)), (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cm)(options) && (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(InnerContent, {\n                elTag: \"div\",\n                elClasses: [\n                    \"fc-timegrid-col-misc\"\n                ]\n            })));\n    }\n    renderFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting, forcedKey) {\n        let { props } = this;\n        if (props.forPrint) {\n            return renderPlainFgSegs(sortedFgSegs, props);\n        }\n        return this.renderPositionedFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting, forcedKey);\n    }\n    renderPositionedFgSegs(segs, segIsInvisible, isDragging, isResizing, isDateSelecting, forcedKey) {\n        let { eventMaxStack, eventShortHeight, eventOrderStrict, eventMinHeight } = this.context.options;\n        let { date, slatCoords, eventSelection, todayRange, nowDate } = this.props;\n        let isMirror = isDragging || isResizing || isDateSelecting;\n        let segVCoords = computeSegVCoords(segs, date, slatCoords, eventMinHeight);\n        let { segPlacements, hiddenGroups } = computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack);\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, this.renderHiddenGroups(hiddenGroups, segs), segPlacements.map((segPlacement)=>{\n            let { seg, rect } = segPlacement;\n            let instanceId = seg.eventRange.instance.instanceId;\n            let isVisible = isMirror || Boolean(!segIsInvisible[instanceId] && rect);\n            let vStyle = computeSegVStyle(rect && rect.span);\n            let hStyle = !isMirror && rect ? this.computeSegHStyle(rect) : {\n                left: 0,\n                right: 0\n            };\n            let isInset = Boolean(rect) && rect.stackForward > 0;\n            let isShort = Boolean(rect) && rect.span.end - rect.span.start < eventShortHeight; // look at other places for this problem\n            return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-timegrid-event-harness\" + (isInset ? \" fc-timegrid-event-harness-inset\" : \"\"),\n                key: forcedKey || instanceId,\n                style: Object.assign(Object.assign({\n                    visibility: isVisible ? \"\" : \"hidden\"\n                }, vStyle), hStyle)\n            }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TimeColEvent, Object.assign({\n                seg: seg,\n                isDragging: isDragging,\n                isResizing: isResizing,\n                isDateSelecting: isDateSelecting,\n                isSelected: instanceId === eventSelection,\n                isShort: isShort\n            }, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bS)(seg, todayRange, nowDate))));\n        }));\n    }\n    // will already have eventMinHeight applied because segInputs already had it\n    renderHiddenGroups(hiddenGroups, segs) {\n        let { extraDateSpan, dateProfile, todayRange, nowDate, eventSelection, eventDrag, eventResize } = this.props;\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, hiddenGroups.map((hiddenGroup)=>{\n            let positionCss = computeSegVStyle(hiddenGroup.span);\n            let hiddenSegs = compileSegsFromEntries(hiddenGroup.entries, segs);\n            return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TimeColMoreLink, {\n                key: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bw)((0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cs)(hiddenSegs)),\n                hiddenSegs: hiddenSegs,\n                top: positionCss.top,\n                bottom: positionCss.bottom,\n                extraDateSpan: extraDateSpan,\n                dateProfile: dateProfile,\n                todayRange: todayRange,\n                nowDate: nowDate,\n                eventSelection: eventSelection,\n                eventDrag: eventDrag,\n                eventResize: eventResize\n            });\n        }));\n    }\n    renderFillSegs(segs, fillType) {\n        let { props, context } = this;\n        let segVCoords = computeSegVCoords(segs, props.date, props.slatCoords, context.options.eventMinHeight); // don't assume all populated\n        let children = segVCoords.map((vcoords, i)=>{\n            let seg = segs[i];\n            return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                key: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bT)(seg.eventRange),\n                className: \"fc-timegrid-bg-harness\",\n                style: computeSegVStyle(vcoords)\n            }, fillType === \"bg-event\" ? (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cp, Object.assign({\n                seg: seg\n            }, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bS)(seg, props.todayRange, props.nowDate))) : (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.co)(fillType));\n        });\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, children);\n    }\n    renderNowIndicator(segs) {\n        let { slatCoords, date } = this.props;\n        if (!slatCoords) {\n            return null;\n        }\n        return segs.map((seg, i)=>(0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ck, {\n                // key doesn't matter. will only ever be one\n                key: i,\n                elClasses: [\n                    \"fc-timegrid-now-indicator-line\"\n                ],\n                elStyle: {\n                    top: slatCoords.computeDateTop(seg.start, date)\n                },\n                isAxis: false,\n                date: date\n            }));\n    }\n    computeSegHStyle(segHCoords) {\n        let { isRtl, options } = this.context;\n        let shouldOverlap = options.slotEventOverlap;\n        let nearCoord = segHCoords.levelCoord; // the left side if LTR. the right side if RTL. floating-point\n        let farCoord = segHCoords.levelCoord + segHCoords.thickness; // the right side if LTR. the left side if RTL. floating-point\n        let left; // amount of space from left edge, a fraction of the total width\n        let right; // amount of space from right edge, a fraction of the total width\n        if (shouldOverlap) {\n            // double the width, but don't go beyond the maximum forward coordinate (1.0)\n            farCoord = Math.min(1, nearCoord + (farCoord - nearCoord) * 2);\n        }\n        if (isRtl) {\n            left = 1 - farCoord;\n            right = nearCoord;\n        } else {\n            left = nearCoord;\n            right = 1 - farCoord;\n        }\n        let props = {\n            zIndex: segHCoords.stackDepth + 1,\n            left: left * 100 + \"%\",\n            right: right * 100 + \"%\"\n        };\n        if (shouldOverlap && !segHCoords.stackForward) {\n            // add padding to the edge so that forward stacked events don't cover the resizer's icon\n            props[isRtl ? \"marginLeft\" : \"marginRight\"] = 10 * 2; // 10 is a guesstimate of the icon's width\n        }\n        return props;\n    }\n}\nfunction renderPlainFgSegs(sortedFgSegs, { todayRange, nowDate, eventSelection, eventDrag, eventResize }) {\n    let hiddenInstances = (eventDrag ? eventDrag.affectedInstances : null) || (eventResize ? eventResize.affectedInstances : null) || {};\n    return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, sortedFgSegs.map((seg)=>{\n        let instanceId = seg.eventRange.instance.instanceId;\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            key: instanceId,\n            style: {\n                visibility: hiddenInstances[instanceId] ? \"hidden\" : \"\"\n            }\n        }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TimeColEvent, Object.assign({\n            seg: seg,\n            isDragging: false,\n            isResizing: false,\n            isDateSelecting: false,\n            isSelected: instanceId === eventSelection,\n            isShort: false\n        }, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bS)(seg, todayRange, nowDate))));\n    }));\n}\nfunction computeSegVStyle(segVCoords) {\n    if (!segVCoords) {\n        return {\n            top: \"\",\n            bottom: \"\"\n        };\n    }\n    return {\n        top: segVCoords.start,\n        bottom: -segVCoords.end\n    };\n}\nfunction compileSegsFromEntries(segEntries, allSegs) {\n    return segEntries.map((segEntry)=>allSegs[segEntry.index]);\n}\nclass TimeColsContent extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    constructor(){\n        super(...arguments);\n        this.splitFgEventSegs = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitSegsByCol);\n        this.splitBgEventSegs = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitSegsByCol);\n        this.splitBusinessHourSegs = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitSegsByCol);\n        this.splitNowIndicatorSegs = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitSegsByCol);\n        this.splitDateSelectionSegs = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitSegsByCol);\n        this.splitEventDrag = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitInteractionByCol);\n        this.splitEventResize = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitInteractionByCol);\n        this.rootElRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        this.cellElRefs = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cf();\n    }\n    render() {\n        let { props, context } = this;\n        let nowIndicatorTop = context.options.nowIndicator && props.slatCoords && props.slatCoords.safeComputeTop(props.nowDate); // might return void\n        let colCnt = props.cells.length;\n        let fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, colCnt);\n        let bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, colCnt);\n        let businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, colCnt);\n        let nowIndicatorSegsByRow = this.splitNowIndicatorSegs(props.nowIndicatorSegs, colCnt);\n        let dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, colCnt);\n        let eventDragByRow = this.splitEventDrag(props.eventDrag, colCnt);\n        let eventResizeByRow = this.splitEventResize(props.eventResize, colCnt);\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            className: \"fc-timegrid-cols\",\n            ref: this.rootElRef\n        }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"table\", {\n            role: \"presentation\",\n            style: {\n                minWidth: props.tableMinWidth,\n                width: props.clientWidth\n            }\n        }, props.tableColGroupNode, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tbody\", {\n            role: \"presentation\"\n        }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", {\n            role: \"row\"\n        }, props.axis && (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"td\", {\n            \"aria-hidden\": true,\n            className: \"fc-timegrid-col fc-timegrid-axis\"\n        }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            className: \"fc-timegrid-col-frame\"\n        }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            className: \"fc-timegrid-now-indicator-container\"\n        }, typeof nowIndicatorTop === \"number\" && (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ck, {\n            elClasses: [\n                \"fc-timegrid-now-indicator-arrow\"\n            ],\n            elStyle: {\n                top: nowIndicatorTop\n            },\n            isAxis: true,\n            date: props.nowDate\n        })))), props.cells.map((cell, i)=>(0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TimeCol, {\n                key: cell.key,\n                elRef: this.cellElRefs.createRef(cell.key),\n                dateProfile: props.dateProfile,\n                date: cell.date,\n                nowDate: props.nowDate,\n                todayRange: props.todayRange,\n                extraRenderProps: cell.extraRenderProps,\n                extraDataAttrs: cell.extraDataAttrs,\n                extraClassNames: cell.extraClassNames,\n                extraDateSpan: cell.extraDateSpan,\n                fgEventSegs: fgEventSegsByRow[i],\n                bgEventSegs: bgEventSegsByRow[i],\n                businessHourSegs: businessHourSegsByRow[i],\n                nowIndicatorSegs: nowIndicatorSegsByRow[i],\n                dateSelectionSegs: dateSelectionSegsByRow[i],\n                eventDrag: eventDragByRow[i],\n                eventResize: eventResizeByRow[i],\n                slatCoords: props.slatCoords,\n                eventSelection: props.eventSelection,\n                forPrint: props.forPrint\n            }))))));\n    }\n    componentDidMount() {\n        this.updateCoords();\n    }\n    componentDidUpdate() {\n        this.updateCoords();\n    }\n    updateCoords() {\n        let { props } = this;\n        if (props.onColCoords && props.clientWidth !== null // means sizing has stabilized\n        ) {\n            props.onColCoords(new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ba(this.rootElRef.current, collectCellEls(this.cellElRefs.currentMap, props.cells), true, false));\n        }\n    }\n}\nfunction collectCellEls(elMap, cells) {\n    return cells.map((cell)=>elMap[cell.key]);\n}\n/* A component that renders one or more columns of vertical time slots\n----------------------------------------------------------------------------------------------------------------------*/ class TimeCols extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.be {\n    constructor(){\n        super(...arguments);\n        this.processSlotOptions = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(processSlotOptions);\n        this.state = {\n            slatCoords: null\n        };\n        this.handleRootEl = (el)=>{\n            if (el) {\n                this.context.registerInteractiveComponent(this, {\n                    el,\n                    isHitComboAllowed: this.props.isHitComboAllowed\n                });\n            } else {\n                this.context.unregisterInteractiveComponent(this);\n            }\n        };\n        this.handleScrollRequest = (request)=>{\n            let { onScrollTopRequest } = this.props;\n            let { slatCoords } = this.state;\n            if (onScrollTopRequest && slatCoords) {\n                if (request.time) {\n                    let top = slatCoords.computeTimeTop(request.time);\n                    top = Math.ceil(top); // zoom can give weird floating-point values. rather scroll a little bit further\n                    if (top) {\n                        top += 1; // to overcome top border that slots beyond the first have. looks better\n                    }\n                    onScrollTopRequest(top);\n                }\n                return true;\n            }\n            return false;\n        };\n        this.handleColCoords = (colCoords)=>{\n            this.colCoords = colCoords;\n        };\n        this.handleSlatCoords = (slatCoords)=>{\n            this.setState({\n                slatCoords\n            });\n            if (this.props.onSlatCoords) {\n                this.props.onSlatCoords(slatCoords);\n            }\n        };\n    }\n    render() {\n        let { props, state } = this;\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            className: \"fc-timegrid-body\",\n            ref: this.handleRootEl,\n            style: {\n                // these props are important to give this wrapper correct dimensions for interactions\n                // TODO: if we set it here, can we avoid giving to inner tables?\n                width: props.clientWidth,\n                minWidth: props.tableMinWidth\n            }\n        }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TimeColsSlats, {\n            axis: props.axis,\n            dateProfile: props.dateProfile,\n            slatMetas: props.slatMetas,\n            clientWidth: props.clientWidth,\n            minHeight: props.expandRows ? props.clientHeight : \"\",\n            tableMinWidth: props.tableMinWidth,\n            tableColGroupNode: props.axis ? props.tableColGroupNode : null,\n            onCoords: this.handleSlatCoords\n        }), (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TimeColsContent, {\n            cells: props.cells,\n            axis: props.axis,\n            dateProfile: props.dateProfile,\n            businessHourSegs: props.businessHourSegs,\n            bgEventSegs: props.bgEventSegs,\n            fgEventSegs: props.fgEventSegs,\n            dateSelectionSegs: props.dateSelectionSegs,\n            eventSelection: props.eventSelection,\n            eventDrag: props.eventDrag,\n            eventResize: props.eventResize,\n            todayRange: props.todayRange,\n            nowDate: props.nowDate,\n            nowIndicatorSegs: props.nowIndicatorSegs,\n            clientWidth: props.clientWidth,\n            tableMinWidth: props.tableMinWidth,\n            tableColGroupNode: props.tableColGroupNode,\n            slatCoords: state.slatCoords,\n            onColCoords: this.handleColCoords,\n            forPrint: props.forPrint\n        }));\n    }\n    componentDidMount() {\n        this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);\n    }\n    componentDidUpdate(prevProps) {\n        this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);\n    }\n    componentWillUnmount() {\n        this.scrollResponder.detach();\n    }\n    queryHit(positionLeft, positionTop) {\n        let { dateEnv, options } = this.context;\n        let { colCoords } = this;\n        let { dateProfile } = this.props;\n        let { slatCoords } = this.state;\n        let { snapDuration, snapsPerSlot } = this.processSlotOptions(this.props.slotDuration, options.snapDuration);\n        let colIndex = colCoords.leftToIndex(positionLeft);\n        let slatIndex = slatCoords.positions.topToIndex(positionTop);\n        if (colIndex != null && slatIndex != null) {\n            let cell = this.props.cells[colIndex];\n            let slatTop = slatCoords.positions.tops[slatIndex];\n            let slatHeight = slatCoords.positions.getHeight(slatIndex);\n            let partial = (positionTop - slatTop) / slatHeight; // floating point number between 0 and 1\n            let localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat\n            let snapIndex = slatIndex * snapsPerSlot + localSnapIndex;\n            let dayDate = this.props.cells[colIndex].date;\n            let time = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bp)(dateProfile.slotMinTime, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bo)(snapDuration, snapIndex));\n            let start = dateEnv.add(dayDate, time);\n            let end = dateEnv.add(start, snapDuration);\n            return {\n                dateProfile,\n                dateSpan: Object.assign({\n                    range: {\n                        start,\n                        end\n                    },\n                    allDay: false\n                }, cell.extraDateSpan),\n                dayEl: colCoords.els[colIndex],\n                rect: {\n                    left: colCoords.lefts[colIndex],\n                    right: colCoords.rights[colIndex],\n                    top: slatTop,\n                    bottom: slatTop + slatHeight\n                },\n                layer: 0\n            };\n        }\n        return null;\n    }\n}\nfunction processSlotOptions(slotDuration, snapDurationOverride) {\n    let snapDuration = snapDurationOverride || slotDuration;\n    let snapsPerSlot = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bt)(slotDuration, snapDuration);\n    if (snapsPerSlot === null) {\n        snapDuration = slotDuration;\n        snapsPerSlot = 1;\n    // TODO: say warning?\n    }\n    return {\n        snapDuration,\n        snapsPerSlot\n    };\n}\nclass DayTimeColsSlicer extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bW {\n    sliceRange(range, dayRanges) {\n        let segs = [];\n        for(let col = 0; col < dayRanges.length; col += 1){\n            let segRange = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.o)(range, dayRanges[col]);\n            if (segRange) {\n                segs.push({\n                    start: segRange.start,\n                    end: segRange.end,\n                    isStart: segRange.start.valueOf() === range.start.valueOf(),\n                    isEnd: segRange.end.valueOf() === range.end.valueOf(),\n                    col\n                });\n            }\n        }\n        return segs;\n    }\n}\nclass DayTimeCols extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.be {\n    constructor(){\n        super(...arguments);\n        this.buildDayRanges = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildDayRanges);\n        this.slicer = new DayTimeColsSlicer();\n        this.timeColsRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n    }\n    render() {\n        let { props, context } = this;\n        let { dateProfile, dayTableModel } = props;\n        let { nowIndicator, nextDayThreshold } = context.options;\n        let dayRanges = this.buildDayRanges(dayTableModel, dateProfile, context.dateEnv);\n        // give it the first row of cells\n        // TODO: would move this further down hierarchy, but sliceNowDate needs it\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ch, {\n            unit: nowIndicator ? \"minute\" : \"day\"\n        }, (nowDate, todayRange)=>(0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TimeCols, Object.assign({\n                ref: this.timeColsRef\n            }, this.slicer.sliceProps(props, dateProfile, null, context, dayRanges), {\n                forPrint: props.forPrint,\n                axis: props.axis,\n                dateProfile: dateProfile,\n                slatMetas: props.slatMetas,\n                slotDuration: props.slotDuration,\n                cells: dayTableModel.cells[0],\n                tableColGroupNode: props.tableColGroupNode,\n                tableMinWidth: props.tableMinWidth,\n                clientWidth: props.clientWidth,\n                clientHeight: props.clientHeight,\n                expandRows: props.expandRows,\n                nowDate: nowDate,\n                nowIndicatorSegs: nowIndicator && this.slicer.sliceNowDate(nowDate, dateProfile, nextDayThreshold, context, dayRanges),\n                todayRange: todayRange,\n                onScrollTopRequest: props.onScrollTopRequest,\n                onSlatCoords: props.onSlatCoords\n            })));\n    }\n}\nfunction buildDayRanges(dayTableModel, dateProfile, dateEnv) {\n    let ranges = [];\n    for (let date of dayTableModel.headerDates){\n        ranges.push({\n            start: dateEnv.add(date, dateProfile.slotMinTime),\n            end: dateEnv.add(date, dateProfile.slotMaxTime)\n        });\n    }\n    return ranges;\n}\n// potential nice values for the slot-duration and interval-duration\n// from largest to smallest\nconst STOCK_SUB_DURATIONS = [\n    {\n        hours: 1\n    },\n    {\n        minutes: 30\n    },\n    {\n        minutes: 15\n    },\n    {\n        seconds: 30\n    },\n    {\n        seconds: 15\n    }\n];\nfunction buildSlatMetas(slotMinTime, slotMaxTime, explicitLabelInterval, slotDuration, dateEnv) {\n    let dayStart = new Date(0);\n    let slatTime = slotMinTime;\n    let slatIterator = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.d)(0);\n    let labelInterval = explicitLabelInterval || computeLabelInterval(slotDuration);\n    let metas = [];\n    while((0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bs)(slatTime) < (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bs)(slotMaxTime)){\n        let date = dateEnv.add(dayStart, slatTime);\n        let isLabeled = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bt)(slatIterator, labelInterval) !== null;\n        metas.push({\n            date,\n            time: slatTime,\n            key: date.toISOString(),\n            isoTimeStr: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bu)(date),\n            isLabeled\n        });\n        slatTime = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bp)(slatTime, slotDuration);\n        slatIterator = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bp)(slatIterator, slotDuration);\n    }\n    return metas;\n}\n// Computes an automatic value for slotLabelInterval\nfunction computeLabelInterval(slotDuration) {\n    let i;\n    let labelInterval;\n    let slotsPerLabel;\n    // find the smallest stock label interval that results in more than one slots-per-label\n    for(i = STOCK_SUB_DURATIONS.length - 1; i >= 0; i -= 1){\n        labelInterval = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.d)(STOCK_SUB_DURATIONS[i]);\n        slotsPerLabel = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bt)(labelInterval, slotDuration);\n        if (slotsPerLabel !== null && slotsPerLabel > 1) {\n            return labelInterval;\n        }\n    }\n    return slotDuration; // fall back\n}\nclass DayTimeColsView extends TimeColsView {\n    constructor(){\n        super(...arguments);\n        this.buildTimeColsModel = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildTimeColsModel);\n        this.buildSlatMetas = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildSlatMetas);\n    }\n    render() {\n        let { options, dateEnv, dateProfileGenerator } = this.context;\n        let { props } = this;\n        let { dateProfile } = props;\n        let dayTableModel = this.buildTimeColsModel(dateProfile, dateProfileGenerator);\n        let splitProps = this.allDaySplitter.splitProps(props);\n        let slatMetas = this.buildSlatMetas(dateProfile.slotMinTime, dateProfile.slotMaxTime, options.slotLabelInterval, options.slotDuration, dateEnv);\n        let { dayMinWidth } = options;\n        let hasAttachedAxis = !dayMinWidth;\n        let hasDetachedAxis = dayMinWidth;\n        let headerContent = options.dayHeaders && (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bK, {\n            dates: dayTableModel.headerDates,\n            dateProfile: dateProfile,\n            datesRepDistinctDays: true,\n            renderIntro: hasAttachedAxis ? this.renderHeadAxis : null\n        });\n        let allDayContent = options.allDaySlot !== false && ((contentArg)=>(0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_daygrid_internal_js__WEBPACK_IMPORTED_MODULE_2__.DayTable, Object.assign({}, splitProps.allDay, {\n                dateProfile: dateProfile,\n                dayTableModel: dayTableModel,\n                nextDayThreshold: options.nextDayThreshold,\n                tableMinWidth: contentArg.tableMinWidth,\n                colGroupNode: contentArg.tableColGroupNode,\n                renderRowIntro: hasAttachedAxis ? this.renderTableRowAxis : null,\n                showWeekNumbers: false,\n                expandRows: false,\n                headerAlignElRef: this.headerElRef,\n                clientWidth: contentArg.clientWidth,\n                clientHeight: contentArg.clientHeight,\n                forPrint: props.forPrint\n            }, this.getAllDayMaxEventProps())));\n        let timeGridContent = (contentArg)=>(0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(DayTimeCols, Object.assign({}, splitProps.timed, {\n                dayTableModel: dayTableModel,\n                dateProfile: dateProfile,\n                axis: hasAttachedAxis,\n                slotDuration: options.slotDuration,\n                slatMetas: slatMetas,\n                forPrint: props.forPrint,\n                tableColGroupNode: contentArg.tableColGroupNode,\n                tableMinWidth: contentArg.tableMinWidth,\n                clientWidth: contentArg.clientWidth,\n                clientHeight: contentArg.clientHeight,\n                onSlatCoords: this.handleSlatCoords,\n                expandRows: contentArg.expandRows,\n                onScrollTopRequest: this.handleScrollTopRequest\n            }));\n        return hasDetachedAxis ? this.renderHScrollLayout(headerContent, allDayContent, timeGridContent, dayTableModel.colCnt, dayMinWidth, slatMetas, this.state.slatCoords) : this.renderSimpleLayout(headerContent, allDayContent, timeGridContent);\n    }\n}\nfunction buildTimeColsModel(dateProfile, dateProfileGenerator) {\n    let daySeries = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bO(dateProfile.renderRange, dateProfileGenerator);\n    return new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bV(daySeries, false);\n}\nvar css_248z = '.fc-v-event{background-color:var(--fc-event-bg-color);border:1px solid var(--fc-event-border-color);display:block}.fc-v-event .fc-event-main{color:var(--fc-event-text-color);height:100%}.fc-v-event .fc-event-main-frame{display:flex;flex-direction:column;height:100%}.fc-v-event .fc-event-time{flex-grow:0;flex-shrink:0;max-height:100%;overflow:hidden}.fc-v-event .fc-event-title-container{flex-grow:1;flex-shrink:1;min-height:0}.fc-v-event .fc-event-title{bottom:0;max-height:100%;overflow:hidden;top:0}.fc-v-event:not(.fc-event-start){border-top-left-radius:0;border-top-right-radius:0;border-top-width:0}.fc-v-event:not(.fc-event-end){border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-width:0}.fc-v-event.fc-event-selected:before{left:-10px;right:-10px}.fc-v-event .fc-event-resizer-start{cursor:n-resize}.fc-v-event .fc-event-resizer-end{cursor:s-resize}.fc-v-event:not(.fc-event-selected) .fc-event-resizer{height:var(--fc-event-resizer-thickness);left:0;right:0}.fc-v-event:not(.fc-event-selected) .fc-event-resizer-start{top:calc(var(--fc-event-resizer-thickness)/-2)}.fc-v-event:not(.fc-event-selected) .fc-event-resizer-end{bottom:calc(var(--fc-event-resizer-thickness)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer{left:50%;margin-left:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer-start{top:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer-end{bottom:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc .fc-timegrid .fc-daygrid-body{z-index:2}.fc .fc-timegrid-divider{padding:0 0 2px}.fc .fc-timegrid-body{min-height:100%;position:relative;z-index:1}.fc .fc-timegrid-axis-chunk{position:relative}.fc .fc-timegrid-axis-chunk>table,.fc .fc-timegrid-slots{position:relative;z-index:1}.fc .fc-timegrid-slot{border-bottom:0;height:1.5em}.fc .fc-timegrid-slot:empty:before{content:\"\\\\00a0\"}.fc .fc-timegrid-slot-minor{border-top-style:dotted}.fc .fc-timegrid-slot-label-cushion{display:inline-block;white-space:nowrap}.fc .fc-timegrid-slot-label{vertical-align:middle}.fc .fc-timegrid-axis-cushion,.fc .fc-timegrid-slot-label-cushion{padding:0 4px}.fc .fc-timegrid-axis-frame-liquid{height:100%}.fc .fc-timegrid-axis-frame{align-items:center;display:flex;justify-content:flex-end;overflow:hidden}.fc .fc-timegrid-axis-cushion{flex-shrink:0;max-width:60px}.fc-direction-ltr .fc-timegrid-slot-label-frame{text-align:right}.fc-direction-rtl .fc-timegrid-slot-label-frame{text-align:left}.fc-liquid-hack .fc-timegrid-axis-frame-liquid{bottom:0;height:auto;left:0;position:absolute;right:0;top:0}.fc .fc-timegrid-col.fc-day-today{background-color:var(--fc-today-bg-color)}.fc .fc-timegrid-col-frame{min-height:100%;position:relative}.fc-media-screen.fc-liquid-hack .fc-timegrid-col-frame{bottom:0;height:auto;left:0;position:absolute;right:0;top:0}.fc-media-screen .fc-timegrid-cols{bottom:0;left:0;position:absolute;right:0;top:0}.fc-media-screen .fc-timegrid-cols>table{height:100%}.fc-media-screen .fc-timegrid-col-bg,.fc-media-screen .fc-timegrid-col-events,.fc-media-screen .fc-timegrid-now-indicator-container{left:0;position:absolute;right:0;top:0}.fc .fc-timegrid-col-bg{z-index:2}.fc .fc-timegrid-col-bg .fc-non-business{z-index:1}.fc .fc-timegrid-col-bg .fc-bg-event{z-index:2}.fc .fc-timegrid-col-bg .fc-highlight{z-index:3}.fc .fc-timegrid-bg-harness{left:0;position:absolute;right:0}.fc .fc-timegrid-col-events{z-index:3}.fc .fc-timegrid-now-indicator-container{bottom:0;overflow:hidden}.fc-direction-ltr .fc-timegrid-col-events{margin:0 2.5% 0 2px}.fc-direction-rtl .fc-timegrid-col-events{margin:0 2px 0 2.5%}.fc-timegrid-event-harness{position:absolute}.fc-timegrid-event-harness>.fc-timegrid-event{bottom:0;left:0;position:absolute;right:0;top:0}.fc-timegrid-event-harness-inset .fc-timegrid-event,.fc-timegrid-event.fc-event-mirror,.fc-timegrid-more-link{box-shadow:0 0 0 1px var(--fc-page-bg-color)}.fc-timegrid-event,.fc-timegrid-more-link{border-radius:3px;font-size:var(--fc-small-font-size)}.fc-timegrid-event{margin-bottom:1px}.fc-timegrid-event .fc-event-main{padding:1px 1px 0}.fc-timegrid-event .fc-event-time{font-size:var(--fc-small-font-size);margin-bottom:1px;white-space:nowrap}.fc-timegrid-event-short .fc-event-main-frame{flex-direction:row;overflow:hidden}.fc-timegrid-event-short .fc-event-time:after{content:\"\\\\00a0-\\\\00a0\"}.fc-timegrid-event-short .fc-event-title{font-size:var(--fc-small-font-size)}.fc-timegrid-more-link{background:var(--fc-more-link-bg-color);color:var(--fc-more-link-text-color);cursor:pointer;margin-bottom:1px;position:absolute;z-index:9999}.fc-timegrid-more-link-inner{padding:3px 2px;top:0}.fc-direction-ltr .fc-timegrid-more-link{right:0}.fc-direction-rtl .fc-timegrid-more-link{left:0}.fc .fc-timegrid-now-indicator-arrow,.fc .fc-timegrid-now-indicator-line{pointer-events:none}.fc .fc-timegrid-now-indicator-line{border-color:var(--fc-now-indicator-color);border-style:solid;border-width:1px 0 0;left:0;position:absolute;right:0;z-index:4}.fc .fc-timegrid-now-indicator-arrow{border-color:var(--fc-now-indicator-color);border-style:solid;margin-top:-5px;position:absolute;z-index:4}.fc-direction-ltr .fc-timegrid-now-indicator-arrow{border-bottom-color:transparent;border-top-color:transparent;border-width:5px 0 5px 6px;left:0}.fc-direction-rtl .fc-timegrid-now-indicator-arrow{border-bottom-color:transparent;border-top-color:transparent;border-width:5px 6px 5px 0;right:0}';\n(0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cw)(css_248z);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci90aW1lZ3JpZC9pbnRlcm5hbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBMDFCO0FBQ3h3QjtBQUNyQjtBQUU3RCxNQUFNc0QsdUJBQXVCdEQsOERBQVFBO0lBQ2pDdUQsYUFBYTtRQUNULE9BQU87WUFDSEMsUUFBUSxDQUFDO1lBQ1RDLE9BQU8sQ0FBQztRQUNaO0lBQ0o7SUFDQUMsbUJBQW1CQyxRQUFRLEVBQUU7UUFDekIsSUFBSUEsU0FBU0gsTUFBTSxFQUFFO1lBQ2pCLE9BQU87Z0JBQUM7YUFBUztRQUNyQjtRQUNBLE9BQU87WUFBQztTQUFRO0lBQ3BCO0lBQ0FJLG1CQUFtQkMsUUFBUSxFQUFFO1FBQ3pCLElBQUksQ0FBQ0EsU0FBU0wsTUFBTSxFQUFFO1lBQ2xCLE9BQU87Z0JBQUM7YUFBUTtRQUNwQjtRQUNBLElBQUl2RCxrRUFBY0EsQ0FBQzRELFdBQVc7WUFDMUIsT0FBTztnQkFBQztnQkFBUzthQUFTO1FBQzlCO1FBQ0EsT0FBTztZQUFDO1NBQVM7SUFDckI7QUFDSjtBQUVBLE1BQU1DLDRCQUE0QjVELGlFQUFlQSxDQUFDO0lBQzlDNkQsTUFBTTtJQUNOQyxRQUFRO0lBQ1JDLGdCQUFnQjtJQUNoQkMsVUFBVTtBQUNkO0FBQ0EsU0FBU0MsaUJBQWlCQyxLQUFLO0lBQzNCLElBQUlDLGFBQWE7UUFDYjtRQUNBO1FBQ0FELE1BQU1FLFNBQVMsR0FBRyx5QkFBeUI7S0FDOUM7SUFDRCxPQUFRcEIsMkVBQWFBLENBQUMvQyw2REFBZUEsQ0FBQ29FLFFBQVEsRUFBRSxNQUFNLENBQUNDO1FBQ25ELElBQUksQ0FBQ0osTUFBTUUsU0FBUyxFQUFFO1lBQ2xCLE9BQVFwQiwyRUFBYUEsQ0FBQyxNQUFNO2dCQUFFdUIsV0FBV0osV0FBV0ssSUFBSSxDQUFDO2dCQUFNLGFBQWFOLE1BQU1PLFVBQVU7WUFBQztRQUNqRztRQUNBLElBQUksRUFBRUMsT0FBTyxFQUFFQyxPQUFPLEVB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RCxPQUFPLElBQUl6ZCw4REFBYUEsQ0FBQ3llLFdBQVc7QUFDeEM7QUFFQSxJQUFJQyxXQUFXO0FBQ2Z6ZSxrRUFBWUEsQ0FBQ3llO0FBRStJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVoYXNwb3J0LW1hbmFnZW1lbnQvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci90aW1lZ3JpZC9pbnRlcm5hbC5qcz81MjNlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNwbGl0dGVyLCBoYXNCZ1JlbmRlcmluZywgY3JlYXRlRm9ybWF0dGVyLCBWaWV3Q29udGV4dFR5cGUsIENvbnRlbnRDb250YWluZXIsIEJhc2VDb21wb25lbnQsIERhdGVDb21wb25lbnQsIGRpZmZEYXlzLCBidWlsZE5hdkxpbmtBdHRycywgV2Vla051bWJlckNvbnRhaW5lciwgZ2V0U3RpY2t5SGVhZGVyRGF0ZXMsIFZpZXdDb250YWluZXIsIFNpbXBsZVNjcm9sbEdyaWQsIGdldFN0aWNreUZvb3RlclNjcm9sbGJhciwgTm93VGltZXIsIE5vd0luZGljYXRvckNvbnRhaW5lciwgcmVuZGVyU2Nyb2xsU2hpbSwgcmFuZ2VDb250YWluc01hcmtlciwgc3RhcnRPZkRheSwgYXNSb3VnaE1zLCBjcmVhdGVEdXJhdGlvbiwgUmVmTWFwLCBQb3NpdGlvbkNhY2hlLCBNb3JlTGlua0NvbnRhaW5lciwgU2VnSGllcmFyY2h5LCBncm91cEludGVyc2VjdGluZ0VudHJpZXMsIGJpbmFyeVNlYXJjaCwgZ2V0RW50cnlTcGFuRW5kLCBidWlsZEVudHJ5S2V5LCBTdGFuZGFyZEV2ZW50LCBtZW1vaXplLCBzb3J0RXZlbnRTZWdzLCBEYXlDZWxsQ29udGFpbmVyLCBoYXNDdXN0b21EYXlDZWxsQ29udGVudCwgZ2V0U2VnTWV0YSwgYnVpbGRJc29TdHJpbmcsIGNvbXB1dGVFYXJsaWVzdFNlZ1N0YXJ0LCBidWlsZEV2ZW50UmFuZ2VLZXksIEJnRXZlbnQsIHJlbmRlckZpbGwsIGFkZER1cmF0aW9ucywgbXVsdGlwbHlEdXJhdGlvbiwgd2hvbGVEaXZpZGVEdXJhdGlvbnMsIFNsaWNlciwgaW50ZXJzZWN0UmFuZ2VzLCBmb3JtYXRJc29UaW1lU3RyaW5nLCBEYXlIZWFkZXIsIERheVNlcmllc01vZGVsLCBEYXlUYWJsZU1vZGVsLCBpbmplY3RTdHlsZXMgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUvaW50ZXJuYWwuanMnO1xuaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgY3JlYXRlUmVmLCBGcmFnbWVudCB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZS9wcmVhY3QuanMnO1xuaW1wb3J0IHsgRGF5VGFibGUgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2RheWdyaWQvaW50ZXJuYWwuanMnO1xuXG5jbGFzcyBBbGxEYXlTcGxpdHRlciBleHRlbmRzIFNwbGl0dGVyIHtcbiAgICBnZXRLZXlJbmZvKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWxsRGF5OiB7fSxcbiAgICAgICAgICAgIHRpbWVkOiB7fSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0S2V5c0ZvckRhdGVTcGFuKGRhdGVTcGFuKSB7XG4gICAgICAgIGlmIChkYXRlU3Bhbi5hbGxEYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ2FsbERheSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbJ3RpbWVkJ107XG4gICAgfVxuICAgIGdldEtleXNGb3JFdmVudERlZihldmVudERlZikge1xuICAgICAgICBpZiAoIWV2ZW50RGVmLmFsbERheSkge1xuICAgICAgICAgICAgcmV0dXJuIFsndGltZWQnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzQmdSZW5kZXJpbmcoZXZlbnREZWYpKSB7XG4gICAgICAgICAgICByZXR1cm4gWyd0aW1lZCcsICdhbGxEYXknXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWydhbGxEYXknXTtcbiAgICB9XG59XG5cbmNvbnN0IERFRkFVTFRfU0xBVF9MQUJFTF9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoe1xuICAgIGhvdXI6ICdudW1lcmljJyxcbiAgICBtaW51dGU6ICcyLWRpZ2l0JyxcbiAgICBvbWl0WmVyb01pbnV0ZTogdHJ1ZSxcbiAgICBtZXJpZGllbTogJ3Nob3J0Jyxcbn0pO1xuZnVuY3Rpb24gVGltZUNvbHNBeGlzQ2VsbChwcm9wcykge1xuICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgICAnZmMtdGltZWdyaWQtc2xvdCcsXG4gICAgICAgICdmYy10aW1lZ3JpZC1zbG90LWxhYmVsJyxcbiAgICAgICAgcHJvcHMuaXNMYWJlbGVkID8gJ2ZjLXNjcm9sbGdyaWQtc2hyaW5rJyA6ICdmYy10aW1lZ3JpZC1zbG90LW1pbm9yJyxcbiAgICBdO1xuICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChWaWV3Q29udGV4dFR5cGUuQ29uc3VtZXIsIG51bGwsIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGlmICghcHJvcHMuaXNMYWJlbGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy5qb2luKCcgJyksIFwiZGF0YS10aW1lXCI6IHByb3BzLmlzb1RpbWVTdHIgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IGRhdGVFbnYsIG9wdGlvbnMsIHZpZXdBcGkgfSA9IGNvbnRleHQ7XG4gICAgICAgIGxldCBsYWJlbEZvcm1hdCA9IC8vIFRPRE86IGZ1bGx5IHByZS1wYXJzZVxuICAgICAgICAgb3B0aW9ucy5zbG90TGFiZWxGb3JtYXQgPT0gbnVsbCA/IERFRkFVTFRfU0xBVF9MQUJFTF9GT1JNQVQgOlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShvcHRpb25zLnNsb3RMYWJlbEZvcm1hdCkgPyBjcmVhdGVGb3JtYXR0ZXIob3B0aW9ucy5zbG90TGFiZWxGb3JtYXRbMF0pIDpcbiAgICAgICAgICAgICAgICBjcmVhdGVGb3JtYXR0ZXIob3B0aW9ucy5zbG90TGFiZWxGb3JtYXQpO1xuICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSB7XG4gICAgICAgICAgICBsZXZlbDogMCxcbiAgICAgICAgICAgIHRpbWU6IHByb3BzLnRpbWUsXG4gICAgICAgICAgICBkYXRlOiBkYXRlRW52LnRvRGF0ZShwcm9wcy5kYXRlKSxcbiAgICAgICAgICAgIHZpZXc6IHZpZXdBcGksXG4gICAgICAgICAgICB0ZXh0OiBkYXRlRW52LmZvcm1hdChwcm9wcy5kYXRlLCBsYWJlbEZvcm1hdCksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChDb250ZW50Q29udGFpbmVyLCB7IGVsVGFnOiBcInRkXCIsIGVsQ2xhc3NlczogY2xhc3NOYW1lcywgZWxBdHRyczoge1xuICAgICAgICAgICAgICAgICdkYXRhLXRpbWUnOiBwcm9wcy5pc29UaW1lU3RyLFxuICAgICAgICAgICAgfSwgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcInNsb3RMYWJlbENvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLnNsb3RMYWJlbENvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlcklubmVyQ29udGVudCwgY2xhc3NOYW1lR2VuZXJhdG9yOiBvcHRpb25zLnNsb3RMYWJlbENsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLnNsb3RMYWJlbERpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5zbG90TGFiZWxXaWxsVW5tb3VudCB9LCAoSW5uZXJDb250ZW50KSA9PiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1zbG90LWxhYmVsLWZyYW1lIGZjLXNjcm9sbGdyaWQtc2hyaW5rLWZyYW1lXCIgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcImRpdlwiLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLXNsb3QtbGFiZWwtY3VzaGlvbicsXG4gICAgICAgICAgICAgICAgICAgICdmYy1zY3JvbGxncmlkLXNocmluay1jdXNoaW9uJyxcbiAgICAgICAgICAgICAgICBdIH0pKSkpKTtcbiAgICB9KSk7XG59XG5mdW5jdGlvbiByZW5kZXJJbm5lckNvbnRlbnQocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMudGV4dDtcbn1cblxuY2xhc3MgVGltZUJvZHlBeGlzIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5zbGF0TWV0YXMubWFwKChzbGF0TWV0YSkgPT4gKGNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IGtleTogc2xhdE1ldGEua2V5IH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFRpbWVDb2xzQXhpc0NlbGwsIE9iamVjdC5hc3NpZ24oe30sIHNsYXRNZXRhKSkpKSk7XG4gICAgfVxufVxuXG5jb25zdCBERUZBVUxUX1dFRUtfTlVNX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7IHdlZWs6ICdzaG9ydCcgfSk7XG5jb25zdCBBVVRPX0FMTF9EQVlfTUFYX0VWRU5UX1JPV1MgPSA1O1xuY2xhc3MgVGltZUNvbHNWaWV3IGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuYWxsRGF5U3BsaXR0ZXIgPSBuZXcgQWxsRGF5U3BsaXR0ZXIoKTsgLy8gZm9yIHVzZSBieSBzdWJjbGFzc2VzXG4gICAgICAgIHRoaXMuaGVhZGVyRWxSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy5yb290RWxSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy5zY3JvbGxlckVsUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBzbGF0Q29vcmRzOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbFRvcFJlcXVlc3QgPSAoc2Nyb2xsVG9wKSA9PiB7XG4gICAgICAgICAgICBsZXQgc2Nyb2xsZXJFbCA9IHRoaXMuc2Nyb2xsZXJFbFJlZi5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKHNjcm9sbGVyRWwpIHsgLy8gVE9ETzogbm90IHN1cmUgaG93IHRoaXMgY291bGQgZXZlciBiZSBudWxsLiB3ZWlyZG5lc3Mgd2l0aCB0aGUgcmVkdWNlclxuICAgICAgICAgICAgICAgIHNjcm9sbGVyRWwuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiBIZWFkZXIgUmVuZGVyIE1ldGhvZHNcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICAgICAgdGhpcy5yZW5kZXJIZWFkQXhpcyA9IChyb3dLZXksIGZyYW1lSGVpZ2h0ID0gJycpID0+IHtcbiAgICAgICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgICAgIGxldCB7IGRhdGVQcm9maWxlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gZGF0ZVByb2ZpbGUucmVuZGVyUmFuZ2U7XG4gICAgICAgICAgICBsZXQgZGF5Q250ID0gZGlmZkRheXMocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCk7XG4gICAgICAgICAgICAvLyBvbmx5IGRvIGluIGRheSB2aWV3cyAodG8gYXZvaWQgZG9pbmcgaW4gd2VlayB2aWV3cyB0aGF0IGRvbnQgbmVlZCBpdClcbiAgICAgICAgICAgIGxldCBuYXZMaW5rQXR0cnMgPSAoZGF5Q250ID09PSAxKVxuICAgICAgICAgICAgICAgID8gYnVpbGROYXZMaW5rQXR0cnModGhpcy5jb250ZXh0LCByYW5nZS5zdGFydCwgJ3dlZWsnKVxuICAgICAgICAgICAgICAgIDoge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy53ZWVrTnVtYmVycyAmJiByb3dLZXkgPT09ICdkYXknKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFdlZWtOdW1iZXJDb250YWluZXIsIHsgZWxUYWc6IFwidGhcIiwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtdGltZWdyaWQtYXhpcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zaHJpbmsnLFxuICAgICAgICAgICAgICAgICAgICBdLCBlbEF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnYXJpYS1oaWRkZW4nOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9LCBkYXRlOiByYW5nZS5zdGFydCwgZGVmYXVsdEZvcm1hdDogREVGQVVMVF9XRUVLX05VTV9GT1JNQVQgfSwgKElubmVyQ29udGVudCkgPT4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1heGlzLWZyYW1lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYy1zY3JvbGxncmlkLXNocmluay1mcmFtZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtdGltZWdyaWQtYXhpcy1mcmFtZS1saXF1aWQnLFxuICAgICAgICAgICAgICAgICAgICBdLmpvaW4oJyAnKSwgc3R5bGU6IHsgaGVpZ2h0OiBmcmFtZUhlaWdodCB9IH0sXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcImFcIiwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLWF4aXMtY3VzaGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXNjcm9sbGdyaWQtc2hyaW5rLWN1c2hpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmYy1zY3JvbGxncmlkLXN5bmMtaW5uZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSwgZWxBdHRyczogbmF2TGlua0F0dHJzIH0pKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcInRoXCIsIHsgXCJhcmlhLWhpZGRlblwiOiB0cnVlLCBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtYXhpc1wiIH0sXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1heGlzLWZyYW1lXCIsIHN0eWxlOiB7IGhlaWdodDogZnJhbWVIZWlnaHQgfSB9KSkpO1xuICAgICAgICB9O1xuICAgICAgICAvKiBUYWJsZSBDb21wb25lbnQgUmVuZGVyIE1ldGhvZHNcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICAgICAgLy8gb25seSBhIG9uZS13YXkgaGVpZ2h0IHN5bmMuIHdlIGRvbid0IHNlbmQgdGhlIGF4aXMgaW5uZXItY29udGVudCBoZWlnaHQgdG8gdGhlIERheUdyaWQsXG4gICAgICAgIC8vIGJ1dCBEYXlHcmlkIHN0aWxsIG5lZWRzIHRvIGhhdmUgY2xhc3NOYW1lcyBvbiBpbm5lciBlbGVtZW50cyBpbiBvcmRlciB0byBtZWFzdXJlLlxuICAgICAgICB0aGlzLnJlbmRlclRhYmxlUm93QXhpcyA9IChyb3dIZWlnaHQpID0+IHtcbiAgICAgICAgICAgIGxldCB7IG9wdGlvbnMsIHZpZXdBcGkgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgICAgIGxldCByZW5kZXJQcm9wcyA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBvcHRpb25zLmFsbERheVRleHQsXG4gICAgICAgICAgICAgICAgdmlldzogdmlld0FwaSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgLy8gVE9ETzogbWFrZSByZXVzYWJsZSBob29rLiB1c2VkIGluIGxpc3QgdmlldyB0b29cbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciwgeyBlbFRhZzogXCJ0ZFwiLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLWF4aXMnLFxuICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zaHJpbmsnLFxuICAgICAgICAgICAgICAgIF0sIGVsQXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwiYWxsRGF5Q29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMuYWxsRGF5Q29udGVudCwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVyQWxsRGF5SW5uZXIsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5hbGxEYXlDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5hbGxEYXlEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuYWxsRGF5V2lsbFVubW91bnQgfSwgKElubmVyQ29udGVudCkgPT4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLWF4aXMtZnJhbWUnLFxuICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zaHJpbmstZnJhbWUnLFxuICAgICAgICAgICAgICAgICAgICByb3dIZWlnaHQgPT0gbnVsbCA/ICcgZmMtdGltZWdyaWQtYXhpcy1mcmFtZS1saXF1aWQnIDogJycsXG4gICAgICAgICAgICAgICAgXS5qb2luKCcgJyksIHN0eWxlOiB7IGhlaWdodDogcm93SGVpZ2h0IH0gfSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJzcGFuXCIsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLWF4aXMtY3VzaGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zaHJpbmstY3VzaGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zeW5jLWlubmVyJyxcbiAgICAgICAgICAgICAgICAgICAgXSB9KSkpKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlU2xhdENvb3JkcyA9IChzbGF0Q29vcmRzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgc2xhdENvb3JkcyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gcmVuZGVyaW5nXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHJlbmRlclNpbXBsZUxheW91dChoZWFkZXJSb3dDb250ZW50LCBhbGxEYXlDb250ZW50LCB0aW1lQ29udGVudCkge1xuICAgICAgICBsZXQgeyBjb250ZXh0LCBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHNlY3Rpb25zID0gW107XG4gICAgICAgIGxldCBzdGlja3lIZWFkZXJEYXRlcyA9IGdldFN0aWNreUhlYWRlckRhdGVzKGNvbnRleHQub3B0aW9ucyk7XG4gICAgICAgIGlmIChoZWFkZXJSb3dDb250ZW50KSB7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGVhZGVyJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdoZWFkZXInLFxuICAgICAgICAgICAgICAgIGlzU3RpY2t5OiBzdGlja3lIZWFkZXJEYXRlcyxcbiAgICAgICAgICAgICAgICBjaHVuazoge1xuICAgICAgICAgICAgICAgICAgICBlbFJlZjogdGhpcy5oZWFkZXJFbFJlZixcbiAgICAgICAgICAgICAgICAgICAgdGFibGVDbGFzc05hbWU6ICdmYy1jb2wtaGVhZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgcm93Q29udGVudDogaGVhZGVyUm93Q29udGVudCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbERheUNvbnRlbnQpIHtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgICAgICBrZXk6ICdhbGwtZGF5JyxcbiAgICAgICAgICAgICAgICBjaHVuazogeyBjb250ZW50OiBhbGxEYXlDb250ZW50IH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgICAgICBrZXk6ICdhbGwtZGF5LWRpdmlkZXInLFxuICAgICAgICAgICAgICAgIG91dGVyQ29udGVudDogKCAvLyBUT0RPOiByZW5hbWUgdG8gY2VsbENvbnRlbnQgc28gZG9uJ3QgbmVlZCB0byBkZWZpbmUgPHRyPj9cbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidHJcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiLCBjbGFzc05hbWU6IFwiZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRkXCIsIHsgY2xhc3NOYW1lOiAnZmMtdGltZWdyaWQtZGl2aWRlciAnICsgY29udGV4dC50aGVtZS5nZXRDbGFzcygndGFibGVDZWxsU2hhZGVkJykgfSkpKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ2JvZHknLFxuICAgICAgICAgICAga2V5OiAnYm9keScsXG4gICAgICAgICAgICBsaXF1aWQ6IHRydWUsXG4gICAgICAgICAgICBleHBhbmRSb3dzOiBCb29sZWFuKGNvbnRleHQub3B0aW9ucy5leHBhbmRSb3dzKSxcbiAgICAgICAgICAgIGNodW5rOiB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJFbFJlZjogdGhpcy5zY3JvbGxlckVsUmVmLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRpbWVDb250ZW50LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChWaWV3Q29udGFpbmVyLCB7IGVsUmVmOiB0aGlzLnJvb3RFbFJlZiwgZWxDbGFzc2VzOiBbJ2ZjLXRpbWVncmlkJ10sIHZpZXdTcGVjOiBjb250ZXh0LnZpZXdTcGVjIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFNpbXBsZVNjcm9sbEdyaWQsIHsgbGlxdWlkOiAhcHJvcHMuaXNIZWlnaHRBdXRvICYmICFwcm9wcy5mb3JQcmludCwgY29sbGFwc2libGVXaWR0aDogcHJvcHMuZm9yUHJpbnQsIGNvbHM6IFt7IHdpZHRoOiAnc2hyaW5rJyB9XSwgc2VjdGlvbnM6IHNlY3Rpb25zIH0pKSk7XG4gICAgfVxuICAgIHJlbmRlckhTY3JvbGxMYXlvdXQoaGVhZGVyUm93Q29udGVudCwgYWxsRGF5Q29udGVudCwgdGltZUNvbnRlbnQsIGNvbENudCwgZGF5TWluV2lkdGgsIHNsYXRNZXRhcywgc2xhdENvb3Jkcykge1xuICAgICAgICBsZXQgU2Nyb2xsR3JpZCA9IHRoaXMuY29udGV4dC5wbHVnaW5Ib29rcy5zY3JvbGxHcmlkSW1wbDtcbiAgICAgICAgaWYgKCFTY3JvbGxHcmlkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFNjcm9sbEdyaWQgaW1wbGVtZW50YXRpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBjb250ZXh0LCBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHN0aWNreUhlYWRlckRhdGVzID0gIXByb3BzLmZvclByaW50ICYmIGdldFN0aWNreUhlYWRlckRhdGVzKGNvbnRleHQub3B0aW9ucyk7XG4gICAgICAgIGxldCBzdGlja3lGb290ZXJTY3JvbGxiYXIgPSAhcHJvcHMuZm9yUHJpbnQgJiYgZ2V0U3RpY2t5Rm9vdGVyU2Nyb2xsYmFyKGNvbnRleHQub3B0aW9ucyk7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IFtdO1xuICAgICAgICBpZiAoaGVhZGVyUm93Q29udGVudCkge1xuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2hlYWRlcicsXG4gICAgICAgICAgICAgICAga2V5OiAnaGVhZGVyJyxcbiAgICAgICAgICAgICAgICBpc1N0aWNreTogc3RpY2t5SGVhZGVyRGF0ZXMsXG4gICAgICAgICAgICAgICAgc3luY1Jvd0hlaWdodHM6IHRydWUsXG4gICAgICAgICAgICAgICAgY2h1bmtzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2F4aXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93Q29udGVudDogKGFyZykgPT4gKGNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IHJvbGU6IFwicHJlc2VudGF0aW9uXCIgfSwgdGhpcy5yZW5kZXJIZWFkQXhpcygnZGF5JywgYXJnLnJvd1N5bmNIZWlnaHRzWzBdKSkpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdjb2xzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsUmVmOiB0aGlzLmhlYWRlckVsUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVDbGFzc05hbWU6ICdmYy1jb2wtaGVhZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0NvbnRlbnQ6IGhlYWRlclJvd0NvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGxEYXlDb250ZW50KSB7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICAgICAga2V5OiAnYWxsLWRheScsXG4gICAgICAgICAgICAgICAgc3luY1Jvd0hlaWdodHM6IHRydWUsXG4gICAgICAgICAgICAgICAgY2h1bmtzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2F4aXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93Q29udGVudDogKGNvbnRlbnRBcmcpID0+IChjcmVhdGVFbGVtZW50KFwidHJcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiIH0sIHRoaXMucmVuZGVyVGFibGVSb3dBeGlzKGNvbnRlbnRBcmcucm93U3luY0hlaWdodHNbMF0pKSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2NvbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogYWxsRGF5Q29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXk6ICdhbGwtZGF5LWRpdmlkZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgICAgICBvdXRlckNvbnRlbnQ6ICggLy8gVE9ETzogcmVuYW1lIHRvIGNlbGxDb250ZW50IHNvIGRvbid0IG5lZWQgdG8gZGVmaW5lIDx0cj4/XG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRyXCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiwgY2xhc3NOYW1lOiBcImZjLXNjcm9sbGdyaWQtc2VjdGlvblwiIH0sXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IGNvbFNwYW46IDIsIGNsYXNzTmFtZTogJ2ZjLXRpbWVncmlkLWRpdmlkZXIgJyArIGNvbnRleHQudGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlQ2VsbFNoYWRlZCcpIH0pKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaXNOb3dJbmRpY2F0b3IgPSBjb250ZXh0Lm9wdGlvbnMubm93SW5kaWNhdG9yO1xuICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgIGtleTogJ2JvZHknLFxuICAgICAgICAgICAgbGlxdWlkOiB0cnVlLFxuICAgICAgICAgICAgZXhwYW5kUm93czogQm9vbGVhbihjb250ZXh0Lm9wdGlvbnMuZXhwYW5kUm93cyksXG4gICAgICAgICAgICBjaHVua3M6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ2F4aXMnLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAoYXJnKSA9PiAoXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IG1ha2UgdGhpcyBub3ctaW5kaWNhdG9yIGFycm93IG1vcmUgRFJZIHdpdGggVGltZUNvbHNDb250ZW50XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtYXhpcy1jaHVua1wiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGFibGVcIiwgeyBcImFyaWEtaGlkZGVuXCI6IHRydWUsIHN0eWxlOiB7IGhlaWdodDogYXJnLmV4cGFuZFJvd3MgPyBhcmcuY2xpZW50SGVpZ2h0IDogJycgfSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZy50YWJsZUNvbEdyb3VwTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGJvZHlcIiwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChUaW1lQm9keUF4aXMsIHsgc2xhdE1ldGFzOiBzbGF0TWV0YXMgfSkpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1jb250YWluZXJcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoTm93VGltZXIsIHsgdW5pdDogaXNOb3dJbmRpY2F0b3IgPyAnbWludXRlJyA6ICdkYXknIC8qIGhhY2t5ICovIH0sIChub3dEYXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub3dJbmRpY2F0b3JUb3AgPSBpc05vd0luZGljYXRvciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xhdENvb3JkcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xhdENvb3Jkcy5zYWZlQ29tcHV0ZVRvcChub3dEYXRlKTsgLy8gbWlnaHQgcmV0dXJuIHZvaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBub3dJbmRpY2F0b3JUb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoTm93SW5kaWNhdG9yQ29udGFpbmVyLCB7IGVsQ2xhc3NlczogWydmYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWFycm93J10sIGVsU3R5bGU6IHsgdG9wOiBub3dJbmRpY2F0b3JUb3AgfSwgaXNBeGlzOiB0cnVlLCBkYXRlOiBub3dEYXRlIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkpKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiAnY29scycsXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGVyRWxSZWY6IHRoaXMuc2Nyb2xsZXJFbFJlZixcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogdGltZUNvbnRlbnQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyKSB7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXk6ICdmb290ZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdmb290ZXInLFxuICAgICAgICAgICAgICAgIGlzU3RpY2t5OiB0cnVlLFxuICAgICAgICAgICAgICAgIGNodW5rczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdheGlzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHJlbmRlclNjcm9sbFNoaW0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2NvbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogcmVuZGVyU2Nyb2xsU2hpbSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFZpZXdDb250YWluZXIsIHsgZWxSZWY6IHRoaXMucm9vdEVsUmVmLCBlbENsYXNzZXM6IFsnZmMtdGltZWdyaWQnXSwgdmlld1NwZWM6IGNvbnRleHQudmlld1NwZWMgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoU2Nyb2xsR3JpZCwgeyBsaXF1aWQ6ICFwcm9wcy5pc0hlaWdodEF1dG8gJiYgIXByb3BzLmZvclByaW50LCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQsIGNvbGxhcHNpYmxlV2lkdGg6IGZhbHNlLCBjb2xHcm91cHM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyB3aWR0aDogJ3NocmluaycsIGNvbHM6IFt7IHdpZHRoOiAnc2hyaW5rJyB9XSB9LFxuICAgICAgICAgICAgICAgICAgICB7IGNvbHM6IFt7IHNwYW46IGNvbENudCwgbWluV2lkdGg6IGRheU1pbldpZHRoIH1dIH0sXG4gICAgICAgICAgICAgICAgXSwgc2VjdGlvbnM6IHNlY3Rpb25zIH0pKSk7XG4gICAgfVxuICAgIC8qIERpbWVuc2lvbnNcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAgIGdldEFsbERheU1heEV2ZW50UHJvcHMoKSB7XG4gICAgICAgIGxldCB7IGRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzIH0gPSB0aGlzLmNvbnRleHQub3B0aW9ucztcbiAgICAgICAgaWYgKGRheU1heEV2ZW50cyA9PT0gdHJ1ZSB8fCBkYXlNYXhFdmVudFJvd3MgPT09IHRydWUpIHsgLy8gaXMgYXV0bz9cbiAgICAgICAgICAgIGRheU1heEV2ZW50cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGRheU1heEV2ZW50Um93cyA9IEFVVE9fQUxMX0RBWV9NQVhfRVZFTlRfUk9XUzsgLy8gbWFrZSBzdXJlIFwiYXV0b1wiIGdvZXMgdG8gYSByZWFsIG51bWJlclxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzIH07XG4gICAgfVxufVxuZnVuY3Rpb24gcmVuZGVyQWxsRGF5SW5uZXIocmVuZGVyUHJvcHMpIHtcbiAgICByZXR1cm4gcmVuZGVyUHJvcHMudGV4dDtcbn1cblxuY2xhc3MgVGltZUNvbHNTbGF0c0Nvb3JkcyB7XG4gICAgY29uc3RydWN0b3IocG9zaXRpb25zLCBkYXRlUHJvZmlsZSwgc2xvdER1cmF0aW9uKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgICAgICB0aGlzLmRhdGVQcm9maWxlID0gZGF0ZVByb2ZpbGU7XG4gICAgICAgIHRoaXMuc2xvdER1cmF0aW9uID0gc2xvdER1cmF0aW9uO1xuICAgIH1cbiAgICBzYWZlQ29tcHV0ZVRvcChkYXRlKSB7XG4gICAgICAgIGxldCB7IGRhdGVQcm9maWxlIH0gPSB0aGlzO1xuICAgICAgICBpZiAocmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UsIGRhdGUpKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnRPZkRheURhdGUgPSBzdGFydE9mRGF5KGRhdGUpO1xuICAgICAgICAgICAgbGV0IHRpbWVNcyA9IGRhdGUudmFsdWVPZigpIC0gc3RhcnRPZkRheURhdGUudmFsdWVPZigpO1xuICAgICAgICAgICAgaWYgKHRpbWVNcyA+PSBhc1JvdWdoTXMoZGF0ZVByb2ZpbGUuc2xvdE1pblRpbWUpICYmXG4gICAgICAgICAgICAgICAgdGltZU1zIDwgYXNSb3VnaE1zKGRhdGVQcm9maWxlLnNsb3RNYXhUaW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVUaW1lVG9wKGNyZWF0ZUR1cmF0aW9uKHRpbWVNcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBDb21wdXRlcyB0aGUgdG9wIGNvb3JkaW5hdGUsIHJlbGF0aXZlIHRvIHRoZSBib3VuZHMgb2YgdGhlIGdyaWQsIG9mIHRoZSBnaXZlbiBkYXRlLlxuICAgIC8vIEEgYHN0YXJ0T2ZEYXlEYXRlYCBtdXN0IGJlIGdpdmVuIGZvciBhdm9pZGluZyBhbWJpZ3VpdHkgb3ZlciBob3cgdG8gdHJlYXQgbWlkbmlnaHQuXG4gICAgY29tcHV0ZURhdGVUb3Aod2hlbiwgc3RhcnRPZkRheURhdGUpIHtcbiAgICAgICAgaWYgKCFzdGFydE9mRGF5RGF0ZSkge1xuICAgICAgICAgICAgc3RhcnRPZkRheURhdGUgPSBzdGFydE9mRGF5KHdoZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVUaW1lVG9wKGNyZWF0ZUR1cmF0aW9uKHdoZW4udmFsdWVPZigpIC0gc3RhcnRPZkRheURhdGUudmFsdWVPZigpKSk7XG4gICAgfVxuICAgIC8vIENvbXB1dGVzIHRoZSB0b3AgY29vcmRpbmF0ZSwgcmVsYXRpdmUgdG8gdGhlIGJvdW5kcyBvZiB0aGUgZ3JpZCwgb2YgdGhlIGdpdmVuIHRpbWUgKGEgRHVyYXRpb24pLlxuICAgIC8vIFRoaXMgaXMgYSBtYWtlc2hpZnkgd2F5IHRvIGNvbXB1dGUgdGhlIHRpbWUtdG9wLiBBc3N1bWVzIGFsbCBzbGF0TWV0YXMgZGF0ZXMgYXJlIHVuaWZvcm0uXG4gICAgLy8gRXZlbnR1YWxseSBhbGxvdyBjb21wdXRhdGlvbiB3aXRoIGFyYmlyYXJ5IHNsYXQgZGF0ZXMuXG4gICAgY29tcHV0ZVRpbWVUb3AoZHVyYXRpb24pIHtcbiAgICAgICAgbGV0IHsgcG9zaXRpb25zLCBkYXRlUHJvZmlsZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IGxlbiA9IHBvc2l0aW9ucy5lbHMubGVuZ3RoO1xuICAgICAgICAvLyBmbG9hdGluZy1wb2ludCB2YWx1ZSBvZiAjIG9mIHNsb3RzIGNvdmVyZWRcbiAgICAgICAgbGV0IHNsYXRDb3ZlcmFnZSA9IChkdXJhdGlvbi5taWxsaXNlY29uZHMgLSBhc1JvdWdoTXMoZGF0ZVByb2ZpbGUuc2xvdE1pblRpbWUpKSAvIGFzUm91Z2hNcyh0aGlzLnNsb3REdXJhdGlvbik7XG4gICAgICAgIGxldCBzbGF0SW5kZXg7XG4gICAgICAgIGxldCBzbGF0UmVtYWluZGVyO1xuICAgICAgICAvLyBjb21wdXRlIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGZvciBob3cgbWFueSBzbGF0cyBzaG91bGQgYmUgcHJvZ3Jlc3NlZCB0aHJvdWdoLlxuICAgICAgICAvLyBmcm9tIDAgdG8gbnVtYmVyIG9mIHNsYXRzIChpbmNsdXNpdmUpXG4gICAgICAgIC8vIGNvbnN0cmFpbmVkIGJlY2F1c2Ugc2xvdE1pblRpbWUvc2xvdE1heFRpbWUgbWlnaHQgYmUgY3VzdG9taXplZC5cbiAgICAgICAgc2xhdENvdmVyYWdlID0gTWF0aC5tYXgoMCwgc2xhdENvdmVyYWdlKTtcbiAgICAgICAgc2xhdENvdmVyYWdlID0gTWF0aC5taW4obGVuLCBzbGF0Q292ZXJhZ2UpO1xuICAgICAgICAvLyBhbiBpbnRlZ2VyIGluZGV4IG9mIHRoZSBmdXJ0aGVzdCB3aG9sZSBzbGF0XG4gICAgICAgIC8vIGZyb20gMCB0byBudW1iZXIgc2xhdHMgKCpleGNsdXNpdmUqLCBzbyBsZW4tMSlcbiAgICAgICAgc2xhdEluZGV4ID0gTWF0aC5mbG9vcihzbGF0Q292ZXJhZ2UpO1xuICAgICAgICBzbGF0SW5kZXggPSBNYXRoLm1pbihzbGF0SW5kZXgsIGxlbiAtIDEpO1xuICAgICAgICAvLyBob3cgbXVjaCBmdXJ0aGVyIHRocm91Z2ggdGhlIHNsYXRJbmRleCBzbGF0IChmcm9tIDAuMC0xLjApIG11c3QgYmUgY292ZXJlZCBpbiBhZGRpdGlvbi5cbiAgICAgICAgLy8gY291bGQgYmUgMS4wIGlmIHNsYXRDb3ZlcmFnZSBpcyBjb3ZlcmluZyAqYWxsKiB0aGUgc2xvdHNcbiAgICAgICAgc2xhdFJlbWFpbmRlciA9IHNsYXRDb3ZlcmFnZSAtIHNsYXRJbmRleDtcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9ucy50b3BzW3NsYXRJbmRleF0gK1xuICAgICAgICAgICAgcG9zaXRpb25zLmdldEhlaWdodChzbGF0SW5kZXgpICogc2xhdFJlbWFpbmRlcjtcbiAgICB9XG59XG5cbmNsYXNzIFRpbWVDb2xzU2xhdHNCb2R5IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICAgICAgbGV0IHsgc2xhdEVsUmVmcyB9ID0gcHJvcHM7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcInRib2R5XCIsIG51bGwsIHByb3BzLnNsYXRNZXRhcy5tYXAoKHNsYXRNZXRhLCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgdGltZTogc2xhdE1ldGEudGltZSxcbiAgICAgICAgICAgICAgICBkYXRlOiBjb250ZXh0LmRhdGVFbnYudG9EYXRlKHNsYXRNZXRhLmRhdGUpLFxuICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IGtleTogc2xhdE1ldGEua2V5LCByZWY6IHNsYXRFbFJlZnMuY3JlYXRlUmVmKHNsYXRNZXRhLmtleSkgfSxcbiAgICAgICAgICAgICAgICBwcm9wcy5heGlzICYmIChjcmVhdGVFbGVtZW50KFRpbWVDb2xzQXhpc0NlbGwsIE9iamVjdC5hc3NpZ24oe30sIHNsYXRNZXRhKSkpLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciwgeyBlbFRhZzogXCJ0ZFwiLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1zbG90JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1zbG90LWxhbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgIXNsYXRNZXRhLmlzTGFiZWxlZCAmJiAnZmMtdGltZWdyaWQtc2xvdC1taW5vcicsXG4gICAgICAgICAgICAgICAgICAgIF0sIGVsQXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLXRpbWUnOiBzbGF0TWV0YS5pc29UaW1lU3RyLFxuICAgICAgICAgICAgICAgICAgICB9LCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwic2xvdExhbmVDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5zbG90TGFuZUNvbnRlbnQsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5zbG90TGFuZUNsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLnNsb3RMYW5lRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLnNsb3RMYW5lV2lsbFVubW91bnQgfSkpKTtcbiAgICAgICAgfSkpKTtcbiAgICB9XG59XG5cbi8qXG5mb3IgdGhlIGhvcml6b250YWwgXCJzbGF0c1wiIHRoYXQgcnVuIHdpZHRoLXdpc2UuIEhhcyBhIHRpbWUgYXhpcyBvbiBhIHNpZGUuIERlcGVuZHMgb24gUlRMLlxuKi9cbmNsYXNzIFRpbWVDb2xzU2xhdHMgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5yb290RWxSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy5zbGF0RWxSZWZzID0gbmV3IFJlZk1hcCgpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHRoaXMucm9vdEVsUmVmLCBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtc2xvdHNcIiB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRhYmxlXCIsIHsgXCJhcmlhLWhpZGRlblwiOiB0cnVlLCBjbGFzc05hbWU6IGNvbnRleHQudGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlJyksIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIG1pbldpZHRoOiBwcm9wcy50YWJsZU1pbldpZHRoLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogcHJvcHMuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogcHJvcHMubWluSGVpZ2h0LFxuICAgICAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgICAgICBwcm9wcy50YWJsZUNvbEdyb3VwTm9kZSAvKiByZWxpZXMgb24gdGhlcmUgb25seSBiZWluZyBhIHNpbmdsZSA8Y29sPiBmb3IgdGhlIGF4aXMgKi8sXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChUaW1lQ29sc1NsYXRzQm9keSwgeyBzbGF0RWxSZWZzOiB0aGlzLnNsYXRFbFJlZnMsIGF4aXM6IHByb3BzLmF4aXMsIHNsYXRNZXRhczogcHJvcHMuc2xhdE1ldGFzIH0pKSkpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVTaXppbmcoKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVNpemluZygpO1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMub25Db29yZHMpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25Db29yZHMobnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlU2l6aW5nKCkge1xuICAgICAgICBsZXQgeyBjb250ZXh0LCBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgaWYgKHByb3BzLm9uQ29vcmRzICYmXG4gICAgICAgICAgICBwcm9wcy5jbGllbnRXaWR0aCAhPT0gbnVsbCAvLyBtZWFucyBzaXppbmcgaGFzIHN0YWJpbGl6ZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBsZXQgcm9vdEVsID0gdGhpcy5yb290RWxSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGlmIChyb290RWwub2Zmc2V0SGVpZ2h0KSB7IC8vIG5vdCBoaWRkZW4gYnkgY3NzXG4gICAgICAgICAgICAgICAgcHJvcHMub25Db29yZHMobmV3IFRpbWVDb2xzU2xhdHNDb29yZHMobmV3IFBvc2l0aW9uQ2FjaGUodGhpcy5yb290RWxSZWYuY3VycmVudCwgY29sbGVjdFNsYXRFbHModGhpcy5zbGF0RWxSZWZzLmN1cnJlbnRNYXAsIHByb3BzLnNsYXRNZXRhcyksIGZhbHNlLCB0cnVlKSwgdGhpcy5wcm9wcy5kYXRlUHJvZmlsZSwgY29udGV4dC5vcHRpb25zLnNsb3REdXJhdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY29sbGVjdFNsYXRFbHMoZWxNYXAsIHNsYXRNZXRhcykge1xuICAgIHJldHVybiBzbGF0TWV0YXMubWFwKChzbGF0TWV0YSkgPT4gZWxNYXBbc2xhdE1ldGEua2V5XSk7XG59XG5cbmZ1bmN0aW9uIHNwbGl0U2Vnc0J5Q29sKHNlZ3MsIGNvbENudCkge1xuICAgIGxldCBzZWdzQnlDb2wgPSBbXTtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY29sQ250OyBpICs9IDEpIHtcbiAgICAgICAgc2Vnc0J5Q29sLnB1c2goW10pO1xuICAgIH1cbiAgICBpZiAoc2Vncykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgc2Vnc0J5Q29sW3NlZ3NbaV0uY29sXS5wdXNoKHNlZ3NbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWdzQnlDb2w7XG59XG5mdW5jdGlvbiBzcGxpdEludGVyYWN0aW9uQnlDb2wodWksIGNvbENudCkge1xuICAgIGxldCBieVJvdyA9IFtdO1xuICAgIGlmICghdWkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xDbnQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgYnlSb3dbaV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbENudDsgaSArPSAxKSB7XG4gICAgICAgICAgICBieVJvd1tpXSA9IHtcbiAgICAgICAgICAgICAgICBhZmZlY3RlZEluc3RhbmNlczogdWkuYWZmZWN0ZWRJbnN0YW5jZXMsXG4gICAgICAgICAgICAgICAgaXNFdmVudDogdWkuaXNFdmVudCxcbiAgICAgICAgICAgICAgICBzZWdzOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgc2VnIG9mIHVpLnNlZ3MpIHtcbiAgICAgICAgICAgIGJ5Um93W3NlZy5jb2xdLnNlZ3MucHVzaChzZWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBieVJvdztcbn1cblxuY2xhc3MgVGltZUNvbE1vcmVMaW5rIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KE1vcmVMaW5rQ29udGFpbmVyLCB7IGVsQ2xhc3NlczogWydmYy10aW1lZ3JpZC1tb3JlLWxpbmsnXSwgZWxTdHlsZToge1xuICAgICAgICAgICAgICAgIHRvcDogcHJvcHMudG9wLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogcHJvcHMuYm90dG9tLFxuICAgICAgICAgICAgfSwgYWxsRGF5RGF0ZTogbnVsbCwgbW9yZUNudDogcHJvcHMuaGlkZGVuU2Vncy5sZW5ndGgsIGFsbFNlZ3M6IHByb3BzLmhpZGRlblNlZ3MsIGhpZGRlblNlZ3M6IHByb3BzLmhpZGRlblNlZ3MsIGV4dHJhRGF0ZVNwYW46IHByb3BzLmV4dHJhRGF0ZVNwYW4sIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgcG9wb3ZlckNvbnRlbnQ6ICgpID0+IHJlbmRlclBsYWluRmdTZWdzKHByb3BzLmhpZGRlblNlZ3MsIHByb3BzKSwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVyTW9yZUxpbmtJbm5lciwgZm9yY2VUaW1lZDogdHJ1ZSB9LCAoSW5uZXJDb250ZW50KSA9PiAoY3JlYXRlRWxlbWVudChJbm5lckNvbnRlbnQsIHsgZWxUYWc6IFwiZGl2XCIsIGVsQ2xhc3NlczogWydmYy10aW1lZ3JpZC1tb3JlLWxpbmstaW5uZXInLCAnZmMtc3RpY2t5J10gfSkpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVuZGVyTW9yZUxpbmtJbm5lcihwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy5zaG9ydFRleHQ7XG59XG5cbi8vIHNlZ0lucHV0cyBhc3N1bWVkIHNvcnRlZFxuZnVuY3Rpb24gYnVpbGRQb3NpdGlvbmluZyhzZWdJbnB1dHMsIHN0cmljdE9yZGVyLCBtYXhTdGFja0NudCkge1xuICAgIGxldCBoaWVyYXJjaHkgPSBuZXcgU2VnSGllcmFyY2h5KCk7XG4gICAgaWYgKHN0cmljdE9yZGVyICE9IG51bGwpIHtcbiAgICAgICAgaGllcmFyY2h5LnN0cmljdE9yZGVyID0gc3RyaWN0T3JkZXI7XG4gICAgfVxuICAgIGlmIChtYXhTdGFja0NudCAhPSBudWxsKSB7XG4gICAgICAgIGhpZXJhcmNoeS5tYXhTdGFja0NudCA9IG1heFN0YWNrQ250O1xuICAgIH1cbiAgICBsZXQgaGlkZGVuRW50cmllcyA9IGhpZXJhcmNoeS5hZGRTZWdzKHNlZ0lucHV0cyk7XG4gICAgbGV0IGhpZGRlbkdyb3VwcyA9IGdyb3VwSW50ZXJzZWN0aW5nRW50cmllcyhoaWRkZW5FbnRyaWVzKTtcbiAgICBsZXQgd2ViID0gYnVpbGRXZWIoaGllcmFyY2h5KTtcbiAgICB3ZWIgPSBzdHJldGNoV2ViKHdlYiwgMSk7IC8vIGFsbCBsZXZlbENvb3Jkcy90aGlja25lc3Mgd2lsbCBoYXZlIDAuMC0xLjBcbiAgICBsZXQgc2VnUmVjdHMgPSB3ZWJUb1JlY3RzKHdlYik7XG4gICAgcmV0dXJuIHsgc2VnUmVjdHMsIGhpZGRlbkdyb3VwcyB9O1xufVxuZnVuY3Rpb24gYnVpbGRXZWIoaGllcmFyY2h5KSB7XG4gICAgY29uc3QgeyBlbnRyaWVzQnlMZXZlbCB9ID0gaGllcmFyY2h5O1xuICAgIGNvbnN0IGJ1aWxkTm9kZSA9IGNhY2hlYWJsZSgobGV2ZWwsIGxhdGVyYWwpID0+IGxldmVsICsgJzonICsgbGF0ZXJhbCwgKGxldmVsLCBsYXRlcmFsKSA9PiB7XG4gICAgICAgIGxldCBzaWJsaW5nUmFuZ2UgPSBmaW5kTmV4dExldmVsU2VncyhoaWVyYXJjaHksIGxldmVsLCBsYXRlcmFsKTtcbiAgICAgICAgbGV0IG5leHRMZXZlbFJlcyA9IGJ1aWxkTm9kZXMoc2libGluZ1JhbmdlLCBidWlsZE5vZGUpO1xuICAgICAgICBsZXQgZW50cnkgPSBlbnRyaWVzQnlMZXZlbFtsZXZlbF1bbGF0ZXJhbF07XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGVudHJ5KSwgeyBuZXh0TGV2ZWxOb2RlczogbmV4dExldmVsUmVzWzBdIH0pLFxuICAgICAgICAgICAgZW50cnkudGhpY2tuZXNzICsgbmV4dExldmVsUmVzWzFdLCAvLyB0aGUgcHJlc3N1cmUgYnVpbGRzXG4gICAgICAgIF07XG4gICAgfSk7XG4gICAgcmV0dXJuIGJ1aWxkTm9kZXMoZW50cmllc0J5TGV2ZWwubGVuZ3RoXG4gICAgICAgID8geyBsZXZlbDogMCwgbGF0ZXJhbFN0YXJ0OiAwLCBsYXRlcmFsRW5kOiBlbnRyaWVzQnlMZXZlbFswXS5sZW5ndGggfVxuICAgICAgICA6IG51bGwsIGJ1aWxkTm9kZSlbMF07XG59XG5mdW5jdGlvbiBidWlsZE5vZGVzKHNpYmxpbmdSYW5nZSwgYnVpbGROb2RlKSB7XG4gICAgaWYgKCFzaWJsaW5nUmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIFtbXSwgMF07XG4gICAgfVxuICAgIGxldCB7IGxldmVsLCBsYXRlcmFsU3RhcnQsIGxhdGVyYWxFbmQgfSA9IHNpYmxpbmdSYW5nZTtcbiAgICBsZXQgbGF0ZXJhbCA9IGxhdGVyYWxTdGFydDtcbiAgICBsZXQgcGFpcnMgPSBbXTtcbiAgICB3aGlsZSAobGF0ZXJhbCA8IGxhdGVyYWxFbmQpIHtcbiAgICAgICAgcGFpcnMucHVzaChidWlsZE5vZGUobGV2ZWwsIGxhdGVyYWwpKTtcbiAgICAgICAgbGF0ZXJhbCArPSAxO1xuICAgIH1cbiAgICBwYWlycy5zb3J0KGNtcERlc2NQcmVzc3VyZXMpO1xuICAgIHJldHVybiBbXG4gICAgICAgIHBhaXJzLm1hcChleHRyYWN0Tm9kZSksXG4gICAgICAgIHBhaXJzWzBdWzFdLCAvLyBmaXJzdCBpdGVtJ3MgcHJlc3N1cmVcbiAgICBdO1xufVxuZnVuY3Rpb24gY21wRGVzY1ByZXNzdXJlcyhhLCBiKSB7XG4gICAgcmV0dXJuIGJbMV0gLSBhWzFdO1xufVxuZnVuY3Rpb24gZXh0cmFjdE5vZGUoYSkge1xuICAgIHJldHVybiBhWzBdO1xufVxuZnVuY3Rpb24gZmluZE5leHRMZXZlbFNlZ3MoaGllcmFyY2h5LCBzdWJqZWN0TGV2ZWwsIHN1YmplY3RMYXRlcmFsKSB7XG4gICAgbGV0IHsgbGV2ZWxDb29yZHMsIGVudHJpZXNCeUxldmVsIH0gPSBoaWVyYXJjaHk7XG4gICAgbGV0IHN1YmplY3RFbnRyeSA9IGVudHJpZXNCeUxldmVsW3N1YmplY3RMZXZlbF1bc3ViamVjdExhdGVyYWxdO1xuICAgIGxldCBhZnRlclN1YmplY3QgPSBsZXZlbENvb3Jkc1tzdWJqZWN0TGV2ZWxdICsgc3ViamVjdEVudHJ5LnRoaWNrbmVzcztcbiAgICBsZXQgbGV2ZWxDbnQgPSBsZXZlbENvb3Jkcy5sZW5ndGg7XG4gICAgbGV0IGxldmVsID0gc3ViamVjdExldmVsO1xuICAgIC8vIHNraXAgcGFzdCBsZXZlbHMgdGhhdCBhcmUgdG9vIGhpZ2ggdXBcbiAgICBmb3IgKDsgbGV2ZWwgPCBsZXZlbENudCAmJiBsZXZlbENvb3Jkc1tsZXZlbF0gPCBhZnRlclN1YmplY3Q7IGxldmVsICs9IDEpXG4gICAgICAgIDsgLy8gZG8gbm90aGluZ1xuICAgIGZvciAoOyBsZXZlbCA8IGxldmVsQ250OyBsZXZlbCArPSAxKSB7XG4gICAgICAgIGxldCBlbnRyaWVzID0gZW50cmllc0J5TGV2ZWxbbGV2ZWxdO1xuICAgICAgICBsZXQgZW50cnk7XG4gICAgICAgIGxldCBzZWFyY2hJbmRleCA9IGJpbmFyeVNlYXJjaChlbnRyaWVzLCBzdWJqZWN0RW50cnkuc3Bhbi5zdGFydCwgZ2V0RW50cnlTcGFuRW5kKTtcbiAgICAgICAgbGV0IGxhdGVyYWxTdGFydCA9IHNlYXJjaEluZGV4WzBdICsgc2VhcmNoSW5kZXhbMV07IC8vIGlmIGV4YWN0IG1hdGNoICh3aGljaCBkb2Vzbid0IGNvbGxpZGUpLCBnbyB0byBuZXh0IG9uZVxuICAgICAgICBsZXQgbGF0ZXJhbEVuZCA9IGxhdGVyYWxTdGFydDtcbiAgICAgICAgd2hpbGUgKCAvLyBsb29wIHRocm91Z2ggZW50cmllcyB0aGF0IGhvcml6b250YWxseSBpbnRlcnNlY3RcbiAgICAgICAgKGVudHJ5ID0gZW50cmllc1tsYXRlcmFsRW5kXSkgJiYgLy8gYnV0IG5vdCBwYXN0IHRoZSB3aG9sZSBzZWcgbGlzdFxuICAgICAgICAgICAgZW50cnkuc3Bhbi5zdGFydCA8IHN1YmplY3RFbnRyeS5zcGFuLmVuZCkge1xuICAgICAgICAgICAgbGF0ZXJhbEVuZCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXRlcmFsU3RhcnQgPCBsYXRlcmFsRW5kKSB7XG4gICAgICAgICAgICByZXR1cm4geyBsZXZlbCwgbGF0ZXJhbFN0YXJ0LCBsYXRlcmFsRW5kIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBzdHJldGNoV2ViKHRvcExldmVsTm9kZXMsIHRvdGFsVGhpY2tuZXNzKSB7XG4gICAgY29uc3Qgc3RyZXRjaE5vZGUgPSBjYWNoZWFibGUoKG5vZGUsIHN0YXJ0Q29vcmQsIHByZXZUaGlja25lc3MpID0+IGJ1aWxkRW50cnlLZXkobm9kZSksIChub2RlLCBzdGFydENvb3JkLCBwcmV2VGhpY2tuZXNzKSA9PiB7XG4gICAgICAgIGxldCB7IG5leHRMZXZlbE5vZGVzLCB0aGlja25lc3MgfSA9IG5vZGU7XG4gICAgICAgIGxldCBhbGxUaGlja25lc3MgPSB0aGlja25lc3MgKyBwcmV2VGhpY2tuZXNzO1xuICAgICAgICBsZXQgdGhpY2tuZXNzRnJhY3Rpb24gPSB0aGlja25lc3MgLyBhbGxUaGlja25lc3M7XG4gICAgICAgIGxldCBlbmRDb29yZDtcbiAgICAgICAgbGV0IG5ld0NoaWxkcmVuID0gW107XG4gICAgICAgIGlmICghbmV4dExldmVsTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbmRDb29yZCA9IHRvdGFsVGhpY2tuZXNzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGROb2RlIG9mIG5leHRMZXZlbE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuZENvb3JkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlcyA9IHN0cmV0Y2hOb2RlKGNoaWxkTm9kZSwgc3RhcnRDb29yZCwgYWxsVGhpY2tuZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgZW5kQ29vcmQgPSByZXNbMF07XG4gICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2gocmVzWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXMgPSBzdHJldGNoTm9kZShjaGlsZE5vZGUsIGVuZENvb3JkLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGRyZW4ucHVzaChyZXNbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV3VGhpY2tuZXNzID0gKGVuZENvb3JkIC0gc3RhcnRDb29yZCkgKiB0aGlja25lc3NGcmFjdGlvbjtcbiAgICAgICAgcmV0dXJuIFtlbmRDb29yZCAtIG5ld1RoaWNrbmVzcywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBub2RlKSwgeyB0aGlja25lc3M6IG5ld1RoaWNrbmVzcywgbmV4dExldmVsTm9kZXM6IG5ld0NoaWxkcmVuIH0pXTtcbiAgICB9KTtcbiAgICByZXR1cm4gdG9wTGV2ZWxOb2Rlcy5tYXAoKG5vZGUpID0+IHN0cmV0Y2hOb2RlKG5vZGUsIDAsIDApWzFdKTtcbn1cbi8vIG5vdCBzb3J0ZWQgaW4gYW55IHBhcnRpY3VsYXIgb3JkZXJcbmZ1bmN0aW9uIHdlYlRvUmVjdHModG9wTGV2ZWxOb2Rlcykge1xuICAgIGxldCByZWN0cyA9IFtdO1xuICAgIGNvbnN0IHByb2Nlc3NOb2RlID0gY2FjaGVhYmxlKChub2RlLCBsZXZlbENvb3JkLCBzdGFja0RlcHRoKSA9PiBidWlsZEVudHJ5S2V5KG5vZGUpLCAobm9kZSwgbGV2ZWxDb29yZCwgc3RhY2tEZXB0aCkgPT4ge1xuICAgICAgICBsZXQgcmVjdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbm9kZSksIHsgbGV2ZWxDb29yZCxcbiAgICAgICAgICAgIHN0YWNrRGVwdGgsIHN0YWNrRm9yd2FyZDogMCB9KTtcbiAgICAgICAgcmVjdHMucHVzaChyZWN0KTtcbiAgICAgICAgcmV0dXJuIChyZWN0LnN0YWNrRm9yd2FyZCA9IHByb2Nlc3NOb2Rlcyhub2RlLm5leHRMZXZlbE5vZGVzLCBsZXZlbENvb3JkICsgbm9kZS50aGlja25lc3MsIHN0YWNrRGVwdGggKyAxKSArIDEpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHByb2Nlc3NOb2Rlcyhub2RlcywgbGV2ZWxDb29yZCwgc3RhY2tEZXB0aCkge1xuICAgICAgICBsZXQgc3RhY2tGb3J3YXJkID0gMDtcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICAgICAgc3RhY2tGb3J3YXJkID0gTWF0aC5tYXgocHJvY2Vzc05vZGUobm9kZSwgbGV2ZWxDb29yZCwgc3RhY2tEZXB0aCksIHN0YWNrRm9yd2FyZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YWNrRm9yd2FyZDtcbiAgICB9XG4gICAgcHJvY2Vzc05vZGVzKHRvcExldmVsTm9kZXMsIDAsIDApO1xuICAgIHJldHVybiByZWN0czsgLy8gVE9ETzogc29ydCByZWN0cyBieSBsZXZlbENvb3JkIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCB0b1JlY3RzP1xufVxuLy8gVE9ETzogbW92ZSB0byBnZW5lcmFsIHV0aWxcbmZ1bmN0aW9uIGNhY2hlYWJsZShrZXlGdW5jLCB3b3JrRnVuYykge1xuICAgIGNvbnN0IGNhY2hlID0ge307XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGxldCBrZXkgPSBrZXlGdW5jKC4uLmFyZ3MpO1xuICAgICAgICByZXR1cm4gKGtleSBpbiBjYWNoZSlcbiAgICAgICAgICAgID8gY2FjaGVba2V5XVxuICAgICAgICAgICAgOiAoY2FjaGVba2V5XSA9IHdvcmtGdW5jKC4uLmFyZ3MpKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjb21wdXRlU2VnVkNvb3JkcyhzZWdzLCBjb2xEYXRlLCBzbGF0Q29vcmRzID0gbnVsbCwgZXZlbnRNaW5IZWlnaHQgPSAwKSB7XG4gICAgbGV0IHZjb29yZHMgPSBbXTtcbiAgICBpZiAoc2xhdENvb3Jkcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGxldCBzZWcgPSBzZWdzW2ldO1xuICAgICAgICAgICAgbGV0IHNwYW5TdGFydCA9IHNsYXRDb29yZHMuY29tcHV0ZURhdGVUb3Aoc2VnLnN0YXJ0LCBjb2xEYXRlKTtcbiAgICAgICAgICAgIGxldCBzcGFuRW5kID0gTWF0aC5tYXgoc3BhblN0YXJ0ICsgKGV2ZW50TWluSGVpZ2h0IHx8IDApLCAvLyA6KFxuICAgICAgICAgICAgc2xhdENvb3Jkcy5jb21wdXRlRGF0ZVRvcChzZWcuZW5kLCBjb2xEYXRlKSk7XG4gICAgICAgICAgICB2Y29vcmRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBNYXRoLnJvdW5kKHNwYW5TdGFydCksXG4gICAgICAgICAgICAgICAgZW5kOiBNYXRoLnJvdW5kKHNwYW5FbmQpLCAvL1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZjb29yZHM7XG59XG5mdW5jdGlvbiBjb21wdXRlRmdTZWdQbGFjZW1lbnRzKHNlZ3MsIHNlZ1ZDb29yZHMsIC8vIG1pZ2h0IG5vdCBoYXZlIGZvciBldmVyeSBzZWdcbmV2ZW50T3JkZXJTdHJpY3QsIGV2ZW50TWF4U3RhY2spIHtcbiAgICBsZXQgc2VnSW5wdXRzID0gW107XG4gICAgbGV0IGR1bWJTZWdzID0gW107IC8vIHNlZ3Mgd2l0aG91dCBjb29yZHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgbGV0IHZjb29yZHMgPSBzZWdWQ29vcmRzW2ldO1xuICAgICAgICBpZiAodmNvb3Jkcykge1xuICAgICAgICAgICAgc2VnSW5wdXRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgIHRoaWNrbmVzczogMSxcbiAgICAgICAgICAgICAgICBzcGFuOiB2Y29vcmRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkdW1iU2Vncy5wdXNoKHNlZ3NbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCB7IHNlZ1JlY3RzLCBoaWRkZW5Hcm91cHMgfSA9IGJ1aWxkUG9zaXRpb25pbmcoc2VnSW5wdXRzLCBldmVudE9yZGVyU3RyaWN0LCBldmVudE1heFN0YWNrKTtcbiAgICBsZXQgc2VnUGxhY2VtZW50cyA9IFtdO1xuICAgIGZvciAobGV0IHNlZ1JlY3Qgb2Ygc2VnUmVjdHMpIHtcbiAgICAgICAgc2VnUGxhY2VtZW50cy5wdXNoKHtcbiAgICAgICAgICAgIHNlZzogc2Vnc1tzZWdSZWN0LmluZGV4XSxcbiAgICAgICAgICAgIHJlY3Q6IHNlZ1JlY3QsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBkdW1iU2VnIG9mIGR1bWJTZWdzKSB7XG4gICAgICAgIHNlZ1BsYWNlbWVudHMucHVzaCh7IHNlZzogZHVtYlNlZywgcmVjdDogbnVsbCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2VnUGxhY2VtZW50cywgaGlkZGVuR3JvdXBzIH07XG59XG5cbmNvbnN0IERFRkFVTFRfVElNRV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoe1xuICAgIGhvdXI6ICdudW1lcmljJyxcbiAgICBtaW51dGU6ICcyLWRpZ2l0JyxcbiAgICBtZXJpZGllbTogZmFsc2UsXG59KTtcbmNsYXNzIFRpbWVDb2xFdmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFN0YW5kYXJkRXZlbnQsIE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMsIHsgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLWV2ZW50JyxcbiAgICAgICAgICAgICAgICAnZmMtdi1ldmVudCcsXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5pc1Nob3J0ICYmICdmYy10aW1lZ3JpZC1ldmVudC1zaG9ydCcsXG4gICAgICAgICAgICBdLCBkZWZhdWx0VGltZUZvcm1hdDogREVGQVVMVF9USU1FX0ZPUk1BVCB9KSkpO1xuICAgIH1cbn1cblxuY2xhc3MgVGltZUNvbCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnNvcnRFdmVudFNlZ3MgPSBtZW1vaXplKHNvcnRFdmVudFNlZ3MpO1xuICAgIH1cbiAgICAvLyBUT0RPOiBtZW1vaXplIGV2ZW50LXBsYWNlbWVudD9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgICAgICBsZXQgaXNTZWxlY3RNaXJyb3IgPSBvcHRpb25zLnNlbGVjdE1pcnJvcjtcbiAgICAgICAgbGV0IG1pcnJvclNlZ3MgPSAvLyB5dWNrXG4gICAgICAgICAocHJvcHMuZXZlbnREcmFnICYmIHByb3BzLmV2ZW50RHJhZy5zZWdzKSB8fFxuICAgICAgICAgICAgKHByb3BzLmV2ZW50UmVzaXplICYmIHByb3BzLmV2ZW50UmVzaXplLnNlZ3MpIHx8XG4gICAgICAgICAgICAoaXNTZWxlY3RNaXJyb3IgJiYgcHJvcHMuZGF0ZVNlbGVjdGlvblNlZ3MpIHx8XG4gICAgICAgICAgICBbXTtcbiAgICAgICAgbGV0IGludGVyYWN0aW9uQWZmZWN0ZWRJbnN0YW5jZXMgPSAvLyBUT0RPOiBtZXNzeSB3YXkgdG8gY29tcHV0ZSB0aGlzXG4gICAgICAgICAocHJvcHMuZXZlbnREcmFnICYmIHByb3BzLmV2ZW50RHJhZy5hZmZlY3RlZEluc3RhbmNlcykgfHxcbiAgICAgICAgICAgIChwcm9wcy5ldmVudFJlc2l6ZSAmJiBwcm9wcy5ldmVudFJlc2l6ZS5hZmZlY3RlZEluc3RhbmNlcykgfHxcbiAgICAgICAgICAgIHt9O1xuICAgICAgICBsZXQgc29ydGVkRmdTZWdzID0gdGhpcy5zb3J0RXZlbnRTZWdzKHByb3BzLmZnRXZlbnRTZWdzLCBvcHRpb25zLmV2ZW50T3JkZXIpO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRGF5Q2VsbENvbnRhaW5lciwgeyBlbFRhZzogXCJ0ZFwiLCBlbFJlZjogcHJvcHMuZWxSZWYsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1jb2wnLFxuICAgICAgICAgICAgICAgIC4uLihwcm9wcy5leHRyYUNsYXNzTmFtZXMgfHwgW10pLFxuICAgICAgICAgICAgXSwgZWxBdHRyczogT2JqZWN0LmFzc2lnbih7IHJvbGU6ICdncmlkY2VsbCcgfSwgcHJvcHMuZXh0cmFEYXRhQXR0cnMpLCBkYXRlOiBwcm9wcy5kYXRlLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIGV4dHJhUmVuZGVyUHJvcHM6IHByb3BzLmV4dHJhUmVuZGVyUHJvcHMgfSwgKElubmVyQ29udGVudCkgPT4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtY29sLWZyYW1lXCIgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtY29sLWJnXCIgfSxcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckZpbGxTZWdzKHByb3BzLmJ1c2luZXNzSG91clNlZ3MsICdub24tYnVzaW5lc3MnKSxcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckZpbGxTZWdzKHByb3BzLmJnRXZlbnRTZWdzLCAnYmctZXZlbnQnKSxcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckZpbGxTZWdzKHByb3BzLmRhdGVTZWxlY3Rpb25TZWdzLCAnaGlnaGxpZ2h0JykpLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1jb2wtZXZlbnRzXCIgfSwgdGhpcy5yZW5kZXJGZ1NlZ3Moc29ydGVkRmdTZWdzLCBpbnRlcmFjdGlvbkFmZmVjdGVkSW5zdGFuY2VzLCBmYWxzZSwgZmFsc2UsIGZhbHNlKSksXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbC1ldmVudHNcIiB9LCB0aGlzLnJlbmRlckZnU2VncyhtaXJyb3JTZWdzLCB7fSwgQm9vbGVhbihwcm9wcy5ldmVudERyYWcpLCBCb29sZWFuKHByb3BzLmV2ZW50UmVzaXplKSwgQm9vbGVhbihpc1NlbGVjdE1pcnJvciksICdtaXJyb3InKSksXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItY29udGFpbmVyXCIgfSwgdGhpcy5yZW5kZXJOb3dJbmRpY2F0b3IocHJvcHMubm93SW5kaWNhdG9yU2VncykpLFxuICAgICAgICAgICAgaGFzQ3VzdG9tRGF5Q2VsbENvbnRlbnQob3B0aW9ucykgJiYgKGNyZWF0ZUVsZW1lbnQoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcImRpdlwiLCBlbENsYXNzZXM6IFsnZmMtdGltZWdyaWQtY29sLW1pc2MnXSB9KSkpKSkpO1xuICAgIH1cbiAgICByZW5kZXJGZ1NlZ3Moc29ydGVkRmdTZWdzLCBzZWdJc0ludmlzaWJsZSwgaXNEcmFnZ2luZywgaXNSZXNpemluZywgaXNEYXRlU2VsZWN0aW5nLCBmb3JjZWRLZXkpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGlmIChwcm9wcy5mb3JQcmludCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlbmRlclBsYWluRmdTZWdzKHNvcnRlZEZnU2VncywgcHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlclBvc2l0aW9uZWRGZ1NlZ3Moc29ydGVkRmdTZWdzLCBzZWdJc0ludmlzaWJsZSwgaXNEcmFnZ2luZywgaXNSZXNpemluZywgaXNEYXRlU2VsZWN0aW5nLCBmb3JjZWRLZXkpO1xuICAgIH1cbiAgICByZW5kZXJQb3NpdGlvbmVkRmdTZWdzKHNlZ3MsIC8vIGlmIG5vdCBtaXJyb3IsIG5lZWRzIHRvIGJlIHNvcnRlZFxuICAgIHNlZ0lzSW52aXNpYmxlLCBpc0RyYWdnaW5nLCBpc1Jlc2l6aW5nLCBpc0RhdGVTZWxlY3RpbmcsIGZvcmNlZEtleSkge1xuICAgICAgICBsZXQgeyBldmVudE1heFN0YWNrLCBldmVudFNob3J0SGVpZ2h0LCBldmVudE9yZGVyU3RyaWN0LCBldmVudE1pbkhlaWdodCB9ID0gdGhpcy5jb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgIGxldCB7IGRhdGUsIHNsYXRDb29yZHMsIGV2ZW50U2VsZWN0aW9uLCB0b2RheVJhbmdlLCBub3dEYXRlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQgaXNNaXJyb3IgPSBpc0RyYWdnaW5nIHx8IGlzUmVzaXppbmcgfHwgaXNEYXRlU2VsZWN0aW5nO1xuICAgICAgICBsZXQgc2VnVkNvb3JkcyA9IGNvbXB1dGVTZWdWQ29vcmRzKHNlZ3MsIGRhdGUsIHNsYXRDb29yZHMsIGV2ZW50TWluSGVpZ2h0KTtcbiAgICAgICAgbGV0IHsgc2VnUGxhY2VtZW50cywgaGlkZGVuR3JvdXBzIH0gPSBjb21wdXRlRmdTZWdQbGFjZW1lbnRzKHNlZ3MsIHNlZ1ZDb29yZHMsIGV2ZW50T3JkZXJTdHJpY3QsIGV2ZW50TWF4U3RhY2spO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICB0aGlzLnJlbmRlckhpZGRlbkdyb3VwcyhoaWRkZW5Hcm91cHMsIHNlZ3MpLFxuICAgICAgICAgICAgc2VnUGxhY2VtZW50cy5tYXAoKHNlZ1BsYWNlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB7IHNlZywgcmVjdCB9ID0gc2VnUGxhY2VtZW50O1xuICAgICAgICAgICAgICAgIGxldCBpbnN0YW5jZUlkID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZDtcbiAgICAgICAgICAgICAgICBsZXQgaXNWaXNpYmxlID0gaXNNaXJyb3IgfHwgQm9vbGVhbighc2VnSXNJbnZpc2libGVbaW5zdGFuY2VJZF0gJiYgcmVjdCk7XG4gICAgICAgICAgICAgICAgbGV0IHZTdHlsZSA9IGNvbXB1dGVTZWdWU3R5bGUocmVjdCAmJiByZWN0LnNwYW4pO1xuICAgICAgICAgICAgICAgIGxldCBoU3R5bGUgPSAoIWlzTWlycm9yICYmIHJlY3QpID8gdGhpcy5jb21wdXRlU2VnSFN0eWxlKHJlY3QpIDogeyBsZWZ0OiAwLCByaWdodDogMCB9O1xuICAgICAgICAgICAgICAgIGxldCBpc0luc2V0ID0gQm9vbGVhbihyZWN0KSAmJiByZWN0LnN0YWNrRm9yd2FyZCA+IDA7XG4gICAgICAgICAgICAgICAgbGV0IGlzU2hvcnQgPSBCb29sZWFuKHJlY3QpICYmIChyZWN0LnNwYW4uZW5kIC0gcmVjdC5zcGFuLnN0YXJ0KSA8IGV2ZW50U2hvcnRIZWlnaHQ7IC8vIGxvb2sgYXQgb3RoZXIgcGxhY2VzIGZvciB0aGlzIHByb2JsZW1cbiAgICAgICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6ICdmYy10aW1lZ3JpZC1ldmVudC1oYXJuZXNzJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAoaXNJbnNldCA/ICcgZmMtdGltZWdyaWQtZXZlbnQtaGFybmVzcy1pbnNldCcgOiAnJyksIGtleTogZm9yY2VkS2V5IHx8IGluc3RhbmNlSWQsIHN0eWxlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyB2aXNpYmlsaXR5OiBpc1Zpc2libGUgPyAnJyA6ICdoaWRkZW4nIH0sIHZTdHlsZSksIGhTdHlsZSkgfSxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChUaW1lQ29sRXZlbnQsIE9iamVjdC5hc3NpZ24oeyBzZWc6IHNlZywgaXNEcmFnZ2luZzogaXNEcmFnZ2luZywgaXNSZXNpemluZzogaXNSZXNpemluZywgaXNEYXRlU2VsZWN0aW5nOiBpc0RhdGVTZWxlY3RpbmcsIGlzU2VsZWN0ZWQ6IGluc3RhbmNlSWQgPT09IGV2ZW50U2VsZWN0aW9uLCBpc1Nob3J0OiBpc1Nob3J0IH0sIGdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlLCBub3dEYXRlKSkpKSk7XG4gICAgICAgICAgICB9KSkpO1xuICAgIH1cbiAgICAvLyB3aWxsIGFscmVhZHkgaGF2ZSBldmVudE1pbkhlaWdodCBhcHBsaWVkIGJlY2F1c2Ugc2VnSW5wdXRzIGFscmVhZHkgaGFkIGl0XG4gICAgcmVuZGVySGlkZGVuR3JvdXBzKGhpZGRlbkdyb3Vwcywgc2Vncykge1xuICAgICAgICBsZXQgeyBleHRyYURhdGVTcGFuLCBkYXRlUHJvZmlsZSwgdG9kYXlSYW5nZSwgbm93RGF0ZSwgZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZywgZXZlbnRSZXNpemUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgaGlkZGVuR3JvdXBzLm1hcCgoaGlkZGVuR3JvdXApID0+IHtcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbkNzcyA9IGNvbXB1dGVTZWdWU3R5bGUoaGlkZGVuR3JvdXAuc3Bhbik7XG4gICAgICAgICAgICBsZXQgaGlkZGVuU2VncyA9IGNvbXBpbGVTZWdzRnJvbUVudHJpZXMoaGlkZGVuR3JvdXAuZW50cmllcywgc2Vncyk7XG4gICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVGltZUNvbE1vcmVMaW5rLCB7IGtleTogYnVpbGRJc29TdHJpbmcoY29tcHV0ZUVhcmxpZXN0U2VnU3RhcnQoaGlkZGVuU2VncykpLCBoaWRkZW5TZWdzOiBoaWRkZW5TZWdzLCB0b3A6IHBvc2l0aW9uQ3NzLnRvcCwgYm90dG9tOiBwb3NpdGlvbkNzcy5ib3R0b20sIGV4dHJhRGF0ZVNwYW46IGV4dHJhRGF0ZVNwYW4sIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogdG9kYXlSYW5nZSwgbm93RGF0ZTogbm93RGF0ZSwgZXZlbnRTZWxlY3Rpb246IGV2ZW50U2VsZWN0aW9uLCBldmVudERyYWc6IGV2ZW50RHJhZywgZXZlbnRSZXNpemU6IGV2ZW50UmVzaXplIH0pKTtcbiAgICAgICAgfSkpKTtcbiAgICB9XG4gICAgcmVuZGVyRmlsbFNlZ3Moc2VncywgZmlsbFR5cGUpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCBzZWdWQ29vcmRzID0gY29tcHV0ZVNlZ1ZDb29yZHMoc2VncywgcHJvcHMuZGF0ZSwgcHJvcHMuc2xhdENvb3JkcywgY29udGV4dC5vcHRpb25zLmV2ZW50TWluSGVpZ2h0KTsgLy8gZG9uJ3QgYXNzdW1lIGFsbCBwb3B1bGF0ZWRcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gc2VnVkNvb3Jkcy5tYXAoKHZjb29yZHMsIGkpID0+IHtcbiAgICAgICAgICAgIGxldCBzZWcgPSBzZWdzW2ldO1xuICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsga2V5OiBidWlsZEV2ZW50UmFuZ2VLZXkoc2VnLmV2ZW50UmFuZ2UpLCBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtYmctaGFybmVzc1wiLCBzdHlsZTogY29tcHV0ZVNlZ1ZTdHlsZSh2Y29vcmRzKSB9LCBmaWxsVHlwZSA9PT0gJ2JnLWV2ZW50JyA/XG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChCZ0V2ZW50LCBPYmplY3QuYXNzaWduKHsgc2VnOiBzZWcgfSwgZ2V0U2VnTWV0YShzZWcsIHByb3BzLnRvZGF5UmFuZ2UsIHByb3BzLm5vd0RhdGUpKSkgOlxuICAgICAgICAgICAgICAgIHJlbmRlckZpbGwoZmlsbFR5cGUpKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pO1xuICAgIH1cbiAgICByZW5kZXJOb3dJbmRpY2F0b3Ioc2Vncykge1xuICAgICAgICBsZXQgeyBzbGF0Q29vcmRzLCBkYXRlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBpZiAoIXNsYXRDb29yZHMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdzLm1hcCgoc2VnLCBpKSA9PiAoY3JlYXRlRWxlbWVudChOb3dJbmRpY2F0b3JDb250YWluZXJcbiAgICAgICAgLy8ga2V5IGRvZXNuJ3QgbWF0dGVyLiB3aWxsIG9ubHkgZXZlciBiZSBvbmVcbiAgICAgICAgLCB7IFxuICAgICAgICAgICAgLy8ga2V5IGRvZXNuJ3QgbWF0dGVyLiB3aWxsIG9ubHkgZXZlciBiZSBvbmVcbiAgICAgICAgICAgIGtleTogaSwgZWxDbGFzc2VzOiBbJ2ZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItbGluZSddLCBlbFN0eWxlOiB7XG4gICAgICAgICAgICAgICAgdG9wOiBzbGF0Q29vcmRzLmNvbXB1dGVEYXRlVG9wKHNlZy5zdGFydCwgZGF0ZSksXG4gICAgICAgICAgICB9LCBpc0F4aXM6IGZhbHNlLCBkYXRlOiBkYXRlIH0pKSk7XG4gICAgfVxuICAgIGNvbXB1dGVTZWdIU3R5bGUoc2VnSENvb3Jkcykge1xuICAgICAgICBsZXQgeyBpc1J0bCwgb3B0aW9ucyB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgc2hvdWxkT3ZlcmxhcCA9IG9wdGlvbnMuc2xvdEV2ZW50T3ZlcmxhcDtcbiAgICAgICAgbGV0IG5lYXJDb29yZCA9IHNlZ0hDb29yZHMubGV2ZWxDb29yZDsgLy8gdGhlIGxlZnQgc2lkZSBpZiBMVFIuIHRoZSByaWdodCBzaWRlIGlmIFJUTC4gZmxvYXRpbmctcG9pbnRcbiAgICAgICAgbGV0IGZhckNvb3JkID0gc2VnSENvb3Jkcy5sZXZlbENvb3JkICsgc2VnSENvb3Jkcy50aGlja25lc3M7IC8vIHRoZSByaWdodCBzaWRlIGlmIExUUi4gdGhlIGxlZnQgc2lkZSBpZiBSVEwuIGZsb2F0aW5nLXBvaW50XG4gICAgICAgIGxldCBsZWZ0OyAvLyBhbW91bnQgb2Ygc3BhY2UgZnJvbSBsZWZ0IGVkZ2UsIGEgZnJhY3Rpb24gb2YgdGhlIHRvdGFsIHdpZHRoXG4gICAgICAgIGxldCByaWdodDsgLy8gYW1vdW50IG9mIHNwYWNlIGZyb20gcmlnaHQgZWRnZSwgYSBmcmFjdGlvbiBvZiB0aGUgdG90YWwgd2lkdGhcbiAgICAgICAgaWYgKHNob3VsZE92ZXJsYXApIHtcbiAgICAgICAgICAgIC8vIGRvdWJsZSB0aGUgd2lkdGgsIGJ1dCBkb24ndCBnbyBiZXlvbmQgdGhlIG1heGltdW0gZm9yd2FyZCBjb29yZGluYXRlICgxLjApXG4gICAgICAgICAgICBmYXJDb29yZCA9IE1hdGgubWluKDEsIG5lYXJDb29yZCArIChmYXJDb29yZCAtIG5lYXJDb29yZCkgKiAyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNSdGwpIHtcbiAgICAgICAgICAgIGxlZnQgPSAxIC0gZmFyQ29vcmQ7XG4gICAgICAgICAgICByaWdodCA9IG5lYXJDb29yZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxlZnQgPSBuZWFyQ29vcmQ7XG4gICAgICAgICAgICByaWdodCA9IDEgLSBmYXJDb29yZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJvcHMgPSB7XG4gICAgICAgICAgICB6SW5kZXg6IHNlZ0hDb29yZHMuc3RhY2tEZXB0aCArIDEsXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0ICogMTAwICsgJyUnLFxuICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0ICogMTAwICsgJyUnLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2hvdWxkT3ZlcmxhcCAmJiAhc2VnSENvb3Jkcy5zdGFja0ZvcndhcmQpIHtcbiAgICAgICAgICAgIC8vIGFkZCBwYWRkaW5nIHRvIHRoZSBlZGdlIHNvIHRoYXQgZm9yd2FyZCBzdGFja2VkIGV2ZW50cyBkb24ndCBjb3ZlciB0aGUgcmVzaXplcidzIGljb25cbiAgICAgICAgICAgIHByb3BzW2lzUnRsID8gJ21hcmdpbkxlZnQnIDogJ21hcmdpblJpZ2h0J10gPSAxMCAqIDI7IC8vIDEwIGlzIGEgZ3Vlc3N0aW1hdGUgb2YgdGhlIGljb24ncyB3aWR0aFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9wcztcbiAgICB9XG59XG5mdW5jdGlvbiByZW5kZXJQbGFpbkZnU2Vncyhzb3J0ZWRGZ1NlZ3MsIHsgdG9kYXlSYW5nZSwgbm93RGF0ZSwgZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZywgZXZlbnRSZXNpemUgfSkge1xuICAgIGxldCBoaWRkZW5JbnN0YW5jZXMgPSAoZXZlbnREcmFnID8gZXZlbnREcmFnLmFmZmVjdGVkSW5zdGFuY2VzIDogbnVsbCkgfHxcbiAgICAgICAgKGV2ZW50UmVzaXplID8gZXZlbnRSZXNpemUuYWZmZWN0ZWRJbnN0YW5jZXMgOiBudWxsKSB8fFxuICAgICAgICB7fTtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIHNvcnRlZEZnU2Vncy5tYXAoKHNlZykgPT4ge1xuICAgICAgICBsZXQgaW5zdGFuY2VJZCA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQ7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGtleTogaW5zdGFuY2VJZCwgc3R5bGU6IHsgdmlzaWJpbGl0eTogaGlkZGVuSW5zdGFuY2VzW2luc3RhbmNlSWRdID8gJ2hpZGRlbicgOiAnJyB9IH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFRpbWVDb2xFdmVudCwgT2JqZWN0LmFzc2lnbih7IHNlZzogc2VnLCBpc0RyYWdnaW5nOiBmYWxzZSwgaXNSZXNpemluZzogZmFsc2UsIGlzRGF0ZVNlbGVjdGluZzogZmFsc2UsIGlzU2VsZWN0ZWQ6IGluc3RhbmNlSWQgPT09IGV2ZW50U2VsZWN0aW9uLCBpc1Nob3J0OiBmYWxzZSB9LCBnZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSwgbm93RGF0ZSkpKSkpO1xuICAgIH0pKSk7XG59XG5mdW5jdGlvbiBjb21wdXRlU2VnVlN0eWxlKHNlZ1ZDb29yZHMpIHtcbiAgICBpZiAoIXNlZ1ZDb29yZHMpIHtcbiAgICAgICAgcmV0dXJuIHsgdG9wOiAnJywgYm90dG9tOiAnJyB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHNlZ1ZDb29yZHMuc3RhcnQsXG4gICAgICAgIGJvdHRvbTogLXNlZ1ZDb29yZHMuZW5kLFxuICAgIH07XG59XG5mdW5jdGlvbiBjb21waWxlU2Vnc0Zyb21FbnRyaWVzKHNlZ0VudHJpZXMsIGFsbFNlZ3MpIHtcbiAgICByZXR1cm4gc2VnRW50cmllcy5tYXAoKHNlZ0VudHJ5KSA9PiBhbGxTZWdzW3NlZ0VudHJ5LmluZGV4XSk7XG59XG5cbmNsYXNzIFRpbWVDb2xzQ29udGVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnNwbGl0RmdFdmVudFNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Q29sKTtcbiAgICAgICAgdGhpcy5zcGxpdEJnRXZlbnRTZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeUNvbCk7XG4gICAgICAgIHRoaXMuc3BsaXRCdXNpbmVzc0hvdXJTZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeUNvbCk7XG4gICAgICAgIHRoaXMuc3BsaXROb3dJbmRpY2F0b3JTZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeUNvbCk7XG4gICAgICAgIHRoaXMuc3BsaXREYXRlU2VsZWN0aW9uU2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlDb2wpO1xuICAgICAgICB0aGlzLnNwbGl0RXZlbnREcmFnID0gbWVtb2l6ZShzcGxpdEludGVyYWN0aW9uQnlDb2wpO1xuICAgICAgICB0aGlzLnNwbGl0RXZlbnRSZXNpemUgPSBtZW1vaXplKHNwbGl0SW50ZXJhY3Rpb25CeUNvbCk7XG4gICAgICAgIHRoaXMucm9vdEVsUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMuY2VsbEVsUmVmcyA9IG5ldyBSZWZNYXAoKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IG5vd0luZGljYXRvclRvcCA9IGNvbnRleHQub3B0aW9ucy5ub3dJbmRpY2F0b3IgJiZcbiAgICAgICAgICAgIHByb3BzLnNsYXRDb29yZHMgJiZcbiAgICAgICAgICAgIHByb3BzLnNsYXRDb29yZHMuc2FmZUNvbXB1dGVUb3AocHJvcHMubm93RGF0ZSk7IC8vIG1pZ2h0IHJldHVybiB2b2lkXG4gICAgICAgIGxldCBjb2xDbnQgPSBwcm9wcy5jZWxscy5sZW5ndGg7XG4gICAgICAgIGxldCBmZ0V2ZW50U2Vnc0J5Um93ID0gdGhpcy5zcGxpdEZnRXZlbnRTZWdzKHByb3BzLmZnRXZlbnRTZWdzLCBjb2xDbnQpO1xuICAgICAgICBsZXQgYmdFdmVudFNlZ3NCeVJvdyA9IHRoaXMuc3BsaXRCZ0V2ZW50U2Vncyhwcm9wcy5iZ0V2ZW50U2VncywgY29sQ250KTtcbiAgICAgICAgbGV0IGJ1c2luZXNzSG91clNlZ3NCeVJvdyA9IHRoaXMuc3BsaXRCdXNpbmVzc0hvdXJTZWdzKHByb3BzLmJ1c2luZXNzSG91clNlZ3MsIGNvbENudCk7XG4gICAgICAgIGxldCBub3dJbmRpY2F0b3JTZWdzQnlSb3cgPSB0aGlzLnNwbGl0Tm93SW5kaWNhdG9yU2Vncyhwcm9wcy5ub3dJbmRpY2F0b3JTZWdzLCBjb2xDbnQpO1xuICAgICAgICBsZXQgZGF0ZVNlbGVjdGlvblNlZ3NCeVJvdyA9IHRoaXMuc3BsaXREYXRlU2VsZWN0aW9uU2Vncyhwcm9wcy5kYXRlU2VsZWN0aW9uU2VncywgY29sQ250KTtcbiAgICAgICAgbGV0IGV2ZW50RHJhZ0J5Um93ID0gdGhpcy5zcGxpdEV2ZW50RHJhZyhwcm9wcy5ldmVudERyYWcsIGNvbENudCk7XG4gICAgICAgIGxldCBldmVudFJlc2l6ZUJ5Um93ID0gdGhpcy5zcGxpdEV2ZW50UmVzaXplKHByb3BzLmV2ZW50UmVzaXplLCBjb2xDbnQpO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtY29sc1wiLCByZWY6IHRoaXMucm9vdEVsUmVmIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGFibGVcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiLCBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgICAgICBwcm9wcy50YWJsZUNvbEdyb3VwTm9kZSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGJvZHlcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiIH0sXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IHJvbGU6IFwicm93XCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmF4aXMgJiYgKGNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSwgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbCBmYy10aW1lZ3JpZC1heGlzXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbC1mcmFtZVwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1jb250YWluZXJcIiB9LCB0eXBlb2Ygbm93SW5kaWNhdG9yVG9wID09PSAnbnVtYmVyJyAmJiAoY3JlYXRlRWxlbWVudChOb3dJbmRpY2F0b3JDb250YWluZXIsIHsgZWxDbGFzc2VzOiBbJ2ZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItYXJyb3cnXSwgZWxTdHlsZTogeyB0b3A6IG5vd0luZGljYXRvclRvcCB9LCBpc0F4aXM6IHRydWUsIGRhdGU6IHByb3BzLm5vd0RhdGUgfSkpKSkpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmNlbGxzLm1hcCgoY2VsbCwgaSkgPT4gKGNyZWF0ZUVsZW1lbnQoVGltZUNvbCwgeyBrZXk6IGNlbGwua2V5LCBlbFJlZjogdGhpcy5jZWxsRWxSZWZzLmNyZWF0ZVJlZihjZWxsLmtleSksIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgZGF0ZTogY2VsbC5kYXRlLCBub3dEYXRlOiBwcm9wcy5ub3dEYXRlLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBleHRyYVJlbmRlclByb3BzOiBjZWxsLmV4dHJhUmVuZGVyUHJvcHMsIGV4dHJhRGF0YUF0dHJzOiBjZWxsLmV4dHJhRGF0YUF0dHJzLCBleHRyYUNsYXNzTmFtZXM6IGNlbGwuZXh0cmFDbGFzc05hbWVzLCBleHRyYURhdGVTcGFuOiBjZWxsLmV4dHJhRGF0ZVNwYW4sIGZnRXZlbnRTZWdzOiBmZ0V2ZW50U2Vnc0J5Um93W2ldLCBiZ0V2ZW50U2VnczogYmdFdmVudFNlZ3NCeVJvd1tpXSwgYnVzaW5lc3NIb3VyU2VnczogYnVzaW5lc3NIb3VyU2Vnc0J5Um93W2ldLCBub3dJbmRpY2F0b3JTZWdzOiBub3dJbmRpY2F0b3JTZWdzQnlSb3dbaV0sIGRhdGVTZWxlY3Rpb25TZWdzOiBkYXRlU2VsZWN0aW9uU2Vnc0J5Um93W2ldLCBldmVudERyYWc6IGV2ZW50RHJhZ0J5Um93W2ldLCBldmVudFJlc2l6ZTogZXZlbnRSZXNpemVCeVJvd1tpXSwgc2xhdENvb3JkczogcHJvcHMuc2xhdENvb3JkcywgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQgfSkpKSkpKSkpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVDb29yZHMoKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUNvb3JkcygpO1xuICAgIH1cbiAgICB1cGRhdGVDb29yZHMoKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBpZiAocHJvcHMub25Db2xDb29yZHMgJiZcbiAgICAgICAgICAgIHByb3BzLmNsaWVudFdpZHRoICE9PSBudWxsIC8vIG1lYW5zIHNpemluZyBoYXMgc3RhYmlsaXplZFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHByb3BzLm9uQ29sQ29vcmRzKG5ldyBQb3NpdGlvbkNhY2hlKHRoaXMucm9vdEVsUmVmLmN1cnJlbnQsIGNvbGxlY3RDZWxsRWxzKHRoaXMuY2VsbEVsUmVmcy5jdXJyZW50TWFwLCBwcm9wcy5jZWxscyksIHRydWUsIC8vIGhvcml6b250YWxcbiAgICAgICAgICAgIGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjb2xsZWN0Q2VsbEVscyhlbE1hcCwgY2VsbHMpIHtcbiAgICByZXR1cm4gY2VsbHMubWFwKChjZWxsKSA9PiBlbE1hcFtjZWxsLmtleV0pO1xufVxuXG4vKiBBIGNvbXBvbmVudCB0aGF0IHJlbmRlcnMgb25lIG9yIG1vcmUgY29sdW1ucyBvZiB2ZXJ0aWNhbCB0aW1lIHNsb3RzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmNsYXNzIFRpbWVDb2xzIGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucHJvY2Vzc1Nsb3RPcHRpb25zID0gbWVtb2l6ZShwcm9jZXNzU2xvdE9wdGlvbnMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgc2xhdENvb3JkczogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVSb290RWwgPSAoZWwpID0+IHtcbiAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgICAgICAgIGlzSGl0Q29tYm9BbGxvd2VkOiB0aGlzLnByb3BzLmlzSGl0Q29tYm9BbGxvd2VkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGxSZXF1ZXN0ID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIGxldCB7IG9uU2Nyb2xsVG9wUmVxdWVzdCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGxldCB7IHNsYXRDb29yZHMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBpZiAob25TY3JvbGxUb3BSZXF1ZXN0ICYmIHNsYXRDb29yZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC50aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0b3AgPSBzbGF0Q29vcmRzLmNvbXB1dGVUaW1lVG9wKHJlcXVlc3QudGltZSk7XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IE1hdGguY2VpbCh0b3ApOyAvLyB6b29tIGNhbiBnaXZlIHdlaXJkIGZsb2F0aW5nLXBvaW50IHZhbHVlcy4gcmF0aGVyIHNjcm9sbCBhIGxpdHRsZSBiaXQgZnVydGhlclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgKz0gMTsgLy8gdG8gb3ZlcmNvbWUgdG9wIGJvcmRlciB0aGF0IHNsb3RzIGJleW9uZCB0aGUgZmlyc3QgaGF2ZS4gbG9va3MgYmV0dGVyXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb25TY3JvbGxUb3BSZXF1ZXN0KHRvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUNvbENvb3JkcyA9IChjb2xDb29yZHMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29sQ29vcmRzID0gY29sQ29vcmRzO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVNsYXRDb29yZHMgPSAoc2xhdENvb3JkcykgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHNsYXRDb29yZHMgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vblNsYXRDb29yZHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uU2xhdENvb3JkcyhzbGF0Q29vcmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1ib2R5XCIsIHJlZjogdGhpcy5oYW5kbGVSb290RWwsIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgLy8gdGhlc2UgcHJvcHMgYXJlIGltcG9ydGFudCB0byBnaXZlIHRoaXMgd3JhcHBlciBjb3JyZWN0IGRpbWVuc2lvbnMgZm9yIGludGVyYWN0aW9uc1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGlmIHdlIHNldCBpdCBoZXJlLCBjYW4gd2UgYXZvaWQgZ2l2aW5nIHRvIGlubmVyIHRhYmxlcz9cbiAgICAgICAgICAgICAgICB3aWR0aDogcHJvcHMuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgbWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsXG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFRpbWVDb2xzU2xhdHMsIHsgYXhpczogcHJvcHMuYXhpcywgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBzbGF0TWV0YXM6IHByb3BzLnNsYXRNZXRhcywgY2xpZW50V2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLCBtaW5IZWlnaHQ6IHByb3BzLmV4cGFuZFJvd3MgPyBwcm9wcy5jbGllbnRIZWlnaHQgOiAnJywgdGFibGVNaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCwgdGFibGVDb2xHcm91cE5vZGU6IHByb3BzLmF4aXMgPyBwcm9wcy50YWJsZUNvbEdyb3VwTm9kZSA6IG51bGwgLyogYXhpcyBkZXBlbmRzIG9uIHRoZSBjb2xncm91cCdzIHNocmlua2luZyAqLywgb25Db29yZHM6IHRoaXMuaGFuZGxlU2xhdENvb3JkcyB9KSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoVGltZUNvbHNDb250ZW50LCB7IGNlbGxzOiBwcm9wcy5jZWxscywgYXhpczogcHJvcHMuYXhpcywgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBidXNpbmVzc0hvdXJTZWdzOiBwcm9wcy5idXNpbmVzc0hvdXJTZWdzLCBiZ0V2ZW50U2VnczogcHJvcHMuYmdFdmVudFNlZ3MsIGZnRXZlbnRTZWdzOiBwcm9wcy5mZ0V2ZW50U2VncywgZGF0ZVNlbGVjdGlvblNlZ3M6IHByb3BzLmRhdGVTZWxlY3Rpb25TZWdzLCBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZzogcHJvcHMuZXZlbnREcmFnLCBldmVudFJlc2l6ZTogcHJvcHMuZXZlbnRSZXNpemUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIG5vd0RhdGU6IHByb3BzLm5vd0RhdGUsIG5vd0luZGljYXRvclNlZ3M6IHByb3BzLm5vd0luZGljYXRvclNlZ3MsIGNsaWVudFdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCwgdGFibGVNaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCwgdGFibGVDb2xHcm91cE5vZGU6IHByb3BzLnRhYmxlQ29sR3JvdXBOb2RlLCBzbGF0Q29vcmRzOiBzdGF0ZS5zbGF0Q29vcmRzLCBvbkNvbENvb3JkczogdGhpcy5oYW5kbGVDb2xDb29yZHMsIGZvclByaW50OiBwcm9wcy5mb3JQcmludCB9KSkpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxSZXNwb25kZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlU2Nyb2xsUmVzcG9uZGVyKHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxSZXNwb25kZXIudXBkYXRlKHByZXZQcm9wcy5kYXRlUHJvZmlsZSAhPT0gdGhpcy5wcm9wcy5kYXRlUHJvZmlsZSk7XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB0aGlzLnNjcm9sbFJlc3BvbmRlci5kZXRhY2goKTtcbiAgICB9XG4gICAgcXVlcnlIaXQocG9zaXRpb25MZWZ0LCBwb3NpdGlvblRvcCkge1xuICAgICAgICBsZXQgeyBkYXRlRW52LCBvcHRpb25zIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCB7IGNvbENvb3JkcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgZGF0ZVByb2ZpbGUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCB7IHNsYXRDb29yZHMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGxldCB7IHNuYXBEdXJhdGlvbiwgc25hcHNQZXJTbG90IH0gPSB0aGlzLnByb2Nlc3NTbG90T3B0aW9ucyh0aGlzLnByb3BzLnNsb3REdXJhdGlvbiwgb3B0aW9ucy5zbmFwRHVyYXRpb24pO1xuICAgICAgICBsZXQgY29sSW5kZXggPSBjb2xDb29yZHMubGVmdFRvSW5kZXgocG9zaXRpb25MZWZ0KTtcbiAgICAgICAgbGV0IHNsYXRJbmRleCA9IHNsYXRDb29yZHMucG9zaXRpb25zLnRvcFRvSW5kZXgocG9zaXRpb25Ub3ApO1xuICAgICAgICBpZiAoY29sSW5kZXggIT0gbnVsbCAmJiBzbGF0SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGNlbGwgPSB0aGlzLnByb3BzLmNlbGxzW2NvbEluZGV4XTtcbiAgICAgICAgICAgIGxldCBzbGF0VG9wID0gc2xhdENvb3Jkcy5wb3NpdGlvbnMudG9wc1tzbGF0SW5kZXhdO1xuICAgICAgICAgICAgbGV0IHNsYXRIZWlnaHQgPSBzbGF0Q29vcmRzLnBvc2l0aW9ucy5nZXRIZWlnaHQoc2xhdEluZGV4KTtcbiAgICAgICAgICAgIGxldCBwYXJ0aWFsID0gKHBvc2l0aW9uVG9wIC0gc2xhdFRvcCkgLyBzbGF0SGVpZ2h0OyAvLyBmbG9hdGluZyBwb2ludCBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICAgICAgICBsZXQgbG9jYWxTbmFwSW5kZXggPSBNYXRoLmZsb29yKHBhcnRpYWwgKiBzbmFwc1BlclNsb3QpOyAvLyB0aGUgc25hcCAjIHJlbGF0aXZlIHRvIHN0YXJ0IG9mIHNsYXRcbiAgICAgICAgICAgIGxldCBzbmFwSW5kZXggPSBzbGF0SW5kZXggKiBzbmFwc1BlclNsb3QgKyBsb2NhbFNuYXBJbmRleDtcbiAgICAgICAgICAgIGxldCBkYXlEYXRlID0gdGhpcy5wcm9wcy5jZWxsc1tjb2xJbmRleF0uZGF0ZTtcbiAgICAgICAgICAgIGxldCB0aW1lID0gYWRkRHVyYXRpb25zKGRhdGVQcm9maWxlLnNsb3RNaW5UaW1lLCBtdWx0aXBseUR1cmF0aW9uKHNuYXBEdXJhdGlvbiwgc25hcEluZGV4KSk7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBkYXRlRW52LmFkZChkYXlEYXRlLCB0aW1lKTtcbiAgICAgICAgICAgIGxldCBlbmQgPSBkYXRlRW52LmFkZChzdGFydCwgc25hcER1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICAgICAgZGF0ZVNwYW46IE9iamVjdC5hc3NpZ24oeyByYW5nZTogeyBzdGFydCwgZW5kIH0sIGFsbERheTogZmFsc2UgfSwgY2VsbC5leHRyYURhdGVTcGFuKSxcbiAgICAgICAgICAgICAgICBkYXlFbDogY29sQ29vcmRzLmVsc1tjb2xJbmRleF0sXG4gICAgICAgICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBjb2xDb29yZHMubGVmdHNbY29sSW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICByaWdodDogY29sQ29vcmRzLnJpZ2h0c1tjb2xJbmRleF0sXG4gICAgICAgICAgICAgICAgICAgIHRvcDogc2xhdFRvcCxcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBzbGF0VG9wICsgc2xhdEhlaWdodCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxheWVyOiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzU2xvdE9wdGlvbnMoc2xvdER1cmF0aW9uLCBzbmFwRHVyYXRpb25PdmVycmlkZSkge1xuICAgIGxldCBzbmFwRHVyYXRpb24gPSBzbmFwRHVyYXRpb25PdmVycmlkZSB8fCBzbG90RHVyYXRpb247XG4gICAgbGV0IHNuYXBzUGVyU2xvdCA9IHdob2xlRGl2aWRlRHVyYXRpb25zKHNsb3REdXJhdGlvbiwgc25hcER1cmF0aW9uKTtcbiAgICBpZiAoc25hcHNQZXJTbG90ID09PSBudWxsKSB7XG4gICAgICAgIHNuYXBEdXJhdGlvbiA9IHNsb3REdXJhdGlvbjtcbiAgICAgICAgc25hcHNQZXJTbG90ID0gMTtcbiAgICAgICAgLy8gVE9ETzogc2F5IHdhcm5pbmc/XG4gICAgfVxuICAgIHJldHVybiB7IHNuYXBEdXJhdGlvbiwgc25hcHNQZXJTbG90IH07XG59XG5cbmNsYXNzIERheVRpbWVDb2xzU2xpY2VyIGV4dGVuZHMgU2xpY2VyIHtcbiAgICBzbGljZVJhbmdlKHJhbmdlLCBkYXlSYW5nZXMpIHtcbiAgICAgICAgbGV0IHNlZ3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgZGF5UmFuZ2VzLmxlbmd0aDsgY29sICs9IDEpIHtcbiAgICAgICAgICAgIGxldCBzZWdSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhyYW5nZSwgZGF5UmFuZ2VzW2NvbF0pO1xuICAgICAgICAgICAgaWYgKHNlZ1JhbmdlKSB7XG4gICAgICAgICAgICAgICAgc2Vncy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHNlZ1JhbmdlLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHNlZ1JhbmdlLmVuZCxcbiAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogc2VnUmFuZ2Uuc3RhcnQudmFsdWVPZigpID09PSByYW5nZS5zdGFydC52YWx1ZU9mKCksXG4gICAgICAgICAgICAgICAgICAgIGlzRW5kOiBzZWdSYW5nZS5lbmQudmFsdWVPZigpID09PSByYW5nZS5lbmQudmFsdWVPZigpLFxuICAgICAgICAgICAgICAgICAgICBjb2wsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlZ3M7XG4gICAgfVxufVxuXG5jbGFzcyBEYXlUaW1lQ29scyBleHRlbmRzIERhdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmJ1aWxkRGF5UmFuZ2VzID0gbWVtb2l6ZShidWlsZERheVJhbmdlcyk7XG4gICAgICAgIHRoaXMuc2xpY2VyID0gbmV3IERheVRpbWVDb2xzU2xpY2VyKCk7XG4gICAgICAgIHRoaXMudGltZUNvbHNSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgZGF0ZVByb2ZpbGUsIGRheVRhYmxlTW9kZWwgfSA9IHByb3BzO1xuICAgICAgICBsZXQgeyBub3dJbmRpY2F0b3IsIG5leHREYXlUaHJlc2hvbGQgfSA9IGNvbnRleHQub3B0aW9ucztcbiAgICAgICAgbGV0IGRheVJhbmdlcyA9IHRoaXMuYnVpbGREYXlSYW5nZXMoZGF5VGFibGVNb2RlbCwgZGF0ZVByb2ZpbGUsIGNvbnRleHQuZGF0ZUVudik7XG4gICAgICAgIC8vIGdpdmUgaXQgdGhlIGZpcnN0IHJvdyBvZiBjZWxsc1xuICAgICAgICAvLyBUT0RPOiB3b3VsZCBtb3ZlIHRoaXMgZnVydGhlciBkb3duIGhpZXJhcmNoeSwgYnV0IHNsaWNlTm93RGF0ZSBuZWVkcyBpdFxuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoTm93VGltZXIsIHsgdW5pdDogbm93SW5kaWNhdG9yID8gJ21pbnV0ZScgOiAnZGF5JyB9LCAobm93RGF0ZSwgdG9kYXlSYW5nZSkgPT4gKGNyZWF0ZUVsZW1lbnQoVGltZUNvbHMsIE9iamVjdC5hc3NpZ24oeyByZWY6IHRoaXMudGltZUNvbHNSZWYgfSwgdGhpcy5zbGljZXIuc2xpY2VQcm9wcyhwcm9wcywgZGF0ZVByb2ZpbGUsIG51bGwsIGNvbnRleHQsIGRheVJhbmdlcyksIHsgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50LCBheGlzOiBwcm9wcy5heGlzLCBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIHNsYXRNZXRhczogcHJvcHMuc2xhdE1ldGFzLCBzbG90RHVyYXRpb246IHByb3BzLnNsb3REdXJhdGlvbiwgY2VsbHM6IGRheVRhYmxlTW9kZWwuY2VsbHNbMF0sIHRhYmxlQ29sR3JvdXBOb2RlOiBwcm9wcy50YWJsZUNvbEdyb3VwTm9kZSwgdGFibGVNaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCwgY2xpZW50V2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IHByb3BzLmNsaWVudEhlaWdodCwgZXhwYW5kUm93czogcHJvcHMuZXhwYW5kUm93cywgbm93RGF0ZTogbm93RGF0ZSwgbm93SW5kaWNhdG9yU2Vnczogbm93SW5kaWNhdG9yICYmIHRoaXMuc2xpY2VyLnNsaWNlTm93RGF0ZShub3dEYXRlLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgY29udGV4dCwgZGF5UmFuZ2VzKSwgdG9kYXlSYW5nZTogdG9kYXlSYW5nZSwgb25TY3JvbGxUb3BSZXF1ZXN0OiBwcm9wcy5vblNjcm9sbFRvcFJlcXVlc3QsIG9uU2xhdENvb3JkczogcHJvcHMub25TbGF0Q29vcmRzIH0pKSkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZERheVJhbmdlcyhkYXlUYWJsZU1vZGVsLCBkYXRlUHJvZmlsZSwgZGF0ZUVudikge1xuICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICBmb3IgKGxldCBkYXRlIG9mIGRheVRhYmxlTW9kZWwuaGVhZGVyRGF0ZXMpIHtcbiAgICAgICAgcmFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgc3RhcnQ6IGRhdGVFbnYuYWRkKGRhdGUsIGRhdGVQcm9maWxlLnNsb3RNaW5UaW1lKSxcbiAgICAgICAgICAgIGVuZDogZGF0ZUVudi5hZGQoZGF0ZSwgZGF0ZVByb2ZpbGUuc2xvdE1heFRpbWUpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlcztcbn1cblxuLy8gcG90ZW50aWFsIG5pY2UgdmFsdWVzIGZvciB0aGUgc2xvdC1kdXJhdGlvbiBhbmQgaW50ZXJ2YWwtZHVyYXRpb25cbi8vIGZyb20gbGFyZ2VzdCB0byBzbWFsbGVzdFxuY29uc3QgU1RPQ0tfU1VCX0RVUkFUSU9OUyA9IFtcbiAgICB7IGhvdXJzOiAxIH0sXG4gICAgeyBtaW51dGVzOiAzMCB9LFxuICAgIHsgbWludXRlczogMTUgfSxcbiAgICB7IHNlY29uZHM6IDMwIH0sXG4gICAgeyBzZWNvbmRzOiAxNSB9LFxuXTtcbmZ1bmN0aW9uIGJ1aWxkU2xhdE1ldGFzKHNsb3RNaW5UaW1lLCBzbG90TWF4VGltZSwgZXhwbGljaXRMYWJlbEludGVydmFsLCBzbG90RHVyYXRpb24sIGRhdGVFbnYpIHtcbiAgICBsZXQgZGF5U3RhcnQgPSBuZXcgRGF0ZSgwKTtcbiAgICBsZXQgc2xhdFRpbWUgPSBzbG90TWluVGltZTtcbiAgICBsZXQgc2xhdEl0ZXJhdG9yID0gY3JlYXRlRHVyYXRpb24oMCk7XG4gICAgbGV0IGxhYmVsSW50ZXJ2YWwgPSBleHBsaWNpdExhYmVsSW50ZXJ2YWwgfHwgY29tcHV0ZUxhYmVsSW50ZXJ2YWwoc2xvdER1cmF0aW9uKTtcbiAgICBsZXQgbWV0YXMgPSBbXTtcbiAgICB3aGlsZSAoYXNSb3VnaE1zKHNsYXRUaW1lKSA8IGFzUm91Z2hNcyhzbG90TWF4VGltZSkpIHtcbiAgICAgICAgbGV0IGRhdGUgPSBkYXRlRW52LmFkZChkYXlTdGFydCwgc2xhdFRpbWUpO1xuICAgICAgICBsZXQgaXNMYWJlbGVkID0gd2hvbGVEaXZpZGVEdXJhdGlvbnMoc2xhdEl0ZXJhdG9yLCBsYWJlbEludGVydmFsKSAhPT0gbnVsbDtcbiAgICAgICAgbWV0YXMucHVzaCh7XG4gICAgICAgICAgICBkYXRlLFxuICAgICAgICAgICAgdGltZTogc2xhdFRpbWUsXG4gICAgICAgICAgICBrZXk6IGRhdGUudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGlzb1RpbWVTdHI6IGZvcm1hdElzb1RpbWVTdHJpbmcoZGF0ZSksXG4gICAgICAgICAgICBpc0xhYmVsZWQsXG4gICAgICAgIH0pO1xuICAgICAgICBzbGF0VGltZSA9IGFkZER1cmF0aW9ucyhzbGF0VGltZSwgc2xvdER1cmF0aW9uKTtcbiAgICAgICAgc2xhdEl0ZXJhdG9yID0gYWRkRHVyYXRpb25zKHNsYXRJdGVyYXRvciwgc2xvdER1cmF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGFzO1xufVxuLy8gQ29tcHV0ZXMgYW4gYXV0b21hdGljIHZhbHVlIGZvciBzbG90TGFiZWxJbnRlcnZhbFxuZnVuY3Rpb24gY29tcHV0ZUxhYmVsSW50ZXJ2YWwoc2xvdER1cmF0aW9uKSB7XG4gICAgbGV0IGk7XG4gICAgbGV0IGxhYmVsSW50ZXJ2YWw7XG4gICAgbGV0IHNsb3RzUGVyTGFiZWw7XG4gICAgLy8gZmluZCB0aGUgc21hbGxlc3Qgc3RvY2sgbGFiZWwgaW50ZXJ2YWwgdGhhdCByZXN1bHRzIGluIG1vcmUgdGhhbiBvbmUgc2xvdHMtcGVyLWxhYmVsXG4gICAgZm9yIChpID0gU1RPQ0tfU1VCX0RVUkFUSU9OUy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBsYWJlbEludGVydmFsID0gY3JlYXRlRHVyYXRpb24oU1RPQ0tfU1VCX0RVUkFUSU9OU1tpXSk7XG4gICAgICAgIHNsb3RzUGVyTGFiZWwgPSB3aG9sZURpdmlkZUR1cmF0aW9ucyhsYWJlbEludGVydmFsLCBzbG90RHVyYXRpb24pO1xuICAgICAgICBpZiAoc2xvdHNQZXJMYWJlbCAhPT0gbnVsbCAmJiBzbG90c1BlckxhYmVsID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVsSW50ZXJ2YWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNsb3REdXJhdGlvbjsgLy8gZmFsbCBiYWNrXG59XG5cbmNsYXNzIERheVRpbWVDb2xzVmlldyBleHRlbmRzIFRpbWVDb2xzVmlldyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuYnVpbGRUaW1lQ29sc01vZGVsID0gbWVtb2l6ZShidWlsZFRpbWVDb2xzTW9kZWwpO1xuICAgICAgICB0aGlzLmJ1aWxkU2xhdE1ldGFzID0gbWVtb2l6ZShidWlsZFNsYXRNZXRhcyk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgb3B0aW9ucywgZGF0ZUVudiwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGRhdGVQcm9maWxlIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IGRheVRhYmxlTW9kZWwgPSB0aGlzLmJ1aWxkVGltZUNvbHNNb2RlbChkYXRlUHJvZmlsZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpO1xuICAgICAgICBsZXQgc3BsaXRQcm9wcyA9IHRoaXMuYWxsRGF5U3BsaXR0ZXIuc3BsaXRQcm9wcyhwcm9wcyk7XG4gICAgICAgIGxldCBzbGF0TWV0YXMgPSB0aGlzLmJ1aWxkU2xhdE1ldGFzKGRhdGVQcm9maWxlLnNsb3RNaW5UaW1lLCBkYXRlUHJvZmlsZS5zbG90TWF4VGltZSwgb3B0aW9ucy5zbG90TGFiZWxJbnRlcnZhbCwgb3B0aW9ucy5zbG90RHVyYXRpb24sIGRhdGVFbnYpO1xuICAgICAgICBsZXQgeyBkYXlNaW5XaWR0aCB9ID0gb3B0aW9ucztcbiAgICAgICAgbGV0IGhhc0F0dGFjaGVkQXhpcyA9ICFkYXlNaW5XaWR0aDtcbiAgICAgICAgbGV0IGhhc0RldGFjaGVkQXhpcyA9IGRheU1pbldpZHRoO1xuICAgICAgICBsZXQgaGVhZGVyQ29udGVudCA9IG9wdGlvbnMuZGF5SGVhZGVycyAmJiAoY3JlYXRlRWxlbWVudChEYXlIZWFkZXIsIHsgZGF0ZXM6IGRheVRhYmxlTW9kZWwuaGVhZGVyRGF0ZXMsIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgZGF0ZXNSZXBEaXN0aW5jdERheXM6IHRydWUsIHJlbmRlckludHJvOiBoYXNBdHRhY2hlZEF4aXMgPyB0aGlzLnJlbmRlckhlYWRBeGlzIDogbnVsbCB9KSk7XG4gICAgICAgIGxldCBhbGxEYXlDb250ZW50ID0gKG9wdGlvbnMuYWxsRGF5U2xvdCAhPT0gZmFsc2UpICYmICgoY29udGVudEFyZykgPT4gKGNyZWF0ZUVsZW1lbnQoRGF5VGFibGUsIE9iamVjdC5hc3NpZ24oe30sIHNwbGl0UHJvcHMuYWxsRGF5LCB7IGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgZGF5VGFibGVNb2RlbDogZGF5VGFibGVNb2RlbCwgbmV4dERheVRocmVzaG9sZDogb3B0aW9ucy5uZXh0RGF5VGhyZXNob2xkLCB0YWJsZU1pbldpZHRoOiBjb250ZW50QXJnLnRhYmxlTWluV2lkdGgsIGNvbEdyb3VwTm9kZTogY29udGVudEFyZy50YWJsZUNvbEdyb3VwTm9kZSwgcmVuZGVyUm93SW50cm86IGhhc0F0dGFjaGVkQXhpcyA/IHRoaXMucmVuZGVyVGFibGVSb3dBeGlzIDogbnVsbCwgc2hvd1dlZWtOdW1iZXJzOiBmYWxzZSwgZXhwYW5kUm93czogZmFsc2UsIGhlYWRlckFsaWduRWxSZWY6IHRoaXMuaGVhZGVyRWxSZWYsIGNsaWVudFdpZHRoOiBjb250ZW50QXJnLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IGNvbnRlbnRBcmcuY2xpZW50SGVpZ2h0LCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQgfSwgdGhpcy5nZXRBbGxEYXlNYXhFdmVudFByb3BzKCkpKSkpO1xuICAgICAgICBsZXQgdGltZUdyaWRDb250ZW50ID0gKGNvbnRlbnRBcmcpID0+IChjcmVhdGVFbGVtZW50KERheVRpbWVDb2xzLCBPYmplY3QuYXNzaWduKHt9LCBzcGxpdFByb3BzLnRpbWVkLCB7IGRheVRhYmxlTW9kZWw6IGRheVRhYmxlTW9kZWwsIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgYXhpczogaGFzQXR0YWNoZWRBeGlzLCBzbG90RHVyYXRpb246IG9wdGlvbnMuc2xvdER1cmF0aW9uLCBzbGF0TWV0YXM6IHNsYXRNZXRhcywgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50LCB0YWJsZUNvbEdyb3VwTm9kZTogY29udGVudEFyZy50YWJsZUNvbEdyb3VwTm9kZSwgdGFibGVNaW5XaWR0aDogY29udGVudEFyZy50YWJsZU1pbldpZHRoLCBjbGllbnRXaWR0aDogY29udGVudEFyZy5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0OiBjb250ZW50QXJnLmNsaWVudEhlaWdodCwgb25TbGF0Q29vcmRzOiB0aGlzLmhhbmRsZVNsYXRDb29yZHMsIGV4cGFuZFJvd3M6IGNvbnRlbnRBcmcuZXhwYW5kUm93cywgb25TY3JvbGxUb3BSZXF1ZXN0OiB0aGlzLmhhbmRsZVNjcm9sbFRvcFJlcXVlc3QgfSkpKTtcbiAgICAgICAgcmV0dXJuIGhhc0RldGFjaGVkQXhpc1xuICAgICAgICAgICAgPyB0aGlzLnJlbmRlckhTY3JvbGxMYXlvdXQoaGVhZGVyQ29udGVudCwgYWxsRGF5Q29udGVudCwgdGltZUdyaWRDb250ZW50LCBkYXlUYWJsZU1vZGVsLmNvbENudCwgZGF5TWluV2lkdGgsIHNsYXRNZXRhcywgdGhpcy5zdGF0ZS5zbGF0Q29vcmRzKVxuICAgICAgICAgICAgOiB0aGlzLnJlbmRlclNpbXBsZUxheW91dChoZWFkZXJDb250ZW50LCBhbGxEYXlDb250ZW50LCB0aW1lR3JpZENvbnRlbnQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkVGltZUNvbHNNb2RlbChkYXRlUHJvZmlsZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpIHtcbiAgICBsZXQgZGF5U2VyaWVzID0gbmV3IERheVNlcmllc01vZGVsKGRhdGVQcm9maWxlLnJlbmRlclJhbmdlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcik7XG4gICAgcmV0dXJuIG5ldyBEYXlUYWJsZU1vZGVsKGRheVNlcmllcywgZmFsc2UpO1xufVxuXG52YXIgY3NzXzI0OHogPSBcIi5mYy12LWV2ZW50e2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtZXZlbnQtYmctY29sb3IpO2JvcmRlcjoxcHggc29saWQgdmFyKC0tZmMtZXZlbnQtYm9yZGVyLWNvbG9yKTtkaXNwbGF5OmJsb2NrfS5mYy12LWV2ZW50IC5mYy1ldmVudC1tYWlue2NvbG9yOnZhcigtLWZjLWV2ZW50LXRleHQtY29sb3IpO2hlaWdodDoxMDAlfS5mYy12LWV2ZW50IC5mYy1ldmVudC1tYWluLWZyYW1le2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47aGVpZ2h0OjEwMCV9LmZjLXYtZXZlbnQgLmZjLWV2ZW50LXRpbWV7ZmxleC1ncm93OjA7ZmxleC1zaHJpbms6MDttYXgtaGVpZ2h0OjEwMCU7b3ZlcmZsb3c6aGlkZGVufS5mYy12LWV2ZW50IC5mYy1ldmVudC10aXRsZS1jb250YWluZXJ7ZmxleC1ncm93OjE7ZmxleC1zaHJpbms6MTttaW4taGVpZ2h0OjB9LmZjLXYtZXZlbnQgLmZjLWV2ZW50LXRpdGxle2JvdHRvbTowO21heC1oZWlnaHQ6MTAwJTtvdmVyZmxvdzpoaWRkZW47dG9wOjB9LmZjLXYtZXZlbnQ6bm90KC5mYy1ldmVudC1zdGFydCl7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czowO2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOjA7Ym9yZGVyLXRvcC13aWR0aDowfS5mYy12LWV2ZW50Om5vdCguZmMtZXZlbnQtZW5kKXtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjA7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MDtib3JkZXItYm90dG9tLXdpZHRoOjB9LmZjLXYtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQ6YmVmb3Jle2xlZnQ6LTEwcHg7cmlnaHQ6LTEwcHh9LmZjLXYtZXZlbnQgLmZjLWV2ZW50LXJlc2l6ZXItc3RhcnR7Y3Vyc29yOm4tcmVzaXplfS5mYy12LWV2ZW50IC5mYy1ldmVudC1yZXNpemVyLWVuZHtjdXJzb3I6cy1yZXNpemV9LmZjLXYtZXZlbnQ6bm90KC5mYy1ldmVudC1zZWxlY3RlZCkgLmZjLWV2ZW50LXJlc2l6ZXJ7aGVpZ2h0OnZhcigtLWZjLWV2ZW50LXJlc2l6ZXItdGhpY2tuZXNzKTtsZWZ0OjA7cmlnaHQ6MH0uZmMtdi1ldmVudDpub3QoLmZjLWV2ZW50LXNlbGVjdGVkKSAuZmMtZXZlbnQtcmVzaXplci1zdGFydHt0b3A6Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLXRoaWNrbmVzcykvLTIpfS5mYy12LWV2ZW50Om5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpIC5mYy1ldmVudC1yZXNpemVyLWVuZHtib3R0b206Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLXRoaWNrbmVzcykvLTIpfS5mYy12LWV2ZW50LmZjLWV2ZW50LXNlbGVjdGVkIC5mYy1ldmVudC1yZXNpemVye2xlZnQ6NTAlO21hcmdpbi1sZWZ0OmNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci1kb3QtdG90YWwtd2lkdGgpLy0yKX0uZmMtdi1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplci1zdGFydHt0b3A6Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLWRvdC10b3RhbC13aWR0aCkvLTIpfS5mYy12LWV2ZW50LmZjLWV2ZW50LXNlbGVjdGVkIC5mYy1ldmVudC1yZXNpemVyLWVuZHtib3R0b206Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLWRvdC10b3RhbC13aWR0aCkvLTIpfS5mYyAuZmMtdGltZWdyaWQgLmZjLWRheWdyaWQtYm9keXt6LWluZGV4OjJ9LmZjIC5mYy10aW1lZ3JpZC1kaXZpZGVye3BhZGRpbmc6MCAwIDJweH0uZmMgLmZjLXRpbWVncmlkLWJvZHl7bWluLWhlaWdodDoxMDAlO3Bvc2l0aW9uOnJlbGF0aXZlO3otaW5kZXg6MX0uZmMgLmZjLXRpbWVncmlkLWF4aXMtY2h1bmt7cG9zaXRpb246cmVsYXRpdmV9LmZjIC5mYy10aW1lZ3JpZC1heGlzLWNodW5rPnRhYmxlLC5mYyAuZmMtdGltZWdyaWQtc2xvdHN7cG9zaXRpb246cmVsYXRpdmU7ei1pbmRleDoxfS5mYyAuZmMtdGltZWdyaWQtc2xvdHtib3JkZXItYm90dG9tOjA7aGVpZ2h0OjEuNWVtfS5mYyAuZmMtdGltZWdyaWQtc2xvdDplbXB0eTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXDAwYTBcXFwifS5mYyAuZmMtdGltZWdyaWQtc2xvdC1taW5vcntib3JkZXItdG9wLXN0eWxlOmRvdHRlZH0uZmMgLmZjLXRpbWVncmlkLXNsb3QtbGFiZWwtY3VzaGlvbntkaXNwbGF5OmlubGluZS1ibG9jazt3aGl0ZS1zcGFjZTpub3dyYXB9LmZjIC5mYy10aW1lZ3JpZC1zbG90LWxhYmVse3ZlcnRpY2FsLWFsaWduOm1pZGRsZX0uZmMgLmZjLXRpbWVncmlkLWF4aXMtY3VzaGlvbiwuZmMgLmZjLXRpbWVncmlkLXNsb3QtbGFiZWwtY3VzaGlvbntwYWRkaW5nOjAgNHB4fS5mYyAuZmMtdGltZWdyaWQtYXhpcy1mcmFtZS1saXF1aWR7aGVpZ2h0OjEwMCV9LmZjIC5mYy10aW1lZ3JpZC1heGlzLWZyYW1le2FsaWduLWl0ZW1zOmNlbnRlcjtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OmZsZXgtZW5kO292ZXJmbG93OmhpZGRlbn0uZmMgLmZjLXRpbWVncmlkLWF4aXMtY3VzaGlvbntmbGV4LXNocmluazowO21heC13aWR0aDo2MHB4fS5mYy1kaXJlY3Rpb24tbHRyIC5mYy10aW1lZ3JpZC1zbG90LWxhYmVsLWZyYW1le3RleHQtYWxpZ246cmlnaHR9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLXRpbWVncmlkLXNsb3QtbGFiZWwtZnJhbWV7dGV4dC1hbGlnbjpsZWZ0fS5mYy1saXF1aWQtaGFjayAuZmMtdGltZWdyaWQtYXhpcy1mcmFtZS1saXF1aWR7Ym90dG9tOjA7aGVpZ2h0OmF1dG87bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmZjIC5mYy10aW1lZ3JpZC1jb2wuZmMtZGF5LXRvZGF5e2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtdG9kYXktYmctY29sb3IpfS5mYyAuZmMtdGltZWdyaWQtY29sLWZyYW1le21pbi1oZWlnaHQ6MTAwJTtwb3NpdGlvbjpyZWxhdGl2ZX0uZmMtbWVkaWEtc2NyZWVuLmZjLWxpcXVpZC1oYWNrIC5mYy10aW1lZ3JpZC1jb2wtZnJhbWV7Ym90dG9tOjA7aGVpZ2h0OmF1dG87bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmZjLW1lZGlhLXNjcmVlbiAuZmMtdGltZWdyaWQtY29sc3tib3R0b206MDtsZWZ0OjA7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDt0b3A6MH0uZmMtbWVkaWEtc2NyZWVuIC5mYy10aW1lZ3JpZC1jb2xzPnRhYmxle2hlaWdodDoxMDAlfS5mYy1tZWRpYS1zY3JlZW4gLmZjLXRpbWVncmlkLWNvbC1iZywuZmMtbWVkaWEtc2NyZWVuIC5mYy10aW1lZ3JpZC1jb2wtZXZlbnRzLC5mYy1tZWRpYS1zY3JlZW4gLmZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItY29udGFpbmVye2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowfS5mYyAuZmMtdGltZWdyaWQtY29sLWJne3otaW5kZXg6Mn0uZmMgLmZjLXRpbWVncmlkLWNvbC1iZyAuZmMtbm9uLWJ1c2luZXNze3otaW5kZXg6MX0uZmMgLmZjLXRpbWVncmlkLWNvbC1iZyAuZmMtYmctZXZlbnR7ei1pbmRleDoyfS5mYyAuZmMtdGltZWdyaWQtY29sLWJnIC5mYy1oaWdobGlnaHR7ei1pbmRleDozfS5mYyAuZmMtdGltZWdyaWQtYmctaGFybmVzc3tsZWZ0OjA7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MH0uZmMgLmZjLXRpbWVncmlkLWNvbC1ldmVudHN7ei1pbmRleDozfS5mYyAuZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1jb250YWluZXJ7Ym90dG9tOjA7b3ZlcmZsb3c6aGlkZGVufS5mYy1kaXJlY3Rpb24tbHRyIC5mYy10aW1lZ3JpZC1jb2wtZXZlbnRze21hcmdpbjowIDIuNSUgMCAycHh9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLXRpbWVncmlkLWNvbC1ldmVudHN7bWFyZ2luOjAgMnB4IDAgMi41JX0uZmMtdGltZWdyaWQtZXZlbnQtaGFybmVzc3twb3NpdGlvbjphYnNvbHV0ZX0uZmMtdGltZWdyaWQtZXZlbnQtaGFybmVzcz4uZmMtdGltZWdyaWQtZXZlbnR7Ym90dG9tOjA7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmZjLXRpbWVncmlkLWV2ZW50LWhhcm5lc3MtaW5zZXQgLmZjLXRpbWVncmlkLWV2ZW50LC5mYy10aW1lZ3JpZC1ldmVudC5mYy1ldmVudC1taXJyb3IsLmZjLXRpbWVncmlkLW1vcmUtbGlua3tib3gtc2hhZG93OjAgMCAwIDFweCB2YXIoLS1mYy1wYWdlLWJnLWNvbG9yKX0uZmMtdGltZWdyaWQtZXZlbnQsLmZjLXRpbWVncmlkLW1vcmUtbGlua3tib3JkZXItcmFkaXVzOjNweDtmb250LXNpemU6dmFyKC0tZmMtc21hbGwtZm9udC1zaXplKX0uZmMtdGltZWdyaWQtZXZlbnR7bWFyZ2luLWJvdHRvbToxcHh9LmZjLXRpbWVncmlkLWV2ZW50IC5mYy1ldmVudC1tYWlue3BhZGRpbmc6MXB4IDFweCAwfS5mYy10aW1lZ3JpZC1ldmVudCAuZmMtZXZlbnQtdGltZXtmb250LXNpemU6dmFyKC0tZmMtc21hbGwtZm9udC1zaXplKTttYXJnaW4tYm90dG9tOjFweDt3aGl0ZS1zcGFjZTpub3dyYXB9LmZjLXRpbWVncmlkLWV2ZW50LXNob3J0IC5mYy1ldmVudC1tYWluLWZyYW1le2ZsZXgtZGlyZWN0aW9uOnJvdztvdmVyZmxvdzpoaWRkZW59LmZjLXRpbWVncmlkLWV2ZW50LXNob3J0IC5mYy1ldmVudC10aW1lOmFmdGVye2NvbnRlbnQ6XFxcIlxcXFwwMGEwLVxcXFwwMGEwXFxcIn0uZmMtdGltZWdyaWQtZXZlbnQtc2hvcnQgLmZjLWV2ZW50LXRpdGxle2ZvbnQtc2l6ZTp2YXIoLS1mYy1zbWFsbC1mb250LXNpemUpfS5mYy10aW1lZ3JpZC1tb3JlLWxpbmt7YmFja2dyb3VuZDp2YXIoLS1mYy1tb3JlLWxpbmstYmctY29sb3IpO2NvbG9yOnZhcigtLWZjLW1vcmUtbGluay10ZXh0LWNvbG9yKTtjdXJzb3I6cG9pbnRlcjttYXJnaW4tYm90dG9tOjFweDtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4Ojk5OTl9LmZjLXRpbWVncmlkLW1vcmUtbGluay1pbm5lcntwYWRkaW5nOjNweCAycHg7dG9wOjB9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLXRpbWVncmlkLW1vcmUtbGlua3tyaWdodDowfS5mYy1kaXJlY3Rpb24tcnRsIC5mYy10aW1lZ3JpZC1tb3JlLWxpbmt7bGVmdDowfS5mYyAuZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1hcnJvdywuZmMgLmZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItbGluZXtwb2ludGVyLWV2ZW50czpub25lfS5mYyAuZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1saW5le2JvcmRlci1jb2xvcjp2YXIoLS1mYy1ub3ctaW5kaWNhdG9yLWNvbG9yKTtib3JkZXItc3R5bGU6c29saWQ7Ym9yZGVyLXdpZHRoOjFweCAwIDA7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7ei1pbmRleDo0fS5mYyAuZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1hcnJvd3tib3JkZXItY29sb3I6dmFyKC0tZmMtbm93LWluZGljYXRvci1jb2xvcik7Ym9yZGVyLXN0eWxlOnNvbGlkO21hcmdpbi10b3A6LTVweDtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjR9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItYXJyb3d7Ym9yZGVyLWJvdHRvbS1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXItdG9wLWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlci13aWR0aDo1cHggMCA1cHggNnB4O2xlZnQ6MH0uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1hcnJvd3tib3JkZXItYm90dG9tLWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlci10b3AtY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyLXdpZHRoOjVweCA2cHggNXB4IDA7cmlnaHQ6MH1cIjtcbmluamVjdFN0eWxlcyhjc3NfMjQ4eik7XG5cbmV4cG9ydCB7IERheVRpbWVDb2xzLCBEYXlUaW1lQ29sc1NsaWNlciwgRGF5VGltZUNvbHNWaWV3LCBUaW1lQ29scywgVGltZUNvbHNTbGF0c0Nvb3JkcywgVGltZUNvbHNWaWV3LCBidWlsZERheVJhbmdlcywgYnVpbGRTbGF0TWV0YXMsIGJ1aWxkVGltZUNvbHNNb2RlbCB9O1xuIl0sIm5hbWVzIjpbIlNwbGl0dGVyIiwiaGFzQmdSZW5kZXJpbmciLCJjcmVhdGVGb3JtYXR0ZXIiLCJWaWV3Q29udGV4dFR5cGUiLCJDb250ZW50Q29udGFpbmVyIiwiQmFzZUNvbXBvbmVudCIsIkRhdGVDb21wb25lbnQiLCJkaWZmRGF5cyIsImJ1aWxkTmF2TGlua0F0dHJzIiwiV2Vla051bWJlckNvbnRhaW5lciIsImdldFN0aWNreUhlYWRlckRhdGVzIiwiVmlld0NvbnRhaW5lciIsIlNpbXBsZVNjcm9sbEdyaWQiLCJnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIiLCJOb3dUaW1lciIsIk5vd0luZGljYXRvckNvbnRhaW5lciIsInJlbmRlclNjcm9sbFNoaW0iLCJyYW5nZUNvbnRhaW5zTWFya2VyIiwic3RhcnRPZkRheSIsImFzUm91Z2hNcyIsImNyZWF0ZUR1cmF0aW9uIiwiUmVmTWFwIiwiUG9zaXRpb25DYWNoZSIsIk1vcmVMaW5rQ29udGFpbmVyIiwiU2VnSGllcmFyY2h5IiwiZ3JvdXBJbnRlcnNlY3RpbmdFbnRyaWVzIiwiYmluYXJ5U2VhcmNoIiwiZ2V0RW50cnlTcGFuRW5kIiwiYnVpbGRFbnRyeUtleSIsIlN0YW5kYXJkRXZlbnQiLCJtZW1vaXplIiwic29ydEV2ZW50U2VncyIsIkRheUNlbGxDb250YWluZXIiLCJoYXNDdXN0b21EYXlDZWxsQ29udGVudCIsImdldFNlZ01ldGEiLCJidWlsZElzb1N0cmluZyIsImNvbXB1dGVFYXJsaWVzdFNlZ1N0YXJ0IiwiYnVpbGRFdmVudFJhbmdlS2V5IiwiQmdFdmVudCIsInJlbmRlckZpbGwiLCJhZGREdXJhdGlvbnMiLCJtdWx0aXBseUR1cmF0aW9uIiwid2hvbGVEaXZpZGVEdXJhdGlvbnMiLCJTbGljZXIiLCJpbnRlcnNlY3RSYW5nZXMiLCJmb3JtYXRJc29UaW1lU3RyaW5nIiwiRGF5SGVhZGVyIiwiRGF5U2VyaWVzTW9kZWwiLCJEYXlUYWJsZU1vZGVsIiwiaW5qZWN0U3R5bGVzIiwiY3JlYXRlRWxlbWVudCIsImNyZWF0ZVJlZiIsIkZyYWdtZW50IiwiRGF5VGFibGUiLCJBbGxEYXlTcGxpdHRlciIsImdldEtleUluZm8iLCJhbGxEYXkiLCJ0aW1lZCIsImdldEtleXNGb3JEYXRlU3BhbiIsImRhdGVTcGFuIiwiZ2V0S2V5c0ZvckV2ZW50RGVmIiwiZXZlbnREZWYiLCJERUZBVUxUX1NMQVRfTEFCRUxfRk9STUFUIiwiaG91ciIsIm1pbnV0ZSIsIm9taXRaZXJvTWludXRlIiwibWVyaWRpZW0iLCJUaW1lQ29sc0F4aXNDZWxsIiwicHJvcHMiLCJjbGFzc05hbWVzIiwiaXNMYWJlbGVkIiwiQ29uc3VtZXIiLCJjb250ZXh0IiwiY2xhc3NOYW1lIiwiam9pbiIsImlzb1RpbWVTdHIiLCJkYXRlRW52Iiwib3B0aW9ucyIsInZpZXdBcGkiLCJsYWJlbEZvcm1hdCIsInNsb3RMYWJlbEZvcm1hdCIsIkFycmF5IiwiaXNBcnJheSIsInJlbmRlclByb3BzIiwibGV2ZWwiLCJ0aW1lIiwiZGF0ZSIsInRvRGF0ZSIsInZpZXciLCJ0ZXh0IiwiZm9ybWF0IiwiZWxUYWciLCJlbENsYXNzZXMiLCJlbEF0dHJzIiwiZ2VuZXJhdG9yTmFtZSIsImN1c3RvbUdlbmVyYXRvciIsInNsb3RMYWJlbENvbnRlbnQiLCJkZWZhdWx0R2VuZXJhdG9yIiwicmVuZGVySW5uZXJDb250ZW50IiwiY2xhc3NOYW1lR2VuZXJhdG9yIiwic2xvdExhYmVsQ2xhc3NOYW1lcyIsImRpZE1vdW50Iiwic2xvdExhYmVsRGlkTW91bnQiLCJ3aWxsVW5tb3VudCIsInNsb3RMYWJlbFdpbGxVbm1vdW50IiwiSW5uZXJDb250ZW50IiwiVGltZUJvZHlBeGlzIiwicmVuZGVyIiwic2xhdE1ldGFzIiwibWFwIiwic2xhdE1ldGEiLCJrZXkiLCJPYmplY3QiLCJhc3NpZ24iLCJERUZBVUxUX1dFRUtfTlVNX0ZPUk1BVCIsIndlZWsiLCJBVVRPX0FMTF9EQVlfTUFYX0VWRU5UX1JPV1MiLCJUaW1lQ29sc1ZpZXciLCJjb25zdHJ1Y3RvciIsImFyZ3VtZW50cyIsImFsbERheVNwbGl0dGVyIiwiaGVhZGVyRWxSZWYiLCJyb290RWxSZWYiLCJzY3JvbGxlckVsUmVmIiwic3RhdGUiLCJzbGF0Q29vcmRzIiwiaGFuZGxlU2Nyb2xsVG9wUmVxdWVzdCIsInNjcm9sbFRvcCIsInNjcm9sbGVyRWwiLCJjdXJyZW50IiwicmVuZGVySGVhZEF4aXMiLCJyb3dLZXkiLCJmcmFtZUhlaWdodCIsImRhdGVQcm9maWxlIiwicmFuZ2UiLCJyZW5kZXJSYW5nZSIsImRheUNudCIsInN0YXJ0IiwiZW5kIiwibmF2TGlua0F0dHJzIiwid2Vla051bWJlcnMiLCJkZWZhdWx0Rm9ybWF0Iiwic3R5bGUiLCJoZWlnaHQiLCJyZW5kZXJUYWJsZVJvd0F4aXMiLCJyb3dIZWlnaHQiLCJhbGxEYXlUZXh0IiwiYWxsRGF5Q29udGVudCIsInJlbmRlckFsbERheUlubmVyIiwiYWxsRGF5Q2xhc3NOYW1lcyIsImFsbERheURpZE1vdW50IiwiYWxsRGF5V2lsbFVubW91bnQiLCJoYW5kbGVTbGF0Q29vcmRzIiwic2V0U3RhdGUiLCJyZW5kZXJTaW1wbGVMYXlvdXQiLCJoZWFkZXJSb3dDb250ZW50IiwidGltZUNvbnRlbnQiLCJzZWN0aW9ucyIsInN0aWNreUhlYWRlckRhdGVzIiwicHVzaCIsInR5cGUiLCJpc1N0aWNreSIsImNodW5rIiwiZWxSZWYiLCJ0YWJsZUNsYXNzTmFtZSIsInJvd0NvbnRlbnQiLCJjb250ZW50Iiwib3V0ZXJDb250ZW50Iiwicm9sZSIsInRoZW1lIiwiZ2V0Q2xhc3MiLCJsaXF1aWQiLCJleHBhbmRSb3dzIiwiQm9vbGVhbiIsInZpZXdTcGVjIiwiaXNIZWlnaHRBdXRvIiwiZm9yUHJpbnQiLCJjb2xsYXBzaWJsZVdpZHRoIiwiY29scyIsIndpZHRoIiwicmVuZGVySFNjcm9sbExheW91dCIsImNvbENudCIsImRheU1pbldpZHRoIiwiU2Nyb2xsR3JpZCIsInBsdWdpbkhvb2tzIiwic2Nyb2xsR3JpZEltcGwiLCJFcnJvciIsInN0aWNreUZvb3RlclNjcm9sbGJhciIsInN5bmNSb3dIZWlnaHRzIiwiY2h1bmtzIiwiYXJnIiwicm93U3luY0hlaWdodHMiLCJjb250ZW50QXJnIiwiY29sU3BhbiIsImlzTm93SW5kaWNhdG9yIiwibm93SW5kaWNhdG9yIiwiY2xpZW50SGVpZ2h0IiwidGFibGVDb2xHcm91cE5vZGUiLCJ1bml0Iiwibm93RGF0ZSIsIm5vd0luZGljYXRvclRvcCIsInNhZmVDb21wdXRlVG9wIiwiZWxTdHlsZSIsInRvcCIsImlzQXhpcyIsImNvbEdyb3VwcyIsInNwYW4iLCJtaW5XaWR0aCIsImdldEFsbERheU1heEV2ZW50UHJvcHMiLCJkYXlNYXhFdmVudHMiLCJkYXlNYXhFdmVudFJvd3MiLCJ1bmRlZmluZWQiLCJUaW1lQ29sc1NsYXRzQ29vcmRzIiwicG9zaXRpb25zIiwic2xvdER1cmF0aW9uIiwiY3VycmVudFJhbmdlIiwic3RhcnRPZkRheURhdGUiLCJ0aW1lTXMiLCJ2YWx1ZU9mIiwic2xvdE1pblRpbWUiLCJzbG90TWF4VGltZSIsImNvbXB1dGVUaW1lVG9wIiwiY29tcHV0ZURhdGVUb3AiLCJ3aGVuIiwiZHVyYXRpb24iLCJsZW4iLCJlbHMiLCJsZW5ndGgiLCJzbGF0Q292ZXJhZ2UiLCJtaWxsaXNlY29uZHMiLCJzbGF0SW5kZXgiLCJzbGF0UmVtYWluZGVyIiwiTWF0aCIsIm1heCIsIm1pbiIsImZsb29yIiwidG9wcyIsImdldEhlaWdodCIsIlRpbWVDb2xzU2xhdHNCb2R5Iiwic2xhdEVsUmVmcyIsImkiLCJyZWYiLCJheGlzIiwic2xvdExhbmVDb250ZW50Iiwic2xvdExhbmVDbGFzc05hbWVzIiwic2xvdExhbmVEaWRNb3VudCIsInNsb3RMYW5lV2lsbFVubW91bnQiLCJUaW1lQ29sc1NsYXRzIiwidGFibGVNaW5XaWR0aCIsImNsaWVudFdpZHRoIiwibWluSGVpZ2h0IiwiY29tcG9uZW50RGlkTW91bnQiLCJ1cGRhdGVTaXppbmciLCJjb21wb25lbnREaWRVcGRhdGUiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsIm9uQ29vcmRzIiwicm9vdEVsIiwib2Zmc2V0SGVpZ2h0IiwiY29sbGVjdFNsYXRFbHMiLCJjdXJyZW50TWFwIiwiZWxNYXAiLCJzcGxpdFNlZ3NCeUNvbCIsInNlZ3MiLCJzZWdzQnlDb2wiLCJjb2wiLCJzcGxpdEludGVyYWN0aW9uQnlDb2wiLCJ1aSIsImJ5Um93IiwiYWZmZWN0ZWRJbnN0YW5jZXMiLCJpc0V2ZW50Iiwic2VnIiwiVGltZUNvbE1vcmVMaW5rIiwiYm90dG9tIiwiYWxsRGF5RGF0ZSIsIm1vcmVDbnQiLCJoaWRkZW5TZWdzIiwiYWxsU2VncyIsImV4dHJhRGF0ZVNwYW4iLCJ0b2RheVJhbmdlIiwicG9wb3ZlckNvbnRlbnQiLCJyZW5kZXJQbGFpbkZnU2VncyIsInJlbmRlck1vcmVMaW5rSW5uZXIiLCJmb3JjZVRpbWVkIiwic2hvcnRUZXh0IiwiYnVpbGRQb3NpdGlvbmluZyIsInNlZ0lucHV0cyIsInN0cmljdE9yZGVyIiwibWF4U3RhY2tDbnQiLCJoaWVyYXJjaHkiLCJoaWRkZW5FbnRyaWVzIiwiYWRkU2VncyIsImhpZGRlbkdyb3VwcyIsIndlYiIsImJ1aWxkV2ViIiwic3RyZXRjaFdlYiIsInNlZ1JlY3RzIiwid2ViVG9SZWN0cyIsImVudHJpZXNCeUxldmVsIiwiYnVpbGROb2RlIiwiY2FjaGVhYmxlIiwibGF0ZXJhbCIsInNpYmxpbmdSYW5nZSIsImZpbmROZXh0TGV2ZWxTZWdzIiwibmV4dExldmVsUmVzIiwiYnVpbGROb2RlcyIsImVudHJ5IiwibmV4dExldmVsTm9kZXMiLCJ0aGlja25lc3MiLCJsYXRlcmFsU3RhcnQiLCJsYXRlcmFsRW5kIiwicGFpcnMiLCJzb3J0IiwiY21wRGVzY1ByZXNzdXJlcyIsImV4dHJhY3ROb2RlIiwiYSIsImIiLCJzdWJqZWN0TGV2ZWwiLCJzdWJqZWN0TGF0ZXJhbCIsImxldmVsQ29vcmRzIiwic3ViamVjdEVudHJ5IiwiYWZ0ZXJTdWJqZWN0IiwibGV2ZWxDbnQiLCJlbnRyaWVzIiwic2VhcmNoSW5kZXgiLCJ0b3BMZXZlbE5vZGVzIiwidG90YWxUaGlja25lc3MiLCJzdHJldGNoTm9kZSIsIm5vZGUiLCJzdGFydENvb3JkIiwicHJldlRoaWNrbmVzcyIsImFsbFRoaWNrbmVzcyIsInRoaWNrbmVzc0ZyYWN0aW9uIiwiZW5kQ29vcmQiLCJuZXdDaGlsZHJlbiIsImNoaWxkTm9kZSIsInJlcyIsIm5ld1RoaWNrbmVzcyIsInJlY3RzIiwicHJvY2Vzc05vZGUiLCJsZXZlbENvb3JkIiwic3RhY2tEZXB0aCIsInJlY3QiLCJzdGFja0ZvcndhcmQiLCJwcm9jZXNzTm9kZXMiLCJub2RlcyIsImtleUZ1bmMiLCJ3b3JrRnVuYyIsImNhY2hlIiwiYXJncyIsImNvbXB1dGVTZWdWQ29vcmRzIiwiY29sRGF0ZSIsImV2ZW50TWluSGVpZ2h0IiwidmNvb3JkcyIsInNwYW5TdGFydCIsInNwYW5FbmQiLCJyb3VuZCIsImNvbXB1dGVGZ1NlZ1BsYWNlbWVudHMiLCJzZWdWQ29vcmRzIiwiZXZlbnRPcmRlclN0cmljdCIsImV2ZW50TWF4U3RhY2siLCJkdW1iU2VncyIsImluZGV4Iiwic2VnUGxhY2VtZW50cyIsInNlZ1JlY3QiLCJkdW1iU2VnIiwiREVGQVVMVF9USU1FX0ZPUk1BVCIsIlRpbWVDb2xFdmVudCIsImlzU2hvcnQiLCJkZWZhdWx0VGltZUZvcm1hdCIsIlRpbWVDb2wiLCJpc1NlbGVjdE1pcnJvciIsInNlbGVjdE1pcnJvciIsIm1pcnJvclNlZ3MiLCJldmVudERyYWciLCJldmVudFJlc2l6ZSIsImRhdGVTZWxlY3Rpb25TZWdzIiwiaW50ZXJhY3Rpb25BZmZlY3RlZEluc3RhbmNlcyIsInNvcnRlZEZnU2VncyIsImZnRXZlbnRTZWdzIiwiZXZlbnRPcmRlciIsImV4dHJhQ2xhc3NOYW1lcyIsImV4dHJhRGF0YUF0dHJzIiwiZXh0cmFSZW5kZXJQcm9wcyIsInJlbmRlckZpbGxTZWdzIiwiYnVzaW5lc3NIb3VyU2VncyIsImJnRXZlbnRTZWdzIiwicmVuZGVyRmdTZWdzIiwicmVuZGVyTm93SW5kaWNhdG9yIiwibm93SW5kaWNhdG9yU2VncyIsInNlZ0lzSW52aXNpYmxlIiwiaXNEcmFnZ2luZyIsImlzUmVzaXppbmciLCJpc0RhdGVTZWxlY3RpbmciLCJmb3JjZWRLZXkiLCJyZW5kZXJQb3NpdGlvbmVkRmdTZWdzIiwiZXZlbnRTaG9ydEhlaWdodCIsImV2ZW50U2VsZWN0aW9uIiwiaXNNaXJyb3IiLCJyZW5kZXJIaWRkZW5Hcm91cHMiLCJzZWdQbGFjZW1lbnQiLCJpbnN0YW5jZUlkIiwiZXZlbnRSYW5nZSIsImluc3RhbmNlIiwiaXNWaXNpYmxlIiwidlN0eWxlIiwiY29tcHV0ZVNlZ1ZTdHlsZSIsImhTdHlsZSIsImNvbXB1dGVTZWdIU3R5bGUiLCJsZWZ0IiwicmlnaHQiLCJpc0luc2V0IiwidmlzaWJpbGl0eSIsImlzU2VsZWN0ZWQiLCJoaWRkZW5Hcm91cCIsInBvc2l0aW9uQ3NzIiwiY29tcGlsZVNlZ3NGcm9tRW50cmllcyIsImZpbGxUeXBlIiwiY2hpbGRyZW4iLCJzZWdIQ29vcmRzIiwiaXNSdGwiLCJzaG91bGRPdmVybGFwIiwic2xvdEV2ZW50T3ZlcmxhcCIsIm5lYXJDb29yZCIsImZhckNvb3JkIiwiekluZGV4IiwiaGlkZGVuSW5zdGFuY2VzIiwic2VnRW50cmllcyIsInNlZ0VudHJ5IiwiVGltZUNvbHNDb250ZW50Iiwic3BsaXRGZ0V2ZW50U2VncyIsInNwbGl0QmdFdmVudFNlZ3MiLCJzcGxpdEJ1c2luZXNzSG91clNlZ3MiLCJzcGxpdE5vd0luZGljYXRvclNlZ3MiLCJzcGxpdERhdGVTZWxlY3Rpb25TZWdzIiwic3BsaXRFdmVudERyYWciLCJzcGxpdEV2ZW50UmVzaXplIiwiY2VsbEVsUmVmcyIsImNlbGxzIiwiZmdFdmVudFNlZ3NCeVJvdyIsImJnRXZlbnRTZWdzQnlSb3ciLCJidXNpbmVzc0hvdXJTZWdzQnlSb3ciLCJub3dJbmRpY2F0b3JTZWdzQnlSb3ciLCJkYXRlU2VsZWN0aW9uU2Vnc0J5Um93IiwiZXZlbnREcmFnQnlSb3ciLCJldmVudFJlc2l6ZUJ5Um93IiwiY2VsbCIsInVwZGF0ZUNvb3JkcyIsIm9uQ29sQ29vcmRzIiwiY29sbGVjdENlbGxFbHMiLCJUaW1lQ29scyIsInByb2Nlc3NTbG90T3B0aW9ucyIsImhhbmRsZVJvb3RFbCIsImVsIiwicmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCIsImlzSGl0Q29tYm9BbGxvd2VkIiwidW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50IiwiaGFuZGxlU2Nyb2xsUmVxdWVzdCIsInJlcXVlc3QiLCJvblNjcm9sbFRvcFJlcXVlc3QiLCJjZWlsIiwiaGFuZGxlQ29sQ29vcmRzIiwiY29sQ29vcmRzIiwib25TbGF0Q29vcmRzIiwic2Nyb2xsUmVzcG9uZGVyIiwiY3JlYXRlU2Nyb2xsUmVzcG9uZGVyIiwicHJldlByb3BzIiwidXBkYXRlIiwiZGV0YWNoIiwicXVlcnlIaXQiLCJwb3NpdGlvbkxlZnQiLCJwb3NpdGlvblRvcCIsInNuYXBEdXJhdGlvbiIsInNuYXBzUGVyU2xvdCIsImNvbEluZGV4IiwibGVmdFRvSW5kZXgiLCJ0b3BUb0luZGV4Iiwic2xhdFRvcCIsInNsYXRIZWlnaHQiLCJwYXJ0aWFsIiwibG9jYWxTbmFwSW5kZXgiLCJzbmFwSW5kZXgiLCJkYXlEYXRlIiwiYWRkIiwiZGF5RWwiLCJsZWZ0cyIsInJpZ2h0cyIsImxheWVyIiwic25hcER1cmF0aW9uT3ZlcnJpZGUiLCJEYXlUaW1lQ29sc1NsaWNlciIsInNsaWNlUmFuZ2UiLCJkYXlSYW5nZXMiLCJzZWdSYW5nZSIsImlzU3RhcnQiLCJpc0VuZCIsIkRheVRpbWVDb2xzIiwiYnVpbGREYXlSYW5nZXMiLCJzbGljZXIiLCJ0aW1lQ29sc1JlZiIsImRheVRhYmxlTW9kZWwiLCJuZXh0RGF5VGhyZXNob2xkIiwic2xpY2VQcm9wcyIsInNsaWNlTm93RGF0ZSIsInJhbmdlcyIsImhlYWRlckRhdGVzIiwiU1RPQ0tfU1VCX0RVUkFUSU9OUyIsImhvdXJzIiwibWludXRlcyIsInNlY29uZHMiLCJidWlsZFNsYXRNZXRhcyIsImV4cGxpY2l0TGFiZWxJbnRlcnZhbCIsImRheVN0YXJ0IiwiRGF0ZSIsInNsYXRUaW1lIiwic2xhdEl0ZXJhdG9yIiwibGFiZWxJbnRlcnZhbCIsImNvbXB1dGVMYWJlbEludGVydmFsIiwibWV0YXMiLCJ0b0lTT1N0cmluZyIsInNsb3RzUGVyTGFiZWwiLCJEYXlUaW1lQ29sc1ZpZXciLCJidWlsZFRpbWVDb2xzTW9kZWwiLCJkYXRlUHJvZmlsZUdlbmVyYXRvciIsInNwbGl0UHJvcHMiLCJzbG90TGFiZWxJbnRlcnZhbCIsImhhc0F0dGFjaGVkQXhpcyIsImhhc0RldGFjaGVkQXhpcyIsImhlYWRlckNvbnRlbnQiLCJkYXlIZWFkZXJzIiwiZGF0ZXMiLCJkYXRlc1JlcERpc3RpbmN0RGF5cyIsInJlbmRlckludHJvIiwiYWxsRGF5U2xvdCIsImNvbEdyb3VwTm9kZSIsInJlbmRlclJvd0ludHJvIiwic2hvd1dlZWtOdW1iZXJzIiwiaGVhZGVyQWxpZ25FbFJlZiIsInRpbWVHcmlkQ29udGVudCIsImRheVNlcmllcyIsImNzc18yNDh6Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@fullcalendar/timegrid/internal.js\n");

/***/ })

};
;